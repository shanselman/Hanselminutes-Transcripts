WEBVTT FILE

1
00:00:12.230 --> 00:00:17.780
From hanselminutes.com. It's Hanselman. That's
a weekly discussion with web

2
00:00:17.780 --> 00:00:22.610
developer and technologist Scott Hanselman.
This is Lawrence Ryan announcing show

3
00:00:22.610 --> 00:00:28.760
number three 40 recorded live
Thursday, October 4th, 2012. This episode is

4
00:00:28.760 --> 00:00:31.760
brought to you by Tellerik
offering the best in developer

5
00:00:31.760 --> 00:00:39.410
tools and support online@telprik.com and
by Franklin Stott net training

6
00:00:39.410 --> 00:00:42.800
developers to work smarter and
now offering gesture pack a

7
00:00:42.800 --> 00:00:46.460
powerful gesture, recording and recognition
system for Microsoft connect for

8
00:00:46.460 --> 00:00:52.670
windows developers details@gesturepak.com. In this
episode, Scott talks with Andrews.

9
00:00:52.670 --> 00:00:59.000
Hillsburg about a new language
called Hi, this is Scott

10
00:00:59.000 --> 00:01:01.250
Hanselman. This is another episode
of Hanselminutes and I'm here

11
00:01:01.250 --> 00:01:03.440
in our who set the
go to conference and we've

12
00:01:03.440 --> 00:01:06.410
just come out of the
keynote, the ending keynote of

13
00:01:06.410 --> 00:01:08.330
the conference. And I'm sitting
with Andrews Helzberg who has

14
00:01:08.330 --> 00:01:11.840
just talked about TypeScript in
front of a rapt audience.

15
00:01:13.130 --> 00:01:15.110
Yeah, it was fun. It
was fun. I'm pretty well.

16
00:01:15.110 --> 00:01:18.590
So congratulations. You released TypeScript
on Monday. You just presented

17
00:01:18.590 --> 00:01:21.110
it in front of everybody
and did a whole hour

18
00:01:21.110 --> 00:01:24.200
of live coding all in
type script. So give me

19
00:01:24.200 --> 00:01:25.820
a little basics on what
type script is for the

20
00:01:25.820 --> 00:01:28.490
people who have been not
paying attention all week. Sure.

21
00:01:29.000 --> 00:01:32.120
So far for, you know,
I'd say like the last

22
00:01:32.120 --> 00:01:34.910
five years, we've sort of
increasingly heard from customers and

23
00:01:34.910 --> 00:01:37.430
internal teams about how hard
it is for them to

24
00:01:37.430 --> 00:01:42.050
ride large JavaScript applications. Part
of the reasoning is, is,

25
00:01:42.050 --> 00:01:44.540
you know, the JavaScript was
never intended to be a

26
00:01:44.540 --> 00:01:46.970
programming language for, for large
apps. It doesn't really have

27
00:01:46.970 --> 00:01:50.800
any other structuring concepts that
you would normally find in,

28
00:01:50.800 --> 00:01:54.980
in, in, in programming languages
like classes or modules. And

29
00:01:54.980 --> 00:01:58.850
also it doesn't have any
static type information and static

30
00:01:58.850 --> 00:02:03.200
type information is basically the
engine that powers today's modern

31
00:02:03.230 --> 00:02:06.380
IDE that's, that's what we
use when we do code

32
00:02:06.380 --> 00:02:10.370
completion, find all references refactorings
and so forth. But without

33
00:02:10.370 --> 00:02:13.100
it, it's very hard to
do a decent job. We

34
00:02:13.100 --> 00:02:15.950
can sort of sometimes guests
and sometimes get it right,

35
00:02:15.950 --> 00:02:18.470
but sometimes we get it
wrong and it's very frustrating

36
00:02:18.470 --> 00:02:21.350
to work in a, in
an environment like that. So,

37
00:02:22.280 --> 00:02:24.110
so two, three years ago,
when we were thinking about

38
00:02:24.110 --> 00:02:27.050
where to go next with
Java script development tools, we,

39
00:02:27.320 --> 00:02:30.620
we thought it'd be really
awesome. If we could strengthen

40
00:02:30.620 --> 00:02:33.440
Java script with these things
that are missing, like classes,

41
00:02:33.440 --> 00:02:38.330
modules, optional, static, typing without,
without giving up any of

42
00:02:38.330 --> 00:02:41.990
the inherent advantages of JavaScript.
I E that it's cross-platform

43
00:02:41.990 --> 00:02:45.200
and open standards, weapon so
forth. And that's, that's what

44
00:02:45.200 --> 00:02:50.390
TypeScript is about. Basically, it's
a language for application scale,

45
00:02:50.450 --> 00:02:54.020
Java script development, and the
way we built it is

46
00:02:54.020 --> 00:02:56.720
we built it as a
super set of JavaScript that

47
00:02:56.720 --> 00:03:01.990
compiled to plain JavaScript. And
then that plain JavaScript runs

48
00:03:01.990 --> 00:03:06.030
anywhere on any browser in
EOS. So any host, So

49
00:03:06.030 --> 00:03:07.650
you're saying that you started
thinking about this two or

50
00:03:07.650 --> 00:03:10.440
three years ago, and team
working on this. How does

51
00:03:10.440 --> 00:03:13.620
something like this where it's
a Microsoft thing, but it's

52
00:03:13.620 --> 00:03:17.130
an open source thing compared
to the standards based movements

53
00:03:17.130 --> 00:03:19.590
around ECMAScript, which isn't going
to be ready for another

54
00:03:19.590 --> 00:03:21.750
year or so, how do
you deal with those tensions?

55
00:03:21.760 --> 00:03:23.970
Like you could improve the
actual language or you could

56
00:03:23.970 --> 00:03:27.060
just do it yourself Well,
so, so we've taken a

57
00:03:27.060 --> 00:03:29.100
lot of inspiration from the
work that's going on in

58
00:03:29.100 --> 00:03:31.620
ECMAScript six. So there are
actually proposals for a lot

59
00:03:31.620 --> 00:03:34.710
of features that, that look
like they will be adopted,

60
00:03:34.740 --> 00:03:38.310
like say classes and modules
and arrow functions and rest

61
00:03:38.310 --> 00:03:42.420
parameters and a whole bunch
more. And so, so some

62
00:03:42.420 --> 00:03:46.830
of those we have actually
implemented in, in TypeScript and

63
00:03:46.830 --> 00:03:49.740
we are aligning as best
we can with what the

64
00:03:49.740 --> 00:03:53.220
proposals look like in ECMAScript
six, but of course ECMAScript

65
00:03:53.220 --> 00:03:56.130
is not proposing to add
static typing to, to, to

66
00:03:56.160 --> 00:03:58.520
the language. So that's something
we then layer on on

67
00:03:58.530 --> 00:04:00.960
top. Okay. So it's a
balance between there are features

68
00:04:00.960 --> 00:04:02.940
that you want and that
you, you could use and

69
00:04:02.940 --> 00:04:04.920
you feel people could want,
but there are also cool

70
00:04:04.920 --> 00:04:07.410
things that they're doing. It
seems like you've given us

71
00:04:07.670 --> 00:04:11.520
ECMAScript six. I like early
It's. You could, you could

72
00:04:11.520 --> 00:04:13.320
think of it as a
preview of what what's, what's

73
00:04:13.320 --> 00:04:15.480
an accurate script six, although
we have not implemented all

74
00:04:15.480 --> 00:04:18.030
of the features and there,
there are many, and, and

75
00:04:18.030 --> 00:04:21.150
some of them, you know,
are more amenable to D

76
00:04:21.150 --> 00:04:23.970
sugaring into IES five as,
as we do. And, and

77
00:04:23.970 --> 00:04:26.790
some are not, you know,
so yeah, Some, some people,

78
00:04:26.790 --> 00:04:29.070
you know, and there's always
naysayers and people are very

79
00:04:29.280 --> 00:04:32.160
excited about this, and I've
heard people yelling, good things

80
00:04:32.160 --> 00:04:34.860
about TypeScript and yelling, bad
things about TypeScript, even when

81
00:04:34.860 --> 00:04:37.620
it's just been out for
an hour. And some, some

82
00:04:37.620 --> 00:04:40.560
of the initial knee jerk
reactions are, well, why do

83
00:04:40.560 --> 00:04:43.560
we need this static typing
for tooling? We have tools

84
00:04:43.560 --> 00:04:47.610
that could be doing dynamic
interpretation of JavaScript, and then

85
00:04:47.610 --> 00:04:49.740
have the IDE give you
all the things like statement

86
00:04:49.740 --> 00:04:53.550
completion without that type of
information. Well, sometimes you can.

87
00:04:53.550 --> 00:04:56.730
And sometimes you can like,
if, if you're sitting, if

88
00:04:56.730 --> 00:04:58.290
you're sitting in a piece
of code or you have

89
00:04:58.290 --> 00:05:00.570
a function that takes a
parameter X, and that's all,

90
00:05:00.570 --> 00:05:04.080
you know, right now, then
there's just very little that

91
00:05:04.080 --> 00:05:06.360
a tool can do other
than show you all of

92
00:05:06.360 --> 00:05:09.390
the identifies that it's ever
seen. For example, when you,

93
00:05:09.390 --> 00:05:12.210
when you do statement completion
and that's where static typing,

94
00:05:12.210 --> 00:05:13.920
if you put an annotation
on it, you say, Hey,

95
00:05:13.920 --> 00:05:18.300
X is actually a type
string or customer or, or

96
00:05:18.300 --> 00:05:20.520
whatever, you know, then all
of a sudden we can

97
00:05:20.520 --> 00:05:23.730
light up a whole bunch
of touring experiences. But the

98
00:05:23.730 --> 00:05:26.370
cool thing about, about TypeScript
is that it all compiles

99
00:05:26.370 --> 00:05:29.760
away. So when you compile
all the type annotations go

100
00:05:29.760 --> 00:05:33.900
away, because they're purely there
for static verification at development

101
00:05:33.900 --> 00:05:38.670
time for static verification and
for tooling sake to age

102
00:05:38.670 --> 00:05:42.180
you in writing the code,
and then they just evaporate

103
00:05:42.390 --> 00:05:45.120
in the, in the generated
JavaScript. So there's no cost

104
00:05:45.120 --> 00:05:48.120
to, to doing it this
way. There's no runtime cost.

105
00:05:48.120 --> 00:05:51.330
It's just it's idiomatic. Yeah.
Yes, yes. TypeScript does not

106
00:05:51.330 --> 00:05:53.790
have a runtime library at
all. It is, it is

107
00:05:53.790 --> 00:05:56.490
just a tool. So let's
juxtapose it against a couple

108
00:05:56.490 --> 00:05:59.090
of different tools there. Cause
it's, some people were saying

109
00:05:59.420 --> 00:06:02.180
TypeScript, blah, blah, blah, coffee
script, or TypeScript, blah, blah,

110
00:06:02.180 --> 00:06:04.760
blah, closure, compiler. And these
are all not apples and

111
00:06:04.760 --> 00:06:08.930
oranges. These are apples and
cucumbers. Yeah. For example, you

112
00:06:08.930 --> 00:06:12.590
have optional type annotations, but
there are already optional type

113
00:06:12.590 --> 00:06:17.400
annotations in comments by other
sure, Sure. Yeah. So closure

114
00:06:17.500 --> 00:06:20.800
Google's closure uses comments to,
to, to, to put your

115
00:06:20.800 --> 00:06:25.120
optional type annotations, but you
know, it's, first of all,

116
00:06:25.120 --> 00:06:28.060
it's not a very expressive
place to put your type

117
00:06:28.060 --> 00:06:30.070
system, you know, and then
it's hard to make a

118
00:06:30.070 --> 00:06:32.440
complete type system. And it's
hard to have types that

119
00:06:32.440 --> 00:06:34.660
depend on other types. And
there are certain places where

120
00:06:34.660 --> 00:06:37.870
you can't really sneak into
comment and, and so forth.

121
00:06:37.900 --> 00:06:40.030
And it also just sort
of looks ugly, you know,

122
00:06:40.030 --> 00:06:42.850
and it's very verbose, right?
And so we felt, Hey,

123
00:06:43.240 --> 00:06:45.340
you know, if you're going
to put these annotations in

124
00:06:45.340 --> 00:06:47.200
there, why not make it
look like the language? So

125
00:06:47.200 --> 00:06:49.300
you can just look at
it and then actually reason

126
00:06:49.300 --> 00:06:52.600
about it in your head
without being visually disturbed by,

127
00:06:52.600 --> 00:06:56.200
by all of the noise,
right? And then there's languages

128
00:06:56.200 --> 00:06:59.500
like coffee script, which is,
which is on its surface.

129
00:06:59.530 --> 00:07:02.540
The closest that we would
initially want to compare, but

130
00:07:02.560 --> 00:07:04.990
COVID trips is a whole
other kind of language. I

131
00:07:04.990 --> 00:07:09.280
think there are two big
fundamental differences between coffee script

132
00:07:09.280 --> 00:07:13.150
and TypeScript. A difference. Number
one is that coffee script

133
00:07:13.150 --> 00:07:16.210
is a different language where
TypeScript is a superset of

134
00:07:16.210 --> 00:07:19.720
JavaScript. So in order to
learn TypeScript, well, you already

135
00:07:19.720 --> 00:07:22.480
know it. You just don't
know the few extensions that

136
00:07:22.480 --> 00:07:25.210
are in there for classes
and modules. And in fact,

137
00:07:25.360 --> 00:07:28.060
those, you will know once
you program with ECMAScript six.

138
00:07:28.060 --> 00:07:30.160
So even those are in
a sense JavaScript or a

139
00:07:30.160 --> 00:07:33.820
preview of it. So, so
all you have to learn

140
00:07:33.820 --> 00:07:36.910
is classes, modules, and how
to do your type annotations

141
00:07:36.910 --> 00:07:39.100
wherein in coffee script, you
have to learn a whole

142
00:07:39.100 --> 00:07:42.160
new thing. The other big
difference is that that coffee

143
00:07:42.160 --> 00:07:45.580
script doesn't have optional, static
typing, and therefore it can't

144
00:07:45.580 --> 00:07:49.570
really offer you any inherent
tooling advantages over a regular

145
00:07:49.570 --> 00:07:52.030
JavaScript. You know, at least
not to the extent that

146
00:07:52.030 --> 00:07:54.490
we can do with the
TypeScript. I've seen a couple

147
00:07:54.490 --> 00:07:57.100
of people confused, and I
believe that they're confused on

148
00:07:57.100 --> 00:07:59.740
Twitter saying that I tried
to quote unquote, convert my

149
00:07:59.740 --> 00:08:02.500
existing libraries to TypeScript, which
is a very kind of

150
00:08:02.560 --> 00:08:05.620
coffee script style of doing
things you'd copy paste, and

151
00:08:05.620 --> 00:08:08.620
then you'd start removing things.
Yeah. But with TypeScript, I

152
00:08:08.620 --> 00:08:10.630
would just, I mean, I've
changed my dot JS to

153
00:08:10.630 --> 00:08:13.120
a dot T S it
still works. Sure. You might

154
00:08:13.120 --> 00:08:14.830
get some errors because we
are in a sense, a

155
00:08:14.830 --> 00:08:17.800
link tool. So we will,
we will start flagging errors

156
00:08:17.800 --> 00:08:20.740
in there possibly, you know,
plus what you, what you

157
00:08:20.750 --> 00:08:23.260
likely want to do then
is add some type annotations

158
00:08:23.260 --> 00:08:25.750
to it. But I think
the thing that's interesting about

159
00:08:25.750 --> 00:08:28.120
TypeScript too, is that you
can actually choose to just

160
00:08:28.120 --> 00:08:31.240
leave your JavaScript alone and
not touch it at all.

161
00:08:31.240 --> 00:08:33.820
And then you can go
write a declaration file that

162
00:08:33.820 --> 00:08:37.930
provides the static type information
that is in a sense,

163
00:08:37.930 --> 00:08:41.200
you know, the static view
of what your library provides.

164
00:08:41.200 --> 00:08:43.840
And then you can use
dat when you're using the

165
00:08:43.840 --> 00:08:46.000
library and then the tools
will light up and give

166
00:08:46.000 --> 00:08:48.910
you all the statement completion
and so forth. Okay, interesting.

167
00:08:48.910 --> 00:08:51.490
So I might have an
existing Scott dot JS that

168
00:08:51.490 --> 00:08:53.770
I don't want to convert
to TypeScript, but I'll make

169
00:08:53.770 --> 00:08:57.660
a Scott dot D T
T S sitting parallel to

170
00:08:57.660 --> 00:09:00.060
it. Yes. It provides all
of that. An IDL file.

171
00:09:00.120 --> 00:09:04.010
Right, right. It sorta, but
it's, but it's a little

172
00:09:04.010 --> 00:09:07.700
nicer than IDL syntax. Yes.
But, and we've actually done

173
00:09:07.700 --> 00:09:13.100
this for the entire JavaScript
Dom and JavaScript runtime RDH

174
00:09:13.100 --> 00:09:16.730
ML dominant JavaScript runtime library.
We've also produced static type

175
00:09:16.730 --> 00:09:20.660
information or typing's for node
dot JS and for jQuery.

176
00:09:21.740 --> 00:09:24.950
And, you know, and we're
hoping that that the community

177
00:09:24.950 --> 00:09:26.840
will, will pick up and,
and do some of these

178
00:09:26.840 --> 00:09:29.720
typings, you know, because once
you do, they're, they're in

179
00:09:29.720 --> 00:09:32.150
a sense free, right. They're
cost free. There's no cost

180
00:09:32.150 --> 00:09:34.760
that runtime. But if you,
if you, if you make

181
00:09:34.760 --> 00:09:38.270
them, we can give you
a much better tooling experience.

182
00:09:38.810 --> 00:09:42.260
I think also there's another
thing that's interesting about these

183
00:09:42.260 --> 00:09:46.040
declaration files, which is that
there is really no common

184
00:09:46.040 --> 00:09:49.220
language that we can use
today. When we reason about

185
00:09:49.340 --> 00:09:52.010
what is in what is
in this library, how am

186
00:09:52.010 --> 00:09:54.590
I going to tell you
what's in there and how

187
00:09:54.590 --> 00:09:56.300
am I going to tell
you in the same language

188
00:09:56.300 --> 00:09:58.970
as the other guy over
here? So we can reason

189
00:09:58.970 --> 00:10:01.460
about what happens when we
combine these libraries and what

190
00:10:01.460 --> 00:10:04.460
types are shared and how,
how are they compatible. It

191
00:10:04.460 --> 00:10:06.980
simply doesn't exist today, right?
I mean, the only way

192
00:10:07.000 --> 00:10:09.560
you find out is by
either looking through the source

193
00:10:09.560 --> 00:10:13.070
code or this library, or
by groveling through some documentation

194
00:10:13.070 --> 00:10:17.420
website that uses a different
vernacular than the other documentation

195
00:10:17.420 --> 00:10:19.700
website. And so now you
sorta gotta translate in your

196
00:10:19.700 --> 00:10:22.730
head what they're talking about.
And, and so it's actually

197
00:10:22.730 --> 00:10:26.630
super useful just to have
a nomenclature and an agreed

198
00:10:26.630 --> 00:10:29.660
upon way to write down
these type declarations. And that's

199
00:10:29.720 --> 00:10:33.170
in a sense what types
group is too. So Number

200
00:10:33.170 --> 00:10:36.770
of people split up their
languages in kind of religious

201
00:10:36.770 --> 00:10:39.500
affiliations and they are the
dynamic people in there are

202
00:10:39.500 --> 00:10:43.070
the static people. And when
people refer to, to you

203
00:10:43.070 --> 00:10:45.710
and to Gosling into different
people who work on different

204
00:10:45.710 --> 00:10:49.310
languages and have, you know,
heritage involved in a language,

205
00:10:49.580 --> 00:10:51.890
they'll put you on the
side of the static typer.

206
00:10:51.890 --> 00:10:53.780
And they'll say that you're
a zealot, you're a religious

207
00:10:53.810 --> 00:10:56.390
zealot. You can continue to
push your static, typing work,

208
00:10:56.690 --> 00:10:58.940
you know, viewing the world,
even though we've added the

209
00:10:58.940 --> 00:11:02.330
dynamic keyword in the C-sharp.
Yeah. Do you have a

210
00:11:02.330 --> 00:11:05.600
particular kind of religious affiliation
as a programmer at, towards

211
00:11:05.600 --> 00:11:07.640
you? You really like things
to be static with strong?

212
00:11:08.180 --> 00:11:11.420
No. All what I like
to do is to build

213
00:11:11.420 --> 00:11:14.720
programmer productivity and bottle it
and sell it right. In

214
00:11:14.720 --> 00:11:17.150
a, in a sense, that's
what, that's what I see

215
00:11:17.150 --> 00:11:20.210
my job as now the,
the, the vehicle that I

216
00:11:20.210 --> 00:11:23.120
can do that through is
sometimes the language, sometimes the

217
00:11:23.120 --> 00:11:26.240
ID, you know, and it's
a symbiosis between all of

218
00:11:26.240 --> 00:11:29.060
those that makes programmers productive.
Right. And I think it's,

219
00:11:29.350 --> 00:11:32.090
it's silly to view it
as a religious argument. It

220
00:11:32.090 --> 00:11:35.330
is not religious. And honestly,
the thing that's interesting about

221
00:11:35.330 --> 00:11:38.420
TypeScript too, is the, the
religious view of it is

222
00:11:38.420 --> 00:11:41.540
that typing is an on,
off switch. It's either not

223
00:11:41.540 --> 00:11:45.140
there, or it's entirely statically
typed. We've changed the switch

224
00:11:45.140 --> 00:11:47.540
to a dial and TypeScript.
You can dial it all

225
00:11:47.540 --> 00:11:49.070
the way down to zero,
or you could dial it

226
00:11:49.070 --> 00:11:50.660
up as hard as you
as high as you want,

227
00:11:50.660 --> 00:11:53.470
you know, because some parts
of your code, but I

228
00:11:53.470 --> 00:11:55.330
don't need the checking. And
in fact, I don't want

229
00:11:55.330 --> 00:11:57.880
the check in here. Great.
Then don't add type invitations.

230
00:11:57.880 --> 00:12:00.700
And then there is no
checking, but in other places

231
00:12:00.700 --> 00:12:02.620
I might want more. And
so you add more type

232
00:12:02.620 --> 00:12:06.750
annotations. It's entirely pay for
plea. That's interesting that from

233
00:12:06.750 --> 00:12:09.450
the, from the side of
JavaScript going completely dynamic and

234
00:12:09.450 --> 00:12:12.510
then turning it slightly in
the dial direction towards static,

235
00:12:12.660 --> 00:12:15.990
there have been a number
of people taking C-sharp and

236
00:12:15.990 --> 00:12:18.870
trying to dial it down
from static. Some people have

237
00:12:18.870 --> 00:12:21.810
gone against linked to sequel
and against enemy framework and

238
00:12:21.810 --> 00:12:25.710
made micro ORMs that return
dynamics, right? People are writing

239
00:12:25.710 --> 00:12:28.290
a style of C-sharp where
it's just all the dynamic

240
00:12:28.290 --> 00:12:31.860
keywords everywhere that they can
do. Sometimes you have the

241
00:12:31.860 --> 00:12:35.310
metadata available, and sometimes you
don't, if you don't well

242
00:12:35.340 --> 00:12:38.250
fine, then you just do
what you do in JavaScript.

243
00:12:38.550 --> 00:12:41.670
But if you do have
the metadata, then why not

244
00:12:41.670 --> 00:12:44.010
put it to good use
in the tooling, right. And

245
00:12:44.010 --> 00:12:46.410
save yourself, having to sit
there with a cheat sheet

246
00:12:46.410 --> 00:12:48.450
or whatever it is you
use to figure out what,

247
00:12:48.750 --> 00:12:51.240
what methods are available on
some object. So it sounds

248
00:12:51.240 --> 00:12:54.450
like you don't, you don't
go with the IntelliSense rots,

249
00:12:54.450 --> 00:12:57.710
the brain perspective that some
people have. No, I, I

250
00:12:57.720 --> 00:13:00.780
most certainly do not. I
think IntelliSense saves you money.

251
00:13:01.950 --> 00:13:04.590
It makes you productive. It
allows you to focus on

252
00:13:04.590 --> 00:13:07.830
the creative process. And that's
the thing that humans bring

253
00:13:07.830 --> 00:13:11.370
to program. It is not
being a look up dictionary

254
00:13:11.370 --> 00:13:13.860
of what, what is in
some API that just brings

255
00:13:13.860 --> 00:13:17.010
nothing to the table, but
what time waste? Yeah. That's

256
00:13:17.010 --> 00:13:19.740
funny. That reminds me of
when syntax highlighting became really

257
00:13:19.740 --> 00:13:22.740
popular and, you know, the,
the, the get off my

258
00:13:22.740 --> 00:13:25.530
lawn guys were like, do
we need syntax highlighting, you

259
00:13:25.530 --> 00:13:28.320
know, green text on a
black screen was good enough.

260
00:13:28.410 --> 00:13:32.160
Yup. Yup. And Hey, you
know, I mean, sometimes you

261
00:13:32.160 --> 00:13:36.480
don't, and, and I completely
understand that, that if you're

262
00:13:36.510 --> 00:13:40.340
a single person writing a
large JavaScript application, you know

263
00:13:40.350 --> 00:13:42.810
exactly what every object is
and you made us all,

264
00:13:42.810 --> 00:13:44.940
and it's beautiful and it's
fast, mean you can change

265
00:13:44.940 --> 00:13:47.370
it into any other thing
that you want because you

266
00:13:47.370 --> 00:13:50.130
know everything about it in
your head, right. But once

267
00:13:50.130 --> 00:13:55.020
you start programming larger apps
in teams, you know, we

268
00:13:55.020 --> 00:13:58.770
just find that teams want
to have the ability to

269
00:13:58.770 --> 00:14:01.920
agree upon in between these
two modules, we have to

270
00:14:01.920 --> 00:14:03.930
follow in contract and they
want to have things that

271
00:14:03.930 --> 00:14:06.540
can validate that they are
adhering to the contract. You

272
00:14:06.540 --> 00:14:08.880
know, you can't just like
run into each other's office

273
00:14:08.880 --> 00:14:10.920
and like compare code all
the time. You, you want

274
00:14:10.920 --> 00:14:13.410
to have some sort of
agreed upon way that you

275
00:14:13.410 --> 00:14:16.020
write this down. And you
also want, when new people

276
00:14:16.020 --> 00:14:18.780
come in, something that tells
you a bit about what

277
00:14:18.780 --> 00:14:21.150
is a hundred thousand line
code based does. Right. How

278
00:14:21.150 --> 00:14:24.300
am I supposed to understand
what this parameter X's? I

279
00:14:24.600 --> 00:14:27.480
don't know. I don't know.
X tell me with an

280
00:14:27.480 --> 00:14:29.850
annotation. Right. So it sounds
to me like, if, if,

281
00:14:30.120 --> 00:14:33.720
if someone asks you, what
problem was this solving? JavaScript

282
00:14:33.720 --> 00:14:37.710
was fine. It's the problem
of large scale development. It's

283
00:14:37.710 --> 00:14:40.770
not that you're trying to
make JavaScript like C sharp

284
00:14:40.770 --> 00:14:42.810
or shove a type system
in where a type system

285
00:14:42.810 --> 00:14:45.450
wasn't one. Yeah. Right. Yeah.
Well, yeah. And, and, but

286
00:14:45.450 --> 00:14:47.700
I, but I would say
that tax group is super

287
00:14:47.700 --> 00:14:52.160
useful also for little development.
Right. Because it'll just be,

288
00:14:52.220 --> 00:14:54.410
if nothing else, it'll just
help you look up all

289
00:14:54.410 --> 00:14:56.750
of these methods on all
these jQuery objects or the

290
00:14:56.750 --> 00:14:59.060
Dom or whatever you're using.
Right. So, so you don't

291
00:14:59.060 --> 00:15:01.040
have to like, go look
it up yourself. And in

292
00:15:01.040 --> 00:15:04.150
that sense, it can improve
your productivity too. Well, like

293
00:15:04.150 --> 00:15:06.490
in visual studio, 2012, there's
a lot of improvements with

294
00:15:06.490 --> 00:15:10.480
the chakra engine. The, the,
I E 10 JavaScript engine

295
00:15:10.480 --> 00:15:14.710
running inside of the JavaScript
editor, because it's actually running

296
00:15:14.710 --> 00:15:17.350
the JavaScript all the time.
But in large scale development,

297
00:15:17.350 --> 00:15:20.200
I have actually personally found
that that fell down using

298
00:15:20.200 --> 00:15:23.320
sophisticated libraries. First of all,
I think they've done amazing

299
00:15:23.320 --> 00:15:26.590
work. And I was floored
when I saw what they

300
00:15:26.590 --> 00:15:29.440
actually could figure out out.
But the problem is it

301
00:15:29.440 --> 00:15:33.340
is almost impossible to, to
make it a hundred percent

302
00:15:33.340 --> 00:15:37.090
reliable, right? Because you can
do some speculative execution of

303
00:15:37.090 --> 00:15:40.420
code, but sometimes you can't
speculatively execute it because you

304
00:15:40.420 --> 00:15:42.310
can't make it get to
the point that you are

305
00:15:42.310 --> 00:15:44.710
in the code right now.
Or sometimes you just don't

306
00:15:44.710 --> 00:15:47.290
know if you're in some
file that has a function

307
00:15:47.290 --> 00:15:50.470
that has a parameter, and
you don't know what, what

308
00:15:50.470 --> 00:15:51.790
the type of that thing
is going to be. And

309
00:15:51.790 --> 00:15:53.830
there's nothing you can execute
to figure it out because

310
00:15:53.830 --> 00:15:57.880
no one's written any calls
to it yet. Hi, this

311
00:15:57.880 --> 00:15:59.470
is Scott and I've got
a cool offer from the

312
00:15:59.470 --> 00:16:04.150
folks@lynda.com, L Y N D
a.com. It's an online learning

313
00:16:04.150 --> 00:16:08.710
company. They've got more than
77,000 video tutorials. They teach

314
00:16:08.710 --> 00:16:13.120
software creative business skills. Memberships
started only $25 a month.

315
00:16:13.390 --> 00:16:16.450
You get unlimited 24 seven
access to all their top

316
00:16:16.450 --> 00:16:19.960
quality video courses. They're all
taught by expert instructors. You

317
00:16:19.960 --> 00:16:22.480
get to learn anytime, anywhere
at your own pace. There's

318
00:16:22.480 --> 00:16:26.770
bite-size tutorials, there's comprehensive courses.
You can learn web design

319
00:16:26.770 --> 00:16:32.560
and programming, regular design photography,
business, 3d animation, lots more

320
00:16:32.590 --> 00:16:35.890
lynda.com has got a variety
of courses for Microsoft developers.

321
00:16:35.920 --> 00:16:40.360
They've got courses on visual
studio, windows, windows, phones, SQL

322
00:16:40.360 --> 00:16:42.940
server. You can pick the
courses you want, put them

323
00:16:42.940 --> 00:16:45.670
in your queue for whenever
you're ready to watch. You

324
00:16:45.670 --> 00:16:47.590
can even learn on the
go. They've got an optimized

325
00:16:47.590 --> 00:16:50.920
mobile site, and they've even
got a free iPhone and

326
00:16:50.920 --> 00:16:55.090
iPad app for members. You
can try lynda.com L Y

327
00:16:55.150 --> 00:17:01.210
N D a.com free for
seven days, just visit lynda.com/hansel

328
00:17:01.210 --> 00:17:06.430
minutes, L Y N D
a.com/hansel minutes, exclusive for Hansel

329
00:17:06.430 --> 00:17:13.000
minutes, listeners lynda.com training online
for free seven days. Check

330
00:17:13.000 --> 00:17:18.100
it out. lynda.com/hansel minutes. When
there's also a number of

331
00:17:18.100 --> 00:17:21.880
things in JavaScript that we
as developers think ought to

332
00:17:21.880 --> 00:17:23.920
work. And we always fall
into them like this example

333
00:17:23.920 --> 00:17:25.930
of the scope this that
you give. Can you talk

334
00:17:25.930 --> 00:17:27.640
a little bit about that
and how you fix that?

335
00:17:28.270 --> 00:17:30.130
Sure. So one of, one
of the, one of the

336
00:17:30.130 --> 00:17:34.630
features proposed for ECMAScript six
is arrow functions and arrow

337
00:17:34.630 --> 00:17:36.670
functions. You know, if, if
we're, if you're a C

338
00:17:36.670 --> 00:17:40.720
sharp programmer is like Lambda
expressions, it's the same syntax

339
00:17:40.720 --> 00:17:44.560
as C sharp. Actually. Now
that the problem that that

340
00:17:44.560 --> 00:17:50.040
Lambda or that arrow functions
solve is, is that they

341
00:17:50.130 --> 00:17:55.500
inside and an arrow function.
This is lexical scope, meaning

342
00:17:55.500 --> 00:17:58.410
that you have to same
this as the surrounding function

343
00:17:59.550 --> 00:18:02.730
in JavaScript. This is actually
sort of this hidden parameter

344
00:18:02.730 --> 00:18:05.940
that gets passed to every
function. And you can't always

345
00:18:05.940 --> 00:18:08.550
be sure that you have
the right this, and then

346
00:18:08.550 --> 00:18:11.820
you end up operating on
the wrong object and therefore

347
00:18:11.820 --> 00:18:16.230
wrong things happen in your
app. This is in particular,

348
00:18:16.350 --> 00:18:19.860
a typical problem in event
handlers where, you know, someone

349
00:18:19.860 --> 00:18:23.370
calls you back supplying, not
that this, that you thought

350
00:18:23.370 --> 00:18:25.650
they were going to supply
you and now wrong things

351
00:18:25.650 --> 00:18:28.890
happen, right? So with arrow
functions, you can basically ignore

352
00:18:28.890 --> 00:18:33.300
the incoming this, and, and
just have the outer, this

353
00:18:33.300 --> 00:18:35.790
in scope still. And what
we will do when we

354
00:18:35.790 --> 00:18:39.420
generate ECMAScript or sorry, JavaScript
from, from these arrow functions

355
00:18:39.420 --> 00:18:42.750
is that we will do
the capture pattern where, where

356
00:18:43.020 --> 00:18:44.970
I'm sure you've written it,
where you say VAR, that

357
00:18:45.000 --> 00:18:47.400
equals this in the outer
function. And then the inner

358
00:18:47.400 --> 00:18:51.180
function, you say that.foo and
that.bar, instead of this stuff,

359
00:18:51.180 --> 00:18:53.220
who, and this bar, and
we can do that rewrite

360
00:18:53.220 --> 00:18:55.410
automatically. So this is one
of those things, again, that,

361
00:18:55.830 --> 00:18:58.650
that compilers are great at
doing and, and, and doing

362
00:18:58.650 --> 00:19:02.000
with precision, you know, So
you squirrel away that this

363
00:19:02.300 --> 00:19:04.100
in a variable and then
let it, let it, let

364
00:19:04.100 --> 00:19:06.470
it be really Only do
it if you actually refer

365
00:19:06.470 --> 00:19:08.540
to it. So, so we
optimize the best we can.

366
00:19:08.960 --> 00:19:13.010
So that's an interesting point
that would concern me if

367
00:19:13.070 --> 00:19:15.680
I were writing TypeScript and
then a bunch of helper

368
00:19:15.680 --> 00:19:19.580
functions, or utils suddenly got
injected into my code. You

369
00:19:19.580 --> 00:19:23.090
actually said that you, you
won't do that little trick

370
00:19:23.120 --> 00:19:26.180
unless you see that trick
is needed. That's correct. And

371
00:19:26.180 --> 00:19:29.060
in fact, we will, we
will not inject anything into

372
00:19:29.060 --> 00:19:32.600
your code. There's there's one,
the only one time we'll

373
00:19:32.600 --> 00:19:35.870
inject something is if you
have a derived class and

374
00:19:35.870 --> 00:19:38.720
then we inject a four
line helper function that helps

375
00:19:38.720 --> 00:19:41.600
us set up the prototype
chain, instead of inlining that

376
00:19:41.600 --> 00:19:43.130
code, you know, it's a
little more efficient to, just

377
00:19:43.130 --> 00:19:45.020
to have a, I have
a helper. That's the only

378
00:19:45.020 --> 00:19:48.200
time we inject anything into
your Java script, other than

379
00:19:48.410 --> 00:19:52.550
rewrites from classes into functions
and thought prototypes and blah,

380
00:19:52.550 --> 00:19:56.180
blah, blah. You know, the,
basically the idiomatic JavaScript that

381
00:19:56.180 --> 00:19:58.820
you would have had to
write, but your function bodies

382
00:19:58.820 --> 00:20:03.260
are always exactly what you
wrote. So the, the, the

383
00:20:03.260 --> 00:20:05.660
little chunk that you drop
in, that's something I would

384
00:20:05.720 --> 00:20:08.000
had to have written where
I to write that JavaScript

385
00:20:08.240 --> 00:20:12.380
from scratch. And I've noticed
that for, for small kind

386
00:20:12.380 --> 00:20:15.020
of four and five line
functions, it looks pretty one-to-one.

387
00:20:15.020 --> 00:20:17.150
But then as soon as
you start doing anything complex,

388
00:20:17.150 --> 00:20:19.040
where you add a class,
or you add a module,

389
00:20:19.280 --> 00:20:21.500
the amount of JavaScript you
had to write kind of

390
00:20:21.500 --> 00:20:25.340
explodes. Well, I mean, th
that, and that is why

391
00:20:25.340 --> 00:20:28.430
the ECMAScript committee is looking
at adding classes and modules

392
00:20:28.430 --> 00:20:30.890
to JavaScript, right. Is like,
you can't see the forest

393
00:20:30.890 --> 00:20:33.800
for the trees when you're
writing these, these, you know,

394
00:20:33.800 --> 00:20:37.790
function closures. And then, then,
then the, the funny patterns

395
00:20:37.790 --> 00:20:40.970
that people use, like the
setting up the prototype gene

396
00:20:40.970 --> 00:20:44.960
and whatever, it's just, it's
visually noisy. Right? And then

397
00:20:44.960 --> 00:20:46.880
it makes it hard for
you to sort of get

398
00:20:46.880 --> 00:20:48.940
a mental picture of what
your code is doing, because

399
00:20:48.940 --> 00:20:52.480
you're, you're getting like, like
distracted by all the details.

400
00:20:52.780 --> 00:20:54.460
And that's sort of the
noise that we can take

401
00:20:54.460 --> 00:20:57.780
away. These, these patterns that
people do to, to make

402
00:20:57.780 --> 00:21:00.960
classes work inside of JavaScript,
or to make modules work

403
00:21:01.260 --> 00:21:04.530
with these things that the
designers of JavaScript or the

404
00:21:04.530 --> 00:21:07.500
designer, or to of JavaScript
like thought about, or is

405
00:21:07.500 --> 00:21:09.420
it one of those things
where we, we hacked it

406
00:21:09.420 --> 00:21:11.750
and now it's the hack
that's everyone agrees. Is that,

407
00:21:12.140 --> 00:21:14.550
Yeah, no, no, actually these
are, these are patterns that

408
00:21:14.550 --> 00:21:16.500
have been there all along
and they're, there, there was

409
00:21:16.500 --> 00:21:20.250
always an intent now, now
with prototype, with prototype based

410
00:21:20.250 --> 00:21:22.950
programming, you can do other
patterns and just the class

411
00:21:22.950 --> 00:21:25.770
pattern, you know, but, but
the class pattern is really,

412
00:21:25.770 --> 00:21:28.170
Bob was what it was
put in there for. Right.

413
00:21:28.170 --> 00:21:31.920
And that is the, the,
the you step by far

414
00:21:32.380 --> 00:21:37.110
is the most common for
four prototypes. What about naysayers?

415
00:21:37.110 --> 00:21:39.210
Who might say that you're
trying to bring, you know,

416
00:21:39.210 --> 00:21:42.240
bad old patterns from the
nineties into this kind of

417
00:21:42.300 --> 00:21:45.450
brave new world of jobs.
Well, you know, just because

418
00:21:45.450 --> 00:21:47.220
there are classes, it doesn't
mean you have to use

419
00:21:47.220 --> 00:21:50.700
them, right. I mean, it's,
it's one of those things

420
00:21:50.700 --> 00:21:53.250
that it's a tool. And
if the tool works for

421
00:21:53.250 --> 00:21:55.200
you, well, then for God's
sakes, use it right. If

422
00:21:55.200 --> 00:21:58.200
it doesn't, then don't, you
know, you can, you can

423
00:21:58.200 --> 00:22:02.130
write a TypeScript that uses
just the, nor a D

424
00:22:02.130 --> 00:22:05.280
D other sort of closure
patterns that are common in

425
00:22:05.280 --> 00:22:08.070
Java script, where you use
local variables and NF, nested

426
00:22:08.070 --> 00:22:10.650
functions that close over the
local variables and so forth.

427
00:22:11.220 --> 00:22:14.550
We support that too. It's
just, there are an awful

428
00:22:14.550 --> 00:22:17.640
lot of people out there
that write an awful lot

429
00:22:17.640 --> 00:22:20.490
of object oriented programming, and
then they, it does seem

430
00:22:20.490 --> 00:22:23.400
to work for the world
at large. A lot of

431
00:22:23.400 --> 00:22:26.940
people have been saying, these
are more tech journalists saying

432
00:22:26.940 --> 00:22:32.190
that TypeScript is Microsoft's answer
to dart or Microsoft answer

433
00:22:32.190 --> 00:22:34.680
to coffee script. And well,
I don't work for the

434
00:22:34.680 --> 00:22:37.210
team. And I'm just an
opinionated blogger. I wrote a

435
00:22:37.470 --> 00:22:40.200
blog post that hopefully you
haven't seen yet where I

436
00:22:40.200 --> 00:22:43.590
just said, Oh, no. Okay.
Well, it says, why does

437
00:22:43.590 --> 00:22:45.330
it have to be an
answer to anything? I mean,

438
00:22:45.390 --> 00:22:49.650
are you guys sitting around
thinking, Oh, they they've, they've

439
00:22:49.650 --> 00:22:52.230
sent a shot across our
bow. We have to answer,

440
00:22:52.530 --> 00:22:55.920
or you just do it.
Listen, it is an answer

441
00:22:55.920 --> 00:22:58.080
to something. It is an
answer to the cry for

442
00:22:58.080 --> 00:23:01.500
more productive, JavaScript development tools.
That is what it's an

443
00:23:01.500 --> 00:23:04.320
answer to. It's not a
technology answer to a specific

444
00:23:04.320 --> 00:23:09.090
technology. No, No. It's about
making programmers more productive. And

445
00:23:09.990 --> 00:23:13.410
is it, what's in it
for Microsoft? I mean, it's

446
00:23:13.410 --> 00:23:18.800
open source. It's NPM install.
It's far too nice for,

447
00:23:18.800 --> 00:23:22.290
for Microsoft to be doing
this. Well, listen, this is

448
00:23:22.290 --> 00:23:24.780
the way the world works
now. Right. And we, we,

449
00:23:24.870 --> 00:23:27.240
we have to adapt. And
we, and, and honestly, I

450
00:23:27.240 --> 00:23:29.430
think it's a lot of
fun to work in, in

451
00:23:29.430 --> 00:23:32.970
this more open environment where,
where you can find likeminded

452
00:23:32.970 --> 00:23:35.730
people from anywhere on the
globe. Right. And you can

453
00:23:35.730 --> 00:23:38.280
see on internet time, you
know, I mean, we we've

454
00:23:38.280 --> 00:23:41.010
been out since Monday and
there's already support in cloud

455
00:23:41.010 --> 00:23:43.480
nine editing for four for
TypeScript. You know, it, it

456
00:23:43.490 --> 00:23:46.940
happen in like less than
48 hours. Right. It's fantastic.

457
00:23:47.000 --> 00:23:49.130
And I think it's super
exciting to be part of.

458
00:23:49.170 --> 00:23:53.380
Yeah. So we shipped a
visual studio plugin and then

459
00:23:53.380 --> 00:23:56.350
some initial plugins for like
Emacs and, and, and supply.

460
00:23:56.680 --> 00:24:00.910
Yeah. You mean XVI and
sublime? Yeah. Okay. So presumably

461
00:24:00.910 --> 00:24:03.460
the visual studio one is
like the best example of

462
00:24:03.460 --> 00:24:05.830
what or so far of
what the strong tooling can

463
00:24:05.830 --> 00:24:09.070
offer. It's got the refactoring
things like. Sure. Yes. But

464
00:24:09.070 --> 00:24:11.260
all of the, all of
the things that you see

465
00:24:11.260 --> 00:24:15.280
in the visual studio plugin
are actually powered by the

466
00:24:15.280 --> 00:24:18.940
TypeScript compiler and language service,
which are written in TypeScript

467
00:24:18.970 --> 00:24:21.250
and are open source and
a part of the, of

468
00:24:21.250 --> 00:24:24.130
the distribution they said, and
their Coplex get depo right

469
00:24:24.130 --> 00:24:27.040
now. You can go, go
check them out. Basically what

470
00:24:27.040 --> 00:24:30.460
we do in visual studios,
we load up the JavaScript

471
00:24:30.460 --> 00:24:32.410
compiler, and then we run
it in the background and

472
00:24:32.410 --> 00:24:35.740
use the language services for
colorization statement completion and so

473
00:24:35.740 --> 00:24:38.980
forth. And the only thing
that's that's visual studio specific

474
00:24:38.980 --> 00:24:41.710
about is really is a
shim that we've written in

475
00:24:41.710 --> 00:24:44.740
C sharp that shims it
into visual studio. Right. Interesting.

476
00:24:44.740 --> 00:24:47.560
Cause one of the first
things that someone tweeted was

477
00:24:47.800 --> 00:24:50.560
where is the open source
version of this, you know,

478
00:24:50.560 --> 00:24:53.800
this editor. Yeah. You're saying
that all of the hard

479
00:24:53.800 --> 00:24:56.200
work is being done in
the open source bits that

480
00:24:56.200 --> 00:24:59.380
they already have. Yes. The
hard work. I mean, there's

481
00:24:59.380 --> 00:25:02.770
a, in the playground, there's
an editor control that we've

482
00:25:02.770 --> 00:25:06.910
written, but that uses this
stuff, but the intelligence behind

483
00:25:06.910 --> 00:25:09.640
it is all the openings
Really. Okay. So when you're

484
00:25:09.640 --> 00:25:13.210
typing, whatever dot and you
get statement completion, you've got

485
00:25:13.210 --> 00:25:16.240
that information available. Yeah. That's
the, that's the compiler running

486
00:25:16.240 --> 00:25:19.720
in the background. When you
opened up a few minutes

487
00:25:19.720 --> 00:25:22.270
ago on stage, you opened
up a Ts file and

488
00:25:22.270 --> 00:25:25.990
then suddenly it knew about
all these other Ts files.

489
00:25:25.990 --> 00:25:28.900
Like you didn't open a
project. Right. Right. Yeah. So

490
00:25:28.900 --> 00:25:30.850
one of the things we
allow you to do is

491
00:25:30.850 --> 00:25:34.750
we, first of all, we
support two common module systems

492
00:25:34.750 --> 00:25:38.770
that are out there, common
JS and AMD modules. And

493
00:25:38.770 --> 00:25:40.930
those are the kinds of
modules. The common JS modules

494
00:25:40.930 --> 00:25:43.930
are used by node dot
JS. And so when you,

495
00:25:43.990 --> 00:25:48.850
when you write a modular
application in TypeScript, we can

496
00:25:48.850 --> 00:25:51.790
look at all of your
import statements and see what

497
00:25:51.790 --> 00:25:54.520
references they, what modules they
referenced. And then we can

498
00:25:54.520 --> 00:25:56.650
in turn low dose up
and look at their import

499
00:25:56.650 --> 00:26:00.970
statements. And you can also
put reference comments in your

500
00:26:00.970 --> 00:26:03.610
files that say, Hey, by
the way, when you compile

501
00:26:03.610 --> 00:26:06.310
this file also compiled as
other file along with it.

502
00:26:06.940 --> 00:26:10.570
And we can automatically then
trace the whole graph of

503
00:26:10.570 --> 00:26:14.740
connected files if you will.
So whenever you compile a

504
00:26:14.740 --> 00:26:17.350
file, we automatically do that.
And we compile all of

505
00:26:17.350 --> 00:26:20.080
these other files alongside with
it. Then that's how we

506
00:26:20.080 --> 00:26:22.870
can get a consistent view
of your, of your context

507
00:26:22.900 --> 00:26:25.370
at all times. And we
do that in the ID

508
00:26:25.400 --> 00:26:27.970
also. So we can infer
what your project is by

509
00:26:27.970 --> 00:26:31.960
looking at all of these,
these imports and reference comments.

510
00:26:32.440 --> 00:26:34.660
One of the things that
took me awhile to kind

511
00:26:34.660 --> 00:26:37.180
of click cause again, it's
only been since Monday, but

512
00:26:37.180 --> 00:26:39.160
I think it just clicked
about an hour ago was

513
00:26:39.160 --> 00:26:42.430
the flow. You keep talking
about flow, you could have

514
00:26:42.430 --> 00:26:45.960
a regular file, like anything
you've ever written, put a

515
00:26:45.960 --> 00:26:50.550
single annotation on the right
place and then everything lights

516
00:26:50.630 --> 00:26:53.330
And then watch the types
flow down from there. Yes.

517
00:26:53.420 --> 00:26:56.540
And, and that's, that's the
beauty of type inference when

518
00:26:56.540 --> 00:26:59.480
it really works, right? Is
that you get all of

519
00:26:59.480 --> 00:27:02.990
this static typing just from
sorta at the root of

520
00:27:02.990 --> 00:27:06.080
your app, your app object,
you say, Hey, my app

521
00:27:06.110 --> 00:27:09.500
is an express server. Great.
Then we can flow from

522
00:27:09.500 --> 00:27:11.750
there that there's a get
method. And the get method

523
00:27:11.750 --> 00:27:14.720
has a, is a function
that takes a call back

524
00:27:14.720 --> 00:27:16.640
that has two arguments. And
so we can flow the

525
00:27:16.640 --> 00:27:21.080
types into those and almost
by magic provide you all

526
00:27:21.080 --> 00:27:24.830
of the static type information
readily available in code completion,

527
00:27:24.830 --> 00:27:27.770
and then refactorings and so
forth without you actually having

528
00:27:27.770 --> 00:27:31.880
to do any work almost.
But I don't want to

529
00:27:32.060 --> 00:27:34.550
pretend that it's magic. I
mean, there's obviously some work,

530
00:27:34.580 --> 00:27:37.280
but it, but, but it
is quite astonishing to see,

531
00:27:38.690 --> 00:27:42.440
to see it in action.
In the, in the opening

532
00:27:42.770 --> 00:27:45.890
keynote that I got to
give, I gave a talk

533
00:27:45.890 --> 00:27:48.320
called angle brackets and curly
braces. And I talked about

534
00:27:48.710 --> 00:27:51.140
the one virtual machine and
the one language you get

535
00:27:51.140 --> 00:27:53.600
on the client, right. And
the many virtual machines and

536
00:27:53.600 --> 00:27:55.400
the many languages you get
on the server. Right. And

537
00:27:55.400 --> 00:27:57.980
how excited I was about
that. And then at the

538
00:27:57.980 --> 00:28:00.710
very end of the closing
keynote, you, the creator of

539
00:28:00.710 --> 00:28:04.580
C sharp gives a talk
on a JavaScript thing. Do

540
00:28:04.580 --> 00:28:08.270
I now panic that you've
jumped ship and you've, you've

541
00:28:08.270 --> 00:28:10.090
given up and now you've
gone to the other side.

542
00:28:10.910 --> 00:28:13.970
No, no. But listen, as
we talked about earlier about

543
00:28:14.540 --> 00:28:20.600
religious allegory, I am not
a religious C-sharp zealot. I'm

544
00:28:20.600 --> 00:28:24.080
a language designer and when
language design problems present themselves,

545
00:28:24.080 --> 00:28:27.140
I jump in because I'm
fascinated by what you can

546
00:28:27.140 --> 00:28:30.530
do with languages and for
example, but static typing, you

547
00:28:30.530 --> 00:28:33.890
know, and, and, and, and
so, so that's what I

548
00:28:33.890 --> 00:28:37.610
do, you know, I mean,
now C-sharp is, has a

549
00:28:37.610 --> 00:28:40.640
long, healthy life ahead of
it. I'm still involved in

550
00:28:40.640 --> 00:28:43.190
that project. You know, we
just shipped, she sharp Five-O

551
00:28:43.580 --> 00:28:48.350
with some really cool extensions
for asynchronous programming that, that

552
00:28:48.350 --> 00:28:51.500
I think are just fantastic.
And we're still going on

553
00:28:51.500 --> 00:28:53.930
the Rosslyn project, which is
a project to rewrite that

554
00:28:54.110 --> 00:28:57.110
she shot VB compilers and
the IDE, and all-in managed

555
00:28:57.110 --> 00:29:00.980
code and provide compiler as
an API services on top

556
00:29:00.980 --> 00:29:04.460
of that. And so there's
lots of, lots of investment

557
00:29:04.460 --> 00:29:07.100
and excitement still in, in,
in C sharpen and dot.

558
00:29:07.670 --> 00:29:09.460
Okay, cool. That makes me
feel better. Oh yeah. Yeah.

559
00:29:09.500 --> 00:29:11.540
Cause one of the things
that I thought was really

560
00:29:11.540 --> 00:29:14.180
well said, I think it
was actually Luke Hoban who

561
00:29:14.180 --> 00:29:20.960
works on the, on the
projects that coffee script makes

562
00:29:21.020 --> 00:29:25.610
JavaScript feel comfortable to Ruby
programmers. Therefore TypeScript can make

563
00:29:25.610 --> 00:29:29.570
JavaScript feel comfortable for C
sharp programmer C sharp or

564
00:29:29.570 --> 00:29:32.960
Java programmers or any anyone's
who sorta, because, you know,

565
00:29:32.960 --> 00:29:36.290
I mean, it's, it's, it's
like JavaScript is a language

566
00:29:36.290 --> 00:29:38.570
in the curly brace family.
Right. Right. And so, so

567
00:29:38.570 --> 00:29:41.770
if you're a curly brace
programmer today, well, most of

568
00:29:41.770 --> 00:29:44.710
the other curly braise languages
actually do have static typing.

569
00:29:44.710 --> 00:29:46.720
Right. And so, in a
sense, while we're layering on

570
00:29:46.720 --> 00:29:51.010
top here is optional static
typing that has no cost

571
00:29:51.010 --> 00:29:54.090
than exists just that development
time. Right. Right. So if

572
00:29:54.090 --> 00:29:57.360
you're a C, C plus
plus Java C sharp programmer,

573
00:29:57.600 --> 00:29:59.880
this might just feel right
to you. I think it

574
00:29:59.880 --> 00:30:02.880
feels very familiar when you
bring your yup. Yup. Yeah.

575
00:30:02.910 --> 00:30:05.820
That is, that is, that
is consistently the thing that

576
00:30:05.820 --> 00:30:08.160
I hear C-sharp programmers telling
me once they play with

577
00:30:08.160 --> 00:30:10.770
this for low Wiseco. Wow.
This feels just like being

578
00:30:10.770 --> 00:30:13.440
home. Yeah. I really like
that. You've got an online

579
00:30:13.440 --> 00:30:16.170
playground. You go to TypeScript
lang.org and you can see

580
00:30:16.170 --> 00:30:18.570
that there's a type TypeScript
on the left and on

581
00:30:18.570 --> 00:30:21.270
the right hand side, it
expands. And if you've been

582
00:30:21.270 --> 00:30:24.270
working in JavaScript, you'll see
these familiar patterns emerge. And

583
00:30:24.270 --> 00:30:27.240
then you'll realize that while
it doesn't have the kind

584
00:30:27.240 --> 00:30:30.540
of intense terseness of coffee
script, there is a risk

585
00:30:30.780 --> 00:30:34.620
friendly ness about TypeScript where
it's like, wow, I didn't

586
00:30:34.620 --> 00:30:36.840
have to write all those
curly braces and deal with

587
00:30:36.840 --> 00:30:40.170
all that nesting Reality is
that even if you're coding

588
00:30:40.170 --> 00:30:42.720
in coffee script, you still
have to be proficient in

589
00:30:42.720 --> 00:30:45.630
JavaScript. Right. So, so you
now have to learn to

590
00:30:45.630 --> 00:30:48.810
live. So you're not trying
to hide it. We're no,

591
00:30:48.810 --> 00:30:51.180
we're trying, we're trying to
make just, what is it,

592
00:30:51.210 --> 00:30:54.090
what are qualitatively? What are
the few things that are

593
00:30:54.090 --> 00:30:58.380
missing from JavaScript itself? And
how can we add those

594
00:30:58.380 --> 00:31:01.380
without disturbing all of the
advantages of Java script. Right.

595
00:31:01.380 --> 00:31:04.350
And that's, that's what we're
doing. So there's no runtime

596
00:31:04.350 --> 00:31:07.110
library. There's no virtual machine.
You're not generating a bunch

597
00:31:07.110 --> 00:31:09.360
of extra code that I
can't see. Correct. This is

598
00:31:09.360 --> 00:31:11.970
all about tooling. Yeah. Very,
very cool. Well, thanks so

599
00:31:11.970 --> 00:31:14.550
much for chatting with me.
This was fun. Yeah. All

600
00:31:14.550 --> 00:31:16.590
right. This has been another
episode of Hanselminutes and we'll

601
00:31:16.590 --> 00:31:17.760
see you again next week.


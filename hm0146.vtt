WEBVTT FILE

1
00:00:12.000 --> 00:00:17.280
From Hansel minutes.com. It's Hanselman.
It's a weekly discussion with

2
00:00:17.280 --> 00:00:22.800
web developer and technologists. Scott
Hanselman hosted by Carl Franklin. This

3
00:00:22.800 --> 00:00:26.850
is Lawrence Ryan announcing show number
one 46. Recorded live Monday,

4
00:00:26.850 --> 00:00:32.580
January 12th, 2009. Support for Hanselman it's
just provided by Tellerik rad

5
00:00:32.580 --> 00:00:36.210
controls, the most comprehensive suite
of components for windows forms

6
00:00:36.210 --> 00:00:46.860
and asp.net web applications online@wwwdotterikdotcomandby.net
developers journal the world's leading.net

7
00:00:46.860 --> 00:00:53.160
developer magazine online at www
dot <inaudible> dot com. In

8
00:00:53.160 --> 00:00:56.580
this episode, Scott talks test
driven development with Scott bellwether.

9
00:00:59.370 --> 00:01:01.380
Hi, this is Scott Hanselman,
and this is another episode

10
00:01:01.380 --> 00:01:04.050
of Hanselminutes. And in this
episode, we're sitting down with

11
00:01:04.050 --> 00:01:08.160
Scott bellwether, the agile coach
from Austin, Texas, and he

12
00:01:08.160 --> 00:01:12.390
proposed that. We talk about
test driven development, but specifically

13
00:01:12.390 --> 00:01:15.090
he wanted to call this
talk test driven development. The

14
00:01:15.090 --> 00:01:18.990
last word, the Scott has
some really interesting opinions about

15
00:01:19.020 --> 00:01:21.630
how TDD is being perceived
and being preached in the

16
00:01:21.630 --> 00:01:24.360
community. So I thought that'd
be a real fun discussion.

17
00:01:24.360 --> 00:01:26.930
Thanks, Scott, for sitting down
with me today. Yeah, thanks

18
00:01:26.930 --> 00:01:29.900
for having me on. So
the last word, you know,

19
00:01:29.900 --> 00:01:32.300
that that really implies that
test driven development is being

20
00:01:32.300 --> 00:01:35.660
presented in a way that's
not entirely accurate and we

21
00:01:35.660 --> 00:01:37.910
want to kind of slam
the door shut on that

22
00:01:38.390 --> 00:01:41.600
and move forward. So what
is not being presented appropriately

23
00:01:42.020 --> 00:01:45.680
with regards to TDD in
the community today? I think

24
00:01:45.680 --> 00:01:51.610
that it's, it's pretty well
represented fairly accurately. The, the

25
00:01:51.890 --> 00:01:54.410
problem I think comes in
when we leap to the

26
00:01:54.410 --> 00:01:58.190
assumption of testing, every time
that we start talking about

27
00:01:58.190 --> 00:02:02.630
test driven development or, or
these conversations about software testing

28
00:02:02.630 --> 00:02:09.650
or software quality assurance, it's
almost inevitable now that someone

29
00:02:09.650 --> 00:02:14.030
will turn the conversation to
test driven development, like, you

30
00:02:14.030 --> 00:02:16.280
know, well, you know, let's
talk about quality. And then

31
00:02:16.310 --> 00:02:17.960
what, what do you think
about TDD and how does

32
00:02:17.960 --> 00:02:21.470
the supply, and I think
some of the, the little

33
00:02:21.470 --> 00:02:23.090
bit of the shocker for
me, and maybe it's a

34
00:02:23.090 --> 00:02:26.210
shocker, hopefully for the audience,
is that folks who do

35
00:02:26.210 --> 00:02:29.540
test driven development assert and
have asserted for quite a

36
00:02:29.540 --> 00:02:34.430
long time, that TDD is
more about design than, about

37
00:02:34.430 --> 00:02:38.300
testing. And it doesn't, it
there's a little bit of

38
00:02:38.300 --> 00:02:41.780
benefit to come about talking
about TDD when we're talking

39
00:02:41.780 --> 00:02:45.110
about testing. But you know,
only as talking about the

40
00:02:45.110 --> 00:02:47.960
side effects, the quality side
effects of TDD and it's

41
00:02:48.680 --> 00:02:51.860
it's. So I think a
agregious or it's become, so

42
00:02:51.860 --> 00:02:54.800
agregious over the years that,
you know, TDD has even

43
00:02:54.800 --> 00:02:59.830
been somewhat renamed in, in
recent times to from test

44
00:02:59.830 --> 00:03:03.430
driven development, the behavior of
different development, really to draw

45
00:03:03.430 --> 00:03:07.240
a line in the sand
and, and, and say, you

46
00:03:07.240 --> 00:03:10.060
know, this is not about
testing. This is about something

47
00:03:10.060 --> 00:03:15.040
else. We've got this unfortunate
heritage of TDD that has

48
00:03:15.040 --> 00:03:19.330
the word test in the
name, but it's not. And

49
00:03:19.330 --> 00:03:22.510
we should really endeavor, I
think, more of an effort

50
00:03:22.510 --> 00:03:26.140
to, to preserve the value
that the intrinsic value that

51
00:03:26.140 --> 00:03:29.320
TDD offers and TDD has
really given it, the old

52
00:03:29.320 --> 00:03:33.250
college try to say, Hey,
every time I'm talking about

53
00:03:33.460 --> 00:03:36.400
testing and someone, and I'm
feel my mind wanting to

54
00:03:36.400 --> 00:03:40.090
stray to TDD, maybe I
should program myself to throw

55
00:03:40.090 --> 00:03:44.310
an exception or something like
that. Well, I think that

56
00:03:44.750 --> 00:03:48.870
the, the name, the simple
name test driven development describes

57
00:03:48.870 --> 00:03:52.860
the mechanical action of the
style of development. Yes, yes.

58
00:03:52.860 --> 00:03:56.610
One does test yes. An
aspect of the test drive

59
00:03:56.610 --> 00:04:01.680
development, but, but it's, it's,
that's the, that's the physical

60
00:04:01.710 --> 00:04:03.810
aspects of things. And it's
a bit, it's a bit

61
00:04:03.810 --> 00:04:06.480
of a gray area too,
because even if I say

62
00:04:06.480 --> 00:04:10.680
this is about testing, it's
about design rather than testing.

63
00:04:11.070 --> 00:04:13.620
There's always going to be
an aspect of testing in

64
00:04:13.620 --> 00:04:17.970
TDD, Right. But to write
tests and have them drive

65
00:04:17.970 --> 00:04:21.270
the development, isn't necessarily the
purpose, the whole, the whole

66
00:04:21.270 --> 00:04:25.140
reason for existence of this
style of development. I haven't

67
00:04:25.140 --> 00:04:28.890
felt though that behavior driven
development, well, it seems like

68
00:04:28.890 --> 00:04:31.580
it feels, it feels better
to say for me, it

69
00:04:31.590 --> 00:04:34.530
still doesn't quite say it
right. You know how they

70
00:04:34.530 --> 00:04:37.380
always say an object oriented
programming, you need to really

71
00:04:37.380 --> 00:04:40.110
name it before you can
understand it. And I almost

72
00:04:40.110 --> 00:04:42.790
feel like we haven't named
this style of development and

73
00:04:42.790 --> 00:04:45.660
in a way, at least
for me, that resonates. I

74
00:04:45.660 --> 00:04:49.260
think that if you there's
a behavior driven development discussion

75
00:04:49.260 --> 00:04:52.110
group on Google groups, I
don't remember the address right

76
00:04:52.110 --> 00:04:55.140
now, but I'm sure you
can Google Sure. We'll put

77
00:04:55.140 --> 00:04:59.100
it on the show notes.
And that same thing is

78
00:04:59.100 --> 00:05:01.440
reflected in behavior driven development.
I mean, not only did

79
00:05:01.440 --> 00:05:05.820
behavior driven development change the
name in order to try

80
00:05:05.820 --> 00:05:09.390
to resolve this issue about
TDD in testing, but it,

81
00:05:10.350 --> 00:05:13.380
it also is 10 years
later and some of the

82
00:05:13.380 --> 00:05:16.470
practices have been changed and,
and it introduces its own

83
00:05:16.470 --> 00:05:20.160
set of confusion as any
new thing or new practice

84
00:05:20.160 --> 00:05:25.140
does. So it's questionable whether
the name, you know, actually

85
00:05:25.170 --> 00:05:29.520
does anything except change the
name from test driven development.

86
00:05:29.520 --> 00:05:31.560
And I think that there's
great value in that. I

87
00:05:31.560 --> 00:05:34.680
think it's also quite sad
though, that, that, that no

88
00:05:34.680 --> 00:05:36.930
matter how often it was
brought up or how often

89
00:05:36.930 --> 00:05:40.260
it was pointed out, or
even requested folks to really

90
00:05:40.290 --> 00:05:45.210
consider TDD as testing, rather
than I'm sorry, it has

91
00:05:45.210 --> 00:05:48.240
designed rather than testing that
it never really sank in.

92
00:05:48.240 --> 00:05:52.470
And I find this fascinating.
I think that that questions

93
00:05:52.470 --> 00:05:58.610
and conversations about quality are
somehow, sometimes even damaged when

94
00:05:58.610 --> 00:06:03.950
we, when we let them
fall over into, into conversations

95
00:06:03.950 --> 00:06:07.580
about test driven development. If
you look at writing tests

96
00:06:07.640 --> 00:06:12.680
first, as a means to
achieve software quality from the

97
00:06:12.680 --> 00:06:15.050
perspective of a, you know,
a tester's perspective or a

98
00:06:15.050 --> 00:06:18.770
quality assurance perspective, it's going
to seem pretty senseless. It'll,

99
00:06:18.890 --> 00:06:22.220
you know, TDD will we'll
create quality, but not the

100
00:06:22.220 --> 00:06:26.360
kind of quality that, you
know, the word quality applies

101
00:06:26.360 --> 00:06:29.810
in a different way. I
thought it was fascinating listening

102
00:06:29.810 --> 00:06:34.670
to Carl Franklin, his conversation with
dr. Whitaker and there was

103
00:06:34.670 --> 00:06:37.520
a pretty good, it was
a pretty good episode of,

104
00:06:38.300 --> 00:06:43.830
of your brother's show.net and
a, and a, and I

105
00:06:43.850 --> 00:06:45.290
hope a lot of people
get a chance to listen

106
00:06:45.290 --> 00:06:48.920
to, to dr. Whitaker's perspective,
the only, you know, and

107
00:06:48.920 --> 00:06:50.720
I, some of it I
agreed with and some of

108
00:06:50.720 --> 00:06:52.850
it, I thought it was
a little bit safe. I,

109
00:06:52.860 --> 00:06:55.250
and that's kinda, you know,
that's great. At least at

110
00:06:55.250 --> 00:06:57.530
least there was, it was
engaging. And I appreciated that.

111
00:06:57.560 --> 00:06:59.660
But when it got to
the test driven development question,

112
00:07:00.650 --> 00:07:03.290
it was to me internally,
one of those things like,

113
00:07:03.320 --> 00:07:06.590
Hey, why, why is test
driven development coming up in

114
00:07:06.590 --> 00:07:10.280
the conversation about software quality
and software quality tools? And

115
00:07:10.280 --> 00:07:11.720
for me, it's natural to
think that way. And I

116
00:07:11.720 --> 00:07:14.060
think it's natural to think
that way, for many folks

117
00:07:14.060 --> 00:07:18.350
who do test driven development,
but it's really kind of

118
00:07:18.380 --> 00:07:20.870
hurting test driven development and
the value that it brings.

119
00:07:20.870 --> 00:07:23.150
And I think it also
hurts these conversations about quality.

120
00:07:24.490 --> 00:07:27.220
Okay. So let's, let's do,
let's try this thought experiment.

121
00:07:27.220 --> 00:07:30.070
Let's back up and let's
go from the point of

122
00:07:30.070 --> 00:07:33.520
view of someone who works.
Let's use my economical engineer.

123
00:07:33.520 --> 00:07:36.220
This is the guy that
I call the chief architect

124
00:07:36.220 --> 00:07:39.790
at the Nebraska department of
forestry. He's got, you know,

125
00:07:39.790 --> 00:07:42.550
he's got access machines and
he's learning asp.net. And he

126
00:07:42.550 --> 00:07:44.830
maybe started out as a
Phoebe guy, but maybe it

127
00:07:44.830 --> 00:07:48.820
doesn't really have the deep
computer science passion or the

128
00:07:48.820 --> 00:07:50.920
deep software engineering passion that
a lot of people have.

129
00:07:51.130 --> 00:07:52.600
He's just a guy, who's
got a job and he

130
00:07:52.600 --> 00:07:54.130
enjoys it, but he really
wants to be a better,

131
00:07:54.610 --> 00:07:57.550
better person. This is, you
know, 70% of developers out

132
00:07:57.550 --> 00:08:01.930
there. They want to do
better, but they're, they're saddled

133
00:08:01.930 --> 00:08:04.750
by some issues, whether they
be organizational or technical or

134
00:08:04.750 --> 00:08:08.110
whatever, he starts a new
project. And someone says, Hey,

135
00:08:08.110 --> 00:08:09.580
wait a second. You need
to be writing the tests

136
00:08:09.590 --> 00:08:12.520
first. You need to let
the test drive the development.

137
00:08:12.550 --> 00:08:15.220
And then they give him
the elevator speech on test

138
00:08:15.220 --> 00:08:18.490
driven development. And what I'm
hearing you say is that

139
00:08:18.490 --> 00:08:20.440
he's going to immediately say,
Oh, okay, well, this will

140
00:08:20.440 --> 00:08:23.920
mean that I'll have lots
of tests and I can

141
00:08:23.920 --> 00:08:25.570
go to the command line.
I can type bill dot

142
00:08:25.570 --> 00:08:28.390
bat and test bat, and
I'll have more confidence that

143
00:08:28.390 --> 00:08:31.000
my application works. And then
he goes on with his

144
00:08:31.000 --> 00:08:34.210
life. And you're saying that
that is completely missing the

145
00:08:34.210 --> 00:08:40.180
point he's, he's, he's missing
an opportunity here. Well, I

146
00:08:40.180 --> 00:08:43.090
think if he's trying to
get the opportunity that test

147
00:08:43.090 --> 00:08:47.560
driven development brings to the
party, that he's very possibly

148
00:08:47.560 --> 00:08:51.850
missing point of test driven
development, that in the summary

149
00:08:51.850 --> 00:08:54.550
that you just presented, it
didn't really sound like the

150
00:08:54.550 --> 00:08:57.560
case for driven development was
made. No, it doesn't, but

151
00:08:57.560 --> 00:08:59.780
that's very typical. I mean,
I've, I've lived through those

152
00:08:59.780 --> 00:09:02.990
experiences and lots of times
where someone is introduced to

153
00:09:02.990 --> 00:09:06.110
test room development and in
a very basic sense. Well,

154
00:09:06.110 --> 00:09:08.960
if you introduce it, I
mean, even, I mean, I

155
00:09:08.960 --> 00:09:11.690
would expect anybody to Bach.
If I walked up to

156
00:09:11.690 --> 00:09:14.540
them and say, Hey, you
know, this new unit testing

157
00:09:14.540 --> 00:09:16.820
thing, let's do that. It's
really good. And that person

158
00:09:16.820 --> 00:09:18.440
says, yeah, I've heard of
this. That's a great idea.

159
00:09:18.440 --> 00:09:20.840
I've wanted to do this.
And then I say, but

160
00:09:20.840 --> 00:09:24.560
let's start reading our tests
first. There's no real sort

161
00:09:24.560 --> 00:09:27.950
of rationale or logic that
suggests, you know, that leap

162
00:09:28.040 --> 00:09:31.160
from, you know, doing unit
testing to writing tests first.

163
00:09:31.670 --> 00:09:35.780
And part of the reason
for that is your, the

164
00:09:35.780 --> 00:09:39.800
goal here with test driven
development, isn't really a unit

165
00:09:39.800 --> 00:09:43.820
testing goal. Although we're borrowing
unit testing tools to achieve

166
00:09:43.820 --> 00:09:49.040
the goal and thus test
driven development. And frankly there

167
00:09:49.040 --> 00:09:53.090
is testing involved. I mean,
we are using testing, we're

168
00:09:53.090 --> 00:09:58.880
borrowing testing almost like we're,
you know, sort of demonically

169
00:09:58.880 --> 00:10:02.900
possessing unit testing to, to
achieve other meats. You know,

170
00:10:05.000 --> 00:10:09.320
so I don't think I
could sell test driven development

171
00:10:09.320 --> 00:10:13.070
from the perspective of the
value of unit testing. Okay.

172
00:10:13.430 --> 00:10:15.980
So how do we frame
this? So the guy someone's

173
00:10:15.980 --> 00:10:19.140
got some, some foray into
testing, he's done some testing

174
00:10:19.150 --> 00:10:21.350
and some basic stuff, but
it hasn't taken over his

175
00:10:21.350 --> 00:10:24.320
life. It doesn't fundamentally change
the way he designs software.

176
00:10:25.640 --> 00:10:27.560
Well, the first thing I
would want to do to

177
00:10:27.560 --> 00:10:31.760
frame it is, is ask
whoever I'm working with to

178
00:10:31.760 --> 00:10:36.500
just give it a little
bit of effort, that every

179
00:10:36.500 --> 00:10:39.230
time they hear the word
test driven development, and they

180
00:10:39.230 --> 00:10:43.370
automatically react with thinking about
testing and quality assurance that

181
00:10:43.370 --> 00:10:47.600
they just suspend disbelief every
time that moment comes up

182
00:10:47.600 --> 00:10:49.670
and just give it a
moment of pause and consideration,

183
00:10:50.780 --> 00:10:53.540
that goes a long way
to understanding what we're after

184
00:10:53.540 --> 00:10:57.320
or to disentangle testing from
the goals of TDD or

185
00:10:57.320 --> 00:11:03.710
BDD. The next thing is
to talk about what makes

186
00:11:04.070 --> 00:11:10.700
software great and enjoyable to
work with. And the basic

187
00:11:10.820 --> 00:11:15.920
premise is for me that
you can't really use anything

188
00:11:15.920 --> 00:11:21.770
that you don't understand. So
if software is hard to

189
00:11:21.770 --> 00:11:25.310
understand, it's going to be
hard to work with. So

190
00:11:25.310 --> 00:11:31.580
the easier that we can
make software understandable, the better

191
00:11:31.580 --> 00:11:36.440
our experience as developers and
also the higher our productivity

192
00:11:36.440 --> 00:11:42.890
will be. It's interesting that
the qualities that make software

193
00:11:43.430 --> 00:11:49.160
easier to understand are also
the qualities that are highly

194
00:11:49.160 --> 00:11:53.800
desirable from a O O
design fundamentals perspective. So when

195
00:11:53.800 --> 00:11:59.900
you spoke to Bob Martin
about the solid principles in,

196
00:11:59.950 --> 00:12:04.510
at a very, very basic
abstract and essential level, all

197
00:12:04.510 --> 00:12:08.230
of those principles, point to
designs that are easy for

198
00:12:08.230 --> 00:12:11.400
the human mind to get
around, You know, that's funny

199
00:12:11.400 --> 00:12:15.540
that you mentioned that because
I run my, this is

200
00:12:15.540 --> 00:12:17.040
going to be sound random,
but I think it makes

201
00:12:17.040 --> 00:12:20.220
sense. I run very large
fonts. I have a really

202
00:12:20.220 --> 00:12:21.870
big monitor. Everyone's got a
pretty big monitor, a couple

203
00:12:21.870 --> 00:12:24.930
of monitors, but I run
like 16 point font. People

204
00:12:24.930 --> 00:12:26.640
think that's ridiculous when you're
on 16 point font, I

205
00:12:26.640 --> 00:12:30.030
run a 6.5, but I,
I really get uncomfortable if

206
00:12:30.030 --> 00:12:34.710
I can't see the entire
function without scrolling at 16

207
00:12:34.710 --> 00:12:37.230
point font on my monitor,
which basically adds up to

208
00:12:37.230 --> 00:12:40.650
about 25 lines. If it
gets bigger than that, then

209
00:12:40.860 --> 00:12:43.590
my small mind just can't
conceive of what's beyond the

210
00:12:43.590 --> 00:12:46.860
scroll bar. And I find
that it makes what I

211
00:12:46.860 --> 00:12:49.830
do better. And I'm almost
kind of like mechanically forced

212
00:12:49.830 --> 00:12:53.760
myself to, to have smaller
functions just because I can't

213
00:12:54.120 --> 00:12:57.810
possibly suck that much information
in at a time. And

214
00:12:58.860 --> 00:13:03.480
So you're pointing to an
essential quality of code. That's

215
00:13:03.480 --> 00:13:08.250
easy to understand, which is
it's small, right. Or there's

216
00:13:08.250 --> 00:13:11.100
less of it to, there's
less of it to swallow

217
00:13:11.100 --> 00:13:15.240
at one time. Right. And
then if you start there,

218
00:13:15.570 --> 00:13:18.540
consequently, that's easier to, it's
easier to test. And if,

219
00:13:18.540 --> 00:13:22.080
if it's really small, hopefully
it has only one purpose

220
00:13:22.080 --> 00:13:25.680
to live. Yeah. So what
did, what was the print?

221
00:13:25.720 --> 00:13:29.280
The solid principle that's the,
That a classroom method should

222
00:13:29.280 --> 00:13:33.450
have only one reason to
change. Yeah. The single now

223
00:13:33.450 --> 00:13:36.030
all of this jargon, you
know, test driven development is

224
00:13:36.030 --> 00:13:40.260
also part of the jargon.
Testability is one of the

225
00:13:40.260 --> 00:13:42.870
worst bits of jargon. It's
one of the most accurate

226
00:13:42.870 --> 00:13:44.700
bits of jargon we have.
And it's also, I think

227
00:13:44.700 --> 00:13:47.730
one of the most, you
know, destructive bits of jargon

228
00:13:47.760 --> 00:13:54.180
to the cause of software
design, when I say testability,

229
00:13:54.240 --> 00:13:59.220
or when anybody in the,
you know, progressive for lack

230
00:13:59.220 --> 00:14:02.430
of a better word, software
development community uses a word

231
00:14:02.430 --> 00:14:08.100
like testability it's. It means
something inside that community, inside

232
00:14:08.100 --> 00:14:12.180
that culture. And it means
something that is not understood

233
00:14:12.180 --> 00:14:15.390
outside of that culture, every
programmer in the world should,

234
00:14:15.480 --> 00:14:19.770
should reasonably assume that when
I'm talking about testability, I'm

235
00:14:19.770 --> 00:14:23.880
talking about the ability to
test something. So if I

236
00:14:23.910 --> 00:14:26.940
look at some piece of
code, or if I sit

237
00:14:26.940 --> 00:14:31.500
down with, with Joe programmer,
from Nebraska department of forestry

238
00:14:31.890 --> 00:14:34.800
and I look at his
code and I say, Hey,

239
00:14:34.800 --> 00:14:38.100
that code's not testable. And
he says, you're out of

240
00:14:38.100 --> 00:14:40.170
your mind, I'll show you
the tests for this. As

241
00:14:40.170 --> 00:14:42.860
a matter of fact, I've
got high coverage on, on

242
00:14:42.870 --> 00:14:45.240
this code and this code
is tested. So it must

243
00:14:45.240 --> 00:14:48.000
be testable. You know, I've,
I've kind of, sort of

244
00:14:48.000 --> 00:14:51.560
shot myself in the, in
the ideological foot, by this

245
00:14:51.560 --> 00:14:55.160
word testability. Right. And the
assumption that we're the assumption

246
00:14:55.160 --> 00:14:57.200
that we make in the,
you know, in the inner

247
00:14:57.200 --> 00:15:01.070
sanctums of the echo chamber,
is that we're really saying

248
00:15:01.100 --> 00:15:05.650
it's, it's got easy testability.
Right. And I think that

249
00:15:05.800 --> 00:15:08.950
that point that you just
made it kind of deserves

250
00:15:08.950 --> 00:15:11.560
repeating and paraphrasing and pounding
and pounding because I think

251
00:15:11.560 --> 00:15:14.440
that it, it really clarifies
things for me. I think

252
00:15:14.440 --> 00:15:18.040
it really nails the point,
the idea that you did

253
00:15:18.040 --> 00:15:21.100
test something, and it doesn't
mean that it was easily

254
00:15:21.100 --> 00:15:23.890
testable. And I remember when
I talked to a guy

255
00:15:23.890 --> 00:15:28.450
named quetzal Bradley, who's a
tester at Microsoft who made

256
00:15:28.450 --> 00:15:30.160
the comment to me. What
do you think was a

257
00:15:30.160 --> 00:15:33.070
year ago when I talked
to him that just because

258
00:15:33.070 --> 00:15:35.530
you have a hundred percent
code coverage that doesn't tell

259
00:15:35.530 --> 00:15:39.340
you that your code works
necessarily, it just means you

260
00:15:39.340 --> 00:15:43.030
executed every line. It doesn't
say anything at all about

261
00:15:43.240 --> 00:15:46.540
the bad intent. And it's
just, it's these small little

262
00:15:46.540 --> 00:15:51.040
obvious observations that continually blow
my mind when someone says

263
00:15:51.040 --> 00:15:53.380
that, you know, you know,
I had a guy on

264
00:15:53.380 --> 00:15:56.200
my team who was obsessed,
But that should never be

265
00:15:56.200 --> 00:16:00.760
taken to mean by any
of your listeners. That code

266
00:16:00.760 --> 00:16:04.510
coverage is thus irrelevant. I
had a guy on my

267
00:16:04.510 --> 00:16:06.400
team who was obsessed with
getting to a hundred percent

268
00:16:07.120 --> 00:16:08.590
and I thought it was
great. I was like, all

269
00:16:08.590 --> 00:16:09.970
right, well, if he wants
to work that hard and

270
00:16:09.970 --> 00:16:13.970
get to a hundred percent
good for him, but it

271
00:16:14.110 --> 00:16:16.210
made him feel good, but
it was a completely false

272
00:16:16.210 --> 00:16:21.850
sense of security. I think
a hundred percent code coverage

273
00:16:22.870 --> 00:16:25.780
is a pretty good number.
Tell you the truth. I

274
00:16:25.780 --> 00:16:29.260
think it's a really good
number when that number comes

275
00:16:29.260 --> 00:16:34.900
out of a team that's
using a handful of practices

276
00:16:34.900 --> 00:16:40.630
that make that number mean
something that number on its

277
00:16:40.630 --> 00:16:44.440
own only means something when
you're using the kind of

278
00:16:44.440 --> 00:16:48.700
designs that suggests that the
number is meaningful, and this

279
00:16:48.700 --> 00:16:51.070
comes back to design again,
right. If I get a

280
00:16:51.080 --> 00:16:55.390
hundred percent coverage on code
that has what I would

281
00:16:55.390 --> 00:17:01.090
call defect, attractor design, then
you're really not proving that

282
00:17:01.090 --> 00:17:04.330
the code doesn't have defects.
You're, you know, you're just

283
00:17:04.330 --> 00:17:06.400
proving that you've touched every
line, but if you add

284
00:17:06.400 --> 00:17:09.190
a hundred percent coverage on
code, that was well designed.

285
00:17:09.820 --> 00:17:13.660
It actually starts to mean
something more in terms of,

286
00:17:15.010 --> 00:17:20.320
from a defect rate, certain
designs are more prone to

287
00:17:20.320 --> 00:17:25.660
defects. They attract defects than
other kinds of designs and

288
00:17:25.660 --> 00:17:28.750
the smaller and smaller, you
know, and the more cohesive

289
00:17:28.750 --> 00:17:33.010
these units of, of functionality
become, you know, in accordance

290
00:17:33.010 --> 00:17:36.430
to all of these crazy
grandiose terms like testability and

291
00:17:36.430 --> 00:17:40.270
the solid principles and so
forth, the less amenable they

292
00:17:40.270 --> 00:17:47.080
come become to attracting defects.
Hi, this is Scott coming

293
00:17:47.080 --> 00:17:49.500
at you from another place
in time. Are you looking

294
00:17:49.500 --> 00:17:52.320
for an object, relational mapping
tool for mission critical projects

295
00:17:52.320 --> 00:17:56.670
using lincoln.net? I wanted to
share with you genome specifically

296
00:17:56.670 --> 00:18:00.090
designed for developing Dutton and
enterprise applications. Genome is a

297
00:18:00.090 --> 00:18:03.540
mature link, integrated ORM tool.
It's been employed in numerous

298
00:18:03.540 --> 00:18:06.570
large scale projects over the
last six years, genome was

299
00:18:06.570 --> 00:18:09.390
created for the.net platform as
opposed to being a port

300
00:18:09.390 --> 00:18:13.530
from Java. And it's thrived
on platform innovation since.net. 1.0

301
00:18:14.730 --> 00:18:17.580
genome is supported link since
its CTP release in may

302
00:18:17.580 --> 00:18:21.420
of 2006. It offers several
unique features, such as encapsulation

303
00:18:21.420 --> 00:18:24.510
and reuse of LINQ queries
and expressions. You can really

304
00:18:24.540 --> 00:18:26.970
fully harness the power of
link while benefiting from your

305
00:18:26.970 --> 00:18:31.470
database platforms. Unique features, compose
complex link queries, decompose the

306
00:18:31.470 --> 00:18:34.380
query logic and your domain
model link supports all the

307
00:18:34.380 --> 00:18:37.710
major database platforms you find
in enterprise environments like SQL

308
00:18:37.710 --> 00:18:41.430
server, but also Oracle and
IBM DB too. You can

309
00:18:41.430 --> 00:18:44.310
find out more about how
genome integrates tightly with visual

310
00:18:44.310 --> 00:18:50.040
studio and what tools genome
offers to reduce development time@tinyurl.com

311
00:18:50.130 --> 00:18:54.360
slash try genome G N
O M E, where you

312
00:18:54.360 --> 00:18:57.180
can also download a free
and fully functional trial version.

313
00:18:57.360 --> 00:19:01.080
I hope you enjoy it.
Okay. So are there some

314
00:19:01.080 --> 00:19:03.480
things, are there some specific
things to watch for this

315
00:19:03.480 --> 00:19:07.020
defect attractor design? Cause sometimes
when, when, when, when we,

316
00:19:07.140 --> 00:19:09.510
the echo chamber or whoever
talk about these things, it

317
00:19:09.510 --> 00:19:12.750
is very vague and it's
very difficult to take these

318
00:19:12.750 --> 00:19:17.460
generic concepts and apply them
to something really explicitly point

319
00:19:17.460 --> 00:19:19.500
to a line or point
to something. Is it, is

320
00:19:19.500 --> 00:19:21.720
it falling for us to
try to look for something

321
00:19:21.720 --> 00:19:24.390
really, really concrete when we
say, well, all right, well,

322
00:19:24.390 --> 00:19:26.550
I understand what you're saying,
Scott, but let's get specific.

323
00:19:26.960 --> 00:19:29.840
Here's the new, yeah, here's
an example, right? It's it's

324
00:19:29.840 --> 00:19:32.840
interesting. I think that on
your, on your show with

325
00:19:32.840 --> 00:19:35.720
Bob Martin, he gave a
really interesting example of what

326
00:19:35.720 --> 00:19:38.750
I would think of as
a, as a defect attractor

327
00:19:39.290 --> 00:19:41.540
or an, a design with
a, with a, with a

328
00:19:41.540 --> 00:19:46.100
potential for defects, which was
when he talked about the

329
00:19:46.100 --> 00:19:50.720
substitution principle, they'll discuss substitution
principle. And he gave the

330
00:19:50.720 --> 00:19:56.240
example of, you know, a
collection of objects that are,

331
00:19:56.270 --> 00:20:05.030
have a base class of
square. And somebody implements a

332
00:20:05.030 --> 00:20:08.450
rectangle class to be a
subclass of square. And then

333
00:20:08.960 --> 00:20:12.140
at a higher level, there's
another program or writing code

334
00:20:12.140 --> 00:20:14.900
that iterates over a collection
of squares and calls methods

335
00:20:14.900 --> 00:20:18.740
on them. But the rectangle
has different behaviors because it

336
00:20:18.740 --> 00:20:22.730
is, it is not a,
you know, and it's not

337
00:20:22.730 --> 00:20:25.510
a, Yeah, I thought that
was a great, I thought

338
00:20:25.520 --> 00:20:27.260
it was a great example,
but the idea was that

339
00:20:27.620 --> 00:20:32.480
one's, one's observations about kind
of reality don't necessarily always

340
00:20:32.480 --> 00:20:34.970
translate them, get easily modeled
in software. And that was

341
00:20:34.970 --> 00:20:37.400
just a perfect example of
here's something that, you know,

342
00:20:37.400 --> 00:20:40.760
how it works. You've known
since seventh grade, but you

343
00:20:40.760 --> 00:20:43.940
can't model it like this.
I mean, this specific example

344
00:20:43.940 --> 00:20:45.860
he talked about in the
code where he would have

345
00:20:45.860 --> 00:20:49.570
a, you know, a, of,
of, of types whose dynamic

346
00:20:49.570 --> 00:20:51.850
type is a base class,
and then you operate on

347
00:20:51.850 --> 00:20:53.950
them and you should be
able to operate on any

348
00:20:53.950 --> 00:20:56.890
type. But then he said,
well, we have this special

349
00:20:56.890 --> 00:20:59.320
circumstance. And when, when one
of those items, you know,

350
00:20:59.320 --> 00:21:01.880
when we're iterating through, when
the current item is, is

351
00:21:01.930 --> 00:21:04.570
a, is a rectangle, then
there's an if statement there.

352
00:21:04.570 --> 00:21:06.880
And then the, if statement
has to do some special

353
00:21:06.880 --> 00:21:10.930
processing, that special circumstance that
is at that level of

354
00:21:10.930 --> 00:21:14.440
the design is likely a
place that will cause some

355
00:21:14.440 --> 00:21:17.110
sort of defect to happen
somewhere else. And the reason

356
00:21:17.110 --> 00:21:20.170
for that is it's unexpected
that it's there and it's

357
00:21:20.170 --> 00:21:23.620
hidden knowledge. And this goes
back again to knowledge and

358
00:21:23.620 --> 00:21:28.090
learning and design. So all
of these great design qualities

359
00:21:28.090 --> 00:21:31.900
and all that test driven
development does is drive for

360
00:21:32.200 --> 00:21:37.540
the simplest units of understandability
or the simplest units of,

361
00:21:37.570 --> 00:21:41.260
you know, the things that
your brain can dissolve into

362
00:21:41.260 --> 00:21:44.320
itself and turn into knowledge
and learning. And you can

363
00:21:44.320 --> 00:21:47.530
see this very easily in
some of these practices and

364
00:21:47.530 --> 00:21:50.920
test driven development. We're really
trying to drive at the

365
00:21:50.920 --> 00:21:55.150
smallest amount of setup code.
So if you have a

366
00:21:55.150 --> 00:21:58.300
piece of business logic that
has an if statement in

367
00:21:58.300 --> 00:22:01.810
it that on one branch
of the F let's say

368
00:22:02.170 --> 00:22:04.690
creates a new database row,
but on the other branch

369
00:22:04.690 --> 00:22:09.250
of the F updates a
database row, then you might

370
00:22:09.250 --> 00:22:12.820
have to set up that
test, right to, well, you

371
00:22:12.850 --> 00:22:15.490
need a database, you might
need some sample data. If

372
00:22:15.490 --> 00:22:19.120
you're in the update branch
you might need. And then

373
00:22:19.120 --> 00:22:21.520
of course on both cases,
you'll need to, you know,

374
00:22:21.520 --> 00:22:23.320
query that roll out of
the database to see if

375
00:22:23.320 --> 00:22:27.040
it worked well, the presumption
there that you need to

376
00:22:27.040 --> 00:22:30.580
have an actually, you know,
a live database in place

377
00:22:30.610 --> 00:22:33.220
to test the, if statement
that the, if statement worked

378
00:22:33.220 --> 00:22:35.740
based on the, on the,
on the variables that it

379
00:22:35.740 --> 00:22:39.550
was, that it was checking
is the kind of presumption

380
00:22:39.550 --> 00:22:42.790
you get to when you
have large designs, large chunky

381
00:22:42.790 --> 00:22:47.910
designs when you don't have
modules or modularity, Right. And

382
00:22:47.910 --> 00:22:50.520
that's at that point, it
knows too much. You're starting

383
00:22:50.520 --> 00:22:54.360
to bump up against single
responsibility. You're, you're, you're getting

384
00:22:54.360 --> 00:22:56.940
you're stumbling on a design
smell. Sure. But even if

385
00:22:56.940 --> 00:22:59.550
we don't go into those,
that terminology, I could look

386
00:22:59.550 --> 00:23:03.480
at the test code and
see something that is often

387
00:23:03.480 --> 00:23:06.960
referred to as test friction,
which is the amount of

388
00:23:06.960 --> 00:23:12.570
setup code necessary to run.
This specific scenario is more

389
00:23:12.570 --> 00:23:16.020
than we find comfortable because
I have to create database

390
00:23:16.020 --> 00:23:19.770
rows. I have to set
up objects in the database.

391
00:23:19.770 --> 00:23:21.540
I have to set up
a data, access layer, all

392
00:23:21.540 --> 00:23:23.850
this kind of stuff. So
if you look at what

393
00:23:23.850 --> 00:23:26.790
it takes to take any
old object in your system,

394
00:23:29.190 --> 00:23:33.750
instantiate it into memory and
then poke and prod at

395
00:23:33.750 --> 00:23:37.500
it and learn how it
behaves the amount of effort

396
00:23:37.500 --> 00:23:41.250
it takes to set up
that code. That's kind of

397
00:23:41.280 --> 00:23:44.280
the, one of the most
important things that we're driving

398
00:23:44.280 --> 00:23:48.080
at test driven. It's how
much effort do you have

399
00:23:48.080 --> 00:23:50.570
to make before you can
learn what an object does.

400
00:23:52.330 --> 00:23:53.680
Wow. That's a really good
way to put it. How

401
00:23:53.680 --> 00:23:55.120
much effort do you have
to make before you can

402
00:23:55.120 --> 00:23:57.700
learn what an object does?
You know, there was a

403
00:23:57.700 --> 00:23:59.170
couple of years ago, you
and I were having a

404
00:23:59.260 --> 00:24:02.410
kind of a lower case,
a argument discussion about a

405
00:24:02.410 --> 00:24:04.870
word that you used that
I think really means a

406
00:24:04.870 --> 00:24:08.320
lot right now, which was
called solubility, which is how,

407
00:24:08.560 --> 00:24:11.530
how easy, you know, how,
how little friction is there

408
00:24:11.530 --> 00:24:14.710
between the design and getting
it into your brain. Do

409
00:24:14.710 --> 00:24:16.150
you have to chew on
it for a while or

410
00:24:16.150 --> 00:24:18.580
does it just kind of
grok immediately and suck into

411
00:24:18.580 --> 00:24:23.140
your brain and just smoothly
like drinking water? Well, if

412
00:24:23.140 --> 00:24:26.320
you look at designs that
require a lots of setup

413
00:24:27.340 --> 00:24:30.790
to use them. So the
H I said, Hey, like

414
00:24:30.790 --> 00:24:36.100
a Canadian, but I never
say H the HTTP context

415
00:24:36.100 --> 00:24:38.650
object is a sort of
classic, you know, the classic

416
00:24:38.650 --> 00:24:44.240
example of a design of
a manager object, right? The,

417
00:24:44.240 --> 00:24:49.480
the very big chunky multi-role,
it's, it's a, it's a,

418
00:24:49.660 --> 00:24:53.740
it's a Swiss army knife.
It's always there. It's in

419
00:24:53.740 --> 00:24:56.620
the background. You can pluck
it out. It's implicit parameters.

420
00:24:56.620 --> 00:24:59.710
It's just a ever present,
But how can you ever

421
00:24:59.710 --> 00:25:02.320
instantiate one in memory? So
let's say this it's, this

422
00:25:02.320 --> 00:25:03.930
is a great example. If
I had a code behind

423
00:25:03.940 --> 00:25:07.660
page for, for an asp.net
web forms application, and I

424
00:25:07.660 --> 00:25:10.670
wanted to test that my
ideal scenario would be to,

425
00:25:10.930 --> 00:25:15.700
to, to instantiate the code
behind class in memory and,

426
00:25:15.760 --> 00:25:18.790
you know, call a method
on it. And then I

427
00:25:18.790 --> 00:25:21.730
could see the text that
was rendered from, from the

428
00:25:21.730 --> 00:25:25.120
code behind, you know, from
the, from the method that's

429
00:25:25.120 --> 00:25:30.520
really not possible. And it's
really difficult to understand what

430
00:25:31.240 --> 00:25:34.240
a code behind page does
and to learn what it

431
00:25:34.240 --> 00:25:38.290
does. And there's, you know,
articles and articles and books

432
00:25:38.290 --> 00:25:41.620
written on what we think
of as the, what is

433
00:25:41.620 --> 00:25:44.860
the, the pipeline people call
it. Traditionally, I plan on

434
00:25:44.860 --> 00:25:47.710
all the eventing and stuff,
because things are getting called

435
00:25:48.250 --> 00:25:51.550
kind of via magic. It
is, and it's, it's that

436
00:25:51.550 --> 00:25:56.680
black magic. So when we
go back to the scenario

437
00:25:56.710 --> 00:26:00.340
of business logic, that calls
the database where the, if

438
00:26:00.340 --> 00:26:02.650
statement and the first case
in the first branch might

439
00:26:02.650 --> 00:26:04.840
do an update, and the
second branch might do an

440
00:26:04.840 --> 00:26:10.840
insert, or what have you,
if the business logic has,

441
00:26:11.740 --> 00:26:17.890
and a dependency on this
data database module, then that

442
00:26:18.130 --> 00:26:23.110
dependency has to be made
very clear, very obvious, very

443
00:26:23.110 --> 00:26:28.150
transparent. Let's say in that
business logic module, the constructor

444
00:26:28.180 --> 00:26:34.300
instantiates, a database access class,
a Dao object. And if

445
00:26:34.300 --> 00:26:37.330
it does that instantiation and
the object, then you can't

446
00:26:37.330 --> 00:26:40.390
really tell from the outside
of that object that that's

447
00:26:40.390 --> 00:26:44.700
what's going on. Right. So
when start say, I instantiate

448
00:26:44.700 --> 00:26:47.850
that business object class, and
I start poking and prodding

449
00:26:47.850 --> 00:26:54.090
at it to see how
it works. I'll probably get

450
00:26:54.090 --> 00:26:56.700
a no reference exception or
some crazy thing that happens

451
00:26:56.700 --> 00:26:58.440
once the doubt you went
to the code hits the

452
00:26:58.440 --> 00:27:03.090
Dow, right? Yep. That's what
you would think of with

453
00:27:03.090 --> 00:27:07.590
more esoteric terminology is an
opaque dependency. Those things make

454
00:27:07.590 --> 00:27:13.260
it harder and harder and
harder to understand what that

455
00:27:13.260 --> 00:27:16.040
business logic does. Does that
make sense? It doesn't mean

456
00:27:16.040 --> 00:27:18.740
it makes total sense. So
I'm used to things like,

457
00:27:18.860 --> 00:27:22.910
like Kent Beck's term code
smell, you know, we all

458
00:27:22.910 --> 00:27:24.920
like that. That's a great,
it's a great way to

459
00:27:24.920 --> 00:27:27.770
just say, nah, this isn't
right. And I, and I

460
00:27:27.770 --> 00:27:30.080
think that there's tests, there's
definitely tests smells, and you're

461
00:27:30.080 --> 00:27:34.280
describing kind of design patterns
that are really designed anti-patterns

462
00:27:35.090 --> 00:27:38.690
that then spill over into
testing. So you've got, you

463
00:27:38.690 --> 00:27:42.620
know, all sorts of test
anti-patterns or test smells like,

464
00:27:42.650 --> 00:27:45.890
like you just said, a
lot of context, a lot

465
00:27:45.890 --> 00:27:48.500
of implicit context that's coming
in, that's not being passed

466
00:27:48.500 --> 00:27:51.680
in from a parameter. You've
got lots of setup code,

467
00:27:52.250 --> 00:27:55.490
anything that's in a, any
concept, like a session where

468
00:27:55.490 --> 00:28:00.050
you're plucking things out of
some, some holdings, a holding

469
00:28:00.050 --> 00:28:03.770
area outs outside of yourself,
Outside of the concern of

470
00:28:03.770 --> 00:28:08.750
the test. So if we're
talking about this business logic

471
00:28:08.750 --> 00:28:11.690
module, that has an if
statement in it, if the

472
00:28:11.690 --> 00:28:15.950
data access layer, if I
want to control which data

473
00:28:15.950 --> 00:28:18.230
access object goes into the
test, so that I can

474
00:28:18.230 --> 00:28:23.780
verify how it was used,
I could make the data

475
00:28:23.780 --> 00:28:30.050
access object, a Singleton object.
So I would call, you

476
00:28:30.050 --> 00:28:33.890
know, instead of calling new
on the data access object,

477
00:28:33.890 --> 00:28:36.530
I would call get instance,
but I could have a

478
00:28:36.530 --> 00:28:39.530
hook in that class that
says, here's the instance I

479
00:28:39.530 --> 00:28:43.100
want you to give. So
I set up the data

480
00:28:43.100 --> 00:28:45.950
access object with an instance
of the data access object,

481
00:28:47.120 --> 00:28:49.790
so that when it returns,
when the, when some code

482
00:28:49.790 --> 00:28:52.070
in this constructor of the
business logic module, and this

483
00:28:52.070 --> 00:28:55.070
is really, I don't think
coming across in a conversation

484
00:28:55.070 --> 00:28:58.520
as well as it would
on a whiteboard. But if,

485
00:28:58.550 --> 00:29:01.610
you know, if you have
to set up, if you

486
00:29:01.610 --> 00:29:04.340
have a registry of data
access objects that you use,

487
00:29:04.340 --> 00:29:07.310
and you have to set
up that registry, then you're

488
00:29:07.310 --> 00:29:12.980
not actually setting up the
business logic object. And that

489
00:29:12.980 --> 00:29:16.880
is a code smell. If
you're setting up factories and

490
00:29:16.880 --> 00:29:20.690
if you're setting up containers,
and if you're setting up

491
00:29:20.720 --> 00:29:23.390
red, you know, these registries
and session state and all

492
00:29:23.390 --> 00:29:27.380
of this stuff, yeah. You're
starting to bring in concepts

493
00:29:27.410 --> 00:29:30.470
into the setup of a,
of a test. And let's

494
00:29:30.630 --> 00:29:34.280
say, test the set up
of an object that bring

495
00:29:34.280 --> 00:29:39.740
in more concepts, more issues,
more classes, HDB context is,

496
00:29:39.770 --> 00:29:42.130
you know, a classic example
of, if you want it

497
00:29:42.130 --> 00:29:46.030
to use an HTTP context,
then you'd have to set

498
00:29:46.030 --> 00:29:48.760
up a lot of stuff
before you could even test

499
00:29:48.760 --> 00:29:50.950
the thing that you're actually
concerned with, which is the

500
00:29:50.950 --> 00:29:53.650
operation in a code behind
page or code behind class.

501
00:29:54.100 --> 00:29:56.530
So all of these ancillary
concerns that we have to

502
00:29:56.530 --> 00:30:00.940
bring into our test, this
is test friction. This is,

503
00:30:01.480 --> 00:30:04.570
Hey, I want to run.
I would. My ideal scenario

504
00:30:04.570 --> 00:30:06.190
is I want to run
the click method on a

505
00:30:06.190 --> 00:30:10.150
page, and I just want
that to work. I want

506
00:30:10.150 --> 00:30:12.610
the design behind all of
this to be fairly simple

507
00:30:12.610 --> 00:30:14.350
so that I can just
make that happen. So there's

508
00:30:14.350 --> 00:30:16.990
a framework in the Ruby
world called Merv. And when

509
00:30:16.990 --> 00:30:20.860
you test a, when you
test for all intents and

510
00:30:20.860 --> 00:30:26.650
purposes, a web handling method,
you just call it, you

511
00:30:26.650 --> 00:30:29.470
instantiate the controller and call
it. And that method returns

512
00:30:29.470 --> 00:30:31.360
text, and the text is
the webpage, and you can

513
00:30:31.360 --> 00:30:34.480
inspect the webpage. There's nothing
more simple than this. There's

514
00:30:34.480 --> 00:30:38.860
no true deep necessity I'm
oversimplifying, but there's no real

515
00:30:38.860 --> 00:30:43.360
deep necessity to set up
all of this ancillary stuff.

516
00:30:43.870 --> 00:30:46.810
Right? All of the ancillary
things that we have to

517
00:30:46.810 --> 00:30:49.450
set up the objects before
we can get them in

518
00:30:49.450 --> 00:30:51.790
memory, in a good state
so that we can start

519
00:30:51.790 --> 00:30:55.810
to learn from them. That's
what the noise is. That's

520
00:30:55.810 --> 00:30:58.290
what the test friction is.
And any really good programmers

521
00:30:58.290 --> 00:31:00.460
should be able to say,
yeah, but I'm a good

522
00:31:00.460 --> 00:31:03.790
program, right? I don't really,
I'm not really daunted by

523
00:31:03.790 --> 00:31:07.090
that. I'm beyond that. My
skills are such that I

524
00:31:07.090 --> 00:31:10.840
can handle the pain. I
can take the pain, but

525
00:31:10.840 --> 00:31:14.050
the reality is we, we
tend to stop considering the

526
00:31:14.050 --> 00:31:16.210
other people on the team
who are coming into our

527
00:31:16.210 --> 00:31:21.190
code, likely from a cold
start. I've never seen this

528
00:31:21.190 --> 00:31:24.910
code before, or I have
just been away from this

529
00:31:24.910 --> 00:31:26.410
code for a couple of
days or a couple of

530
00:31:26.410 --> 00:31:30.280
hours, or, you know, you
know, whatever that time span

531
00:31:30.280 --> 00:31:34.140
is that that reflects how
quickly my memory. Yep. And

532
00:31:34.200 --> 00:31:36.450
then, and then you get
yourself into a situation where

533
00:31:36.450 --> 00:31:39.240
you're, you're working on it
on a design. And I

534
00:31:39.240 --> 00:31:43.050
always call this a right
only design. You can slap

535
00:31:43.050 --> 00:31:44.430
the keyboard all you want,
but no one's gonna come

536
00:31:44.430 --> 00:31:46.670
in and ever read this
and figure it out. It

537
00:31:46.670 --> 00:31:50.700
is right only With, with
seeing, with sort of judging

538
00:31:50.850 --> 00:31:53.880
whether or not the thing
that you did just did

539
00:31:53.910 --> 00:31:57.150
is good, is that you're
judging it from having, you

540
00:31:57.150 --> 00:32:00.060
know, your brain is already
warmed up to it. You

541
00:32:00.060 --> 00:32:01.920
don't see how difficult it
is to come at it

542
00:32:01.920 --> 00:32:04.230
from a, from a cold
start because you yourself are

543
00:32:04.230 --> 00:32:06.900
not in a cold start
position, right? This is the

544
00:32:06.900 --> 00:32:11.220
problem of creating usability or
user experience. When we create

545
00:32:11.220 --> 00:32:13.380
a user interface, most of
the people who create user

546
00:32:13.380 --> 00:32:16.080
interfaces that end up being
user interfaces that are thought

547
00:32:16.080 --> 00:32:20.250
of as poor user experiences,
aren't really sitting down to

548
00:32:20.250 --> 00:32:23.010
say, Hey, this is a
poor user experience. They really

549
00:32:23.010 --> 00:32:24.510
kind of look at it
and say, Hey, this works,

550
00:32:24.510 --> 00:32:25.860
this is good. I think
this is good. I'm going

551
00:32:25.860 --> 00:32:29.580
to go with this. The
reason for that is they're

552
00:32:29.940 --> 00:32:33.480
already warm. Yeah. That makes,
that makes total sense. They're

553
00:32:33.480 --> 00:32:36.840
warm. They have already positive
attitudes towards the thing they

554
00:32:36.840 --> 00:32:40.370
hear. There's pride, there's ego
involved. So knowing That that

555
00:32:40.370 --> 00:32:43.550
happens and it happens to
every developer, not just, you

556
00:32:43.550 --> 00:32:45.980
know, I mean the best
developers are some of the

557
00:32:45.980 --> 00:32:50.990
worst user experience people because
they have such a powerful

558
00:32:52.190 --> 00:32:56.870
facility of memory that they
keep this mental map of

559
00:32:56.870 --> 00:32:59.090
the system in their mind.
Right. And they say, well,

560
00:32:59.090 --> 00:33:00.920
I know where all this
is. I don't really need

561
00:33:00.920 --> 00:33:05.540
to create smaller objects just
to help create mnemonics. And

562
00:33:05.540 --> 00:33:08.810
the reality of the scenario
is that's the minority of

563
00:33:08.810 --> 00:33:12.470
developers, right? That's the hero
developer, the developer with the

564
00:33:12.470 --> 00:33:17.360
photographic memory, the reality of
the world, the rest of

565
00:33:17.360 --> 00:33:23.180
the world is most developers
benefit from dealing with objects

566
00:33:23.210 --> 00:33:27.860
and systems of objects that
are much smaller. And when

567
00:33:27.860 --> 00:33:32.360
they get smaller and when
we apply some of these

568
00:33:32.870 --> 00:33:35.720
well, let's, let's not even
talk about applying design principles,

569
00:33:35.990 --> 00:33:38.660
if they're smaller and you
can set them up in

570
00:33:38.660 --> 00:33:41.870
a few lines of code.
So write down some example

571
00:33:41.870 --> 00:33:44.810
code and set them up
and poke at them and

572
00:33:44.810 --> 00:33:47.810
see what they do. Well,
you've got, you've got software,

573
00:33:47.810 --> 00:33:52.100
that's learnable. And like I
said, coincidentally, that software probably

574
00:33:52.100 --> 00:33:57.230
expresses the quality of testability
that people talk about and

575
00:33:57.230 --> 00:34:00.590
then develop a testing community.
And it also will more

576
00:34:00.590 --> 00:34:04.220
than likely express many of
the solid principles. And if

577
00:34:04.220 --> 00:34:08.660
you just make the effort
of writing down some sample

578
00:34:08.660 --> 00:34:11.540
code saying, here's how simple
I want setting up this

579
00:34:11.570 --> 00:34:13.760
object to be. I don't
want it to be any

580
00:34:13.760 --> 00:34:17.900
more complicated than this. If
you make that effort, then

581
00:34:17.930 --> 00:34:23.000
the resulting implementation of that
example that you just wrote

582
00:34:23.060 --> 00:34:26.240
of the, of the level
of simplicity that you want,

583
00:34:27.620 --> 00:34:31.310
the implementation will more than
likely necessarily reflect solid principles.

584
00:34:31.310 --> 00:34:33.230
And I can say categorically
that most of the people

585
00:34:33.230 --> 00:34:36.890
that I know that I
learned or that I came

586
00:34:36.890 --> 00:34:40.940
up with in, Oh, and
TDD, didn't really start from

587
00:34:41.240 --> 00:34:44.120
the perspective of, Hey, here
are these, here's this great

588
00:34:44.120 --> 00:34:47.780
acronym from Bob Martin. And
here are these, these definitions

589
00:34:47.780 --> 00:34:50.810
of object oriented design principles
that we found on Wikipedia.

590
00:34:51.230 --> 00:34:54.890
You know, we kind of
backed into those things, really

591
00:34:54.890 --> 00:34:56.900
backed into them, like kind
of backing up kind of

592
00:34:56.900 --> 00:34:59.120
like one of those cliches
Scooby doo scenes, where, you

593
00:34:59.120 --> 00:35:02.210
know, Fred's backing up and,
you know, Scooby's backing up

594
00:35:02.210 --> 00:35:03.920
and they bump into each
other. And they surprised like

595
00:35:03.920 --> 00:35:06.290
we backed into all of
these design principles and said,

596
00:35:06.290 --> 00:35:08.780
wow, look, look at this
code that we're creating. It

597
00:35:08.780 --> 00:35:12.680
actually reflects these things that
other people said are really

598
00:35:12.680 --> 00:35:15.710
good and desirable. And from
the perspective of looking at

599
00:35:15.710 --> 00:35:18.350
the code we created, we
really began to get a

600
00:35:18.350 --> 00:35:22.640
good understanding of what these
design principles were. And then

601
00:35:22.640 --> 00:35:27.980
we started leveraging them explicitly
and purposefully, but you don't

602
00:35:27.980 --> 00:35:30.230
really have to go at
it from solid. It's great

603
00:35:30.230 --> 00:35:32.540
to know what they mean,
but if you just write

604
00:35:32.540 --> 00:35:35.630
these little examples of simplicity
out, you'll go a long

605
00:35:35.630 --> 00:35:39.740
way. And that is what
test driven development is. Yeah.

606
00:35:40.400 --> 00:35:43.310
Is that, why is the
idea that you would write

607
00:35:43.310 --> 00:35:45.050
down an example, say if
this is how I want

608
00:35:45.050 --> 00:35:47.060
it to behave, this is
how I want it to,

609
00:35:47.100 --> 00:35:50.990
to look, see how easy
it ought to be. That

610
00:35:51.290 --> 00:35:54.410
is that why behavior is
that behavior driven development? I'm

611
00:35:54.410 --> 00:35:57.140
saying that it should behave
like this. It should be

612
00:35:57.140 --> 00:35:59.900
this simple, it should be
this basic, I think behavior

613
00:35:59.900 --> 00:36:02.630
driven development. And I can't
speak for Dan North. It'd

614
00:36:02.630 --> 00:36:05.960
be valuable to, you know,
to, to, to hit up

615
00:36:05.960 --> 00:36:11.360
that behavior driven development is
called behavior driven development. But

616
00:36:11.360 --> 00:36:16.190
there is a notion in,
in, in specification and by

617
00:36:16.190 --> 00:36:20.390
specification, I mean test, which
is sort of specifications, terminology

618
00:36:20.390 --> 00:36:25.700
and BDD for test, we
are really interested in developer

619
00:36:25.700 --> 00:36:30.680
testing and unit testing and
testing behaviors because it's, you

620
00:36:30.680 --> 00:36:34.400
know, it, the value of
the, of, of the system

621
00:36:34.400 --> 00:36:39.320
is, is the things that
it does. So we are,

622
00:36:39.500 --> 00:36:42.410
you know, doing our analysis
from the perspective of behaviors,

623
00:36:43.370 --> 00:36:47.000
we're doing our design from
the perspective of behaviors, kind

624
00:36:47.000 --> 00:36:51.290
of like, you know, this
entity pattern or entity objects,

625
00:36:52.670 --> 00:36:55.550
they, we called them. We
tend to call them behavioral

626
00:36:55.550 --> 00:37:00.170
objects. They're really there to
represent clusters of behavior. Bob

627
00:37:00.170 --> 00:37:03.860
Martin talked about this in,
in, in his conversation with

628
00:37:03.860 --> 00:37:08.450
you about single responsibility principle.
He's talking about creating smaller

629
00:37:08.450 --> 00:37:14.150
objects that have more smaller
sets of behavior that they

630
00:37:14.150 --> 00:37:20.450
represent. I'm sorry, I'm sorry.
Right. I got distracted. Yes.

631
00:37:20.750 --> 00:37:24.290
They have less groups of
behaviors. It's, they're not just

632
00:37:24.290 --> 00:37:27.290
sort of objects named person
manager where we hang every

633
00:37:27.290 --> 00:37:32.010
concept of person off of
this object. You know, that

634
00:37:32.090 --> 00:37:35.180
kind of idea of a
person manager classes is really

635
00:37:35.510 --> 00:37:44.090
a procedural programming pattern. It's
the person function library. So

636
00:37:44.090 --> 00:37:48.290
BDD helps us to focus
our minds on this essential

637
00:37:48.290 --> 00:37:52.370
aspect of software, which is
the logic. And so did

638
00:37:52.370 --> 00:37:54.560
test driven development as well.
It was just sort of,

639
00:37:55.160 --> 00:37:57.050
it's just really hard to
talk about what test driven

640
00:37:57.050 --> 00:38:01.160
development is because people keep
getting really snagged and hung

641
00:38:01.160 --> 00:38:04.700
up on this word test.
Yeah. I think it is

642
00:38:04.700 --> 00:38:06.410
a little bit more us,
but what I feel that

643
00:38:06.410 --> 00:38:10.070
you've, you've definitely enlightened me
and I feel more like

644
00:38:10.070 --> 00:38:11.840
I'm kind of circling the
drain here and I think

645
00:38:12.620 --> 00:38:14.810
I'm heading in the right
direction. I think that I,

646
00:38:14.910 --> 00:38:18.440
I can use this information
to get a better understanding

647
00:38:18.440 --> 00:38:22.100
about, you know, test smells
about when a test doesn't,

648
00:38:22.490 --> 00:38:24.320
when a test doesn't feel
right, and the test smell

649
00:38:24.320 --> 00:38:29.300
inevitably points to a design
smell. And then underneath that,

650
00:38:29.300 --> 00:38:31.790
I may or may not
find, find code smells. But

651
00:38:32.000 --> 00:38:35.290
if my tests aren't, if
there isn't joy in my

652
00:38:35.290 --> 00:38:38.260
test, if I'm doing lots
of setup, if I'm, if,

653
00:38:38.260 --> 00:38:41.410
if my tests are full
of friction and pain and

654
00:38:41.410 --> 00:38:43.870
I don't enjoy riding them,
then there's something wrong with

655
00:38:43.870 --> 00:38:47.350
my design. And that kind
of is regardless of what

656
00:38:47.350 --> 00:38:50.350
we call this thing called
TDD or BDD, that that

657
00:38:50.350 --> 00:38:52.390
is the kind of the
essence of test driven development

658
00:38:52.390 --> 00:38:55.870
to, to unearth those things
and to discover that there's

659
00:38:55.990 --> 00:38:58.150
not, that there's a problem
with my test, but there's

660
00:38:58.150 --> 00:39:00.880
a problem with my coat.
My, my design is not

661
00:39:00.910 --> 00:39:04.650
sufficient. If it can't be
used effortlessly And above and

662
00:39:04.650 --> 00:39:08.730
beyond that, this notion of,
you know, effortless setup and

663
00:39:08.730 --> 00:39:14.430
effortless exercise, the side effects
of this, like I said,

664
00:39:14.460 --> 00:39:17.100
are the solid principles and
the solid principles, just aren't

665
00:39:17.100 --> 00:39:20.730
about testability. We use the
word testability or easy testability

666
00:39:20.730 --> 00:39:25.470
to describe it, but really
the ability to do the

667
00:39:25.470 --> 00:39:29.340
things with software that we
want to leverage it in

668
00:39:30.120 --> 00:39:33.420
more meaningful ways comes out
of these principles, the ability

669
00:39:33.420 --> 00:39:39.960
to decouple software and distribute
them, distribute objects in service

670
00:39:39.960 --> 00:39:45.660
oriented architectures, you know, the
ability to, to use plugins,

671
00:39:45.690 --> 00:39:50.310
to do provider pattern kind
of stuff. The ability to

672
00:39:51.120 --> 00:39:54.720
scale and parallel lies also
comes out of these in

673
00:39:54.720 --> 00:39:58.200
object oriented systems also comes
out of these all comes

674
00:39:58.200 --> 00:40:01.200
out of these principles. Once
you get at this sort

675
00:40:01.200 --> 00:40:06.870
of, you know, quality of
design, all of the other

676
00:40:06.900 --> 00:40:11.160
things that we need from
design that we require from

677
00:40:11.160 --> 00:40:15.360
design become much more readily
available as a side effect.

678
00:40:15.780 --> 00:40:19.020
So it's, it's, we're going
to focus on through writing

679
00:40:19.020 --> 00:40:22.350
sample code that shows how
easy it is to set

680
00:40:22.350 --> 00:40:26.640
up and learn from an
object. And the benefit from

681
00:40:26.640 --> 00:40:30.840
that, isn't just testing it's
high quality design. And even

682
00:40:30.840 --> 00:40:32.670
if you don't know how
to do high quality design

683
00:40:32.670 --> 00:40:35.430
and everybody who's done test
driven development for a long

684
00:40:35.430 --> 00:40:37.260
time will say the same
thing. Even if you don't

685
00:40:37.260 --> 00:40:40.230
know what high quality design
is. If you start with

686
00:40:40.230 --> 00:40:44.460
simplicity and expectations and demands
for simplicity, you're going to

687
00:40:44.460 --> 00:40:46.620
end up at high quality
design or at least higher

688
00:40:46.620 --> 00:40:49.140
quality design. And the more
you do it, the more

689
00:40:49.140 --> 00:40:52.380
this will just become automatic.
And it's amazing what doors

690
00:40:52.380 --> 00:40:55.950
to knowledge about design. This
practice opens up. And like

691
00:40:55.950 --> 00:40:59.850
I said, no one has
to start memorizing the esoteric

692
00:40:59.850 --> 00:41:03.420
terms and their meaning. And
frankly, those terms, and those

693
00:41:03.420 --> 00:41:05.910
meetings are going to make
a whole lot more sense

694
00:41:05.910 --> 00:41:10.290
when you've written some code
that demonstrates it. So what

695
00:41:10.290 --> 00:41:13.410
are some resources or some
books or preferred ways that

696
00:41:13.410 --> 00:41:16.350
people can dig into this?
That's some actions that they

697
00:41:16.350 --> 00:41:19.320
can take after listening to
this podcast. Are there a

698
00:41:19.320 --> 00:41:24.600
particular Bible that you think
people should read? I think

699
00:41:24.600 --> 00:41:28.380
there's a mantra that we
can start with. If we

700
00:41:28.410 --> 00:41:32.190
just get people to say,
test driven development is designed.

701
00:41:33.830 --> 00:41:37.820
I guess that's a good
place to start after that.

702
00:41:38.360 --> 00:41:42.770
There's so many, there's so
many resources about test-driven the

703
00:41:42.770 --> 00:41:46.010
moment, but most of them
I think are written for

704
00:41:46.010 --> 00:41:51.240
people who are already into
test driven development. Unfortunately, the

705
00:41:51.290 --> 00:41:55.520
lure and the love, and,
you know, the almost addiction

706
00:41:55.520 --> 00:41:59.480
to two words and terminology
of test driven development and,

707
00:41:59.480 --> 00:42:04.490
and object oriented design immediately
create an echo chamber. You

708
00:42:04.490 --> 00:42:10.430
know, I think, I think
seeing fancy words produces serotonin

709
00:42:10.520 --> 00:42:15.380
in the programmers brain and
I'm definitely guilty of this,

710
00:42:15.590 --> 00:42:17.360
but the problem is that
it, that it makes it

711
00:42:17.360 --> 00:42:22.580
harder for people who don't
know these terms. So most

712
00:42:22.580 --> 00:42:24.560
of the writing, most of
the really good writing is

713
00:42:24.560 --> 00:42:29.330
written in for an audience
that is already somewhat initiated.

714
00:42:30.590 --> 00:42:34.730
The, the really the book
that made it, made it

715
00:42:34.760 --> 00:42:40.610
really turn on for me
was James new Kirk's book

716
00:42:40.670 --> 00:42:45.530
and ms. Press, he might
be screaming, you know, at

717
00:42:45.530 --> 00:42:49.880
his, at his iPod right
now, but that his book

718
00:42:49.880 --> 00:42:53.750
test driven development with microsoft.net
or in Microsoft on it

719
00:42:54.110 --> 00:42:57.710
is a pretty good set
of exercises to try to

720
00:42:57.710 --> 00:43:02.270
get used to, to.net. And
I think, you know, Jim

721
00:43:02.390 --> 00:43:06.440
said recently that, you know,
somebody needs to rewrite that

722
00:43:06.440 --> 00:43:09.830
book and it's, it's, it's
a fairly, you know, I

723
00:43:09.830 --> 00:43:14.270
guess from a technology perspective,
a timeline perspective, it's a

724
00:43:14.270 --> 00:43:18.080
fairly aged book, but it's
the only book I've seen

725
00:43:18.080 --> 00:43:24.080
for.net programmers to start fresh.
Aside from that, there's lots

726
00:43:24.080 --> 00:43:27.320
of podcasts and there's lots
of blogs on Lowe's techies

727
00:43:28.130 --> 00:43:32.000
on code better, and, and
sites like that. But try

728
00:43:32.000 --> 00:43:34.550
to explain to us are
in development, but it's very,

729
00:43:34.550 --> 00:43:37.970
very difficult to explain something
that has to be experienced.

730
00:43:40.780 --> 00:43:42.820
All right. Well, thank you
very much, Scott Delware for

731
00:43:42.820 --> 00:43:45.100
sitting down with me and
talking about test driven development.

732
00:43:45.100 --> 00:43:47.770
And you remember now that
test driven development is designed.

733
00:43:48.620 --> 00:43:51.850
This has been another episode
of Hanselminutes and we'll see

734
00:43:51.850 --> 00:43:52.810
you again next week.


WEBVTT FILE

1
00:00:12.120 --> 00:00:17.820
From hanselminutes.com. It's Hansel minutes,
a weekly discussion with web

2
00:00:17.820 --> 00:00:22.440
developer and technologists. Scott Hanselman.
This is Lawrence Ryan announcing show

3
00:00:22.440 --> 00:00:28.620
number two 77. Recorded live
Thursday, July 28th, 2011. Support for Hanselman

4
00:00:28.760 --> 00:00:32.550
is provided by Tellerik rad
control, the most comprehensive suite

5
00:00:32.550 --> 00:00:40.920
of components for windows forms
and asp.net web applications. online@wwwdottelerik.com.

6
00:00:42.090 --> 00:00:45.600
In this episode, Scott talks
with Ivan Tolson from mindscape

7
00:00:45.780 --> 00:00:50.790
about the recently released web
workbench. Hi, this is Scott

8
00:00:50.790 --> 00:00:53.400
Hanselman. This is another episode
of Hansel minutes. And today

9
00:00:53.640 --> 00:00:56.340
we're talking all the way
to New Zealand to the folks

10
00:00:56.340 --> 00:00:59.730
at mindscape headquarters. Specifically, we're
talking to Ivan Tolson. How

11
00:00:59.730 --> 00:01:02.010
are you, sir? I'm good
to go. How are you?

12
00:01:02.250 --> 00:01:05.010
Brilliant. Thanks for taking the
time. Fortunately, you didn't have

13
00:01:05.010 --> 00:01:06.210
to get up in the
middle of the night to,

14
00:01:06.360 --> 00:01:09.320
to chat with me today.
I appreciate that That 4:00 AM

15
00:01:09.320 --> 00:01:13.400
was a bit of an
alarm call. Indeed. I blogged

16
00:01:13.400 --> 00:01:16.010
last week about some really
great stuff that your company

17
00:01:16.010 --> 00:01:19.310
mindscape was, was doing. You,
you put something wonderful out

18
00:01:19.310 --> 00:01:22.100
into the community. You, you
gave us the web workbench

19
00:01:22.130 --> 00:01:26.000
with support for less and
SAS. And, and what else

20
00:01:26.000 --> 00:01:28.280
was in the web work
bench? That's coffee script is

21
00:01:28.280 --> 00:01:30.890
the third one. That's in
the web workbench. Indeed, indeed.

22
00:01:31.400 --> 00:01:34.940
And you gave this away
for free. Why would you

23
00:01:34.940 --> 00:01:39.170
do that? Such a thing?
Well, SAS, less than COVID,

24
00:01:39.320 --> 00:01:41.410
they're all open source products.
We thought know we liked

25
00:01:41.410 --> 00:01:44.450
those products, the crates, those
products have given them away

26
00:01:44.450 --> 00:01:45.950
for free. And we'd just
like to share the love

27
00:01:45.950 --> 00:01:50.870
a little bit. We think
that it's a useful product

28
00:01:50.870 --> 00:01:54.890
for people, but a lot
of the asp.net MVC community

29
00:01:54.890 --> 00:01:57.680
is driven around that kind
of those free tools that

30
00:01:57.680 --> 00:01:59.810
shared community. We just wanted
to help out with that

31
00:01:59.810 --> 00:02:03.500
a little bit. Well, it's,
it's definitely appreciated because one

32
00:02:03.500 --> 00:02:04.850
of the things that we
talk about when we try

33
00:02:04.850 --> 00:02:07.190
to figure out how to
get open source driven into

34
00:02:07.190 --> 00:02:09.410
the community more, when we're
sitting around at Microsoft talking

35
00:02:09.410 --> 00:02:12.020
about this is how do
we get them more interested

36
00:02:12.020 --> 00:02:13.910
in these kinds of tools?
I mean, I've known about

37
00:02:13.910 --> 00:02:17.420
coffee script for a long
time, but people, you know,

38
00:02:17.450 --> 00:02:20.000
let's just be frank.net. People
don't really like spending time

39
00:02:20.000 --> 00:02:21.470
at the command line. At
least there's a lot of

40
00:02:21.470 --> 00:02:23.450
people that don't, and unless
it's in visual studio, it

41
00:02:23.450 --> 00:02:25.610
doesn't exist. And I think
that web work benches are

42
00:02:25.610 --> 00:02:27.830
a really great way for
them to introduce themselves to

43
00:02:27.830 --> 00:02:32.000
three extremely powerful tools without
having to leave their comfort

44
00:02:32.000 --> 00:02:34.430
zone. I think that's a
good point. We've seen that

45
00:02:34.430 --> 00:02:37.340
with our other products that
people love the visual city

46
00:02:37.340 --> 00:02:40.370
integration. They've got this one
central home and they can

47
00:02:40.370 --> 00:02:41.930
just plug lots of things
into it. It's a very

48
00:02:41.930 --> 00:02:45.470
capable platform and they can
just add in new languages,

49
00:02:45.500 --> 00:02:49.640
new productivity tools as they
see fit. Now, web workbench

50
00:02:49.670 --> 00:02:52.550
is cool. Yeah, but this,
this, this podcast is not

51
00:02:52.550 --> 00:02:54.620
about web workbench. Well, maybe
we'll do another one some

52
00:02:54.620 --> 00:02:58.210
other day. What I think
is more interesting and a,

53
00:02:58.220 --> 00:03:01.330
a kind of a more
meta issue is that the

54
00:03:01.330 --> 00:03:05.380
web workbench fits together with
kind of three large chunks

55
00:03:05.500 --> 00:03:09.970
and uses what we call
polyglot programming. There's there's languages

56
00:03:09.970 --> 00:03:12.460
in there that aren't just,
C-sharp, there's quite a few,

57
00:03:12.460 --> 00:03:15.660
I think, four or five
at last count, Just the

58
00:03:15.660 --> 00:03:17.520
fall. We were looking at
C, but we decided to

59
00:03:17.520 --> 00:03:22.170
get away from that where
you see sharp F sharp

60
00:03:22.860 --> 00:03:27.270
Ruby and JavaScript as part
of web work bench. The

61
00:03:27.270 --> 00:03:29.850
reason that we do that
is just because the well

62
00:03:29.850 --> 00:03:32.340
there's, there's a number of
reasons for, for doing that.

63
00:03:33.660 --> 00:03:38.670
Obviously SAS is, is written
in, in Ruby, and we

64
00:03:38.670 --> 00:03:41.910
want you to host the
SAS code rather than trying

65
00:03:41.910 --> 00:03:43.920
to reimplement it. And that
would just be far too

66
00:03:43.920 --> 00:03:48.270
much effort. Similarly, the coffee
script compiler is written in

67
00:03:48.270 --> 00:03:50.520
JavaScript. And again, we just
wanted to, to host that,

68
00:03:50.940 --> 00:03:55.170
give people that sort of
guaranteed fidelity to the implementation.

69
00:03:55.740 --> 00:03:58.200
So we need to be
able to host Ruby and

70
00:03:58.230 --> 00:04:04.450
JavaScript source code, but we
found that those, the, the,

71
00:04:04.710 --> 00:04:07.470
the Ruby and JavaScript and
rotations weren't performing well enough,

72
00:04:07.470 --> 00:04:10.590
they weren't giving us enough
out enough output to do

73
00:04:10.590 --> 00:04:14.340
things like syntax, highlighting the
IntelliSense in real time. So

74
00:04:14.340 --> 00:04:15.480
we thought, well, we're going
to have to write our

75
00:04:15.480 --> 00:04:21.090
own parser, our own little
highlighting engine for those languages.

76
00:04:21.690 --> 00:04:23.850
And we actually found the
F shot. We've had some

77
00:04:23.850 --> 00:04:26.550
expenses F sharp before and
found that's a really good

78
00:04:26.550 --> 00:04:30.180
language for that kind of
activity. It's got a lot

79
00:04:30.180 --> 00:04:34.740
of constructs that make it
very expressive, very concise for

80
00:04:34.740 --> 00:04:41.160
writing in particular language oriented
subsistence. So the web work

81
00:04:41.160 --> 00:04:44.100
bench pulls together. These three
languages COVID script less than

82
00:04:44.100 --> 00:04:48.030
SAS that are domain specific
languages. They are languages in

83
00:04:48.060 --> 00:04:51.990
themselves, languages themselves. So like
SAS, for example, if you

84
00:04:51.990 --> 00:04:55.090
looked at it, you'd say,
Oh, that's CSS, but it's,

85
00:04:55.090 --> 00:04:59.070
it's not it's cascading style
sheets with some additional semantics.

86
00:04:59.130 --> 00:05:00.990
So it's fair to say
that it is a tone

87
00:05:01.020 --> 00:05:06.150
grammar That's right. Yes. It,
it builds on CSS, but

88
00:05:06.150 --> 00:05:10.200
because it adds things like
variables and functions and mix

89
00:05:10.200 --> 00:05:12.930
in so that you can
reuse code. For example, you

90
00:05:12.930 --> 00:05:15.810
can specify a color once
as a variable, and you

91
00:05:15.810 --> 00:05:18.690
can then use that again
and again, and again, you

92
00:05:18.690 --> 00:05:21.090
can apply functions to, so
for example, to lighten or

93
00:05:21.090 --> 00:05:25.500
darken it. So although all
CSS is sass and all

94
00:05:25.500 --> 00:05:28.590
CSS is less, they add
these additional capabilities to give

95
00:05:28.590 --> 00:05:32.940
you a lot of code
reuse within your CSS or

96
00:05:32.940 --> 00:05:36.540
your extended CSS. So then
when you take that plus

97
00:05:36.660 --> 00:05:39.810
coffee script, which is a
domain specific language that turns

98
00:05:39.810 --> 00:05:44.730
into JavaScript and less, you
get basically language support for

99
00:05:44.730 --> 00:05:48.870
three new languages that compile
down into lower end languages.

100
00:05:49.170 --> 00:05:51.870
Maybe you saw my talk
about JavaScript is the new

101
00:05:51.870 --> 00:05:55.470
assembler. Really the point about
that is that we're upleveling

102
00:05:55.500 --> 00:05:59.650
things. People aren't writing JavaScript
and trade CSS anymore. That's

103
00:05:59.650 --> 00:06:02.050
right, obviously in the early
days of the web, everybody

104
00:06:02.050 --> 00:06:05.650
was writing Java script, but
there's been an increasing recognition

105
00:06:05.650 --> 00:06:08.650
that while the, the core
of the core of JavaScript,

106
00:06:08.980 --> 00:06:13.480
there's a really great capable
language. It's not necessarily surfaced

107
00:06:13.480 --> 00:06:16.630
in the most convenient way.
When you look at the,

108
00:06:16.940 --> 00:06:19.660
the hoops, you have to
jump through to write modern

109
00:06:19.660 --> 00:06:23.260
Java script without kind of
clashing with the global namespace

110
00:06:23.260 --> 00:06:25.150
and all of those bad,
bad things that everyone warns

111
00:06:25.150 --> 00:06:28.500
you about. And it begins
to drown out your, your

112
00:06:28.510 --> 00:06:32.980
business logic, your, your core
interaction logic in this sea

113
00:06:32.980 --> 00:06:35.680
of additional syntax that you
need to write to make

114
00:06:35.680 --> 00:06:38.260
it safe and languages like
coffee script. And we're seeing

115
00:06:38.260 --> 00:06:41.380
other things like closure script,
for example, those higher level

116
00:06:41.380 --> 00:06:45.640
languages compiled down to Java
script, give you that safety.

117
00:06:45.760 --> 00:06:49.090
They give you that expressiveness
while still because they actually

118
00:06:49.090 --> 00:06:52.570
ship as JavaScript. They still
run on every web browser.

119
00:06:52.750 --> 00:06:54.760
You don't need to get
plugins or anything like that

120
00:06:55.270 --> 00:06:58.030
Is this similar to, to
like a pound define and

121
00:06:58.030 --> 00:07:00.130
see when someone says, we'll
see as great, but I

122
00:07:00.130 --> 00:07:02.170
just hit this thing. That's
not very expressive and I

123
00:07:02.170 --> 00:07:04.330
can express it cleaner like
this. And here's a macro

124
00:07:04.330 --> 00:07:08.080
that then expands into perhaps
of noxious looking see, but

125
00:07:08.080 --> 00:07:10.030
I don't have to think
about that. Or is this

126
00:07:10.030 --> 00:07:12.910
more than that? I think
this is a lot more

127
00:07:12.910 --> 00:07:17.230
than that. All school see
macros are that they're not

128
00:07:17.230 --> 00:07:21.640
very smart. They, you can
introduce a few simple constructs

129
00:07:21.640 --> 00:07:25.690
that way, but a wholesale
change to the language. For

130
00:07:25.690 --> 00:07:28.690
example, the way that coffee
script coffee cups a completely

131
00:07:28.690 --> 00:07:34.830
different syntactically different language to
Java script. The, the, the,

132
00:07:34.840 --> 00:07:37.010
the things that you can
write in coffee script, the

133
00:07:37.060 --> 00:07:39.880
constructs that you use are
not the same as Java

134
00:07:39.880 --> 00:07:43.120
script, that you write everything
in a much different way.

135
00:07:43.120 --> 00:07:48.280
He's going to plead different
syntax with CSS. I'm expanding

136
00:07:48.280 --> 00:07:51.130
to SAS and less. That's
perhaps a little bit more

137
00:07:51.190 --> 00:07:55.330
like a macro, but again,
it's smart enough to avoid

138
00:07:55.330 --> 00:07:58.510
some of the bear traps
that macros used to fall

139
00:07:58.510 --> 00:08:01.930
into. But yeah, those are
kind of extensions rather than

140
00:08:01.930 --> 00:08:04.480
replacements. Okay. So then if
it, if it is the

141
00:08:04.480 --> 00:08:07.870
case that coffee script is
simply a totally different language,

142
00:08:07.870 --> 00:08:10.930
it is not JavaScript. Then
visual studio is not going

143
00:08:10.930 --> 00:08:15.220
to understand it. That's right.
That's right. And the same

144
00:08:15.220 --> 00:08:19.090
thing, I guess, with SAS
and less, although visual studio

145
00:08:19.090 --> 00:08:21.910
can kind of understand the
CSS bits. Once you start

146
00:08:21.910 --> 00:08:26.380
seeing variables and mixings the
visual studio, CSS highlighter, won't

147
00:08:26.380 --> 00:08:31.120
be able to get anywhere.
So you've included support for

148
00:08:31.120 --> 00:08:35.650
an entirely new language, three
entirely new languages inside of

149
00:08:35.650 --> 00:08:39.100
visual studio. And you've extended
visual studio two to allow

150
00:08:39.100 --> 00:08:41.890
the support That's right. That's
what we're workbench to us.

151
00:08:41.890 --> 00:08:44.050
Yes. But you said that
when it came time to

152
00:08:44.050 --> 00:08:46.780
just do something as, as
quote unquote, simple as syntax

153
00:08:46.780 --> 00:08:50.110
highlighting, these interpreted languages like
Java script and Ruby weren't

154
00:08:50.110 --> 00:08:52.780
fast enough. So you started
thinking that we're going to

155
00:08:52.780 --> 00:08:57.810
need to do this in
IRL. That's right. Although Ruby

156
00:08:57.810 --> 00:09:02.400
and JavaScript are obviously very
capable languages, but as people

157
00:09:02.400 --> 00:09:04.860
are actually typing, you know,
you're getting a very quick

158
00:09:04.860 --> 00:09:07.560
turnaround. As people are typing
this, this fractions of a

159
00:09:07.560 --> 00:09:10.320
second, between each keystroke and
people kind of want to

160
00:09:10.320 --> 00:09:15.180
see that they're highlighting, being
updated pretty swiftly as they

161
00:09:15.180 --> 00:09:17.310
type. And we ran into
a couple of issues. The

162
00:09:17.310 --> 00:09:20.280
first thing was the performance
of trying to call out

163
00:09:20.280 --> 00:09:23.460
an interpreter language on potentially
quite a large file. Another

164
00:09:23.460 --> 00:09:25.740
issue we ran into is
things like error recovery. So

165
00:09:25.740 --> 00:09:27.870
for example, if you've got
an error on one line,

166
00:09:29.070 --> 00:09:31.140
okay, you can send, like,
if you can highlight that

167
00:09:31.140 --> 00:09:32.700
line as being a syntax
error, but you kind of

168
00:09:32.700 --> 00:09:34.350
want to be able to
keep going and show other

169
00:09:34.350 --> 00:09:40.410
lines highlighted as best you
can. And the builtin compilers,

170
00:09:40.460 --> 00:09:44.040
the SAS and coffee. So
this has an uncuffed script

171
00:09:44.040 --> 00:09:49.050
compilers that they didn't need
to do that they, their

172
00:09:49.050 --> 00:09:51.810
job was to compile stuff
and anything they could provide

173
00:09:51.810 --> 00:09:54.360
for syntax highlighting was kind
of off to the side

174
00:09:54.360 --> 00:09:56.640
for them. And that's why
we ended up rewriting the

175
00:09:56.640 --> 00:09:59.280
parser in IOL, or rather
than we'd run it in

176
00:09:59.280 --> 00:10:02.570
that shop, which in right
now. But it's interesting to

177
00:10:02.570 --> 00:10:05.630
me that there must be
surely lectures and parsers out

178
00:10:05.630 --> 00:10:08.990
there written in C sharp.
And I I'm, I'm not

179
00:10:08.990 --> 00:10:11.600
someone that I know, I
know F sharp is out

180
00:10:11.600 --> 00:10:13.670
there, but I'm not going
to just bust out M

181
00:10:13.670 --> 00:10:16.040
sharp on a regular basis.
It's not, it would be

182
00:10:16.040 --> 00:10:18.110
like me trying to speak
Spanish, right. It would be

183
00:10:18.770 --> 00:10:21.500
passable. And I could maybe
order food, but it's not

184
00:10:21.500 --> 00:10:23.840
my, it's not a language
I'm fluent in. When we

185
00:10:23.840 --> 00:10:31.670
start thinking about polyglot programming,
it seems extremely imposing that

186
00:10:31.670 --> 00:10:33.800
I would go and write
something in a language that

187
00:10:33.800 --> 00:10:36.500
I'm not even close to
fluent in. Do, do you

188
00:10:36.500 --> 00:10:38.690
just happen to be someone
who can speak F sharp

189
00:10:38.690 --> 00:10:40.280
as well as C sharp,
or was it simply a

190
00:10:40.280 --> 00:10:43.070
matter of it is so
much better for this particular

191
00:10:43.070 --> 00:10:46.310
task that the call of
F sharp was too much

192
00:10:46.310 --> 00:10:49.310
to resist? I guess there's
a couple of things. I've,

193
00:10:49.550 --> 00:10:51.800
I've been following F sharp
for a little while now.

194
00:10:51.800 --> 00:10:54.530
I wouldn't consider myself by
any means an expert in

195
00:10:54.530 --> 00:10:57.560
it, but I've done a
couple of small projects in

196
00:10:57.560 --> 00:10:59.960
it. So I know my
way around it well enough

197
00:10:59.960 --> 00:11:02.960
that it doesn't intimidate me,
but that doesn't take an

198
00:11:02.960 --> 00:11:05.840
awful long time. If chef's
not a hugely complicated language,

199
00:11:06.050 --> 00:11:08.660
it's different from C-sharp. It
requests a little bit of

200
00:11:08.660 --> 00:11:12.960
an adjustment of thinking, but
it's not terribly difficult to,

201
00:11:12.960 --> 00:11:15.830
to get your head around.
It's not, it's not intimidating

202
00:11:15.830 --> 00:11:21.650
to, to learn enough to
get stuff done. You're right.

203
00:11:21.650 --> 00:11:25.280
The C-sharp has got Lexus
and passes. There's examples like

204
00:11:25.310 --> 00:11:29.120
irony, which is a code
Plex project and a antler,

205
00:11:29.360 --> 00:11:31.700
which is a project come
across in the Java world.

206
00:11:31.700 --> 00:11:35.030
And it's very highly respected.
The thing that I found

207
00:11:35.030 --> 00:11:37.820
really attractive about F sharp
was that it just makes

208
00:11:37.820 --> 00:11:42.020
it more convenient to express
certain constructs. So when you,

209
00:11:42.020 --> 00:11:43.940
for example, when you're building
a Plaza, one of the

210
00:11:43.940 --> 00:11:45.650
things you need to express
is what they call the

211
00:11:45.650 --> 00:11:49.220
abstract syntax tree, the AST,
which is kind of the

212
00:11:49.220 --> 00:11:54.700
representation of your code as
a, as abstract construct is

213
00:11:54.700 --> 00:11:57.160
a set of nodes. If
you like, does that make

214
00:11:57.160 --> 00:11:58.470
sense to you? Well, let
me see if I, let

215
00:11:58.470 --> 00:11:59.910
me see if I can
understand. So if I have

216
00:11:59.910 --> 00:12:04.740
something like VAR, I equals
zero something very, very simple.

217
00:12:05.160 --> 00:12:08.190
Yep. That could be expressed
as a tree. That's right.

218
00:12:08.190 --> 00:12:11.280
So you break that down
to notes, representing the VAR,

219
00:12:11.310 --> 00:12:14.880
which would be, say a
key word node. The, I

220
00:12:14.910 --> 00:12:18.690
would be a, identify a
node. The equals might be

221
00:12:18.690 --> 00:12:21.120
say an operator node and
the zero would be a

222
00:12:21.120 --> 00:12:26.820
literal node. So you'd have
maybe a method node, which

223
00:12:26.820 --> 00:12:30.450
would have those four nodes
as its children. Now, is

224
00:12:30.450 --> 00:12:32.490
this, is this a tree
or is this an array?

225
00:12:32.490 --> 00:12:35.070
Is this simply an array
of stuff? Or does it

226
00:12:35.070 --> 00:12:38.880
get more complicated than that?
It's absolutely a tree because

227
00:12:39.810 --> 00:12:43.410
let's take the example of
in SAS, you can nest

228
00:12:43.440 --> 00:12:50.130
selectors within other selectors. So
a selector contains a set

229
00:12:50.130 --> 00:12:55.830
of properties and potentially other
selectors and other mixings. So

230
00:12:55.830 --> 00:13:00.090
a selector contains various things
since a selector can contain

231
00:13:00.090 --> 00:13:04.770
another selector. You can start
recursing down that structure and

232
00:13:04.770 --> 00:13:06.540
therefore it's gotta be a
tree. It can't just be

233
00:13:06.540 --> 00:13:10.110
a flattened array. You've got
to represent it as that

234
00:13:10.110 --> 00:13:13.140
kind of containment structure. Okay.
Yeah. So when I have

235
00:13:13.140 --> 00:13:16.140
an AST note, an abstract
Cintas, a note of an

236
00:13:16.140 --> 00:13:20.580
abstract syntax tree, why is
it easier to express something

237
00:13:20.580 --> 00:13:22.560
like that in F sharp
than it is in C

238
00:13:22.560 --> 00:13:26.070
sharp? Well, when you want
to express nicely, you're going

239
00:13:26.070 --> 00:13:29.400
to, you're basically typically going
to have classes for each

240
00:13:29.430 --> 00:13:31.590
kind of no. So you
mentioned this being a fairly

241
00:13:31.590 --> 00:13:34.890
simple class, all at Rocky,
we've got maybe syntax node

242
00:13:34.890 --> 00:13:37.110
as your base class, and
you have, in your example,

243
00:13:37.470 --> 00:13:41.220
you'd have a keyword node.
You have identify node and

244
00:13:41.220 --> 00:13:45.210
so on. It must be
derived classes of your syntax

245
00:13:45.210 --> 00:13:48.570
node based class. Now in
C-sharp, when you want to

246
00:13:48.570 --> 00:13:50.490
write those classes, you've got
to kind of write them

247
00:13:50.490 --> 00:13:52.080
out long hand. You're going
to have to write out

248
00:13:52.080 --> 00:13:53.580
your base class. And you
have to kind of write

249
00:13:53.580 --> 00:13:56.940
out each of the derived
classes, each of the members

250
00:13:57.000 --> 00:14:00.210
of those derived class, if
they've got individual fields represent

251
00:14:00.210 --> 00:14:02.340
what the keyword is or
what the variable is and

252
00:14:02.340 --> 00:14:08.400
what the list of children
is, this becomes quite laborious.

253
00:14:08.400 --> 00:14:10.320
You've got to write this
all out longhand. And really

254
00:14:10.320 --> 00:14:13.830
those are fairly simple data
classes in F sharp. You

255
00:14:13.830 --> 00:14:17.070
can use a construct called
a discriminated union, where basically

256
00:14:17.070 --> 00:14:20.250
you can create each class,
each of those derived classes

257
00:14:20.490 --> 00:14:23.670
on just one line, and
you can then do pattern

258
00:14:23.670 --> 00:14:29.160
matching over those derived classes
to, to walk your syntax

259
00:14:29.160 --> 00:14:33.210
tree hierarchy, to perform analysis
on it, to flatten it

260
00:14:33.210 --> 00:14:36.300
down to syntax highlighting and
things like that. So in

261
00:14:36.300 --> 00:14:39.000
that regard, F sharp is
much Theresa. You can write

262
00:14:39.000 --> 00:14:42.690
much less code to do
a lot more. I see.

263
00:14:42.690 --> 00:14:46.320
So this isn't an issue
of what you are able

264
00:14:46.320 --> 00:14:49.890
necessarily to do in one
language versus another. But like

265
00:14:49.890 --> 00:14:53.630
an example might be to
try to say, in German,

266
00:14:54.170 --> 00:14:57.650
you say shut in Florida.
And in English you say

267
00:14:57.890 --> 00:15:00.440
taking pleasure at the display
at the, at the pain

268
00:15:00.440 --> 00:15:03.110
of others, right? They're both
kind of, they say effectively

269
00:15:03.120 --> 00:15:05.210
the same thing, but one
is clear and tourism is

270
00:15:05.210 --> 00:15:06.830
a perfect word for it.
And I said it, and

271
00:15:06.830 --> 00:15:10.250
now we understand, well, alternatively,
in another language, I might

272
00:15:10.250 --> 00:15:13.160
need a sentence or a
paragraph or a photograph to

273
00:15:13.160 --> 00:15:17.380
explain what's going on. Exactly
and different languages are good

274
00:15:17.380 --> 00:15:21.610
at different things. You're right.
That all of these languages

275
00:15:21.610 --> 00:15:25.540
are kind of equally capable
at some fundamental level. The,

276
00:15:25.850 --> 00:15:28.360
they call it cheering equivalents
in, in the, the theory

277
00:15:28.360 --> 00:15:33.400
world, but different languages are
more expressive for different things.

278
00:15:33.670 --> 00:15:37.150
We're kind of cultured in
the.net world to look at

279
00:15:37.450 --> 00:15:40.150
visual basic. And C sharp
is the two big, big

280
00:15:40.150 --> 00:15:43.600
examples of programming languages. And
we look at those and

281
00:15:43.600 --> 00:15:45.910
we say, well, actually the
constructs map, pretty much one

282
00:15:45.910 --> 00:15:48.490
to one, there's not much
to choose between them trending,

283
00:15:48.490 --> 00:15:52.810
whether you like keywords or
braces or whatever. And a

284
00:15:52.810 --> 00:15:54.730
lot of people kind of
take away from that. Well,

285
00:15:54.970 --> 00:15:58.090
all languages pretty much the
same, but when you start

286
00:15:58.090 --> 00:16:00.580
looking outside that family, when
you start looking at things

287
00:16:00.580 --> 00:16:03.100
like F sharp, you find
that there are languages that

288
00:16:03.100 --> 00:16:05.560
can do things in different
ways, but actually turned out

289
00:16:05.560 --> 00:16:08.560
to be more expressive for
some things. And that's not

290
00:16:08.560 --> 00:16:11.200
to say that all Lang
that moving away from Seesaw,

291
00:16:11.230 --> 00:16:14.050
visual basic is always a
good idea. It certainly isn't.

292
00:16:14.470 --> 00:16:18.610
For example, there's a lot
of tooling that works really

293
00:16:18.610 --> 00:16:23.020
well with C sharp and
visual. Basic. If you, you

294
00:16:23.020 --> 00:16:27.160
can write, say windows forms,
applications in F sharp. If

295
00:16:27.160 --> 00:16:29.380
you really want to write
out your windows form by

296
00:16:29.380 --> 00:16:32.530
hand in code with all
those buttons dot add statements,

297
00:16:32.950 --> 00:16:35.890
but really you'd rather use
a visual designer. And that's

298
00:16:35.890 --> 00:16:38.290
where sunlight seashells, visual basic
really comes into its own

299
00:16:38.290 --> 00:16:41.380
F shop's not gaining you
anything in terms of building

300
00:16:41.380 --> 00:16:44.320
a windows form. Whereas with
C sharp in visual basic,

301
00:16:44.350 --> 00:16:47.650
the designer gains you an
awful lot of productivity. And

302
00:16:47.650 --> 00:16:49.600
that's where one, that's one
of the nice things about

303
00:16:49.600 --> 00:16:54.070
the.net runtime is that interoperation
between languages. I can use

304
00:16:54.580 --> 00:16:58.270
a C-sharp for my windows
forms or WPF or asp.net

305
00:16:58.660 --> 00:17:02.530
applications, where I've got this
excellent visual studio tooling. And

306
00:17:02.530 --> 00:17:05.500
then when I need some
more algorithmic, I can drop

307
00:17:05.500 --> 00:17:07.660
down to our shop, which
makes it more, which is

308
00:17:07.660 --> 00:17:13.510
more convenient, more expressive for
those kinds of areas. This

309
00:17:13.510 --> 00:17:15.970
episode of Hansel minutes is
brought to you by careers.

310
00:17:16.000 --> 00:17:19.720
2.0 careers, 2.0 is a
new service by our friends

311
00:17:19.720 --> 00:17:23.260
at stack overflow. You're probably
all familiar with stack overflow.

312
00:17:23.290 --> 00:17:27.970
The online QA resource dedicated
specifically to programmers and programming

313
00:17:27.970 --> 00:17:32.080
related topics. Well, the team
at stack overflow created careers

314
00:17:32.080 --> 00:17:35.380
2.0 to provide you with
access to great jobs and

315
00:17:35.380 --> 00:17:37.120
introduce you to a bunch
of great companies that you

316
00:17:37.120 --> 00:17:39.940
might consider working for, even
if you're not currently looking

317
00:17:39.940 --> 00:17:43.210
for a job, think of
careers. 2.0 is a programmer

318
00:17:43.210 --> 00:17:46.570
profile, gives you a platform
to show that you're awesome

319
00:17:47.080 --> 00:17:51.980
by featuring your proudest contributions,
stack overflow, GitHub SourceForge Bitbucket,

320
00:17:51.980 --> 00:17:55.500
anything programming related, you can
even add your favorite programming

321
00:17:55.500 --> 00:18:00.030
books from amazon.com profiles on
careers. 2.0 are free. They're

322
00:18:00.030 --> 00:18:03.390
easy to get started, especially
by importing your LinkedIn profile.

323
00:18:04.410 --> 00:18:09.450
However, there's one catch profiles
on career 2.0 invite only.

324
00:18:10.290 --> 00:18:12.120
They did this to keep
out the spam and have

325
00:18:12.120 --> 00:18:16.050
a cry quality environment. Fortunately,
for you as a Hansel

326
00:18:16.050 --> 00:18:19.080
minutes listener, I've got your
back head on over to

327
00:18:19.080 --> 00:18:25.860
careers.stackoverflow.com/h M to accept your
invitation today, once again, that's

328
00:18:25.860 --> 00:18:33.990
careers dot stack overflow.com/hm. I
hope you like it. Do

329
00:18:33.990 --> 00:18:38.610
you think that B because.net
launched almost 10 years ago,

330
00:18:38.610 --> 00:18:42.270
or actually probably almost exactly
10 years ago with these

331
00:18:42.270 --> 00:18:45.810
languages that were so similar
with the kind of standard

332
00:18:46.050 --> 00:18:49.560
set of languages, not functional
languages, just to kind of

333
00:18:49.560 --> 00:18:53.370
imperative ifs and for loops
type stuff, and this ongoing

334
00:18:53.370 --> 00:18:56.250
kind of schizophrenia, for lack
of a better word that

335
00:18:56.250 --> 00:19:00.390
we have between C-sharp and,
and VB, you know, where

336
00:19:00.450 --> 00:19:03.270
each is first among equals,
and there's a constant thumb

337
00:19:03.270 --> 00:19:08.280
war that.net itself kind of
put itself into a painted

338
00:19:08.280 --> 00:19:10.650
itself into a corner, because
there were really only all

339
00:19:10.650 --> 00:19:15.080
of these languages that were
really just syntactic sugar. I

340
00:19:15.080 --> 00:19:18.170
think you're absolutely right there.
Scott. In fact, when Microsoft

341
00:19:18.170 --> 00:19:20.450
we're launching.net, when they're preparing
it in that they partner

342
00:19:20.450 --> 00:19:24.650
with the academic community, it's
something called project seven, where

343
00:19:24.650 --> 00:19:28.910
they, they asked the Dallas
people to support. I think

344
00:19:28.910 --> 00:19:31.760
it was seven languages across
those things like a Pearl

345
00:19:31.760 --> 00:19:35.900
implementation, early Python and implementation.
I think it was even

346
00:19:35.900 --> 00:19:37.400
a scheme in plantation. There
was a, there was a

347
00:19:37.400 --> 00:19:41.120
bunch of languages that they
asked people to implement for.net

348
00:19:41.480 --> 00:19:46.040
to prove that multilanguage concept.
Now, unfortunately at the time,

349
00:19:46.670 --> 00:19:48.890
as you identify C shop
and visual basic were the

350
00:19:48.890 --> 00:19:52.430
big ones. And once we'll
specify something called the common

351
00:19:52.430 --> 00:19:56.120
language specification, which was kind
of a subset, your language

352
00:19:56.120 --> 00:19:58.670
had to be the, the
capability of language had to

353
00:19:58.670 --> 00:20:01.700
implement in order to play
nicely with C shop and

354
00:20:01.700 --> 00:20:05.180
visual basic. And I think
a lot of language implementers

355
00:20:05.180 --> 00:20:08.960
in those early days got
very hung up on that

356
00:20:09.050 --> 00:20:11.510
CLS side of things. They
wanted to be able to

357
00:20:11.510 --> 00:20:16.310
play nicely with seashells and
visual basic. And they, I

358
00:20:16.310 --> 00:20:20.780
guess, distorted their language, decides
the language implementations to make

359
00:20:20.780 --> 00:20:23.660
sure that they looked like
C sharp or visual basic.

360
00:20:23.660 --> 00:20:28.040
So the CLS would come
through for them. And that

361
00:20:28.040 --> 00:20:29.930
was actually that turned out
to be a really bad

362
00:20:29.930 --> 00:20:33.440
idea. When the, I think
it's Jim Hogan and the

363
00:20:33.440 --> 00:20:37.520
<inaudible> started looking at the
stuff he didn't care about

364
00:20:37.520 --> 00:20:39.620
the CLS. He just wants
to have a really great

365
00:20:39.620 --> 00:20:43.310
implementation of bison on the.net
runtime, like he had on

366
00:20:43.310 --> 00:20:47.710
the Java runtime. And so
he used, he had insight

367
00:20:47.710 --> 00:20:51.370
to break free of that.
We must be like seashell

368
00:20:51.370 --> 00:20:55.840
for visual basic. He decides
to be like Python, similarly

369
00:20:55.840 --> 00:20:58.990
F sharp decided to be
like functional languages in particular

370
00:20:58.990 --> 00:21:01.960
things like ML and low
objective camel, a bit of

371
00:21:01.960 --> 00:21:05.830
hassle as well in there.
These, these language innovators decided

372
00:21:05.830 --> 00:21:08.020
they weren't going to try
to just be seeking up

373
00:21:08.020 --> 00:21:10.480
a visual basic with the
different kind of bracket they

374
00:21:10.480 --> 00:21:12.070
were going to be like
the languages like wanted to

375
00:21:12.070 --> 00:21:15.550
be. And then they'd find
that interrupt points where they

376
00:21:15.550 --> 00:21:19.600
came naturally not forcing those
interrupt points into the languages.

377
00:21:20.460 --> 00:21:23.970
Interesting. So they, it wasn't
that they necessarily made the

378
00:21:23.970 --> 00:21:27.360
decision to, to, to not
do that to not be

379
00:21:27.360 --> 00:21:30.360
saddled by the past. They
were just simply, literally not

380
00:21:30.360 --> 00:21:32.220
saddled by the past. They
were not held back in

381
00:21:32.220 --> 00:21:34.740
any way cause they had
no context. They didn't have

382
00:21:34.740 --> 00:21:38.280
visual basic three and visual
basic six and 20 years

383
00:21:38.280 --> 00:21:41.000
of that kind of, of
context to even think about

384
00:21:41.730 --> 00:21:44.490
That's right. Jim <inaudible> came
out of the Python community.

385
00:21:44.490 --> 00:21:47.040
He was interested in implementing
and creating a great implementation

386
00:21:47.040 --> 00:21:51.090
of Python, not creating a
visual basic clone with Python

387
00:21:51.090 --> 00:21:56.220
syntax. Very cool. So that's,
that's F sharp and you

388
00:21:56.220 --> 00:22:01.800
used F sharp for parsing
within your application. Right? If

389
00:22:01.820 --> 00:22:04.200
I can just button there.
I also wanted to mention,

390
00:22:04.230 --> 00:22:09.330
was we talked briefly about
parcel libraries and we talked

391
00:22:09.330 --> 00:22:11.520
about, we briefly mentioned that
you've got things like irony

392
00:22:11.580 --> 00:22:14.610
and antler on C sharp.
I want you to give

393
00:22:14.610 --> 00:22:17.550
a shout out to an
open source project called F

394
00:22:17.550 --> 00:22:20.490
parsec, which is developed by
chapel Hill. Stephan told store.

395
00:22:21.240 --> 00:22:25.140
It's a very unusual parcel
library. And it's actually based

396
00:22:25.140 --> 00:22:27.990
on the came out of
Microsoft research about I think

397
00:22:28.020 --> 00:22:31.950
eight or 10 years ago
called parsec. And it's a

398
00:22:31.950 --> 00:22:36.150
really neat way of actually
implementing a, a past specification

399
00:22:36.420 --> 00:22:40.320
within the F sharp language
itself. So, whereas with something

400
00:22:40.320 --> 00:22:44.760
like Fs Lex or antler,
you write your grandmas in

401
00:22:44.760 --> 00:22:49.530
a separate language with F
parsec. You write your grandmas

402
00:22:49.590 --> 00:22:53.370
in F sharp itself. It
uses things like operator overloading

403
00:22:53.370 --> 00:22:57.090
and in fixed notation, which
is the F sharp supports

404
00:22:57.090 --> 00:23:00.420
and C sharp doesn't to
create a very expressive sort

405
00:23:00.420 --> 00:23:05.550
of internal DSL within F
sharp, that makes it very

406
00:23:05.550 --> 00:23:09.720
convenient to express grammars without
having to jump out to

407
00:23:09.720 --> 00:23:12.810
separate tools. It also means
you can, for example, write

408
00:23:12.930 --> 00:23:16.500
functions that return grammars. Now
that may seem really odd

409
00:23:16.500 --> 00:23:19.890
thing to do. But one
of the benefits that we

410
00:23:19.890 --> 00:23:23.310
saw when we started looking
at the SAS and Les

411
00:23:23.340 --> 00:23:26.310
side of things is that
Sasson Les has got pretty

412
00:23:26.310 --> 00:23:30.060
similar syntaxes with minor variations.
They both have the same

413
00:23:30.060 --> 00:23:32.400
kind of capabilities you can
use the same kind of

414
00:23:32.400 --> 00:23:35.790
AST for them, but you
need to, for example, use

415
00:23:36.090 --> 00:23:40.980
different variable prefixes. The mixing
in notation is different. They

416
00:23:40.980 --> 00:23:45.140
have some different built in
variables and what that meant,

417
00:23:45.170 --> 00:23:47.450
what you meant. There was
a thing to write two

418
00:23:47.450 --> 00:23:51.620
separate grammar files for these
two separate languages. We could

419
00:23:51.620 --> 00:23:56.510
write grammar functions that took,
for example, the variable prefix

420
00:23:56.540 --> 00:24:00.380
as a parameter, and returned
us a grammar for the

421
00:24:00.380 --> 00:24:04.610
appropriate sub the appropriate part
of the language. And that

422
00:24:04.610 --> 00:24:07.640
meant we could reuse a
whole load of that shared

423
00:24:07.640 --> 00:24:11.960
grammar while still parameterizing the
bits of grammar that were

424
00:24:11.960 --> 00:24:16.420
different between the two. Interesting,
are you almost, and forgive

425
00:24:16.420 --> 00:24:18.640
my ignorance. It's been 20
years since I was in

426
00:24:18.640 --> 00:24:21.250
college and writing anything like
this, where you almost like

427
00:24:21.250 --> 00:24:23.170
removing the need for a
switch statement. It's almost like

428
00:24:23.170 --> 00:24:26.620
a callback for, for a
grammar. You're saying, when I

429
00:24:26.620 --> 00:24:28.750
need this go here, that
function will handle that for

430
00:24:28.750 --> 00:24:33.880
you. Pretty much. Yes. It's
a little bit different in

431
00:24:33.880 --> 00:24:38.410
that a, an F pass
at Parsa is kind of

432
00:24:38.410 --> 00:24:41.410
an object. So it's kind
of more like you've got

433
00:24:41.410 --> 00:24:44.740
a function that will return
a suitable pass. You pass

434
00:24:44.740 --> 00:24:47.800
in a parameter, like the
variable prefects that return a

435
00:24:47.800 --> 00:24:53.200
parser that understands that variable
prefects plus the common identifier

436
00:24:53.200 --> 00:24:56.230
rule. Oh, I see. I
see. So it's a different,

437
00:24:56.230 --> 00:24:58.420
it's kind of a different
way of thinking about parsing.

438
00:24:58.420 --> 00:25:00.670
It's not just the right
of grammar in this tourist

439
00:25:00.670 --> 00:25:03.610
format. It's also, it's right.
A grammar with this language

440
00:25:03.610 --> 00:25:05.770
and use the functions that
are available in this language

441
00:25:05.770 --> 00:25:08.320
and the, and the, the
things that make F sharp.

442
00:25:08.350 --> 00:25:10.630
Great. So it's, it's, it's
a parser for people who

443
00:25:10.630 --> 00:25:14.680
like F sharp. Exactly, exactly.
And it means you can

444
00:25:14.680 --> 00:25:17.470
take advantage of all of
the logic within the F

445
00:25:17.470 --> 00:25:20.140
sharp language, all the capabilities
of F sharp language, as

446
00:25:20.140 --> 00:25:22.480
well as the capabilities of
the parcel library. You don't

447
00:25:22.480 --> 00:25:25.930
have to choose between the,
the grammar format or the

448
00:25:25.930 --> 00:25:29.290
language or, or, or hand
coding things. You can combine

449
00:25:29.290 --> 00:25:32.470
the two as best you
see fit. And that really

450
00:25:32.470 --> 00:25:34.810
kind of underscores the reason
that you would jump out.

451
00:25:34.810 --> 00:25:37.450
It sounds to me like
F sharp was a great

452
00:25:37.450 --> 00:25:40.510
reason to switch over. I
mean, F sharp itself was

453
00:25:40.510 --> 00:25:42.400
a good thing to look
at, but it was the

454
00:25:42.400 --> 00:25:46.810
existence of F parsec that
made you kind of sold

455
00:25:46.810 --> 00:25:51.280
it. It was the existence
of, it was a combination

456
00:25:51.280 --> 00:25:54.070
of things, Scott, like you
say, there are parts of

457
00:25:54.070 --> 00:25:58.900
libraries in, in C sharp,
but it's the, it's the

458
00:25:58.900 --> 00:26:05.960
capability of F parsec combined
with the, the very, the

459
00:26:06.020 --> 00:26:08.440
very confined nature of the,
those suitable nature of F

460
00:26:08.440 --> 00:26:11.020
sharp for the kind of
entities that you need to

461
00:26:11.020 --> 00:26:17.440
work with in a language
Palliser. Indeed. Sometimes there's, there's,

462
00:26:17.470 --> 00:26:20.830
there's open source libraries that
I want so bad. I'm

463
00:26:20.830 --> 00:26:23.620
willing to go through the
hoops though. Like if I

464
00:26:23.620 --> 00:26:27.670
could get like apricot, HTML,
parsing in.net, that would be

465
00:26:27.670 --> 00:26:29.950
like amazing. It's like, you
know, it's the parser for

466
00:26:29.950 --> 00:26:34.780
Ruby. I agree. And I
think that's, again, one of

467
00:26:34.780 --> 00:26:37.690
the interesting things about the
polyglot approach is that it

468
00:26:37.690 --> 00:26:41.950
opens up the possibility of
using those libraries. So for

469
00:26:41.950 --> 00:26:46.680
example, if you can run
apricot under iron Ruby, then

470
00:26:46.710 --> 00:26:50.870
Hey, you've got access to
that within.net, But let's get

471
00:26:50.870 --> 00:26:53.870
to it. Let's get to
that point then isn't, isn't

472
00:26:53.870 --> 00:26:57.650
it complicated? Isn't it interrupt?
I know that if someone

473
00:26:57.650 --> 00:26:59.780
were to say, Oh, well,
I've got this great calm

474
00:26:59.780 --> 00:27:03.320
object. I could go and
do interrupt. People would find

475
00:27:03.320 --> 00:27:08.090
that distasteful, why is picking
these different languages and working

476
00:27:08.090 --> 00:27:10.430
together with them, not distasteful
as it just because they're

477
00:27:10.430 --> 00:27:16.190
all right. I, I'm not
worried to be honest, cause

478
00:27:16.190 --> 00:27:18.680
I'm not worried about this
place. I'm worried about shipping,

479
00:27:18.830 --> 00:27:22.340
interesting software that gets stuff
done. I don't have a

480
00:27:22.350 --> 00:27:25.850
problem with using multiple languages
where that's the best scenario.

481
00:27:26.180 --> 00:27:28.730
If there's a great HTML
pass out there and my

482
00:27:28.730 --> 00:27:32.270
product needs HTML passing, I'd
rather use the gray HTML

483
00:27:32.270 --> 00:27:36.350
parser than try to put
something together on my own.

484
00:27:36.350 --> 00:27:38.570
That would do half the
job. Thank you though. Let

485
00:27:38.570 --> 00:27:41.120
me push back. But that's
you, and that's why you're

486
00:27:41.120 --> 00:27:44.090
on the show, but I
would, I would propose that

487
00:27:44.090 --> 00:27:48.050
the listeners would think that
integrating iron Ruby or F

488
00:27:48.050 --> 00:27:50.600
sharp into their application, their
dotnet application would be a

489
00:27:50.630 --> 00:27:55.670
daunting task. There are certainly
bad traps, too. It certainly

490
00:27:55.670 --> 00:27:58.070
pitfalls to it. Now this
is, and this politically interesting

491
00:27:58.070 --> 00:28:00.230
when you start looking at
things like iron Ruby or

492
00:28:00.230 --> 00:28:05.420
JavaScript F sharp of course,
was designed for the.net runtime.

493
00:28:05.420 --> 00:28:09.860
So it fits very seamlessly
in there. I and Ruby

494
00:28:11.120 --> 00:28:13.310
is designed to be an
implementation of the Ruby language

495
00:28:13.340 --> 00:28:16.910
because it has different semantics
for some very basic things.

496
00:28:17.300 --> 00:28:20.210
For example, an F sharp
string is just a dotnet

497
00:28:20.210 --> 00:28:23.090
string. It's a C-sharp string.
They behave in exactly the

498
00:28:23.090 --> 00:28:26.630
same way. A Ruby string
behaves in different ways. It's

499
00:28:26.630 --> 00:28:30.380
got different methods, for example,
Ruby strings and mutable, which.net

500
00:28:30.380 --> 00:28:34.520
strings aren't. So you may
find, you know, one of

501
00:28:34.520 --> 00:28:36.440
the things that we ran
across from building web workbench

502
00:28:36.440 --> 00:28:40.280
was we wanted to pass.
We wanted to pass the

503
00:28:40.410 --> 00:28:44.000
SAS code into the sass
compiler as a string and

504
00:28:44.000 --> 00:28:48.680
superficially, it seemed to work.
But actually when we it's,

505
00:28:48.680 --> 00:28:51.170
like, in some cases we
hit problems with that because

506
00:28:51.170 --> 00:28:54.560
the SAS code was taking
paths that used Ruby API

507
00:28:54.560 --> 00:28:59.420
APIs, the only worked on
Ruby mutable strings. So we

508
00:28:59.420 --> 00:29:02.150
had to use the iron
Ruby hosting API to make

509
00:29:02.150 --> 00:29:05.810
sure we wrapped everything up
in its corresponding Ruby type

510
00:29:06.170 --> 00:29:11.720
before passing over the boundary
into the SAS code. But

511
00:29:11.720 --> 00:29:13.790
once we'd done that, that
Saska is of course is

512
00:29:13.790 --> 00:29:18.200
just running on the.net runtime.
And we can, we, you

513
00:29:18.200 --> 00:29:20.000
know, we can get objects
back from it. We can

514
00:29:20.000 --> 00:29:22.190
get texts back from it.
We can do all the

515
00:29:22.190 --> 00:29:26.030
things that we want to
do. The, the, the interesting

516
00:29:26.030 --> 00:29:29.120
thing there though, is that
I Ruby isn't like in

517
00:29:29.120 --> 00:29:32.120
complete alignment alignment, is it
though with the latest version

518
00:29:32.120 --> 00:29:35.960
of, okay. That's right. So
yes, we had a couple

519
00:29:35.960 --> 00:29:38.690
of problems with that as
well. So the led specify

520
00:29:38.690 --> 00:29:42.490
and Ruby advertise itself as
one nine, but it doesn't

521
00:29:42.520 --> 00:29:47.470
come implement the entirety of
the 1.9 specification. So there's

522
00:29:47.470 --> 00:29:51.160
some cases where SAS makes
a decision about how it's

523
00:29:51.160 --> 00:29:53.890
going to call one of
its internal functions based on

524
00:29:53.890 --> 00:29:58.090
whether it thinks it's running
under 1.8 or 1.9. And

525
00:29:59.980 --> 00:30:01.720
it saw that it was
running under what it thought

526
00:30:01.720 --> 00:30:05.380
was 1.9. It called the
1.9 version, the internal function

527
00:30:05.440 --> 00:30:07.330
and iron Ruby. Hadn't got
that. It only had the

528
00:30:07.330 --> 00:30:10.960
1.8 version. So that goes
a few headaches too, to

529
00:30:10.960 --> 00:30:14.350
figure out what was going
on there. But again, once

530
00:30:14.350 --> 00:30:16.540
you've got a little bit
of familiarity with the Ruby

531
00:30:16.540 --> 00:30:20.350
language, you can start to
crack these problems in Ruby.

532
00:30:20.350 --> 00:30:25.060
You can modify classes after
they've been built. You can

533
00:30:25.060 --> 00:30:28.630
modify classes that already exist.
You can even modify built-in

534
00:30:28.640 --> 00:30:31.570
classes. So we just wrote
a little fragment of Ruby

535
00:30:31.570 --> 00:30:36.460
code that added the, the
method that iron Ruby didn't

536
00:30:36.460 --> 00:30:40.060
implement. We added that onto
the builtin string class, using

537
00:30:40.060 --> 00:30:42.760
a little bit of Ruby
code and Hey, Presto, our

538
00:30:42.760 --> 00:30:45.220
problem went away. We didn't
have to write a lot

539
00:30:45.220 --> 00:30:49.270
of Ruby. It was maybe
six or seven lines, but

540
00:30:49.540 --> 00:30:51.430
you're absolutely right. You do
need to know the language

541
00:30:51.460 --> 00:30:52.510
in order to do that.
You need to have a

542
00:30:52.510 --> 00:30:55.000
little bit of confidence with
the language, to know what

543
00:30:55.000 --> 00:30:57.870
you can do, how you
can fix these problems. What

544
00:30:57.870 --> 00:31:00.960
would you tell folks that
are, that are listening, that

545
00:31:00.960 --> 00:31:03.180
are interested in this idea,
but still find it a

546
00:31:03.180 --> 00:31:05.340
little bit scary. Where's the
best place for them to

547
00:31:05.340 --> 00:31:09.330
start thinking about getting involved
in polyglot programming and knowing

548
00:31:09.330 --> 00:31:12.720
when to make those transitions?
I think the best place

549
00:31:12.720 --> 00:31:16.350
to start is to understand
what the different languages do,

550
00:31:16.350 --> 00:31:18.810
what libraries are known for,
what are the compelling use

551
00:31:18.810 --> 00:31:22.920
cases for the different languages?
So an F sharp, compelling

552
00:31:22.920 --> 00:31:27.180
use case include particularly passing
pain include for example, heavy

553
00:31:27.180 --> 00:31:31.710
algorithmic computation, scientific competition. For
example, F sharp units of

554
00:31:31.710 --> 00:31:36.390
measure are very helpful in
scientific computation. There's a lot

555
00:31:36.390 --> 00:31:38.610
of financials about their fresh.
If you're looking at particular

556
00:31:38.610 --> 00:31:42.450
domains, then you may find
there are libraries or language

557
00:31:42.450 --> 00:31:45.990
facilities in F sharp that
make you go, that's going

558
00:31:45.990 --> 00:31:47.370
to be a handiwork. That's
going to be a handy

559
00:31:47.370 --> 00:31:52.020
language for implementing that particular
module. Similarly, with Ruby, you've

560
00:31:52.020 --> 00:31:54.390
identified, for example, it's a
lot of, there's a lot

561
00:31:54.390 --> 00:31:58.680
of libraries out there, particularly
for working with HTML, XML,

562
00:31:58.680 --> 00:32:04.380
Jason, things like that. And
you may find that those

563
00:32:04.380 --> 00:32:08.730
libraries exceed the capabilities of
water available on.net and other

564
00:32:08.730 --> 00:32:10.290
cases you might want to
look at that kind of

565
00:32:10.290 --> 00:32:14.040
thing is for example, if
you want to integrate user

566
00:32:14.040 --> 00:32:16.680
code. So by using somebody
else's lab, you're integrating third

567
00:32:16.680 --> 00:32:20.820
party code, it's actually very
easy to host the dotnet

568
00:32:20.820 --> 00:32:24.570
dynamic language, runtime, the runtime
that sits behind iron Ruby

569
00:32:24.570 --> 00:32:27.180
and iron pipe. Then you
can host that within your

570
00:32:27.180 --> 00:32:30.990
own applications and you can
actually create simple scripting facilities

571
00:32:31.410 --> 00:32:33.750
very easily. So if you
want to do something like

572
00:32:33.750 --> 00:32:35.790
that, that will be a
great example for where you

573
00:32:35.790 --> 00:32:38.070
might look at that, but
you do need to have

574
00:32:38.070 --> 00:32:40.190
that familiarity with languages do
need to maybe go out

575
00:32:40.190 --> 00:32:42.620
and have a look at
Don Simon's book on F

576
00:32:42.620 --> 00:32:45.920
sharp, have a look around
the, I think it's try

577
00:32:45.920 --> 00:32:48.860
F sharp.net is a website
where you can actually try

578
00:32:48.860 --> 00:32:52.610
to shop. There's a lovely
website called Fs, snip.net, which

579
00:32:52.610 --> 00:32:56.210
is just a little handy
snippets of F sharp. Certainly

580
00:32:56.210 --> 00:32:59.660
for Ruby. There's a massive
online community for that. There

581
00:32:59.660 --> 00:33:02.240
are some great books out
there. There's some great tutorials

582
00:33:02.300 --> 00:33:05.990
out there. There's great support
forums out there. And there's

583
00:33:05.990 --> 00:33:09.230
a lot of resources for,
for learning Ruby, huge Madden

584
00:33:09.230 --> 00:33:12.160
resources for learning Ruby. Fantastic.
I'll be sure to put

585
00:33:12.160 --> 00:33:14.050
all of those links that
you've given us on the

586
00:33:14.050 --> 00:33:16.060
show notes, so that we've
got those all in one

587
00:33:16.210 --> 00:33:18.730
in one place. Are there
any other things we want

588
00:33:18.730 --> 00:33:20.140
to share? Are there any
other links or PR or

589
00:33:20.140 --> 00:33:22.330
open source projects that we
should share with people as

590
00:33:22.330 --> 00:33:26.410
we wrap up? We certainly
should. We've mentioned, we've talked

591
00:33:26.410 --> 00:33:28.060
a lot about F Shaw.
We've talked a bit about

592
00:33:28.060 --> 00:33:32.800
iron Ruby, but the other
language be used in, in

593
00:33:32.800 --> 00:33:36.070
web workbench was JavaScript. And
I just want to give

594
00:33:36.070 --> 00:33:38.200
a bit of a shout
out to the JavaScript implementation

595
00:33:38.200 --> 00:33:41.950
that we used. There's a,
I think he's actually another

596
00:33:41.950 --> 00:33:45.730
Wellingtonian guy called Paul Goodbar
from Matanzas a project called

597
00:33:45.730 --> 00:33:49.390
Jurassic, which is a complex
project. Now Paul's built this,

598
00:33:49.390 --> 00:33:50.890
I think pretty much from
the ground up. I don't

599
00:33:50.890 --> 00:33:54.130
think he's relying on the
dynamic language runtime. I think

600
00:33:54.130 --> 00:33:58.870
he's built his JavaScript implementation
right from the basics. And

601
00:33:59.560 --> 00:34:01.810
we looked at a couple
of JavaScript implementations. I think

602
00:34:01.810 --> 00:34:05.260
we looked at three or
four and Jurassic, we found

603
00:34:05.260 --> 00:34:08.560
really easy to host it
ran the coffee script compiler,

604
00:34:08.560 --> 00:34:10.720
which is not a trivial
piece of JavaScript. It ran

605
00:34:10.720 --> 00:34:13.480
the Costco compile the first
time out of the box.

606
00:34:13.840 --> 00:34:16.750
So if people are thinking
about using JavaScript as a

607
00:34:16.810 --> 00:34:19.420
scripting language in their applications,
or if they've got a

608
00:34:19.420 --> 00:34:22.870
JavaScript library they'd like to
call into, then drastic is

609
00:34:22.870 --> 00:34:28.540
definitely worth a look. One
little idiosyncrasy. One little difficulty

610
00:34:28.540 --> 00:34:32.290
we ran into with the
JavaScript side of things is,

611
00:34:32.290 --> 00:34:34.270
I guess your listeners might
not have heard, but there's

612
00:34:34.270 --> 00:34:38.590
a, an environment called node
dot JS, which is pretty

613
00:34:38.590 --> 00:34:41.770
widely used now in the,
I guess, in the Unix

614
00:34:41.770 --> 00:34:46.000
and Linux world. And it's,
it's used by things like

615
00:34:46.180 --> 00:34:50.440
coffee script. And I think
it's used by SAS as

616
00:34:50.440 --> 00:34:53.830
well, actually, as soon as
typically by coffee script to

617
00:34:54.100 --> 00:34:56.680
sorry, my mistake it's used
by coffee, not by SAS

618
00:34:57.780 --> 00:35:01.840
to host the command line.
So if you're running the,

619
00:35:02.320 --> 00:35:04.840
the coffee script command line
compiler, it will actually go

620
00:35:04.840 --> 00:35:10.540
through no dot JS and
no dot yes, applies a

621
00:35:10.540 --> 00:35:14.240
bunch of environmental functions that
aren't part of the Java

622
00:35:14.250 --> 00:35:19.030
JavaScript language. So for example,
a require function, which goes

623
00:35:19.030 --> 00:35:22.540
and loads of file for
file system loads. Another JavaScript

624
00:35:22.540 --> 00:35:26.110
file off the file system
and includes that effectively in

625
00:35:26.110 --> 00:35:31.030
your, in your module. Now,
obviously most JavaScript engines don't

626
00:35:31.030 --> 00:35:33.490
support that because they're running
in the browser. You don't

627
00:35:33.490 --> 00:35:35.440
want to give them access
to the local file system.

628
00:35:36.550 --> 00:35:39.630
So it's that only node
does, but because we want

629
00:35:39.630 --> 00:35:41.940
you to run the call
script compiler under Jurassic, we

630
00:35:41.940 --> 00:35:45.270
kind of had to add
that capability to Jurassic. That's

631
00:35:45.270 --> 00:35:47.640
a really easy, simple API
for doing that. You can,

632
00:35:47.650 --> 00:35:51.750
you've got this ad global
function method where you can

633
00:35:51.750 --> 00:35:55.350
implement a function in F
sharp or C-sharp, which are

634
00:35:55.350 --> 00:35:57.960
allowed to talk to the
file system. And you can

635
00:35:57.960 --> 00:36:01.110
expose that to jobs that
you can add that to

636
00:36:01.110 --> 00:36:04.230
your Java script system. So
suddenly it can take advantage

637
00:36:04.290 --> 00:36:07.290
of your F sharp or
C sharp code. If you've

638
00:36:07.290 --> 00:36:10.080
got a really nice two
way interrupt going on there,

639
00:36:10.500 --> 00:36:13.620
you've got your C-sharp driver
code, the visual studio integration,

640
00:36:13.950 --> 00:36:17.880
which calls into Jurassic to
run the coffee script compiler.

641
00:36:18.510 --> 00:36:21.720
When the coffee script compiler
requires those capabilities, that aren't

642
00:36:21.720 --> 00:36:25.980
part of native JavaScript, they're
supplied by your hosting environment.

643
00:36:25.980 --> 00:36:28.680
So you kind of got
a call back into C

644
00:36:28.680 --> 00:36:31.650
sharp. So you've got the
two languages, again, working hand

645
00:36:31.650 --> 00:36:34.080
in hand each doing what
they're capable of, what they're

646
00:36:34.080 --> 00:36:36.510
best at. And it makes
for a really nice synergy.

647
00:36:37.130 --> 00:36:39.500
I think that really is
the conclusion there is that

648
00:36:39.500 --> 00:36:43.040
use the language that, that
helps you accomplish a problem

649
00:36:43.310 --> 00:36:45.410
in a way that's natural
for that language, for that

650
00:36:45.410 --> 00:36:48.920
environment. That's right. It's like,
I think the, the pollical

651
00:36:48.930 --> 00:36:51.650
approach is very pragmatic approach.
You may use the word

652
00:36:51.650 --> 00:36:55.040
distasteful earlier on, and I
kind of see where you're

653
00:36:55.040 --> 00:36:59.090
coming from. And it's a
matter of figuring out what

654
00:36:59.090 --> 00:37:01.040
is the, what are the
appropriate trade offs? Is it

655
00:37:01.040 --> 00:37:04.370
worth bringing in additional language
for the capability? It will

656
00:37:04.370 --> 00:37:07.040
give me which language should
I choose. When should I

657
00:37:07.040 --> 00:37:10.430
use it? How much should
I put into that language?

658
00:37:11.180 --> 00:37:13.190
And I think it's a
matter of, you've got Polly

659
00:37:13.280 --> 00:37:16.340
pollical autism gives you more
tools in your toolbox. You

660
00:37:16.340 --> 00:37:18.620
don't have to use them.
Some it's not appropriate to

661
00:37:18.620 --> 00:37:21.110
use them, but when you've
got the right tool for

662
00:37:21.110 --> 00:37:24.080
the right job, it's a
very pragmatic approach to take.

663
00:37:24.620 --> 00:37:30.230
Definitely, definitely. Now folks can
check all this out@mindscapehq.com. They

664
00:37:30.230 --> 00:37:33.230
can go up there and
they can download the web

665
00:37:33.230 --> 00:37:34.970
work bench for free, as
well as check out the

666
00:37:34.970 --> 00:37:36.920
other stuff. And then did
you say that you had

667
00:37:36.950 --> 00:37:40.700
a special link for Hansel
minutes listeners? That's right. So

668
00:37:40.700 --> 00:37:44.510
we're offering a 30% off
any mindscape products to Hanselman.

669
00:37:45.380 --> 00:37:50.570
If you go to the
COVID slash, then that will

670
00:37:50.570 --> 00:37:54.710
take you to our discount
page 30% off that's up

671
00:37:54.710 --> 00:37:57.740
now, How'd you get that?
You got Hanselman is your

672
00:37:57.740 --> 00:38:05.000
piddly link before I did
scandalous. I am fantastic. We

673
00:38:05.000 --> 00:38:09.020
have the mind. Oh, brilliant.
Well, thank you so much,

674
00:38:09.020 --> 00:38:12.950
Ivan, for chatting with me
today. I appreciate it. This

675
00:38:12.950 --> 00:38:15.740
has been another episode of
Hanselminutes and we'll see you

676
00:38:15.740 --> 00:38:16.640
again next week.


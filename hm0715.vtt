WEBVTT FILE

1
00:00:00.060 --> 00:00:02.850
Hey database experts and app
developers. Do you want to

2
00:00:02.850 --> 00:00:06.900
build faster and run bigger
workloads? We've got you covered

3
00:00:06.900 --> 00:00:11.490
with an exclusive free download
of data stacks. Enterprise DataStax

4
00:00:11.490 --> 00:00:14.850
enterprise works with all the
latest tools like Kafka and

5
00:00:14.850 --> 00:00:19.410
Docker with incredible throughput and
the best security download data

6
00:00:19.410 --> 00:00:24.470
stacks enterprise for free today
by visiting DataStax that's DAA,

7
00:00:24.470 --> 00:00:30.720
T a S T a
x.com/download D S E that's

8
00:00:30.720 --> 00:00:38.070
the DataStax enterprise for free
visit datastax.com/download D S E.

9
00:00:51.680 --> 00:00:54.350
Hi, Scott Hanselman. This is
another episode of Hansel minutes

10
00:00:54.350 --> 00:00:57.740
today. I'm talking with Joe Duffy,
founder and CEO of Poloma

11
00:00:57.740 --> 00:01:01.970
CorePower user. I'm excellent. Glad
to be here, Scott. I

12
00:01:01.970 --> 00:01:07.490
noticed I was over on
the.net blog at Microsoft and,

13
00:01:08.060 --> 00:01:10.130
you know, they don't let
everybody guest post, but there

14
00:01:10.130 --> 00:01:14.390
was an actual guest post
from the Poloma team about

15
00:01:14.390 --> 00:01:17.390
the <inaudible> project. And I
thought that was pretty cool.

16
00:01:17.390 --> 00:01:18.470
And so I was like,
I'm going to start digging

17
00:01:18.470 --> 00:01:20.300
into this and learning about
what's going on here. And

18
00:01:20.300 --> 00:01:25.700
it says infrastructure as code.
What does infrastructure as code?

19
00:01:26.930 --> 00:01:29.630
Yeah, it's, it's not a
term that many of us

20
00:01:29.630 --> 00:01:33.260
developers are familiar with. Certainly
even before starting salumi, I

21
00:01:33.260 --> 00:01:37.940
wasn't very deeply engaged in
doing infrastructure as code. What

22
00:01:37.940 --> 00:01:40.340
infrastructure is code is, is,
is essentially when you want

23
00:01:40.340 --> 00:01:44.240
to build a cloud application,
maybe it uses containers, maybe

24
00:01:44.240 --> 00:01:48.590
is a serverless. You need
to deal with infrastructure. Infrastructure

25
00:01:48.590 --> 00:01:51.110
is the stuff that powers
or cloud applications, the virtual

26
00:01:51.110 --> 00:01:55.520
machines it's the clusters, the
containers themselves infrastructure is code

27
00:01:55.520 --> 00:01:57.950
as a way of managing
that infrastructure actually just using

28
00:01:57.950 --> 00:02:02.030
code. So instead of completely
stepping outside of your programming

29
00:02:02.030 --> 00:02:04.910
language, your editor to go
deal with infrastructure, you can

30
00:02:04.910 --> 00:02:09.020
actually just program it from
within your, your code. And

31
00:02:09.020 --> 00:02:11.990
by doing that, you get
automation. It's, it's basically just

32
00:02:11.990 --> 00:02:15.140
like all the benefits of
writing code it's it's automatic

33
00:02:15.140 --> 00:02:17.750
rate. You can automate things,
you can version it like

34
00:02:17.750 --> 00:02:20.450
code, you can collaborate on
it like code, it works

35
00:02:20.450 --> 00:02:23.150
in your editor. You can
share and reuse things with

36
00:02:23.570 --> 00:02:25.910
package managers, all this stuff
we know about code now

37
00:02:26.060 --> 00:02:29.960
applies to infrastructure, as you're
saying. Okay. So I just

38
00:02:30.140 --> 00:02:33.740
Googled something real quick because
many, many, many years ago,

39
00:02:33.920 --> 00:02:38.300
if you go and search
for PowerShell, large scale Hanselman,

40
00:02:38.300 --> 00:02:42.170
it looks like July of
2007. So 12 years ago,

41
00:02:42.800 --> 00:02:45.860
a PowerShell 1.0 was out.
And this is very long

42
00:02:45.860 --> 00:02:49.190
time ago. I wrote a
white paper called managing large

43
00:02:49.190 --> 00:02:52.040
scale system deployment with windows
PowerShell. This was like before

44
00:02:52.040 --> 00:02:55.400
we knew what the cloud
was. So a large scale

45
00:02:55.400 --> 00:02:58.040
was not quite a thing.
This is even before I

46
00:02:58.040 --> 00:03:02.800
think the idea of, of
a DSC desired state configuration.

47
00:03:03.220 --> 00:03:07.840
And we went and built
out data centers with PowerShell.

48
00:03:07.840 --> 00:03:10.150
And one of the things
that we struggled with was

49
00:03:10.150 --> 00:03:14.770
this idea of declarative versus
programmatic. You know, do you

50
00:03:14.770 --> 00:03:18.220
make an engine versus do
you describe what you want?

51
00:03:18.220 --> 00:03:19.630
And then if you do
describe what you want, how

52
00:03:19.630 --> 00:03:22.030
do you get into that
state and how do you

53
00:03:22.120 --> 00:03:25.270
avoid invalid States? And again,
12 years ago, but it

54
00:03:25.270 --> 00:03:28.090
was basically an XML file
that described a pod that

55
00:03:28.090 --> 00:03:30.940
described an environment and the
different roles of stuff. And

56
00:03:30.940 --> 00:03:32.800
then we had an engine
that was built in PowerShell

57
00:03:32.800 --> 00:03:35.800
that basically did whatever it
could to get the system

58
00:03:36.280 --> 00:03:40.870
where we wanted, but this
is XML and WMI and

59
00:03:40.870 --> 00:03:43.810
calm and D and it
was cool, but not really

60
00:03:43.810 --> 00:03:48.940
very reliable where we reaching
for some Nirvana that we're

61
00:03:48.940 --> 00:03:52.710
starting to actually hit with
products like presuming I think

62
00:03:52.710 --> 00:03:56.790
so I, in the last,
you know, 10, 12 years,

63
00:03:56.820 --> 00:03:58.890
let's say, you know, the
term dev ops has, has

64
00:03:58.890 --> 00:04:02.730
come to come into being,
we've seen tools like, you

65
00:04:02.730 --> 00:04:06.120
know, frankly, PowerShell, but also
things like chef and puppet

66
00:04:06.510 --> 00:04:09.840
Ansible SaltStack a lot of
these technologies have become popular

67
00:04:09.840 --> 00:04:14.820
and commonplace. And the modern
cloud is far more programmable

68
00:04:15.030 --> 00:04:17.400
in it's by its very
nature. You know, the Azure

69
00:04:17.400 --> 00:04:22.080
platform, it exposes APIs for
literally everything that it does.

70
00:04:22.350 --> 00:04:24.090
And so it used to
be the case. There's a

71
00:04:24.090 --> 00:04:27.810
very human driven activity to
do anything with it. Anything

72
00:04:27.810 --> 00:04:30.630
with management, you'd have consoles
that you point and click

73
00:04:30.630 --> 00:04:34.900
around now, everything has an
API. And so that, that

74
00:04:35.010 --> 00:04:37.860
enables you to now build
programming models on top of

75
00:04:37.860 --> 00:04:42.360
those APIs. And that's ultimately
why Poloma is possible. Now

76
00:04:42.390 --> 00:04:45.720
still a lot of infrastructure's
code tools. These days still

77
00:04:45.720 --> 00:04:49.650
use, you know, Jason or
Yammel not, not XML anymore,

78
00:04:49.650 --> 00:04:54.060
but similar concept where you're
basically expressing a desired state

79
00:04:54.060 --> 00:04:58.230
using a markup language. And
the problem with that is

80
00:04:58.410 --> 00:05:00.720
monitoring cloud architectures. It tends
to be a lot of

81
00:05:00.720 --> 00:05:04.170
moving pieces. There's a lot
of complexity. And so actually

82
00:05:04.170 --> 00:05:07.470
using a programming language to
declare your desired state. And

83
00:05:07.470 --> 00:05:11.670
that's a key important differentiation
that Fluney is still desired

84
00:05:11.670 --> 00:05:14.730
state based, even though you're
writing code in a full

85
00:05:14.730 --> 00:05:17.880
blown programming language, but you
don't have to repeat, you

86
00:05:17.880 --> 00:05:20.820
know, recreate the wheel all
the time. You can use

87
00:05:20.820 --> 00:05:22.920
everything we know and love
about languages and apply it

88
00:05:22.920 --> 00:05:26.010
to desired state. So if
you have patterns that recur

89
00:05:26.010 --> 00:05:28.950
from time to time, you
can express those, but absolutely

90
00:05:28.950 --> 00:05:32.670
that the modern progress in
modern clouds is really what

91
00:05:32.670 --> 00:05:35.160
enables these sorts of tools
to exist. So it's that

92
00:05:35.160 --> 00:05:40.320
programmatic programmatic ability programmability. I
was presenting recently in trying

93
00:05:40.330 --> 00:05:41.910
and someone said, well, what's
the cloud, the cloud is

94
00:05:41.910 --> 00:05:44.070
just other people's computers. And
I was like, yeah, I

95
00:05:44.070 --> 00:05:46.050
mean, that's, that's part of
it. Right. But it's being

96
00:05:46.050 --> 00:05:48.510
able to programmatically talk to
it and say, I want

97
00:05:48.510 --> 00:05:51.210
something. And you do the
racking of the machine. You

98
00:05:51.510 --> 00:05:53.700
add more memory. Like we,
we, you and I were

99
00:05:53.700 --> 00:05:55.620
the cloud back in the
day like, Hey, I want,

100
00:05:55.770 --> 00:05:57.620
I want to scale out,
all right, I'll buy a

101
00:05:57.620 --> 00:06:00.620
machine and I'll rack it.
And now the what, what

102
00:06:00.620 --> 00:06:03.260
the cloud is, is it's
elastic newness, right? That's the

103
00:06:03.260 --> 00:06:06.220
magic of the cloud. It
is it's, it's the magic

104
00:06:06.220 --> 00:06:11.890
of the elasticity, the reliability,
the global availability. You know,

105
00:06:11.920 --> 00:06:14.500
we work with a lot
of big companies that still

106
00:06:14.500 --> 00:06:16.870
have to manage data centers
across the world and that's,

107
00:06:17.200 --> 00:06:20.500
that's expensive business. And, and
frankly, you're probably not going

108
00:06:20.500 --> 00:06:24.400
to be as good at
it as say, Microsoft Microsoft's

109
00:06:24.460 --> 00:06:27.610
operations team who can make
sure that Azure continues to

110
00:06:27.610 --> 00:06:31.090
run reliably. And, you know,
Microsoft's got a lot of

111
00:06:31.090 --> 00:06:33.610
really smart engineers building these
cloud services and making sure

112
00:06:33.610 --> 00:06:37.600
that they're reliable and, and,
and fail safe and, and

113
00:06:37.600 --> 00:06:40.660
built in a performance and
scalable way. And you can

114
00:06:40.660 --> 00:06:43.270
leverage all of that expertise
by using the cloud instead

115
00:06:43.270 --> 00:06:45.820
of having to develop it
on your own. So, so

116
00:06:45.820 --> 00:06:47.350
back in the day when
I was kind of like

117
00:06:47.650 --> 00:06:50.860
probing this space 10 plus
years ago, it was trying

118
00:06:50.860 --> 00:06:52.990
to be a declaration, right?
We're all trying to create

119
00:06:52.990 --> 00:06:57.430
a Dom effectively that describes
the state of our data

120
00:06:57.430 --> 00:07:01.060
center. Right. And, and me
lets you do that, that,

121
00:07:01.060 --> 00:07:03.910
that Dom, that description, that
object model, but in whatever

122
00:07:03.910 --> 00:07:08.890
language makes you happy Effectively.
Yes. So polygamy is multilanguage,

123
00:07:08.920 --> 00:07:10.930
it's a, it's a runtime.
So at, at the core,

124
00:07:10.930 --> 00:07:13.210
at the heart of it
is exactly this sort of

125
00:07:13.210 --> 00:07:16.870
Dom, it's like a cloud
object model that represents all

126
00:07:16.870 --> 00:07:20.630
of the different cloud capabilities.
And, and although we work

127
00:07:20.630 --> 00:07:23.110
great on Azure, we also
support, you know, AWS, Google

128
00:07:23.110 --> 00:07:26.380
cloud Kubernetes, which is, you
know, really important to us.

129
00:07:27.460 --> 00:07:30.580
We have actually three dozen
different providers and each one

130
00:07:30.580 --> 00:07:32.950
of those is essentially a
dozen. And then we project.

131
00:07:33.400 --> 00:07:38.440
Wow. Yes. Yeah. So DigitalOcean
new Relic Datadog get hub

132
00:07:38.770 --> 00:07:42.220
lab. Cause it, it turns
out, you know, modern cloud.

133
00:07:42.220 --> 00:07:45.010
Isn't just about the cloud.
It's also about SAS, right?

134
00:07:45.670 --> 00:07:49.180
Oftentimes you're using, you know,
maybe MailChimp to send email

135
00:07:49.180 --> 00:07:52.710
from your application. Maybe you're
using new Relic to, to

136
00:07:52.710 --> 00:07:56.530
do performance monitoring. And all
of that is infrastructure that

137
00:07:56.530 --> 00:07:59.770
you need to manage and
provision. So we support that.

138
00:07:59.770 --> 00:08:02.530
And then we, we basically
project that Dom into all

139
00:08:02.530 --> 00:08:05.650
different languages we support. So
the reason why you saw

140
00:08:05.650 --> 00:08:08.890
the.net post is we just
added.net core support. So you

141
00:08:08.890 --> 00:08:11.680
can actually write your infrastructure's
code using C sharp F

142
00:08:11.680 --> 00:08:16.450
sharp, visual basic. We haven't
yet dusted off the Fortran

143
00:08:16.870 --> 00:08:20.170
or cobalt versions, but you
know, that's, that's coming and

144
00:08:20.170 --> 00:08:23.350
also PowerShell. And so it's
super powerful. You can use

145
00:08:23.350 --> 00:08:26.350
TypeScript, Python, you know, whatever
suits you. So by doing

146
00:08:26.350 --> 00:08:29.440
that, you're getting familiar language.
But more than that, you

147
00:08:29.440 --> 00:08:33.100
can benefit from the ecosystems
of tooling that has been

148
00:08:33.100 --> 00:08:36.820
built around these different languages
When, but who are the

149
00:08:36.880 --> 00:08:39.550
who's the competition. Like I
just said that I'm, you

150
00:08:39.550 --> 00:08:41.860
know, I was messing around
and I only say it

151
00:08:41.860 --> 00:08:44.170
in the lightest of ways,
you know, 12 years ago.

152
00:08:44.170 --> 00:08:46.750
Cause everyone's been trying to
do this forever. Aren't there

153
00:08:46.750 --> 00:08:52.810
other declarative programming languages or
declarative formats for, for cloud.

154
00:08:52.810 --> 00:08:55.680
How does, how does gloomy
rate relate to those? Yeah,

155
00:08:55.680 --> 00:08:58.620
it's interesting, You know, along
this journey of dev ops

156
00:08:58.620 --> 00:09:01.170
and infrastructure as code, you
know, that the term infrastructure

157
00:09:01.170 --> 00:09:03.810
is code is probably eight,
10 years old. You know,

158
00:09:03.810 --> 00:09:05.940
if you look on Wikipedia,
there's a lot of examples.

159
00:09:05.940 --> 00:09:09.360
I mentioned, you know, chef
puppet and those tools were

160
00:09:09.360 --> 00:09:13.020
more around virtual machine configuration
and people still use those

161
00:09:13.020 --> 00:09:15.660
tools. But now as we're
moving more towards container and

162
00:09:15.660 --> 00:09:19.740
serverless architectures, they're used less
and less frequently and in

163
00:09:19.740 --> 00:09:24.030
its place because of this
desired state model, we sort

164
00:09:24.030 --> 00:09:29.070
of reverted to writing everything
in Yammel Jason and scientific

165
00:09:29.070 --> 00:09:33.480
languages, which then hits the
wall at some point. So

166
00:09:33.480 --> 00:09:35.310
a lot of times, you
know, we'll see, Hey, we

167
00:09:35.310 --> 00:09:37.860
copied and pasted the same
Yammel, you know, over and

168
00:09:37.860 --> 00:09:41.220
over again, we needed 10
instances of this certain resource

169
00:09:41.220 --> 00:09:43.800
configured, basically the same. And
because Yammel, doesn't have four

170
00:09:43.800 --> 00:09:46.410
loops, we basically copy and
pasted it. So instead of

171
00:09:46.410 --> 00:09:48.240
having 10 lines of Jamar,
we have, you know, a

172
00:09:48.240 --> 00:09:51.780
hundred lines BMO and it
starts to get unwieldy because,

173
00:09:52.530 --> 00:09:55.950
you know, imagine you fix
a security problem and now

174
00:09:55.950 --> 00:09:57.720
you have to go track
down everywhere else. You copy

175
00:09:57.720 --> 00:10:00.480
and pasted that same problem.
And for some of our

176
00:10:00.480 --> 00:10:03.630
customers, you know, maybe their
consultants they're dealing with, you

177
00:10:03.630 --> 00:10:06.570
know, dozens of, of client
accounts. And now they have

178
00:10:06.570 --> 00:10:08.190
to go back to their
customers and say, Hey, you

179
00:10:08.190 --> 00:10:10.290
know that Yamhill, I gave
you last week, we need

180
00:10:10.290 --> 00:10:15.300
to go fix it. And
so, especially with the current

181
00:10:15.300 --> 00:10:17.490
cloud, you know, modern cloud
is very fine grain. There's

182
00:10:17.490 --> 00:10:22.020
lots of resources to manage
from AI ML services, databases,

183
00:10:22.020 --> 00:10:26.190
object stores, you know, serverless
functions, you know, at that

184
00:10:26.190 --> 00:10:29.910
scale, that level of complexity,
we're seeing just the approach

185
00:10:29.910 --> 00:10:33.030
of using Gamelin domain specific
languages is just breaking down

186
00:10:33.030 --> 00:10:35.630
for most people that we
work with. How, how much

187
00:10:35.630 --> 00:10:37.970
of this is declarative? Like
I like what you said

188
00:10:37.970 --> 00:10:41.210
about a cloud object model
and how much of it

189
00:10:41.210 --> 00:10:43.220
is programmatic. Like you made
a comment about a four

190
00:10:43.220 --> 00:10:45.710
loop. You know, we had
similar problems when we were

191
00:10:45.710 --> 00:10:47.720
trying to express these things
in XML where we were

192
00:10:47.720 --> 00:10:50.720
trying to decide, are we
going to be fully like,

193
00:10:50.750 --> 00:10:52.640
this is a picture of
what it should look like,

194
00:10:52.700 --> 00:10:54.680
figure it out, or are
we going to try to

195
00:10:54.680 --> 00:10:59.780
put in functional, you know,
programmatic constructs and try to

196
00:10:59.840 --> 00:11:01.790
program our way out of
this problem? Yeah. So I,

197
00:11:02.390 --> 00:11:08.600
sometimes I joke that that
prelim is actually implemented. Sure.

198
00:11:09.260 --> 00:11:11.570
I shouldn't have even said
that. It's basically, you know,

199
00:11:11.600 --> 00:11:15.050
you're, you're the, the Dom
itself is declarative, but you're

200
00:11:15.050 --> 00:11:18.650
using an imperative language or
functional, you know, frankly, if

201
00:11:18.650 --> 00:11:22.520
you pick up sharp. So
we've basically decoupled the notion

202
00:11:22.520 --> 00:11:26.240
of how you express your
intent, which has done in

203
00:11:26.240 --> 00:11:30.260
a language with the desired
state. And the key is

204
00:11:30.290 --> 00:11:34.760
that that Dom is something
you can analyze. We actually

205
00:11:34.760 --> 00:11:36.830
give you the Dom. We
actually say, before we do

206
00:11:36.830 --> 00:11:39.500
a deployment, we say, Hey,
here's the Dom, here's the

207
00:11:39.500 --> 00:11:42.620
desired state that we think
you want? Is this correct?

208
00:11:42.650 --> 00:11:44.900
No. Okay. Well, we'll show
you, you know, in your

209
00:11:44.900 --> 00:11:46.820
program where you created this
object and you go fix

210
00:11:46.820 --> 00:11:49.190
that and then say, Hey,
let's, let's give it another,

211
00:11:49.190 --> 00:11:51.920
you know, dry. And then
because we have that Dom,

212
00:11:51.920 --> 00:11:53.950
we can always diff you
know, so we know, Hey,

213
00:11:53.950 --> 00:11:56.350
you're changing this one property.
Or you're, you're creating a

214
00:11:56.350 --> 00:11:58.810
new instance of this. And
in all of that integrates

215
00:11:58.810 --> 00:12:01.210
for us with, you know,
a lot, a lot of

216
00:12:01.210 --> 00:12:04.120
people do get based workflows
where they're actually pushing code

217
00:12:04.120 --> 00:12:06.580
between environments. And so we
can integrate with GitHub pull

218
00:12:06.580 --> 00:12:08.980
requests to show you the
Dom. And so it's really

219
00:12:08.980 --> 00:12:11.800
the, the marriage of the,
of the real, you know,

220
00:12:11.830 --> 00:12:16.210
general purpose languages with this
Dom concept that makes <inaudible>

221
00:12:16.210 --> 00:12:19.980
unique. Is that right? Is
the abstract syntax tree of

222
00:12:19.980 --> 00:12:23.070
it all? Is it, is
it idiomatically the language that

223
00:12:23.070 --> 00:12:26.370
you use or is it
some intermediate language that's halfway

224
00:12:26.370 --> 00:12:30.720
to where your engine can?
Yeah, it's actually one analogy

225
00:12:30.720 --> 00:12:33.330
I kind of draw based
on my background sometimes is

226
00:12:33.330 --> 00:12:37.500
it's almost like think of
how calm worked, right? Where,

227
00:12:37.500 --> 00:12:41.160
you know, calm, you had
projections in different languages. Ultimately

228
00:12:41.160 --> 00:12:43.890
there was the calm object
model and there was an

229
00:12:43.890 --> 00:12:47.340
IDL that kind of described
what that core object model

230
00:12:47.340 --> 00:12:50.670
was. And then there was
an ed Matic as possible

231
00:12:50.940 --> 00:12:53.970
projection into each of the
languages. So like visual basic,

232
00:12:54.210 --> 00:12:56.070
you didn't have to think
about ref counting because in

233
00:12:56.070 --> 00:12:57.810
visual basic, we didn't want
that. But then in C

234
00:12:57.810 --> 00:13:00.600
plus, plus all the ref
counting was at your fingertips

235
00:13:00.600 --> 00:13:03.150
and all the goods and
everything were there. And so

236
00:13:03.150 --> 00:13:05.100
it's kind of a similar
thing with <inaudible>, you know,

237
00:13:05.100 --> 00:13:08.550
for example, our go SDK,
we built that to be

238
00:13:08.550 --> 00:13:11.550
embeddable inside of other products.
And so we actually have

239
00:13:11.550 --> 00:13:13.380
a lot of people that
are building larger systems that

240
00:13:13.380 --> 00:13:14.910
embed that in there. So
it gives you a little

241
00:13:14.910 --> 00:13:17.430
bit more information about the
Dom that you can control.

242
00:13:17.850 --> 00:13:21.750
Whereas, you know, our TypeScript
language support is really targeting

243
00:13:21.750 --> 00:13:24.540
sort of the node JS
developer who really wants to

244
00:13:24.540 --> 00:13:28.320
just create these objects and
stitch them together and use

245
00:13:28.320 --> 00:13:30.900
the, the, the node ecosystem
to do that. And so

246
00:13:30.900 --> 00:13:34.410
it's, it's definitely projected idiomatic
and teach language, but there's

247
00:13:34.410 --> 00:13:38.190
this common core to it,
which is really important, especially

248
00:13:38.190 --> 00:13:42.600
when you're doing, you know,
policy enforcement and security. And,

249
00:13:42.600 --> 00:13:44.850
you know, you know, if
you, if you want visibility

250
00:13:44.850 --> 00:13:48.660
across your organization, knowing that
there's this common object model

251
00:13:48.660 --> 00:13:52.290
that you can analyze and
understand over time is really,

252
00:13:52.320 --> 00:13:56.130
really important. And just to
expand a couple of acronyms

253
00:13:56.130 --> 00:13:59.100
for folks that aren't of
a certain age, when you

254
00:13:59.100 --> 00:14:01.470
said calm and, you know,
the component object model of,

255
00:14:01.500 --> 00:14:05.370
you know, pre.net world to,
you know, late nineties and

256
00:14:05.370 --> 00:14:07.950
then the IDL, the interface
definition language, which was like

257
00:14:07.980 --> 00:14:10.410
wisdom for in process objects.
And then later out of

258
00:14:10.410 --> 00:14:13.620
process objects, it was an
interface definition. So there's this

259
00:14:13.650 --> 00:14:16.530
interface you think of the
cloud as an interface, and

260
00:14:16.530 --> 00:14:20.370
you then have a projection
of that in idiomatic, whatever

261
00:14:20.370 --> 00:14:22.330
language makes you happy and
how many languages do you.

262
00:14:23.290 --> 00:14:28.710
Yes. So we support TypeScript,
JavaScript, Python go, and then

263
00:14:28.710 --> 00:14:31.740
any dotnet core language. So
C sharp F sharp and

264
00:14:31.740 --> 00:14:34.950
VB, Hey friends, I want
to introduce a new sponsor

265
00:14:34.950 --> 00:14:38.070
to you. H M a
VPN. It's a VPN you

266
00:14:38.070 --> 00:14:39.630
can count on. As you
know, I do a lot

267
00:14:39.630 --> 00:14:41.970
of travel and I tend
to connect to a lot

268
00:14:41.970 --> 00:14:45.120
of untrusted wireless networks. And
I probably shouldn't, but I

269
00:14:45.120 --> 00:14:49.410
can use HMA as the
world's largest VPN service offers.

270
00:14:49.410 --> 00:14:54.590
The most server locations covers
190 countries. I was always

271
00:14:54.590 --> 00:14:57.710
a server nearby it doesn't
log your IP address and

272
00:14:57.710 --> 00:15:01.850
allows me to connect five
devices simultaneously works on basically

273
00:15:01.850 --> 00:15:06.710
all platforms, Android, iOS, Mac,
Linux, windows routers, wherever it's

274
00:15:06.710 --> 00:15:10.370
actually been completely redesigned recently
to make it even simpler

275
00:15:10.370 --> 00:15:12.890
and more fun to use.
And there's even a smart

276
00:15:12.890 --> 00:15:16.040
kill switch. That'll turn the
VPN automatically on when you

277
00:15:16.040 --> 00:15:19.160
launch sensitive apps, here's your
call to action. My friends

278
00:15:19.400 --> 00:15:24.260
try HMA VPN risk-free with
a 30 day money back

279
00:15:24.260 --> 00:15:28.490
guarantee. This deal is for
Hanselman its listeners. That's HMA,

280
00:15:28.700 --> 00:15:39.920
vpn.com/offer hyphen Hansel minutes. That's
HMA vpn.com/offer-hansel minutes. And when

281
00:15:39.920 --> 00:15:42.890
we say idiomatic, right, the
goal is to make it

282
00:15:42.890 --> 00:15:45.710
feel not like it's Google
translate where it's like, well,

283
00:15:45.710 --> 00:15:47.540
I see that you're trying
to speak Spanish here, but

284
00:15:47.540 --> 00:15:50.750
it's not really, you are
honestly trying to make C-sharp

285
00:15:50.750 --> 00:15:54.050
people feel comfortable and they're
doing CCRPI type stuff. Well,

286
00:15:54.230 --> 00:15:56.840
Python people feel they're comfortable
when they're using pulling me

287
00:15:56.840 --> 00:16:00.820
in there. That's exactly right.
So in C-sharp we use

288
00:16:00.820 --> 00:16:04.420
tests, you know, task parallelism
and async methods and TypeScript

289
00:16:04.420 --> 00:16:08.170
for using promises and Python
we're using, you know, and

290
00:16:08.270 --> 00:16:10.720
even down to the level
of, you know, getting the

291
00:16:10.720 --> 00:16:14.290
right casing and the right
idiomatic, naming constructs, we really

292
00:16:14.290 --> 00:16:16.930
want you to feel at
home in your language of

293
00:16:16.930 --> 00:16:20.500
choice. It's really important to
us because we actually see,

294
00:16:21.820 --> 00:16:24.910
you know, one of the
founding team members, Luke Hogan

295
00:16:25.180 --> 00:16:27.310
was at Microsoft previously. He
actually was part of the

296
00:16:27.310 --> 00:16:30.580
founding team for TypeScript. And
we often wondered together in

297
00:16:30.580 --> 00:16:33.160
the early days, you know,
as we add new languages

298
00:16:33.310 --> 00:16:36.640
is each one additive. Or
we basically just taking, you

299
00:16:36.640 --> 00:16:38.680
know, imagine there's 100 people
in the world that would

300
00:16:38.680 --> 00:16:41.410
ever use pollute, or we
just, you know, slicing up

301
00:16:41.410 --> 00:16:44.950
that 100, you know, and
dividing and across different language

302
00:16:44.980 --> 00:16:47.980
ecosystems. What we're actually finding
is it is additive. When

303
00:16:47.980 --> 00:16:50.050
we add a dot-net support,
we connected with a totally

304
00:16:50.050 --> 00:16:54.430
different audience than when we
added Python support. And so

305
00:16:54.430 --> 00:16:56.770
there's, this it's really important
to us that we, that

306
00:16:56.770 --> 00:16:59.650
we feel animatic that we're
at home. You feel like

307
00:16:59.650 --> 00:17:02.590
we're at home for those
end users, that you can

308
00:17:02.590 --> 00:17:04.600
use your favorite tools. Like
if you have your own

309
00:17:04.750 --> 00:17:07.150
test framework that you're familiar
with in C-sharp, we want

310
00:17:07.150 --> 00:17:08.830
you to be able to
use that. And so that's

311
00:17:08.830 --> 00:17:10.840
really core to what we
try to do. And then

312
00:17:10.840 --> 00:17:13.780
frankly, it's the hardest part
of, of supporting a new

313
00:17:13.780 --> 00:17:18.550
language for us back to
that horrible Portmanteau that you

314
00:17:18.550 --> 00:17:22.150
just made there, the imperative
versus declarative and new clarity

315
00:17:22.150 --> 00:17:25.390
of there's places like I'm
looking at the dotnet specific

316
00:17:25.390 --> 00:17:27.190
as to I'll make sure
that we include links to

317
00:17:27.190 --> 00:17:29.410
all of this in the
show notes. There's places where

318
00:17:29.410 --> 00:17:34.060
you'll say it's like, like
deployment.run async and then you'll

319
00:17:34.060 --> 00:17:36.970
build kind of with, with
a quasi fluent interface, an

320
00:17:36.970 --> 00:17:40.750
object that like cosmos app
and cosmos app has these

321
00:17:40.750 --> 00:17:43.900
arcs parts of it feel
like you're building a Dom

322
00:17:43.900 --> 00:17:47.110
and then parts of it
have very verb action, you

323
00:17:47.110 --> 00:17:50.640
know, action, verb type stuff
like Renee, is it really

324
00:17:50.640 --> 00:17:52.830
running? Is it really doing
something at that moment? Or

325
00:17:52.830 --> 00:17:56.960
is that a lie? Yeah.
So it's, it's basically declaring

326
00:17:57.050 --> 00:18:00.110
the deployment. When you run
the program using the alumi

327
00:18:00.110 --> 00:18:03.800
CLI it's gonna first run
the program and compute what

328
00:18:03.800 --> 00:18:07.550
we call a preview, sometimes
known as a plan. And

329
00:18:07.550 --> 00:18:09.440
that's going to show you,
it's going to say, what

330
00:18:09.440 --> 00:18:12.740
if the, what if it's
like a dry run and

331
00:18:12.740 --> 00:18:14.660
then the CLI will say,
Hey, is this what you

332
00:18:14.660 --> 00:18:17.630
want to do? Yes, no.
Or show me more details.

333
00:18:19.070 --> 00:18:21.190
If you click, show me
more details, it shows you

334
00:18:21.440 --> 00:18:24.290
the full object graph. You
can inspect it if something

335
00:18:24.290 --> 00:18:26.930
wasn't what you expected, if
you hit yes, then it

336
00:18:26.930 --> 00:18:30.020
actually orchestrates the deployment. And
it just basically applies the

337
00:18:30.020 --> 00:18:32.780
plan that it showed you.
You can run these independently.

338
00:18:32.810 --> 00:18:35.720
Sometimes people, especially, you know,
the get hub pull request

339
00:18:35.720 --> 00:18:38.120
workflow. I mentioned earlier, a
lot of times people want

340
00:18:38.120 --> 00:18:40.220
to see that plan and
the pull request before they

341
00:18:40.220 --> 00:18:42.320
merge it. So they know
that, Hey, when I merge

342
00:18:42.330 --> 00:18:45.890
this, this pull request, it's
going to deploy three functions

343
00:18:45.890 --> 00:18:48.500
and delete, you know, a
container and do all these

344
00:18:48.500 --> 00:18:52.100
things. So that's how the
CLI kind of works in

345
00:18:52.100 --> 00:18:56.360
tandem with the programming model,
When you want something big

346
00:18:56.390 --> 00:19:01.250
made in the cloud and
something small doesn't work. How

347
00:19:01.250 --> 00:19:04.010
does an engine, like, Pilou
me get you into that

348
00:19:04.010 --> 00:19:05.930
state? Like if something happened,
how do you know if

349
00:19:05.930 --> 00:19:09.170
it was a, a transient
thing where like, Oh, well,

350
00:19:09.170 --> 00:19:12.230
you know, AWS or Azure,
couldn't get you a big

351
00:19:12.560 --> 00:19:16.430
VM right now, but try
again, versus, you know, you

352
00:19:16.430 --> 00:19:18.620
ran out of money or
something that stops you in

353
00:19:18.620 --> 00:19:21.500
its tracks. How can you
get a plan that's close

354
00:19:21.500 --> 00:19:25.040
enough versus a plan that
either succeeded or failed? Yeah,

355
00:19:25.040 --> 00:19:28.730
it's a great question. And
honestly, it's interesting being in

356
00:19:28.730 --> 00:19:31.280
our position because we tend
to be the interface into

357
00:19:31.280 --> 00:19:34.910
all these different cloud providers
for our end users. And

358
00:19:34.910 --> 00:19:38.240
so something fails, you know,
it's our responsibility to make

359
00:19:38.240 --> 00:19:40.670
sure it's a great experience
and that's a philosophy we

360
00:19:40.670 --> 00:19:42.710
have on the team. It
doesn't matter if, you know,

361
00:19:42.710 --> 00:19:45.560
Hey, Azure timed out for
some reason, or, you know,

362
00:19:45.650 --> 00:19:47.900
the, the person didn't have
enough money in their account.

363
00:19:48.110 --> 00:19:50.900
Like we, we view that
as core to our experience.

364
00:19:50.900 --> 00:19:53.360
We want it to be
a great experience. Now that

365
00:19:53.360 --> 00:19:56.870
said it's difficult. So what
we do is when you,

366
00:19:56.870 --> 00:19:59.870
when you do that preview
step, we actually validate as

367
00:19:59.870 --> 00:20:02.180
much as we can. We
actually go out to the

368
00:20:02.180 --> 00:20:04.520
cloud provider or we say,
Hey, here's what we're going

369
00:20:04.520 --> 00:20:07.640
to do. Does this look
valid to you? Surface is

370
00:20:07.940 --> 00:20:11.000
basically, you know, sort of
our background in programming languages,

371
00:20:11.000 --> 00:20:13.400
right? You want to find
as many errors as close

372
00:20:13.400 --> 00:20:16.580
to writing the code as
possible. And so we do

373
00:20:16.580 --> 00:20:18.140
as much as we can
in the editor, as you're

374
00:20:18.140 --> 00:20:21.350
typing, you know, red squiggles,
and then during the preview.

375
00:20:21.350 --> 00:20:23.270
And the worst case is
if it fails during a

376
00:20:23.270 --> 00:20:26.450
deployment, but even in that
case, we, we come back

377
00:20:26.450 --> 00:20:28.250
and we tell you exactly
what line of code it

378
00:20:28.250 --> 00:20:32.270
was. And another important thing
is, as you're doing deployments,

379
00:20:32.390 --> 00:20:37.580
salumi is transactionally checkpointing state.
So that no matter what

380
00:20:37.580 --> 00:20:40.730
happens, if you fail, you're
in a known state, you

381
00:20:40.730 --> 00:20:42.980
can choose to roll back
if you want, but you're

382
00:20:42.980 --> 00:20:46.820
always in a known well-defined
state. And so we've made

383
00:20:46.820 --> 00:20:51.130
sure because things fail right?
Re entire regions go offline,

384
00:20:51.130 --> 00:20:53.710
you know, billing as you,
as you point out, sometimes

385
00:20:53.710 --> 00:20:55.780
you might not have permissions
to do the operation you're

386
00:20:55.780 --> 00:20:58.960
trying to do, because you
know, you're in an organization

387
00:20:58.960 --> 00:21:01.990
that has locked down, you
know, security permissions. So we've

388
00:21:01.990 --> 00:21:04.300
tried to make that a
great experience. We also protect

389
00:21:04.300 --> 00:21:07.570
against common failures. Like, you
know, we do retries at

390
00:21:07.570 --> 00:21:09.910
the right time, you know,
in case there is a

391
00:21:09.910 --> 00:21:13.330
transient network problems. So that
try to insulate you from

392
00:21:13.330 --> 00:21:16.920
as many of those failures
as possible, Really significant because

393
00:21:16.950 --> 00:21:19.500
there is the, you know,
going back to my naive

394
00:21:19.500 --> 00:21:24.270
implementation many years ago, when
we got into a, we

395
00:21:24.270 --> 00:21:26.430
don't know what state we're
in, but you know, some

396
00:21:26.430 --> 00:21:30.150
stuff got made and good
luck. It was basically just

397
00:21:30.150 --> 00:21:32.040
torch it and try again
was the best we could

398
00:21:32.040 --> 00:21:34.560
do. There wasn't any kind
of granularity and there was

399
00:21:34.560 --> 00:21:38.700
minimal governance or policy management.
Yeah. That's one of the

400
00:21:38.700 --> 00:21:43.560
biggest arguments for using infrastructures
code tool is, you know,

401
00:21:43.620 --> 00:21:46.590
that sort of infrastructure, maturity
life cycle that we see

402
00:21:46.590 --> 00:21:49.080
is, you know, step one,
most people go into the

403
00:21:49.080 --> 00:21:51.480
Azure console or 80 of
us console point and click

404
00:21:51.480 --> 00:21:54.660
to provision some things they're
just exploring their learning. That's

405
00:21:54.840 --> 00:21:58.350
perfectly fine. Most people learn
that way. And the problem

406
00:21:58.350 --> 00:22:00.240
then comes, you know, Hey,
maybe you want a second

407
00:22:00.240 --> 00:22:03.000
copy of that. Maybe you
want production and staging. Maybe

408
00:22:03.000 --> 00:22:05.430
you want to share it
with a colleague and have

409
00:22:05.430 --> 00:22:07.230
them stand up their own
copy, or you need to

410
00:22:07.410 --> 00:22:09.810
scale, you know, to a
new region at that point,

411
00:22:09.810 --> 00:22:13.680
you need automation. And the
obvious way to do automation

412
00:22:13.680 --> 00:22:16.920
is to open code, you
know, provisioning of new resources.

413
00:22:17.100 --> 00:22:19.080
But the problem is exactly
what you point out where

414
00:22:19.350 --> 00:22:22.050
if it fails. Now, your
script has to think about

415
00:22:22.110 --> 00:22:26.460
every possible permutation of failure
and every state transition. And

416
00:22:26.460 --> 00:22:30.180
that's what an infrastructure's code
tool fundamentally does. It knows

417
00:22:30.180 --> 00:22:33.090
the desired state, and it
knows how to converge on

418
00:22:33.090 --> 00:22:35.520
that desired state, no matter
what state you are currently

419
00:22:35.520 --> 00:22:38.670
in. And that, that removes
a ton of complexity that

420
00:22:38.670 --> 00:22:41.490
you just don't need to
think about it anymore. That

421
00:22:41.490 --> 00:22:43.800
is, that is the trick
though. Like all of this

422
00:22:43.800 --> 00:22:47.130
is trying to hide complexity,
but also it shouldn't feel

423
00:22:47.130 --> 00:22:50.010
like a black box that
is hidden so much that

424
00:22:50.010 --> 00:22:53.310
you just throw your wishes,
you know, into the well

425
00:22:53.310 --> 00:22:55.380
and hope that things work
out nicely. So how do

426
00:22:55.380 --> 00:22:57.630
you find that balance? You
said that you can give

427
00:22:57.630 --> 00:22:59.880
them line numbers. You, you
follow it all the way

428
00:22:59.880 --> 00:23:03.210
back to the projection and
say the engine failed here,

429
00:23:03.210 --> 00:23:07.650
but in your projection, that's
line 26. Exactly. We, we

430
00:23:07.650 --> 00:23:10.290
treat this, you know, a
lot of folks on the

431
00:23:10.290 --> 00:23:14.670
team come from visual studio
and, and.net and, you know,

432
00:23:14.680 --> 00:23:18.090
compilers and languages. And so
we've, we've treated the whole

433
00:23:18.090 --> 00:23:21.690
infrastructure as code experience. Like
we would a programming language

434
00:23:21.690 --> 00:23:25.530
or a compiler, and frankly,
over time where, you know,

435
00:23:25.530 --> 00:23:27.720
we love vs code and
we're, we're kind of integrating

436
00:23:27.720 --> 00:23:30.780
more deeply into that and
bringing more things, just closer

437
00:23:30.780 --> 00:23:33.330
to the development experience. And
so, you know, cause we

438
00:23:33.330 --> 00:23:35.850
talk to people a lot
of times when something fails,

439
00:23:36.390 --> 00:23:38.820
it's, you know, 10, 10
minutes into a deployment, it's

440
00:23:38.820 --> 00:23:42.240
kind of already too late.
Production is now potentially suffering

441
00:23:42.240 --> 00:23:45.890
an outage. And it's kind
of like some transient failure.

442
00:23:45.890 --> 00:23:48.290
You had a pile of
Yammel and it's not even

443
00:23:48.290 --> 00:23:50.900
clear where the failure came
from. And so we're really

444
00:23:50.900 --> 00:23:56.150
trying to bring a great
developer experience to infrastructure, which

445
00:23:56.630 --> 00:24:00.050
is, is pretty unique. I
think, cause a lot of,

446
00:24:00.110 --> 00:24:02.210
a lot of the, you
know, we we've been on

447
00:24:02.210 --> 00:24:03.970
this journey for a long
time and I think our

448
00:24:04.010 --> 00:24:07.940
standards for what's acceptable in
the infrastructure space are actually

449
00:24:07.940 --> 00:24:11.420
much lower than what our
standards are in the application

450
00:24:11.420 --> 00:24:15.470
developer space. We're, we're willing
to tolerate messy, hard to

451
00:24:15.470 --> 00:24:18.350
diagnose failures for some reason.
I think it's just historically

452
00:24:18.350 --> 00:24:20.360
how we ended up here.
And so we're trying to

453
00:24:20.360 --> 00:24:24.310
revisit that The, the, the
larger Poloma kind of cloud

454
00:24:24.310 --> 00:24:28.210
development platform, isn't just this
runtime, right. There's tools, there's

455
00:24:28.210 --> 00:24:31.510
libraries, there's runtime. The goal
of which is to give

456
00:24:31.510 --> 00:24:36.490
you that consistent development, that
consistent operational plane for everything.

457
00:24:36.790 --> 00:24:40.480
How much does it try
to hide? Like pretend that

458
00:24:40.480 --> 00:24:43.090
we don't even know what
cloud we're on versus how

459
00:24:43.090 --> 00:24:46.210
much is it really straightforward
with you about, about the

460
00:24:46.210 --> 00:24:47.920
realities of what you're doing?
Like how much do you

461
00:24:47.920 --> 00:24:51.040
abstract away and how much
do you decidedly not abstract

462
00:24:51.040 --> 00:24:57.280
away. Yeah. Was a great
question. We, we intentionally, so

463
00:24:57.280 --> 00:25:00.310
the system's sort of layered.
We intentionally don't abstract away

464
00:25:00.340 --> 00:25:04.900
at the fundamental building block
layer. So I think of

465
00:25:04.900 --> 00:25:06.670
it as, you know, it's
turtles all the way down,

466
00:25:06.700 --> 00:25:10.030
right? It's a programming language.
So everything's classes and functions

467
00:25:10.030 --> 00:25:13.600
and things compose, but everything
bottoms out at that. Basically

468
00:25:13.600 --> 00:25:16.330
the Dom that we were
talking about, where you've got

469
00:25:16.330 --> 00:25:19.720
access to every cloud provider,
all of the resources and

470
00:25:19.720 --> 00:25:22.420
all the properties on those
resources in their raw form,

471
00:25:22.450 --> 00:25:23.920
we don't get in the
way we don't want to

472
00:25:23.920 --> 00:25:26.500
abstract over it. If you're
going to Azure using cosmos

473
00:25:26.500 --> 00:25:28.390
DB, we want you to
have the latest and greatest

474
00:25:28.390 --> 00:25:32.200
features and be able to
use them fully now where

475
00:25:32.200 --> 00:25:34.960
it starts to get interesting
is we can actually give

476
00:25:34.960 --> 00:25:38.260
you help our libraries, but
still the next layer up

477
00:25:38.260 --> 00:25:41.320
is still cloud specific. So
you mentioned we were actually

478
00:25:41.320 --> 00:25:44.920
on the release and Azure
blog in partnership with the

479
00:25:44.920 --> 00:25:50.560
cosmos DB team, this distributed
application concept where oftentimes people,

480
00:25:50.800 --> 00:25:53.080
you know, will provision a
cosmos database, but then their

481
00:25:53.080 --> 00:25:56.770
application isn't globally distributed. So
it's, it's not taking advantage

482
00:25:56.770 --> 00:25:58.930
of the latency savings of
the database. And so we

483
00:25:58.930 --> 00:26:02.350
can give you a cosmos
application, a component is what

484
00:26:02.350 --> 00:26:04.600
we call it. And that
just hides a lot of

485
00:26:04.600 --> 00:26:07.930
the infrastructure complexity, but you
still know you're using Azure

486
00:26:07.990 --> 00:26:10.390
in that case. And so
that's sort of like this

487
00:26:10.390 --> 00:26:13.060
middle layer where we can
help you with common patterns

488
00:26:13.060 --> 00:26:16.300
so you can frankly build
your own. And then we

489
00:26:16.300 --> 00:26:19.300
do see some people taming
the complexity of having to

490
00:26:19.300 --> 00:26:23.410
do multiple clouds using abstractions.
So one of our customers,

491
00:26:23.650 --> 00:26:25.690
they run an Azure, but
they also have to run

492
00:26:25.690 --> 00:26:28.870
on prem. And so let's
call them Acme Corp. They

493
00:26:28.870 --> 00:26:31.360
were able to create, you
know, an Acme Corp virtual

494
00:26:31.360 --> 00:26:34.960
machine abstraction that knows how
to at deployment time, either

495
00:26:34.960 --> 00:26:38.410
go to Azure or go
to vSphere VMware vSphere on

496
00:26:38.410 --> 00:26:42.670
prem, and that's allowed them,
you know, it's not, it's

497
00:26:42.670 --> 00:26:46.230
not hiding the complexity, but
it helps to encapsulate some

498
00:26:46.230 --> 00:26:49.170
of the complexity and enables
other people on the team

499
00:26:49.170 --> 00:26:51.270
to think at a different
level of abstraction. Right? So

500
00:26:51.270 --> 00:26:55.440
now application developers can create
applications out of composing Acme,

501
00:26:55.440 --> 00:27:00.030
Corp, virtual machines, without having
to completely replicate their configuration

502
00:27:00.030 --> 00:27:02.220
for the two different environments.
And so we see a

503
00:27:02.220 --> 00:27:04.890
lot, you know, increasingly more
of that, and we're really

504
00:27:04.890 --> 00:27:07.770
excited about the sort of
blueprints and patterns there, but

505
00:27:07.770 --> 00:27:11.040
fundamentally you can always Pierce
through the abstraction and get

506
00:27:11.040 --> 00:27:14.400
at the raw underlying cloud.
And I think that's essential

507
00:27:15.030 --> 00:27:18.210
because you see some platforms
as a service that have

508
00:27:18.210 --> 00:27:20.160
come in to where it
works great for sort of

509
00:27:20.160 --> 00:27:22.080
development. But then when you
go into production, you have

510
00:27:22.080 --> 00:27:25.890
to completely rewrite everything because
it had too much from

511
00:27:25.890 --> 00:27:28.470
you is they're trying to
strike a nice balance between

512
00:27:28.470 --> 00:27:32.430
that abstraction in the level
of precision and control that

513
00:27:32.460 --> 00:27:39.770
most enterprises need. So given
the space, which is arguably

514
00:27:39.800 --> 00:27:43.610
somewhat crowded and has been,
you know, developing since, you

515
00:27:43.610 --> 00:27:48.050
know, puppet in 2005, what
does Poloma do that kind

516
00:27:48.050 --> 00:27:51.410
of uniquely sets it aside
from the various and sundry,

517
00:27:52.190 --> 00:27:56.030
you know, list of a
dozen similar, if not coming

518
00:27:56.030 --> 00:27:58.940
on, they're not directly similarly
like one-to-one features, but like

519
00:27:58.940 --> 00:28:00.800
where do you say, Oh
yeah, you should use polygamy

520
00:28:00.800 --> 00:28:04.010
rather than My answer to
this now is different than

521
00:28:04.010 --> 00:28:05.900
it would have been at
the start. You know, at

522
00:28:05.900 --> 00:28:09.880
the start I thought it
was. And honestly, it's, it's

523
00:28:09.890 --> 00:28:13.190
more of a people thing
than it is a technology

524
00:28:13.190 --> 00:28:15.590
thing. I thought it was
technology. I thought it was,

525
00:28:15.590 --> 00:28:18.470
Hey, general purpose languages. You
know, it solves a bunch

526
00:28:18.470 --> 00:28:21.800
of problems, technical problems, right?
Package management, you get, you

527
00:28:21.800 --> 00:28:26.180
know, better editor experience sharing
and reuse. What we're finding

528
00:28:26.180 --> 00:28:30.890
with is actually it's the
fact that now infrastructure and

529
00:28:30.890 --> 00:28:37.130
operations teams can actually work
with development teams together historically

530
00:28:37.130 --> 00:28:40.220
they've had completely different stacks,
right? So the dev team

531
00:28:40.220 --> 00:28:42.170
was working on their app
stack and then the infrastructure

532
00:28:42.170 --> 00:28:44.690
team is working on, you
know, chef puppet or what

533
00:28:44.690 --> 00:28:48.470
have you, where, and that
sort of reinforced some of

534
00:28:48.470 --> 00:28:52.790
the silos where, you know,
if developers need new infrastructure,

535
00:28:52.790 --> 00:28:54.740
they file a ticket and
they wait for the it

536
00:28:54.740 --> 00:28:56.840
team to provision it. And
then they get back, you

537
00:28:56.840 --> 00:28:59.810
know, maybe a month later
or a quarter later. Whereas

538
00:28:59.810 --> 00:29:02.840
now what we're seeing is,
especially with the rate of

539
00:29:02.840 --> 00:29:06.470
change in modern cloud architectures
and things workflows that are

540
00:29:06.470 --> 00:29:11.480
unlocked by technologies like serverless
containers and Kubernetes, we're actually

541
00:29:11.480 --> 00:29:15.440
seeing that infrastructure teams want
to empower their developers to

542
00:29:15.440 --> 00:29:18.350
be a lot more self-serve
if a developer wants a

543
00:29:18.350 --> 00:29:22.040
queue or a pump sub
topic, or, you know, a

544
00:29:22.040 --> 00:29:25.070
new container or a new
Azure function or whatever it

545
00:29:25.070 --> 00:29:27.350
is, they want to be
able to have their teams

546
00:29:27.350 --> 00:29:30.260
do that. But the infrastructure
team wants to put in

547
00:29:30.260 --> 00:29:33.020
place guardrails to make sure
that developers don't accidentally do

548
00:29:33.020 --> 00:29:35.930
the wrong thing. And so
we see developers really like

549
00:29:35.930 --> 00:29:37.430
it because they get to
use their favorite language. They

550
00:29:37.430 --> 00:29:41.650
basically supercharge their, their ability
to build more powerful cloud

551
00:29:41.650 --> 00:29:45.400
applications. While at the same
time, the infrastructure team feels

552
00:29:45.400 --> 00:29:48.580
comfortable and they can still
get the, the management and

553
00:29:48.610 --> 00:29:51.250
policies and oversight that they
need. And so it's really

554
00:29:51.250 --> 00:29:55.360
that developer appeal that I
think sets it really apart

555
00:29:55.360 --> 00:29:58.200
from, from most of what's
out there, I noticed that

556
00:29:58.200 --> 00:30:01.650
I can go and install
the preliminary CLI I can

557
00:30:01.650 --> 00:30:05.430
install stuff on my local
machine, but just while you

558
00:30:05.430 --> 00:30:07.560
were talking, I went to
app dot <inaudible> dot com

559
00:30:07.560 --> 00:30:09.780
logged in with GitHub, said,
I use Azure and C

560
00:30:09.780 --> 00:30:12.630
sharp click, click, click, and
now I'm doing it all

561
00:30:12.630 --> 00:30:16.790
in the cloud. And I
just, I've given like basically

562
00:30:16.900 --> 00:30:18.990
a one liner that I
run to get the things

563
00:30:18.990 --> 00:30:22.050
that I want to get.
And what is the relationship

564
00:30:22.050 --> 00:30:25.170
between the CLI and this
console on the cloud? Yeah.

565
00:30:25.170 --> 00:30:29.460
So I often describe this
using an analogy. So, you

566
00:30:29.460 --> 00:30:31.620
know, the CLI you can
think of as like get,

567
00:30:32.070 --> 00:30:35.250
right, it's an offline tool.
You can run it fully

568
00:30:35.250 --> 00:30:38.100
offline if you want, you
can use it without our

569
00:30:38.100 --> 00:30:40.230
service, but our service is
kind of like get hub

570
00:30:40.830 --> 00:30:44.010
in the sense that get
plus get hub is a

571
00:30:44.010 --> 00:30:46.260
lot easier. It just handles
a lot of problems for

572
00:30:46.260 --> 00:30:49.350
you. If you want to
use it in your organization,

573
00:30:49.350 --> 00:30:51.720
it makes it easier to
share your projects. And so

574
00:30:51.720 --> 00:30:54.000
that's essentially what the preemie
service is all about. The

575
00:30:54.000 --> 00:30:57.540
preemie service is, you know,
it's the default mode that

576
00:30:57.540 --> 00:31:01.050
we recommend people use that
makes it just really reliable.

577
00:31:01.080 --> 00:31:04.020
So everything you're doing is
when I mentioned the transactional

578
00:31:04.020 --> 00:31:07.380
checkpointing, it's using the service
to do that. It's giving

579
00:31:07.380 --> 00:31:09.540
a visibility. So if you
do deployments, you're going to

580
00:31:09.540 --> 00:31:11.550
get full history, similar to
how get hub gives you

581
00:31:11.550 --> 00:31:15.030
commit history with blimey, you'll
see your full deployment history.

582
00:31:15.510 --> 00:31:18.000
And because when you logged
in you, you did it

583
00:31:18.000 --> 00:31:22.110
with get hub. If you're
actually triggering deployments from get

584
00:31:22.110 --> 00:31:24.210
hub itself, watch a show
you the commit itself. So

585
00:31:24.210 --> 00:31:27.630
we'll, we'll show you every
deployment who performed the deployment,

586
00:31:27.960 --> 00:31:30.420
what commit it came from,
what pull requests that came

587
00:31:30.420 --> 00:31:32.850
from them for using the
pull request workflow. And then

588
00:31:32.850 --> 00:31:33.990
if you want to use
a team, you can sign

589
00:31:33.990 --> 00:31:35.790
up a new organization. And
that gives you all the

590
00:31:35.790 --> 00:31:38.850
standard things around an organization
like, you know, role based

591
00:31:38.850 --> 00:31:42.570
access control. You can more
easily share and work and

592
00:31:42.570 --> 00:31:47.100
collaborate on shared projects. You
can have, you know, continuous

593
00:31:47.100 --> 00:31:50.490
integration so that you can
get, you know, service accounts

594
00:31:50.490 --> 00:31:55.290
where you're, you're doing deployments
automatically rather than manually. And

595
00:31:55.290 --> 00:31:57.480
then other other features as
well around just, you know,

596
00:31:57.480 --> 00:32:01.230
security and compliance. And you'll
notice that it's, it's base

597
00:32:01.260 --> 00:32:04.500
basically a SAS model. And
so that's a model for

598
00:32:04.500 --> 00:32:07.320
the company. You know, we,
we open sourced the whole

599
00:32:07.320 --> 00:32:10.470
SDK though. It's there, we
didn't hold anything back. And

600
00:32:10.530 --> 00:32:13.650
the part that we charge
for is just the size.

601
00:32:13.680 --> 00:32:15.450
Now it turns out there's
a free tier as well

602
00:32:15.450 --> 00:32:17.370
for unlimited use. It's really
just when you want to

603
00:32:17.370 --> 00:32:21.630
use similar to how you
get free, you know, individual

604
00:32:21.660 --> 00:32:24.510
repos on GitHub, right? You
get the same with polygamy,

605
00:32:24.540 --> 00:32:27.540
but once you want to
use organizations, that's, that's when

606
00:32:27.540 --> 00:32:29.940
you pay. And even then,
you know, you get started,

607
00:32:29.940 --> 00:32:32.340
it's $50 a month for
three people. It's, it's pretty,

608
00:32:32.580 --> 00:32:35.700
pretty affordable at that point.
Okay. So would you recommend

609
00:32:35.700 --> 00:32:38.340
that people just hit to
that prelim.com walk through the

610
00:32:38.340 --> 00:32:40.700
process? It's like a five
minute Thing to get a

611
00:32:40.700 --> 00:32:43.460
hello world, pulling me out
running, and then a weekend

612
00:32:43.460 --> 00:32:45.890
to take whatever they've already
got going and set it

613
00:32:45.890 --> 00:32:50.420
up for themselves. Yeah, absolutely.
There is, you know, app.plume.com.

614
00:32:50.420 --> 00:32:52.700
There's also, you just go
to pluming.com. There's these getting

615
00:32:52.700 --> 00:32:56.000
started buttons. We call it
action. Blue, you click any

616
00:32:56.000 --> 00:32:58.430
of those buttons will take
you through walkthroughs. And as

617
00:32:58.430 --> 00:33:00.350
you point out, it says,
Hey, which cloud do you

618
00:33:00.350 --> 00:33:01.880
want? Which language do you
want? And then it just

619
00:33:01.880 --> 00:33:04.430
walks you through building a
simple application. And then we've

620
00:33:04.430 --> 00:33:07.850
got over a hundred tutorials
now for lots of different

621
00:33:07.940 --> 00:33:11.780
application architectures. Very cool. Well,
thank you very much, Joe Duffy

622
00:33:11.780 --> 00:33:14.420
for chatting with me today.
Yeah. Thanks Scott. It was

623
00:33:14.420 --> 00:33:16.910
a lot of fun. This
has been another episode of

624
00:33:16.910 --> 00:33:19.340
Hanselminutes and we'll see you
again next week.


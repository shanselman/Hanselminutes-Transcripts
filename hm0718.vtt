WEBVTT FILE

1
00:00:00.240 --> 00:00:03.000
Hey database experts and app
developers. Do you want to

2
00:00:03.000 --> 00:00:07.050
build faster and run bigger
workloads? We've got you covered

3
00:00:07.050 --> 00:00:12.210
with an exclusive free download
of DataStax enterprise DataStax enterprise

4
00:00:12.210 --> 00:00:15.510
works with all the latest
tools like Kafka and Docker

5
00:00:15.780 --> 00:00:20.280
with incredible throughput and the
best security download data stacks

6
00:00:20.460 --> 00:00:24.930
enterprise for free today by
visiting DataStax that's DAA, T

7
00:00:24.930 --> 00:00:30.990
a S T a x.com/download
D S E that's the

8
00:00:30.990 --> 00:00:52.490
DataStax enterprise for free visit
datastax.com/download D S E Scott

9
00:00:52.490 --> 00:00:54.860
Hanselman. And this is another
episode of Hansel minutes today.

10
00:00:54.860 --> 00:00:57.710
I'm talking with Mark Russinovich.
Welcome back to the show

11
00:00:57.980 --> 00:01:01.400
CTO of Azure at Microsoft
and a general reckoned and

12
00:01:01.400 --> 00:01:04.760
tour. Thanks Scott, Scott to
be back. I know it's

13
00:01:04.760 --> 00:01:07.280
been a few years since
I was on the show.

14
00:01:07.280 --> 00:01:10.100
Last. Yeah, last time I
was talking to you, you

15
00:01:10.100 --> 00:01:12.440
had written a book and
now it's a series. I

16
00:01:12.440 --> 00:01:16.820
was at a trilogy. Yep.
It's trilogy the last edition

17
00:01:16.850 --> 00:01:19.940
of the trilogy I released
in 2014. So it's been

18
00:01:19.940 --> 00:01:22.880
a while since, even that,
when are you going to

19
00:01:22.880 --> 00:01:25.070
turn it into a trilogy
of trilogies, like star Wars

20
00:01:25.070 --> 00:01:29.210
and do nine, right. Great
idea. So what I wanted

21
00:01:29.210 --> 00:01:32.060
to talk to you about
today is this thing called

22
00:01:32.060 --> 00:01:36.110
dapper da P our distributed
application. Runtime folks can check

23
00:01:36.110 --> 00:01:38.990
it out at D a
P R dot I O

24
00:01:38.990 --> 00:01:41.240
and I'll make sure to
include show notes to anything

25
00:01:41.240 --> 00:01:44.030
that we talk about or
mentioned during the show here.

26
00:01:44.390 --> 00:01:49.160
It says an event driven,
portable runtime for building microservices

27
00:01:49.250 --> 00:01:52.580
on cloud N edge. That's
a very small number of

28
00:01:52.580 --> 00:01:54.650
words, but it tries to
say a lot right there

29
00:01:54.650 --> 00:01:58.130
in one short sentence. Yup.
I think there's even more

30
00:01:58.130 --> 00:01:59.930
you can say on top
of it. So we had

31
00:01:59.930 --> 00:02:02.750
to be very careful about
which words to pick, to

32
00:02:02.750 --> 00:02:08.300
emphasize the, the core value.
Why is that? Because it's

33
00:02:08.300 --> 00:02:10.340
lots of different things and
you can use it in

34
00:02:10.340 --> 00:02:12.530
lots of different ways. I
think that's why we kind

35
00:02:12.530 --> 00:02:15.500
of let really a programming
runtime platform rather than a

36
00:02:15.500 --> 00:02:20.000
programming runtime, really, because you
can choose to adopt it

37
00:02:20.030 --> 00:02:24.050
piecemeal. You can choose to
integrate it into an existing

38
00:02:24.740 --> 00:02:27.860
what people would consider a
legacy app or a monolithic

39
00:02:27.860 --> 00:02:32.030
app. You can choose to
go full bore and take

40
00:02:32.030 --> 00:02:35.330
advantage of the pure cloud
native serverless aspects of it

41
00:02:35.420 --> 00:02:40.010
and create a massively distributed,
very fine grain microservice based

42
00:02:40.010 --> 00:02:44.660
application. So when I hear
the word runtime at its

43
00:02:44.720 --> 00:02:48.110
at its base, I think
about management, I think about

44
00:02:48.110 --> 00:02:53.210
like a womb or a
cradle that holds my application

45
00:02:53.210 --> 00:02:56.390
and does stuff for me.
So at the most simplistic,

46
00:02:56.780 --> 00:02:59.410
you know, whether it be
node or java.net, the runtime

47
00:02:59.500 --> 00:03:03.490
handles Stuff that I'm not
interested in handling like the

48
00:03:03.490 --> 00:03:06.010
basic example, be garbage collection.
I don't want to do

49
00:03:06.010 --> 00:03:08.350
that anymore. So you do
that thing and I'll focus

50
00:03:08.350 --> 00:03:11.530
on these other things. Is
this a runtime that does

51
00:03:11.530 --> 00:03:13.480
stuff? So I don't have
to think about those things.

52
00:03:13.510 --> 00:03:17.340
Absolutely. In fact, that's kind
of where the logo that

53
00:03:17.340 --> 00:03:19.290
came along with dapper, where
you've got the top hat

54
00:03:19.290 --> 00:03:23.340
and the tie dapper dresser,
but also kind of a

55
00:03:23.340 --> 00:03:26.550
dapper style Butler that handles
things for you that you'd

56
00:03:26.550 --> 00:03:28.860
rather not spend your time
on, so you can focus

57
00:03:28.860 --> 00:03:34.680
on your app. Hmm. So
it's your application concierge. Okay.

58
00:03:35.040 --> 00:03:39.630
So this is primarily in
the context of microservices. Is

59
00:03:39.630 --> 00:03:42.060
it, is it only a
Kubernetes thing or is it

60
00:03:42.060 --> 00:03:46.290
an anywhere thing? There's no
direct connection to Kubernetes other

61
00:03:46.290 --> 00:03:49.110
than we've got built in
support for deploying it onto

62
00:03:49.110 --> 00:03:52.320
Kubernetes, it, you can install
it anywhere. So it runs

63
00:03:52.320 --> 00:03:56.010
in a self hosted mode.
So you can put it

64
00:03:56.010 --> 00:03:58.290
on your own dev box.
You can put it on

65
00:03:58.320 --> 00:04:02.180
a server, a virtual machine,
or you can deploy to

66
00:04:02.190 --> 00:04:05.340
Kubernetes cluster and or to
any other kind of orchestrator

67
00:04:05.340 --> 00:04:06.960
you want. We just have
to have, like I said,

68
00:04:06.960 --> 00:04:12.450
built in support for deploying
it into Kubernetes When, when

69
00:04:12.450 --> 00:04:15.810
I'm making an application, I
think that we sometimes blur

70
00:04:16.200 --> 00:04:18.930
the, the things that we
need to solve to solve

71
00:04:18.930 --> 00:04:20.910
the business problem. And then
all of the kind of

72
00:04:20.910 --> 00:04:23.130
cross cutting concerns. So it's
like, Hey, we're going to

73
00:04:23.130 --> 00:04:28.350
make a website, session management,
authentication, authorization, and on and

74
00:04:28.350 --> 00:04:31.230
on, you know, realization, you
know, there's a whole list

75
00:04:31.230 --> 00:04:34.260
of stuff that has nothing
to do with what we

76
00:04:34.260 --> 00:04:37.560
do here at Acme insurance.
And sometimes we blur the

77
00:04:37.560 --> 00:04:40.710
line and we end up
writing all of these other

78
00:04:40.710 --> 00:04:44.070
things just because they don't
either exist or the ones

79
00:04:44.070 --> 00:04:46.650
that exist. Don't do what
we want them to do

80
00:04:47.430 --> 00:04:51.240
is, is the stuff in
dapper trying to be completely

81
00:04:51.540 --> 00:04:54.870
supportive. It always plays a
supporting role for me to

82
00:04:55.560 --> 00:04:57.750
not have to write something.
And then I do the

83
00:04:57.750 --> 00:05:01.140
business logic separately and entirely
separate from those cross cutting

84
00:05:01.140 --> 00:05:04.590
concerns, That's us goal. And
in fact, it was basically

85
00:05:04.590 --> 00:05:08.070
inspired by what we saw
happening in cloud native programming

86
00:05:08.070 --> 00:05:11.880
models like functions as a
service and actor models. And

87
00:05:11.880 --> 00:05:16.740
really the primary goal of
dapper was to make, to

88
00:05:16.770 --> 00:05:22.170
bring cloud native distributed microservice
application development to enterprise Debs.

89
00:05:22.770 --> 00:05:27.030
Many enterprise devs are familiar
and skilled with, and everyday

90
00:05:27.030 --> 00:05:32.640
writing traditional multi tier web
plus database apps and learning

91
00:05:32.640 --> 00:05:34.800
all the things you need
to learn to build the

92
00:05:34.800 --> 00:05:39.150
distributed microservice-based app is a
lot of complexity and a

93
00:05:39.150 --> 00:05:42.990
lot of different SDKs and
a lot of concepts that

94
00:05:43.260 --> 00:05:46.590
distract from, like you said,
focusing on the Acme problem

95
00:05:46.590 --> 00:05:50.790
that they are paid to
go solve. And so just

96
00:05:50.850 --> 00:05:55.500
like functions as a service
takes and performs a lot

97
00:05:55.500 --> 00:05:57.530
of things on the developers'
behalf. So they don't have

98
00:05:57.530 --> 00:06:01.100
to worry about it. A
dapper takes that idea and

99
00:06:01.130 --> 00:06:05.720
takes it forward. So in
the, in the doctrine and

100
00:06:05.740 --> 00:06:09.730
the read me, it says
dapper codifies, the best practices

101
00:06:09.760 --> 00:06:12.970
for building microservice applications. But
then you said that it

102
00:06:13.120 --> 00:06:17.830
explicitly doesn't target Kubernetes or
prescribes. So it sounds like

103
00:06:17.830 --> 00:06:21.220
you're kind of walking the
Razor's edge between being prescriptive,

104
00:06:21.250 --> 00:06:24.940
but also being flexible. Is
that difficult to, to not

105
00:06:25.330 --> 00:06:27.280
like, hold it down and
say, this is exactly how

106
00:06:27.280 --> 00:06:31.660
you should do everything versus
the cafeteria plan. Not really.

107
00:06:31.660 --> 00:06:34.660
Cause I think one of
the benefits, first of dabbers,

108
00:06:34.660 --> 00:06:38.860
it's extremely extensible. So when
we say codified best practices,

109
00:06:39.220 --> 00:06:42.160
the best practice best practice
can depend on who the

110
00:06:42.160 --> 00:06:45.370
customer is, what the target
workload is, their requirements around

111
00:06:45.370 --> 00:06:50.710
the application, but you can
cautify best practices for classes.

112
00:06:51.040 --> 00:06:55.750
And if the codifications that
are built into dapper and

113
00:06:55.750 --> 00:06:58.150
the ones that come with
it, don't meet your needs.

114
00:06:58.180 --> 00:07:02.440
You can codify your own.
So take, for example, backoff

115
00:07:02.440 --> 00:07:05.710
and retry, when it comes
to interacting with another service,

116
00:07:06.520 --> 00:07:10.690
a there's best practices for
how you do back off

117
00:07:10.690 --> 00:07:14.020
and retries that as a
developer, you don't want to

118
00:07:14.020 --> 00:07:17.200
spend your time implementing that
in your code. And so

119
00:07:17.380 --> 00:07:21.370
that codification of those best
practices can be in dapper

120
00:07:21.370 --> 00:07:23.710
itself so that when you
call into dapper and say,

121
00:07:23.710 --> 00:07:26.830
I want to talk to
this remote service. Dapper is

122
00:07:26.830 --> 00:07:35.200
taking care of that complexity.
It's 2020, and why hasn't

123
00:07:35.200 --> 00:07:38.320
this stuff happened before? Like
I was joking, I was

124
00:07:38.320 --> 00:07:40.180
giving a talk recently and
I joked about how long

125
00:07:40.180 --> 00:07:42.010
my resume was. I said,
I got a three page

126
00:07:42.010 --> 00:07:44.710
resume to page two is
just learning to scale a

127
00:07:44.710 --> 00:07:47.740
web farm. And then, you
know, at some point page

128
00:07:47.770 --> 00:07:49.960
two of my resume got
ripped out because scaling a

129
00:07:49.960 --> 00:07:51.970
web form is pretty much
just a slider bar. Now,

130
00:07:52.090 --> 00:07:55.600
you know, like scaling out
is pretty much understood. It

131
00:07:55.600 --> 00:07:58.030
seems a little bit late
for us to be like

132
00:07:58.390 --> 00:08:00.220
saying, okay, can we all
just agree on how we

133
00:08:00.220 --> 00:08:01.810
manage secrets? Can we all
just agree on how we

134
00:08:01.810 --> 00:08:04.600
manage state? Is this just
a matter of like one

135
00:08:05.050 --> 00:08:09.460
additional standard? Well, I think
the various parts, So this

136
00:08:09.460 --> 00:08:14.500
have emerged in different runtimes
and program models already. I

137
00:08:14.500 --> 00:08:17.050
think what dapper brings to
the table is this sidecar

138
00:08:17.050 --> 00:08:21.460
pattern, the end with the
sidecar pattern and the focus

139
00:08:21.460 --> 00:08:26.830
on solving these distributed systems,
problems that come as part

140
00:08:26.830 --> 00:08:28.660
of the territory, when it
comes to cloud native development,

141
00:08:29.350 --> 00:08:35.140
it really is opening up
the door for a very

142
00:08:35.350 --> 00:08:39.880
flexible extensible runtime that hasn't
existed to this date. And

143
00:08:39.880 --> 00:08:41.830
once you start to look
at dapper, it seems like

144
00:08:42.730 --> 00:08:45.910
the obvious kind of stuff.
It's just that I think

145
00:08:46.900 --> 00:08:49.480
that when we looked at
the problems that we wanted

146
00:08:49.480 --> 00:08:54.280
to solve, that dapper emerged
as the solution to be

147
00:08:54.280 --> 00:08:57.570
able to solve them. And
that Sidecar concept, that sidecar

148
00:08:57.570 --> 00:08:59.820
architecture is really fundamental. This
isn't a thing like I

149
00:08:59.820 --> 00:09:02.580
had used the example of
a, of a, a cradle

150
00:09:02.580 --> 00:09:05.340
or a thing that is
a runtime that is holding

151
00:09:05.340 --> 00:09:08.220
your code. But your application
code is, is the motorcycle

152
00:09:08.220 --> 00:09:10.830
in this context and dapper
is the sidecar. It is

153
00:09:11.160 --> 00:09:13.980
lateral to your application. And
in doing that, it gives

154
00:09:13.980 --> 00:09:18.060
you full flexibility. It's not
prescribing it so much that

155
00:09:18.060 --> 00:09:22.970
it Smothers it with recommendations.
Yeah, exactly. And that's what

156
00:09:22.970 --> 00:09:25.850
really makes it so that
you can incrementally adopted or

157
00:09:25.850 --> 00:09:28.550
fully adopted depending on what
your needs are and what

158
00:09:28.550 --> 00:09:31.460
you want it to do
for you. So just one

159
00:09:31.460 --> 00:09:36.050
example on one side of
that spectrum, you can say,

160
00:09:36.050 --> 00:09:38.890
you know what I like
dappers actor model. And so

161
00:09:38.890 --> 00:09:41.870
I'm gonna use doc dapper
actor model SDK, which provides

162
00:09:41.870 --> 00:09:46.370
me language integration, convenience with
the dapper sidecar, where the

163
00:09:46.700 --> 00:09:51.710
actor interfaces are actually implemented.
And now I'm taking advantage

164
00:09:51.710 --> 00:09:58.070
of dapper for service discovery,
invocation messaging, state store, basically

165
00:09:58.610 --> 00:10:02.480
most of the underlying building
blocks or services that Tapper

166
00:10:02.570 --> 00:10:05.540
provides. On the other hand,
you could say, you know,

167
00:10:05.540 --> 00:10:07.970
what all I want to
do is use dapper to

168
00:10:08.000 --> 00:10:11.480
talk to a CAFCA service
because I don't want to

169
00:10:11.480 --> 00:10:13.730
worry about all the complexities
and integrating with the CAFCA

170
00:10:13.730 --> 00:10:15.620
STK. So I'm going to,
I'm going to do is

171
00:10:16.070 --> 00:10:21.590
talk HTTP to the CAFCA
sidecar and the CAFCA binding

172
00:10:21.650 --> 00:10:24.740
that it supports. And now
I'm taking advantage of the

173
00:10:24.740 --> 00:10:28.520
best practices that are built
into CAFCA finding, I don't

174
00:10:28.520 --> 00:10:33.680
need to include the CAFCA
SDK or the client libraries

175
00:10:33.680 --> 00:10:37.160
or code or get the
right SDK for my language,

176
00:10:37.550 --> 00:10:39.710
into my code. I can
just leverage it directly. And

177
00:10:40.100 --> 00:10:43.010
so if CAFCA only supports
it, doesn't have a rust

178
00:10:43.010 --> 00:10:45.710
SDK, for example, but I
want to write my component

179
00:10:45.710 --> 00:10:49.100
and rust. I can call
into the CAFCA sidecar, which

180
00:10:49.430 --> 00:10:52.250
talks to CAFCA for my
arrest codes In, in bringing

181
00:10:52.250 --> 00:10:55.250
the actor model into it.
Doesn't that kind of like

182
00:10:56.150 --> 00:10:58.460
that's a little bit more
main course than the other

183
00:10:58.460 --> 00:11:02.120
core concepts that are included.
Like something like, Oh, here's

184
00:11:02.120 --> 00:11:04.010
how we do secrets. And
here's how we manage service

185
00:11:04.010 --> 00:11:07.040
invocation seems of a certain
size. And then it's like

186
00:11:07.070 --> 00:11:12.140
actors that seems more, Well,
it is a little bit

187
00:11:12.140 --> 00:11:18.020
more prescriptive, but even there
dapper is flexible in its

188
00:11:18.140 --> 00:11:20.510
in what it provides from
an actor model perspective. But

189
00:11:20.510 --> 00:11:23.600
really where we started from,
it was saying serverless, what

190
00:11:23.600 --> 00:11:26.210
is serverless, what or what
it would make it easy

191
00:11:26.210 --> 00:11:28.700
for what makes it easy
for enterprise developers to write

192
00:11:28.700 --> 00:11:31.280
a cloud native distributed application.
And that's where we took

193
00:11:31.670 --> 00:11:33.560
a look at what was
out there and from our

194
00:11:33.560 --> 00:11:36.860
learnings, without your functions and
service, Robert reliable actors and

195
00:11:36.860 --> 00:11:38.810
talking to customers and seeing
what they were doing with

196
00:11:38.810 --> 00:11:42.230
it, recognizing that, like I
said, enterprise devs want to

197
00:11:42.230 --> 00:11:45.200
focus on their app, not
on all this, this complexities

198
00:11:45.200 --> 00:11:48.770
of distributed application and state
management, service discovery and invocation

199
00:11:48.770 --> 00:11:52.640
and triggers and back offs
and retries. We said, Hey,

200
00:11:53.590 --> 00:11:55.960
if we go with the
sidecar model, we can actually

201
00:11:56.290 --> 00:12:00.280
support a serverless of functions
as a service type programming

202
00:12:00.280 --> 00:12:02.920
model. If a developer wants
to use that, we can

203
00:12:02.920 --> 00:12:05.980
actually support with a little
bit of extra code, like

204
00:12:06.850 --> 00:12:10.630
keeping track of actor invocations
and doing the virtual actor,

205
00:12:11.200 --> 00:12:14.590
state hydration and dehydration that
we can build an actor

206
00:12:14.590 --> 00:12:16.360
model on top of it.
And really then at that

207
00:12:16.360 --> 00:12:21.190
point with functions, the basic
function support, and basic actor

208
00:12:21.190 --> 00:12:25.270
support with degrees of flexibility
for both of them, depending

209
00:12:25.270 --> 00:12:29.660
on what the developer wants.
Now we've got basically a

210
00:12:29.680 --> 00:12:35.830
holistic programming model platform that
supports stateless scale-out microservices, as

211
00:12:35.830 --> 00:12:39.900
well as stateful microservices. What
does it mean though, in

212
00:12:39.900 --> 00:12:42.390
the context of all the
other actor frameworks, whether it

213
00:12:42.390 --> 00:12:44.940
be Orleans or ACA and
et cetera, et cetera, like

214
00:12:44.940 --> 00:12:50.310
there's, there's coopertition and, and
certainly competition in these different

215
00:12:50.310 --> 00:12:53.730
things is this as prescriptive
as those other actor frame,

216
00:12:55.320 --> 00:12:57.930
It's not as prescriptive as
those other ones. For one

217
00:12:57.930 --> 00:13:06.390
thing, it separates the underlying
cluster or management from dapper

218
00:13:06.390 --> 00:13:09.300
dapper, doesn't provide that. What
it does is just keeps

219
00:13:09.300 --> 00:13:11.970
track of where actors are.
So it's got an actor

220
00:13:12.510 --> 00:13:16.470
service management service, but the
reason that it's less prescriptive

221
00:13:16.500 --> 00:13:21.270
is that for one, it
is language agnostic. And if

222
00:13:21.270 --> 00:13:23.460
you take a look at
the active models program models

223
00:13:23.460 --> 00:13:27.180
that are out there, they
typically are Java and C

224
00:13:27.180 --> 00:13:30.540
sharp. And that's it that
you could write an actor

225
00:13:30.540 --> 00:13:34.740
for dapper just using the
HTTP or GRPC interfaces in

226
00:13:34.740 --> 00:13:38.520
whatever language you want, including
like I mentioned, rust. And

227
00:13:38.820 --> 00:13:42.090
so it's less prescriptive in
that way. Like I said,

228
00:13:42.090 --> 00:13:45.150
you can have language SDKs
that make it easy for

229
00:13:45.150 --> 00:13:47.430
you to inherit from some
base class. So you don't

230
00:13:47.430 --> 00:13:51.360
have to implement that yourself
if you want to, but

231
00:13:51.360 --> 00:13:53.790
you don't have to. And
the second way it's less

232
00:13:53.790 --> 00:13:57.630
prescriptive is that we've got
built into it ways that

233
00:13:57.630 --> 00:13:59.940
you can control the concurrency
model on it. So if

234
00:13:59.940 --> 00:14:02.970
you say, well, if you
take a look at this,

235
00:14:03.060 --> 00:14:05.580
the reliable actors like service
rabbit collab, lacquers it had

236
00:14:05.580 --> 00:14:09.630
a strong concurrency model, which
most developers want, which is

237
00:14:09.630 --> 00:14:14.010
when you invoke my actor
on a method, that method

238
00:14:14.010 --> 00:14:17.610
should be serialized with respect
to invocations of that same

239
00:14:17.610 --> 00:14:20.070
method or any others that
are part of this actor

240
00:14:20.070 --> 00:14:23.970
class with dapper. You can
relax that and say, you

241
00:14:23.970 --> 00:14:26.250
know what, I want really
high performance. So I'm going

242
00:14:26.250 --> 00:14:30.660
to take care of synchronization
myself. I'm going to put

243
00:14:30.660 --> 00:14:34.740
locks into my code so
that I can create these

244
00:14:35.700 --> 00:14:40.110
critical sections that are only
necessary. That just to protect

245
00:14:40.110 --> 00:14:43.860
the state transitions that I've
got, but otherwise let things

246
00:14:43.860 --> 00:14:47.250
run in parallel. And so
it also is more flexible

247
00:14:47.250 --> 00:14:50.040
from that perspective. Hey friends,
you know how I love

248
00:14:50.040 --> 00:14:52.250
great podcasts, and I want
you to check out The

249
00:14:52.250 --> 00:14:56.030
code newbie podcast. It's all
about stories from folks on

250
00:14:56.030 --> 00:15:00.230
their coding journey. They talked
to new developers, experienced developers

251
00:15:00.230 --> 00:15:02.510
and everyone in between about
how they got started learning

252
00:15:02.510 --> 00:15:06.260
to code how they navigate
their technical careers. And they

253
00:15:06.260 --> 00:15:09.350
also do deep dives into
technical topics in a newbie

254
00:15:09.350 --> 00:15:14.240
friendly way, check out their
podcast at www dot COVID,

255
00:15:14.300 --> 00:15:23.030
newbie that's any w B
I e.org/podcast. That's code newbie.org/podcast.

256
00:15:23.360 --> 00:15:28.760
So you've pulled aside a
lot of implementation details like

257
00:15:28.790 --> 00:15:32.300
input, output bindings. You can
pick Kafka or AWS or

258
00:15:32.360 --> 00:15:35.840
GCP or whatever your state
store has been pulled aside.

259
00:15:35.840 --> 00:15:40.070
It's again, it's nondenominational in
its religious choices and your

260
00:15:40.070 --> 00:15:44.510
nondenominational in your publish and
subscribe. Can you maintain perf

261
00:15:44.600 --> 00:15:48.440
when you are so plugable
with some of the basic

262
00:15:48.440 --> 00:15:52.030
stuff? Yeah. Good question. So
I think this goes with

263
00:15:52.040 --> 00:15:56.360
it, the flexibility of dapper.
So with the standard bindings

264
00:15:56.360 --> 00:16:00.170
that we got, for example,
for CAFCA, if you decide

265
00:16:00.170 --> 00:16:03.800
that that binding doesn't provide
you sufficient perf you can

266
00:16:03.800 --> 00:16:06.050
write a different binding, nothing
stops you from running your

267
00:16:06.050 --> 00:16:09.680
own custom binding for that
service or any other service,

268
00:16:10.550 --> 00:16:13.760
but at the same time,
nothing stops you from directly

269
00:16:13.760 --> 00:16:17.270
using an SDK for a
service in your code. So

270
00:16:17.270 --> 00:16:19.460
if you don't want to
use dapper to talk to

271
00:16:19.460 --> 00:16:21.890
CAFCA, you can talk to
it directly, nothing gets in

272
00:16:21.890 --> 00:16:26.330
your way. It's just there
as the convenience layer. And

273
00:16:26.360 --> 00:16:28.400
one of the benefits of
it is once you have

274
00:16:28.940 --> 00:16:33.800
these bindings, the ecosystems contributing
to them, if you've want

275
00:16:33.800 --> 00:16:36.050
to improve them, you improve
them. And everybody takes advantage

276
00:16:36.050 --> 00:16:39.470
of them. And not only
that, but the binding that

277
00:16:39.470 --> 00:16:43.220
you write for CAFCA applies
to somebody writing a function

278
00:16:43.220 --> 00:16:45.260
on top of dapper or
somebody running an actor on

279
00:16:45.260 --> 00:16:48.050
top of the dapper or
somebody that just wants to

280
00:16:48.050 --> 00:16:52.520
talk to CAFCA directly from
their existing web app through

281
00:16:52.520 --> 00:16:55.250
using dapper. So it it's
this one place where you

282
00:16:55.250 --> 00:17:02.450
can concentrate and magnify people
doing innovation or PR providing

283
00:17:02.450 --> 00:17:06.260
improvements in performance or security.
So let me up-level and

284
00:17:06.260 --> 00:17:09.260
backup in time a little
bit, there was a time

285
00:17:09.380 --> 00:17:13.550
when we would talk about
chatty interfaces and chunky interfaces,

286
00:17:13.550 --> 00:17:16.460
and we would talk about
in-process calls and out of

287
00:17:16.460 --> 00:17:19.700
process calls. And then we
would ask ourselves, when does

288
00:17:19.700 --> 00:17:22.010
this thing hit the network?
So in process, out of

289
00:17:22.010 --> 00:17:26.180
process, out of, you know,
out of machine, and then

290
00:17:26.180 --> 00:17:28.550
now we're thinking about things
in terms of, have I

291
00:17:29.360 --> 00:17:32.510
swapped over to another pot?
If I swapped into another

292
00:17:32.870 --> 00:17:36.050
rack, am I suddenly now
talking to another data center?

293
00:17:37.040 --> 00:17:40.070
How often does does the
business logic person that we

294
00:17:40.070 --> 00:17:42.410
were trying to target here,
have to think about those

295
00:17:42.410 --> 00:17:44.600
things and like, Oh, I've
just hit the network. And

296
00:17:44.600 --> 00:17:49.040
now perf is gone all
the heck. So nothing can

297
00:17:50.190 --> 00:17:53.970
Take away the, the fact
that for many scenarios, you're

298
00:17:53.970 --> 00:17:57.540
going to be concerned and
have to worry about locality.

299
00:17:57.900 --> 00:17:59.910
Like you've just talked about
in the crossing of network

300
00:17:59.910 --> 00:18:03.900
interfaces, how many hops you're
taking again, the idea is

301
00:18:03.900 --> 00:18:06.570
dapper, doesn't get in the
way of you doing those

302
00:18:06.570 --> 00:18:13.290
optimizations. So when you place
your microservices, that is so

303
00:18:13.620 --> 00:18:15.390
dapper will take care of
it through the actor model.

304
00:18:15.420 --> 00:18:19.470
But, but other than that,
you've got control of it.

305
00:18:19.530 --> 00:18:22.440
So where your microservices get
placed. And so, you know,

306
00:18:22.470 --> 00:18:24.300
you can control how many
hops it's going in from

307
00:18:24.300 --> 00:18:29.850
where to where that is
a operational decision. And I

308
00:18:29.850 --> 00:18:32.490
think it's important to separate
that from the code that

309
00:18:32.490 --> 00:18:35.610
the developer writes. And one
of the, one of the

310
00:18:35.610 --> 00:18:38.760
reasons you see us talk
about dapper that runtime for

311
00:18:38.760 --> 00:18:42.270
the cloud and the edge
is we see a world

312
00:18:42.270 --> 00:18:45.630
emerging where you're going to
have apps that span the

313
00:18:45.630 --> 00:18:49.320
cloud and the edge. And
one of the benefits that

314
00:18:49.320 --> 00:18:52.230
the sidecar pattern gives you
what this local HTTP endpoint

315
00:18:52.260 --> 00:18:55.830
is that you can talk
to services and you don't

316
00:18:55.950 --> 00:18:58.620
from a developer in the
code that they write perspective.

317
00:18:58.770 --> 00:19:00.960
Don't have to worry about
where that service is. It

318
00:19:00.960 --> 00:19:04.140
could be sitting there if
I've got the microservice executing,

319
00:19:04.140 --> 00:19:07.020
hosted on the edge, and
it talks to the dapper

320
00:19:07.020 --> 00:19:09.540
sidecar and says, I want
to talk to this other

321
00:19:09.540 --> 00:19:14.460
microservice, dapper takes care of
the routing, and that could

322
00:19:14.460 --> 00:19:16.470
be sitting there on the
same server. It could be

323
00:19:16.470 --> 00:19:18.210
sitting on another server out
on the edge, or it

324
00:19:18.210 --> 00:19:21.030
could be up running in
the cloud and the code

325
00:19:21.030 --> 00:19:22.500
is going to work the
same. And so I can

326
00:19:22.500 --> 00:19:26.340
move these microservices around to
suit the latency and bandwidth

327
00:19:26.340 --> 00:19:31.200
and reliability requirements of my
application scenario. But that code

328
00:19:31.200 --> 00:19:34.880
doesn't have to change and
Forgive my ignorance, but it's

329
00:19:34.880 --> 00:19:37.400
worth pointing out to myself
and to the audience as

330
00:19:37.400 --> 00:19:40.640
well. That like, so the
dapper runtime is definitely multi-instance,

331
00:19:40.640 --> 00:19:44.270
it's not like it's a
central sidecar. There's these side

332
00:19:44.270 --> 00:19:46.070
cars can go all over
the place. They can live

333
00:19:46.130 --> 00:19:51.440
their multi-instance throughout your application.
That's right. So then you

334
00:19:51.440 --> 00:19:54.440
could have the dapper runtime
on the edge and maybe

335
00:19:54.440 --> 00:19:57.170
take a moment and explain
because everyone hears that term

336
00:19:57.170 --> 00:20:00.050
edge a lot, and it's
very overloaded, but explain what

337
00:20:00.050 --> 00:20:03.540
that means to have your
application exist and live on,

338
00:20:03.540 --> 00:20:06.800
on the edge. Yep. So
the edge, when you talk

339
00:20:06.800 --> 00:20:09.530
about the edge, you're talking
about relative to something in

340
00:20:09.530 --> 00:20:11.810
this case, we're talking about
the cloud public cloud. And

341
00:20:11.810 --> 00:20:15.620
so everybody I'm sure is
familiar with posting applications in

342
00:20:15.620 --> 00:20:18.440
the public cloud like Azure.
When you talking about the

343
00:20:18.440 --> 00:20:21.770
edge of the public cloud,
that means devices that are

344
00:20:21.770 --> 00:20:25.040
outside of the main Azure
data centers in this case.

345
00:20:25.040 --> 00:20:28.130
And so that could be
a Kubernetes cluster that's sitting

346
00:20:28.130 --> 00:20:30.560
in your own data center.
It could be in that

347
00:20:30.560 --> 00:20:33.830
case, it'd be hybrid rather
than technically edge. It could

348
00:20:33.830 --> 00:20:38.210
be a Kubernetes cluster sitting
in a building. That's a

349
00:20:38.210 --> 00:20:41.660
smart building where it's controlling
HVAC or lighting or conference

350
00:20:41.660 --> 00:20:45.890
centers, conference rooms. It could
be a server or a

351
00:20:45.890 --> 00:20:50.500
raspberry PI sitting in a
retail store. That would be

352
00:20:50.500 --> 00:20:55.120
all examples of edge computing.
And the, the reason that

353
00:20:55.120 --> 00:20:58.510
their edge is that they're
communicating with the cloud, they're

354
00:20:58.510 --> 00:21:02.620
getting typically control and deployed
and software deployed from the

355
00:21:02.620 --> 00:21:07.840
public cloud. There's different variations
on the typologies for how

356
00:21:07.840 --> 00:21:10.390
a device gets connected up
in the public cloud. There's

357
00:21:10.390 --> 00:21:16.510
also different kind of configurations
for how they're connected, whether

358
00:21:16.510 --> 00:21:22.570
they're directly connected, constantly connected,
occasionally collected or disconnected with

359
00:21:22.570 --> 00:21:27.460
some kind of air gap
play wave to get the

360
00:21:27.460 --> 00:21:31.270
code and the telemetry and
data back and forth between

361
00:21:31.270 --> 00:21:33.980
the cloud and the edge.
Yeah. I really liked the,

362
00:21:33.980 --> 00:21:37.020
the, the example of a,
like a grocery store. Like

363
00:21:37.020 --> 00:21:39.780
if I managed a big
grocery outlet and I'd have

364
00:21:39.780 --> 00:21:43.500
our central cloud, that was
maybe partially in our own

365
00:21:43.500 --> 00:21:46.710
data center, but largely in
a cloud like Azure. And

366
00:21:46.710 --> 00:21:49.710
then, you know, we don't
want to count on anything.

367
00:21:49.710 --> 00:21:51.930
We don't want to assume
anything. So we'll have our

368
00:21:51.930 --> 00:21:56.880
own Kubernetes cluster running in
the actual, you know, local

369
00:21:56.880 --> 00:21:59.160
grocery store. So that, that
of course the store could

370
00:21:59.160 --> 00:22:02.190
be offline for days even,
and still people would be

371
00:22:02.190 --> 00:22:04.140
able to buy a food,
batch, everything up, and then

372
00:22:04.140 --> 00:22:06.750
it would be sent off.
When we got back our

373
00:22:06.750 --> 00:22:10.710
connectivity to the, to the,
to the central location, it

374
00:22:10.710 --> 00:22:13.050
could phone home, like you
said, so occasionally connected or

375
00:22:13.050 --> 00:22:16.980
at least resiliently connected. And
then if you inject dapper

376
00:22:16.980 --> 00:22:21.180
into that, that sidecar would
run in any, and all

377
00:22:21.180 --> 00:22:23.910
of those locations providing all
the different services and core

378
00:22:23.910 --> 00:22:27.570
concepts that dapper offers, whether
it be in the self

379
00:22:27.570 --> 00:22:30.210
hosted cloud in the actual
public cloud or running on

380
00:22:30.210 --> 00:22:32.730
the edge, or even like
you said, in tiny devices

381
00:22:32.730 --> 00:22:36.870
themselves. And because if I
understand correctly, dapper just makes

382
00:22:36.870 --> 00:22:38.880
the assumption that as long
as your code can speak

383
00:22:38.910 --> 00:22:42.300
HTTP or HTP two, it
can do protocol buffer and

384
00:22:42.300 --> 00:22:46.620
coding because it's all HTTP
and GRPC, really anything could

385
00:22:46.620 --> 00:22:50.220
talk to them. Exactly. I
mean, that's, I think what's

386
00:22:50.220 --> 00:22:54.090
so powerful about this is
exactly that, that it's like

387
00:22:54.210 --> 00:22:57.210
when we've been talking about
really summarized, as dapper provides

388
00:22:57.210 --> 00:23:00.540
all of these building blocks,
you can compute compose all

389
00:23:00.540 --> 00:23:03.030
a cart, or you can
compose them in big chunks

390
00:23:03.030 --> 00:23:05.760
to get things like the
functions as a service model

391
00:23:05.760 --> 00:23:08.730
or that actor model. You
can consume them from any

392
00:23:08.730 --> 00:23:12.870
language, from any app, from
any existing code, because it's

393
00:23:12.990 --> 00:23:15.810
anything that knows how to
talk HTTP or GRPC can

394
00:23:15.810 --> 00:23:19.650
immediately take advantage of some
or all of it. Do

395
00:23:19.650 --> 00:23:23.920
you think that in some
theoretical future, you know, a

396
00:23:23.920 --> 00:23:27.480
year or two years down
the road, that if just

397
00:23:27.480 --> 00:23:31.770
like Apache and then followed
by engine X and then

398
00:23:31.770 --> 00:23:35.610
perhaps something else becomes so
ubiquitous that it becomes the

399
00:23:35.610 --> 00:23:38.220
fabric of the internet itself.
Like there was a day

400
00:23:38.220 --> 00:23:40.260
where Apache wasn't around and
poof and everything was running

401
00:23:40.260 --> 00:23:43.200
on Apache. And then within
a few years and X

402
00:23:43.200 --> 00:23:46.070
just took over and then
within a few Kubernetes is

403
00:23:46.070 --> 00:23:49.160
taking over. If we start
to Uplevel like that, would

404
00:23:49.160 --> 00:23:52.400
you see a programming language
or programming language to start

405
00:23:52.400 --> 00:23:56.180
to optimize for the sidecar
pattern to optimize the way

406
00:23:56.180 --> 00:24:00.830
that we express our, our
code and our intent for

407
00:24:01.190 --> 00:24:05.870
HDP, for GRPC, and then
for something like dapper itself,

408
00:24:05.900 --> 00:24:08.030
because if you're going to
roll your own, you're still

409
00:24:08.030 --> 00:24:12.170
going to be basically making
these, these, these HTTP calls

410
00:24:12.170 --> 00:24:14.360
yourself. And a lot of,
some of the languages are

411
00:24:14.360 --> 00:24:16.190
a little bit more chatty
than maybe they need to

412
00:24:16.190 --> 00:24:19.580
be. Could we hide a
lot of that and write

413
00:24:19.640 --> 00:24:24.110
a language itself that could
speak to a cloud native

414
00:24:24.380 --> 00:24:28.210
actor runtime? Yeah. I definitely
think that you're going to

415
00:24:28.210 --> 00:24:34.150
see language optimizations for talking
HTTP or GRPC. I think

416
00:24:34.840 --> 00:24:37.960
though that, and this is
one of the recognitions that

417
00:24:37.960 --> 00:24:41.200
we had looking at functions
as a service or actor

418
00:24:41.200 --> 00:24:43.240
models, where they only support
a subset of languages. And

419
00:24:43.240 --> 00:24:47.830
the fact is that language
is proliferating like crazy is

420
00:24:47.830 --> 00:24:50.350
that there's not going to
be one language. That's going

421
00:24:50.350 --> 00:24:51.850
to be the one to
rule them all, or even

422
00:24:51.850 --> 00:24:54.340
three or four. And with
the number that we have

423
00:24:54.340 --> 00:24:57.070
to support an Azure interesti
case continues to grow as

424
00:24:57.430 --> 00:25:01.450
new ones become popular. And
so, yeah, you're going to

425
00:25:01.450 --> 00:25:04.120
see those optimizations, but I
think there's not going to

426
00:25:04.120 --> 00:25:07.270
be a, Oh, this is
the programming language for distributed

427
00:25:08.050 --> 00:25:10.870
application development. It's, it's going
to be, everyone is going

428
00:25:10.870 --> 00:25:15.100
to end up with optimizations
and support for it. So

429
00:25:15.280 --> 00:25:18.370
The, the, the essence of
dapper is really nondenominational. The,

430
00:25:18.370 --> 00:25:22.750
the SDKs now have go
Java, javascript.net Python. The developers

431
00:25:22.750 --> 00:25:26.590
never really have to deal
with GRPC and HTTP. So

432
00:25:26.590 --> 00:25:29.620
the SDK largely handles a
lot of those abstractions. So

433
00:25:29.620 --> 00:25:33.340
while there might be some
potential future language that is

434
00:25:33.370 --> 00:25:36.010
optimized for something like dapper,
there's really no need to

435
00:25:36.010 --> 00:25:41.530
do That's right. And I
think that the fact is

436
00:25:41.530 --> 00:25:44.650
like, we've just said that
there's some language convenience, STKs

437
00:25:44.650 --> 00:25:48.820
for dapper, but a new
language comes out the Scott

438
00:25:48.820 --> 00:25:53.080
Hanselman language that you develop.
That's, that's great and optimized

439
00:25:53.080 --> 00:25:57.490
for web development, that, that
you can immediately start integrate

440
00:25:57.490 --> 00:26:00.130
that with dapper because you
don't need on SDK for

441
00:26:00.130 --> 00:26:02.800
it, for dapper to integrate
your language with it. One

442
00:26:02.800 --> 00:26:05.290
of the things that I've
been finding, the larger my

443
00:26:05.290 --> 00:26:07.210
systems get, and the larger
that the systems that I

444
00:26:07.210 --> 00:26:10.150
consult on get is, you
know, it's still just text

445
00:26:10.150 --> 00:26:12.400
files, except now there's a
thousand of them. And I

446
00:26:12.400 --> 00:26:14.500
have to bring all of
those together. You know, I

447
00:26:14.500 --> 00:26:16.390
kind of felt like I'd
have a jet pack right

448
00:26:16.390 --> 00:26:18.730
now, a self driving car.
And I wouldn't be rejecting

449
00:26:18.730 --> 00:26:23.110
through tra through text files,
but the distributed tracing is

450
00:26:23.110 --> 00:26:25.930
a big part of dapper
and it integrates with open

451
00:26:25.930 --> 00:26:27.520
telemetry. And maybe you could
speak about that for a

452
00:26:27.520 --> 00:26:30.640
second. Yeah. So I think
because dapper sitting there at

453
00:26:30.640 --> 00:26:34.360
a sidecar and it's, once
you start integrating with it,

454
00:26:34.360 --> 00:26:38.830
your application traffic is going
through dapper copper has this

455
00:26:38.830 --> 00:26:42.850
great position to be able
to log activity for you

456
00:26:42.850 --> 00:26:44.850
and you to get a
distributed view of the way

457
00:26:44.850 --> 00:26:48.090
your application works. Some people
that are listening probably are

458
00:26:48.090 --> 00:26:51.060
familiar with service meshes and
service meshes are the same

459
00:26:51.060 --> 00:26:54.630
thing, but at the infrastructure
layer, what dapper you can

460
00:26:54.630 --> 00:26:58.110
think of as an application
layer service mesh, and just

461
00:26:58.110 --> 00:27:01.800
like infrastructure service message that
can log network traffic and

462
00:27:01.800 --> 00:27:05.700
impose policy dapper provides that
same kind of control point

463
00:27:05.700 --> 00:27:11.910
for application level inner serve,
microservice communication. And one of

464
00:27:11.910 --> 00:27:15.240
the ones that components that
we built off the bat

465
00:27:15.240 --> 00:27:18.600
to take advantage of that
is the distributed tracing building

466
00:27:18.600 --> 00:27:22.410
block. And once you opt
into that, that it's collecting

467
00:27:22.410 --> 00:27:29.130
and admitting that dapper traces
of a microservice interactions and

468
00:27:29.130 --> 00:27:31.950
the open telemetry format. And
we've got, I think, seven,

469
00:27:32.040 --> 00:27:36.090
there might even be more
than that different tracing systems

470
00:27:36.090 --> 00:27:40.560
that now are plugged into
dapper. So Azure monitor is

471
00:27:40.560 --> 00:27:43.500
one example or application insights.
And so now you can

472
00:27:43.950 --> 00:27:47.280
just by flipping a switch,
have this data admitted and

473
00:27:47.280 --> 00:27:52.290
then viewed in an application
insights and see the execution

474
00:27:52.290 --> 00:27:55.350
of your microservices, how they're
talking to each other, where

475
00:27:55.350 --> 00:27:59.190
there's latency, where there's failures,
all of that basically comes

476
00:27:59.190 --> 00:28:03.980
for free just by using
dapper. Yeah. There's a there's

477
00:28:03.980 --> 00:28:07.130
Azure monitor. There's Datadog who
has been a sponsor of

478
00:28:07.130 --> 00:28:10.160
the show before and Jaeger
and signal if I'm going

479
00:28:10.160 --> 00:28:12.890
on and on and on.
So basically all comers. And

480
00:28:12.890 --> 00:28:16.130
again, if there's not one,
as you've said before, you

481
00:28:16.130 --> 00:28:18.590
can, you can plug it.
Yeah. And I, you know,

482
00:28:18.590 --> 00:28:23.060
when I think about, okay,
so what would stop dapper

483
00:28:23.060 --> 00:28:26.270
from somebody from wanting to
use dapper? I really am

484
00:28:26.270 --> 00:28:29.330
struggle with a reason because
all the kinds of excuses

485
00:28:29.330 --> 00:28:33.470
that we've seen for, why
can't you adopt functions as

486
00:28:33.470 --> 00:28:37.850
a service? Why can't you
adopt at the actor model?

487
00:28:37.880 --> 00:28:42.710
Why can't you adopt some
special purpose runtime, that's providing

488
00:28:42.710 --> 00:28:45.860
something, all of those reasons
why you might not be

489
00:28:45.860 --> 00:28:48.680
able to adopt something are
gone and the benefits of

490
00:28:48.680 --> 00:28:52.910
taking advantage of this open
ecosystem flexibility, and the portability

491
00:28:53.480 --> 00:28:56.150
are all there as part
of the value proposition. So

492
00:28:56.150 --> 00:28:58.250
it seems like a no
brainer to me. I mean,

493
00:28:58.370 --> 00:29:01.880
I struggle with the why
wouldn't I use dapper? Well,

494
00:29:01.880 --> 00:29:04.010
what if you did, what,
if you are starting to

495
00:29:04.010 --> 00:29:07.130
feel like things are getting
so broken apart, that it's

496
00:29:07.130 --> 00:29:09.020
time to go back to
the big ball, but you

497
00:29:09.020 --> 00:29:11.150
know, a big ball of
mud, a monolith, like, are

498
00:29:11.150 --> 00:29:14.900
there any challenges in this
ecosystem of all these open

499
00:29:14.900 --> 00:29:17.450
source projects and everything's moving
so fast and everything's being

500
00:29:17.480 --> 00:29:19.760
versioned so fast, have you
had any challenges? Has your

501
00:29:19.760 --> 00:29:22.520
team had any challenges in
putting this together where you

502
00:29:22.520 --> 00:29:25.730
found something was not as
robust as it should have

503
00:29:25.730 --> 00:29:28.580
been, or maybe you bet
too much on this or

504
00:29:28.580 --> 00:29:32.510
that, or GRPC is not
able to keep perfectly to

505
00:29:32.510 --> 00:29:33.690
the point that you want
it to be? What are

506
00:29:33.710 --> 00:29:36.530
some things that aren't a
slam dunk in all of

507
00:29:36.530 --> 00:29:44.560
this microservices architecture? I think
that, so for one building

508
00:29:44.560 --> 00:29:49.480
on industry standards, I think
means that we can ride

509
00:29:49.480 --> 00:29:55.150
the industry, the ecosystems innovations
around things like GRPC or

510
00:29:55.150 --> 00:30:00.100
HTTP for that matter and
HTTP servers. So for as

511
00:30:00.100 --> 00:30:02.680
far as reasons, you might
not be able to want

512
00:30:02.680 --> 00:30:04.510
to use Dopper. We talked
about, touched on them a

513
00:30:04.510 --> 00:30:09.940
little bit earlier when we
talked about performance, where I

514
00:30:09.940 --> 00:30:13.210
want some, I want performance,
for example, I want to

515
00:30:13.210 --> 00:30:18.190
pack microservices, many of them
into the same process and

516
00:30:18.190 --> 00:30:23.170
the opera doesn't support that
today. Or I want no

517
00:30:23.350 --> 00:30:27.040
hop across an HTTP or
GRPC interface to get out

518
00:30:27.040 --> 00:30:31.150
to the network. I want
to access it directly. That

519
00:30:31.150 --> 00:30:35.950
might be another reason. So
there are potentially some cases

520
00:30:35.950 --> 00:30:37.810
where you might not want
to, but even in those

521
00:30:38.290 --> 00:30:40.360
scenarios where you got an
application that needs to have

522
00:30:40.360 --> 00:30:42.880
some optimized path through it,
it's most likely that there's

523
00:30:43.090 --> 00:30:48.400
many other paths, many other
services that it using dapper

524
00:30:48.400 --> 00:30:54.070
is just fine. So again,
this ability to take advantage

525
00:30:54.070 --> 00:30:56.230
of it in part or
in whole or whatever pieces

526
00:30:56.230 --> 00:31:00.580
of it you want actually
makes it, so that saying

527
00:31:01.030 --> 00:31:04.570
dapper is not good enough.
Again, I don't think as

528
00:31:04.570 --> 00:31:07.720
a blanket statement that I'd
ever can imagine somebody saying,

529
00:31:07.750 --> 00:31:10.000
because it might not be
good enough for this one

530
00:31:10.000 --> 00:31:13.600
particular aspect of my app,
but there's many others that

531
00:31:13.750 --> 00:31:17.610
I'm sure it would be.
Well, it seems like that,

532
00:31:17.760 --> 00:31:21.840
you know, HTTP and GRPC
and their concept of restful

533
00:31:21.840 --> 00:31:25.170
API is I know microservices
and Kubernetes and all the

534
00:31:25.170 --> 00:31:29.040
different supporting things that would
be required to make something

535
00:31:29.040 --> 00:31:34.680
like dapper and, and you,
the listeners application successful, you

536
00:31:34.680 --> 00:31:37.050
know, the time has come
in in the right. It

537
00:31:37.050 --> 00:31:39.600
is the right amount of
maturity and that people should

538
00:31:39.600 --> 00:31:42.480
really explore these architecture. Right?
I think that this is

539
00:31:42.480 --> 00:31:45.030
kind of the next step
on the evolution of cloud

540
00:31:45.030 --> 00:31:48.030
native building on all of
the fundamental work that has

541
00:31:48.030 --> 00:31:51.990
been developed over the last
five to 10 years. And

542
00:31:52.140 --> 00:31:53.740
we're going to see more
on, on top of that.

543
00:31:53.770 --> 00:31:55.590
I'm sure Napa is not
the end of the story,

544
00:31:55.590 --> 00:31:59.010
but it's, I think a
fantastic new level that it's

545
00:31:59.010 --> 00:32:00.960
going to a productivity that
developers are going to get

546
00:32:00.960 --> 00:32:06.960
to with it. Well, folks
can check out dapper@dapr.io. You

547
00:32:06.960 --> 00:32:09.810
can install the CLI on
windows, Mac, or Linux, check

548
00:32:09.810 --> 00:32:13.530
it all out. There's extensive
documentation. There is a burgeoning

549
00:32:13.530 --> 00:32:15.960
and excited community and a
ton of things that you

550
00:32:15.960 --> 00:32:18.450
can plug into it. And
again, it's a cafeteria plan,

551
00:32:18.450 --> 00:32:20.550
so certainly you don't need
to do it all. You

552
00:32:20.550 --> 00:32:22.770
can just take the pieces
that you want. Follow it

553
00:32:22.770 --> 00:32:25.920
on Twitter. I'll put links
to the Gitter community chat

554
00:32:26.310 --> 00:32:29.910
and it's actively being developed.
So poll requests are welcome.

555
00:32:30.450 --> 00:32:33.300
Thank you, Mark Russinovich for
chatting with me today. Hope

556
00:32:33.300 --> 00:32:36.510
I made you a diaper
form. I will go and

557
00:32:36.510 --> 00:32:38.370
check it out immediately and
try to build it out

558
00:32:38.370 --> 00:32:40.640
in my own machine and
see what the kind of

559
00:32:40.640 --> 00:32:43.610
solutions that I can build
with dapper. This has been

560
00:32:43.610 --> 00:32:46.400
another episode of Hansel minutes,
and we'll see you again.

561
00:32:47.200 --> 00:32:58.300
<inaudible>.


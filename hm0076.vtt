WEBVTT FILE

1
00:00:11.990 --> 00:00:17.300
From Hanselman it's dot com.
It's Hansel minutes, a weekly

2
00:00:17.300 --> 00:00:21.560
discussion with web developer and
technologist Scott Hanselman hosted by

3
00:00:21.560 --> 00:00:27.410
Carl Franklin. This is Lawrence Ryan announcing
show number 76. Recorded Friday,

4
00:00:27.410 --> 00:00:34.400
July 27th, 2007. Support for Hanselman it's
as provided by Tellerik already

5
00:00:34.400 --> 00:00:38.540
controls the most comprehensive suite
of components for windows forms

6
00:00:38.540 --> 00:00:51.710
and asp.net web applications. online@wwwdottelerikdotcomandby.net
developers journal, the world's leading

7
00:00:51.710 --> 00:00:57.770
dotnet developer magazine online at
www dot <inaudible> dot com.

8
00:00:58.970 --> 00:01:02.270
In this episode, Scott talks
about F sharp with Robert

9
00:01:02.300 --> 00:01:10.730
Pickering. Hi, this is Scott
Hanselman, and this is another

10
00:01:10.730 --> 00:01:13.640
episode of Hansel minutes, and
we are fortunate enough to

11
00:01:13.640 --> 00:01:17.120
be sitting down today with
Robert Pickering, the author of

12
00:01:17.120 --> 00:01:20.750
the foundations of F sharp
book. And I'm in Portland.

13
00:01:20.780 --> 00:01:24.530
Robert, you are aware right
now I'm in Sandra Manoli

14
00:01:25.010 --> 00:01:29.540
Paris, France. Oh, wow. Well,
Robert, I really appreciate you

15
00:01:29.540 --> 00:01:32.390
coming on the show. I,
I had mentioned F sharp

16
00:01:32.390 --> 00:01:35.420
in your book on a,
on a recent show and

17
00:01:35.420 --> 00:01:37.730
you emailed me and said,
thanks for the mention. And

18
00:01:37.730 --> 00:01:40.520
I was just thrilled to
hear from you to be

19
00:01:40.520 --> 00:01:41.750
able to get you to
come on and talk about

20
00:01:41.780 --> 00:01:46.100
I'm about 280 pages through
the book. Haven't quite made

21
00:01:46.100 --> 00:01:48.950
it to the very, very
end, but I'm enjoying it.

22
00:01:49.340 --> 00:01:53.240
If you could share with
the, with the, the listeners,

23
00:01:54.050 --> 00:02:00.890
why F sharp to start.
Okay. Well, it's, it's a

24
00:02:00.890 --> 00:02:06.200
very interesting question because that
shops a general purpose programming

25
00:02:06.200 --> 00:02:11.180
language. So in a sense,
it is kind of competing

26
00:02:11.180 --> 00:02:14.540
against the, the she shops
and the vb.net. So this

27
00:02:14.540 --> 00:02:20.960
world, which might seem a
bit kind of crazy given

28
00:02:20.960 --> 00:02:23.960
the small number of people
that use it. But I

29
00:02:23.960 --> 00:02:27.650
think the.net platform has sort
of gives us is a

30
00:02:27.650 --> 00:02:30.410
bit of a lever in
that way. And the, any

31
00:02:30.410 --> 00:02:33.440
library written in C sharp,
you can also use some

32
00:02:33.440 --> 00:02:39.500
dotnet. So it gives you
a lot more broader scope.

33
00:02:40.100 --> 00:02:42.740
Now, do you think that
it's going to get a

34
00:02:42.740 --> 00:02:46.310
bad rap because it's a
functional programming language? I mean,

35
00:02:46.310 --> 00:02:48.680
I know it's not a
pure functional language, like maybe

36
00:02:48.680 --> 00:02:51.350
a Haskell, is that, would
that be a fair statement?

37
00:02:52.940 --> 00:02:56.570
I think some people might
perceive it that way, but

38
00:02:58.130 --> 00:03:02.680
I think a lot More
people are taking an interest

39
00:03:02.710 --> 00:03:07.420
in functional programming. Cause a
lot of the features that

40
00:03:07.420 --> 00:03:10.150
are being introduced to C-sharp
the next version of C-sharp

41
00:03:11.950 --> 00:03:17.320
are, are ideas taken from
functional programming? Like I know

42
00:03:17.770 --> 00:03:22.360
generics was, is very popular,
was a very popular feature

43
00:03:22.360 --> 00:03:26.590
in the framework 2.0, and
that's an idealized lifted from

44
00:03:26.620 --> 00:03:29.440
a functional programming. I know
it sort of also looks

45
00:03:29.440 --> 00:03:33.040
a bit like C plus
plus templates, but I think

46
00:03:33.040 --> 00:03:35.470
the idea of type premise
hesitation very much comes from

47
00:03:35.470 --> 00:03:38.140
functional programming. So I think
that sort of thing is

48
00:03:38.140 --> 00:03:42.490
sort of making people sit
up and say, Hey, we

49
00:03:42.490 --> 00:03:44.890
should maybe take a close
look at this functional programming.

50
00:03:46.300 --> 00:03:49.510
I think that's one of
the, the aims of the

51
00:03:49.780 --> 00:03:55.270
shop project is to let
people that maybe, maybe haven't

52
00:03:55.270 --> 00:03:59.350
had so much exposure to
functional programming on a pro

53
00:03:59.350 --> 00:04:02.350
Morenci sharp, and just give
them some exposure to that.

54
00:04:02.860 --> 00:04:05.890
And also to try and
drawing some people that have

55
00:04:05.890 --> 00:04:09.250
maybe done some folk pro
man, Oh, camel or scale

56
00:04:09.250 --> 00:04:12.250
or language just like that.
And maybe wouldn't have otherwise

57
00:04:12.250 --> 00:04:18.790
thought of looking@thedotnetframeworkandlettingthemlookatthe.net framework and
seeing you see what a

58
00:04:18.790 --> 00:04:23.490
nice environment Would you say
that that F sharp is,

59
00:04:23.490 --> 00:04:26.340
is an, is an actual
functional primary language like Oak

60
00:04:26.340 --> 00:04:30.080
Kamler Haskell, or is it
like more FP, like, like

61
00:04:30.080 --> 00:04:34.590
lists, let's say How much
of functional programming language like,

62
00:04:34.950 --> 00:04:40.350
Oh, come on. I mean,
D I do have I've

63
00:04:40.350 --> 00:04:44.290
shopped started out to do,
being, to do and overcome

64
00:04:44.600 --> 00:04:49.350
light language on the.net framework.
And I mean, it still

65
00:04:49.350 --> 00:04:53.190
is very much like come,
but is, is also joined

66
00:04:53.190 --> 00:04:56.150
influences from other languages, like
less than half scale and

67
00:04:56.470 --> 00:04:59.700
even C sharp in some
ways, because the object system

68
00:04:59.700 --> 00:05:01.950
it uses is very much
like the a C sharp

69
00:05:01.950 --> 00:05:05.280
object system. Can you help
me put my finger and

70
00:05:05.280 --> 00:05:07.830
maybe the listeners finger on
what it means to be

71
00:05:07.830 --> 00:05:10.500
a functional programming language? I
don't think everyone who is

72
00:05:10.500 --> 00:05:14.370
listening necessarily went to university
or paid attention in the

73
00:05:14.370 --> 00:05:17.400
functional programming portion of university.
And would it be useful

74
00:05:17.400 --> 00:05:20.580
to understand, at least from
your perspective, what is the

75
00:05:20.580 --> 00:05:23.970
definition? When is the language
become a functional programming language?

76
00:05:23.970 --> 00:05:26.250
Is it about the statelessness
and if so, what does

77
00:05:26.250 --> 00:05:31.590
that mean? Okay. We'll tend
to focus on the statelessness

78
00:05:31.620 --> 00:05:35.400
of the functional pro languages
and in a pure sense

79
00:05:35.400 --> 00:05:38.010
that, I guess that is
what, when people say functional

80
00:05:38.010 --> 00:05:41.250
program language, that they really
mean something that is stainless.

81
00:05:41.850 --> 00:05:46.800
And I guess that really
means that a function has

82
00:05:47.070 --> 00:05:52.440
takes its parameters. It's transforms
those premises into new values

83
00:05:52.470 --> 00:05:55.650
and returns those values. So
it doesn't have any side

84
00:05:55.650 --> 00:06:01.640
effects. It doesn't alter global,
it's not returning the variables

85
00:06:02.600 --> 00:06:06.950
that the parameters it's taken
altered, it's taken a fresh

86
00:06:06.950 --> 00:06:10.670
copy of those premises. So
everything's done in a read

87
00:06:10.670 --> 00:06:16.310
only stateless manner. But for
me, I don't think that's

88
00:06:17.240 --> 00:06:20.320
the, the really important aspect
of the language. I think

89
00:06:20.320 --> 00:06:23.050
perhaps one of the most
important ones aspects of Ash

90
00:06:23.110 --> 00:06:31.180
shop is that, well, there's
two actually, there's that? Oh,

91
00:06:31.960 --> 00:06:34.600
all right. These are all
functions in the language are

92
00:06:34.600 --> 00:06:39.700
also values. So that means
that you can pass a

93
00:06:39.700 --> 00:06:45.220
function to another function, has
a parameter. And I mean,

94
00:06:45.220 --> 00:06:49.390
that doesn't sound incredibly interesting
in itself, but it does

95
00:06:50.170 --> 00:06:52.150
mean that you can do
some really nice things in

96
00:06:52.150 --> 00:06:56.740
terms of abstracting fro control
or unrefined from your code

97
00:06:56.740 --> 00:07:01.300
to be a lot tighter
and more concise by obstructing

98
00:07:01.310 --> 00:07:05.380
flow control. I mean, doing
things like, say, say you

99
00:07:05.380 --> 00:07:09.490
have a list of values,
you can write a generic

100
00:07:09.490 --> 00:07:12.490
function called a map to
transform that, that list of

101
00:07:12.490 --> 00:07:18.040
values into another set of
values. So rather than having

102
00:07:18.040 --> 00:07:20.260
to write a, say, a
four loop over the list,

103
00:07:20.740 --> 00:07:25.780
and the other idea is
that the, the language is

104
00:07:25.870 --> 00:07:29.530
a bit more value on
the interfaces in, and a

105
00:07:29.530 --> 00:07:36.070
language like C-sharp, everything's a
statement. So it's, everything is

106
00:07:36.070 --> 00:07:39.430
kind of a list of
instructions. Whereas an NAF shop,

107
00:07:39.460 --> 00:07:42.850
everything is a value. So
for example, in our shop,

108
00:07:44.530 --> 00:07:50.320
and if statements returns a
value, yeah, it doesn't sound

109
00:07:50.920 --> 00:07:53.260
on a major thing, but
once there's a couple of

110
00:07:53.260 --> 00:07:56.320
things, it was quite nice
about that. So, you know,

111
00:07:56.320 --> 00:07:59.380
I only see shop say
quite often, you want to

112
00:08:02.500 --> 00:08:07.150
creates a warm value, say
initialize the string to be

113
00:08:07.150 --> 00:08:09.700
one value or another value
based on, let's say a

114
00:08:09.700 --> 00:08:12.370
set Boolean, and you can
use an if statement to

115
00:08:12.370 --> 00:08:15.010
do that in C sharp,
of course, but in C

116
00:08:15.010 --> 00:08:19.660
sharp, you have to sort
of declare your value before

117
00:08:19.660 --> 00:08:23.380
the, if statements and then
satisfy any, either side of

118
00:08:23.380 --> 00:08:26.080
the statement. And you've got
no real guarantees that, that

119
00:08:26.080 --> 00:08:29.080
that's happened by the compiler.
Whereas in a shop, you

120
00:08:29.080 --> 00:08:32.020
can just say your value
equals and then have your

121
00:08:32.290 --> 00:08:36.850
statements. And the compiler will
check that each side of

122
00:08:36.850 --> 00:08:40.800
the expression evaluates to a
string and is assigned to,

123
00:08:40.800 --> 00:08:46.150
to the, the value, the
identifier. Are there ways, I

124
00:08:46.150 --> 00:08:47.860
mean, as you're saying this,
I'm trying to put it

125
00:08:47.860 --> 00:08:49.990
into the context of C-sharp,
which is kind of the

126
00:08:49.990 --> 00:08:53.560
language that so far in
my life is spoken by

127
00:08:53.560 --> 00:08:57.240
my own DNA finds their
language. It sounds like you

128
00:08:57.240 --> 00:08:59.460
found F sharp as the
one that spoke to you.

129
00:08:59.940 --> 00:09:01.950
Yeah. And I'm always looking
at other languages trying to

130
00:09:01.950 --> 00:09:04.230
see if maybe this'll be
this next language will be

131
00:09:04.230 --> 00:09:06.840
the one that speaks to
me. So as I try

132
00:09:06.840 --> 00:09:09.840
to get my brain around
F sharp, I asked, I

133
00:09:09.840 --> 00:09:12.930
am asking myself, well, you
said functions are values. All

134
00:09:12.930 --> 00:09:16.620
values are functions. I mean,
how was that different from

135
00:09:16.620 --> 00:09:21.090
being able to pass functions
around just delegates and function

136
00:09:21.090 --> 00:09:24.920
pointers and things like that?
Well, it's, it's incredibly similar

137
00:09:24.920 --> 00:09:28.580
to a delegates. Actually. It's
just a bit of more

138
00:09:28.580 --> 00:09:33.560
of a generic mechanism. I
think a generic, I think

139
00:09:33.560 --> 00:09:37.760
delegates are incredibly useful, but
they've sort of got this

140
00:09:37.760 --> 00:09:41.300
limitation that each time you
want to use a delicate,

141
00:09:41.300 --> 00:09:43.820
you have to go and
define it and you get

142
00:09:43.820 --> 00:09:48.320
this kind of annoying things
where you can get two

143
00:09:48.620 --> 00:09:51.410
delicates with exactly the same
with signature, but they're not

144
00:09:51.680 --> 00:10:00.800
quite equal. So you, you
end up defining, could end

145
00:10:00.800 --> 00:10:04.820
up defining the same. Delicates
in several places that has

146
00:10:04.820 --> 00:10:09.080
the same signature. It was
definitely a lot of prep

147
00:10:09.080 --> 00:10:12.290
work. I know that I
never use delegates without thinking

148
00:10:12.290 --> 00:10:13.970
about it ahead of time.
I always have to go

149
00:10:13.970 --> 00:10:17.570
off and prepare the program
for this delegate. That's coming

150
00:10:17.570 --> 00:10:19.910
along. Now that changes a
little bit with anonymous delegates,

151
00:10:19.940 --> 00:10:23.120
but I get the impression
that in F sharp, you

152
00:10:23.120 --> 00:10:27.650
don't give, throwing a function
around any thoughts. Yes. That's

153
00:10:27.650 --> 00:10:33.230
the sort of, that's the
idea that you can do

154
00:10:33.230 --> 00:10:36.350
exactly that and it, it,
it does end up making

155
00:10:36.350 --> 00:10:41.240
your life easier and that
you can get quite why

156
00:10:41.240 --> 00:10:43.670
I find when I'm coding
and quite often getting situations

157
00:10:43.670 --> 00:10:48.670
where you've got two functions
that are very similar, but

158
00:10:49.540 --> 00:10:51.530
maybe there's a bit at
the beginning. That's similar than

159
00:10:51.530 --> 00:10:53.180
a bit at the end.
That's similar. And then there's

160
00:10:53.180 --> 00:10:55.670
a small section in the
middle of that, that changes

161
00:10:57.110 --> 00:11:01.970
now in C-sharp, that's a
little bit difficult to reflux

162
00:11:01.970 --> 00:11:03.950
her into the same function
because you end up having

163
00:11:03.950 --> 00:11:07.250
to put an F statement
in the middle to do

164
00:11:07.250 --> 00:11:11.120
the two different things. Whereas
in app shop, you could

165
00:11:11.120 --> 00:11:14.060
just make the two the
same function and have the

166
00:11:14.060 --> 00:11:19.250
middle bits as a parameter.
I saw somebody blogging about

167
00:11:19.250 --> 00:11:22.040
this recently, call it this,
or what do they call

168
00:11:22.040 --> 00:11:26.510
it? The hole in the
middle pattern. So how does

169
00:11:26.510 --> 00:11:30.020
this relate to this concept
of Curry to functions or

170
00:11:30.020 --> 00:11:40.040
partial functions? Well, the idea
of code functions is, in

171
00:11:40.040 --> 00:11:43.910
my opinion, it's kind of
an I Stacey feature in,

172
00:11:43.920 --> 00:11:50.420
in, in functional languages. It
relates to the, the all

173
00:11:50.420 --> 00:11:54.220
values being functions in that
if you, what credit function

174
00:11:54.220 --> 00:11:57.400
is, if you don't pass
a function, all of its

175
00:11:57.400 --> 00:12:01.780
premises at once, it will
return a function. That's kind

176
00:12:01.780 --> 00:12:04.870
of waiting for its final
parameter. And that can be

177
00:12:05.350 --> 00:12:08.620
quite useful in some situations,
but it's not sort of

178
00:12:10.600 --> 00:12:14.470
my favorite feature. And it,
it, it does put a

179
00:12:14.470 --> 00:12:17.290
few people off, I think,
just because it can seem

180
00:12:17.290 --> 00:12:21.510
to, to add a bit
of extra complexity. Whereas One

181
00:12:21.510 --> 00:12:24.270
of the things that I
thought was interesting if I'm

182
00:12:24.270 --> 00:12:28.350
understanding this correctly, is that
the control flow concepts in

183
00:12:28.350 --> 00:12:32.370
F sharper are very strong.
You can't have an F

184
00:12:32.370 --> 00:12:34.950
without analysis. Is that true?
Yeah, that's a sort of

185
00:12:34.950 --> 00:12:37.860
going back to what I
was talking about earlier is,

186
00:12:39.000 --> 00:12:41.430
I mean, you can have
an a, an F without

187
00:12:41.430 --> 00:12:45.060
an hour, but the compiler
will check that your F

188
00:12:45.060 --> 00:12:49.230
statements evaluates to B units,
which is after shop's version

189
00:12:49.230 --> 00:12:52.680
of voids. So, so is
it is something with a

190
00:12:52.680 --> 00:12:56.370
side effects. Whereas if you
have an ALS, it will

191
00:12:56.370 --> 00:12:59.790
make sure that both sides
of the Ellis clause evaluates

192
00:12:59.790 --> 00:13:04.080
to be the same thing,
which is quite it's, it's

193
00:13:04.080 --> 00:13:07.620
very useful for catching errors.
When you make small mistakes

194
00:13:07.650 --> 00:13:13.740
in, in an F if
then else statement and L

195
00:13:13.750 --> 00:13:16.980
statement, then the compiler can
type, check that for you,

196
00:13:17.610 --> 00:13:19.680
which is just something you
don't get in C sharp.

197
00:13:20.460 --> 00:13:22.440
So in that case, then
the, if then else kind

198
00:13:22.440 --> 00:13:25.590
of construct is itself an
you know, it's an expression,

199
00:13:25.590 --> 00:13:28.980
it's a, It's a value
it's by now Evaluates to

200
00:13:28.980 --> 00:13:31.860
a value. And that value
must have one type. Yeah,

201
00:13:32.130 --> 00:13:35.130
exactly. So then F sharp
is a strongly typed language.

202
00:13:35.490 --> 00:13:38.940
It's very much strongly typed
language, but I think one

203
00:13:38.940 --> 00:13:41.430
of the things I like
about it, although it's stronger

204
00:13:41.430 --> 00:13:46.140
type, it's still quite concise
because, and I've shot. We

205
00:13:46.140 --> 00:13:51.270
have what's called type inference
where each value has a

206
00:13:51.270 --> 00:13:53.760
type, but the compiler works
out for you. So a

207
00:13:53.760 --> 00:13:58.200
lot of the time you
don't have to type out

208
00:13:58.200 --> 00:14:00.690
the name of the type.
The compiler will just look

209
00:14:00.690 --> 00:14:04.290
at the functions you're calling
and the tools you're using

210
00:14:04.290 --> 00:14:07.020
and say, okay, this should
be of this type. So,

211
00:14:07.190 --> 00:14:10.350
so the strong tiredness does
not necessarily mean that you

212
00:14:10.350 --> 00:14:13.890
have to figure out the
type ahead of time, like

213
00:14:13.890 --> 00:14:17.190
saying, and I like in
C sharp, it's kind of

214
00:14:17.190 --> 00:14:20.430
more like, C-sharp three O
where you, you know, the

215
00:14:20.430 --> 00:14:22.860
type because of the way
you've written, the literal, that

216
00:14:22.860 --> 00:14:26.820
type can be easily inferred.
It may look dynamic, but

217
00:14:26.820 --> 00:14:29.340
ultimately you get all the
performance benefits of a statically

218
00:14:29.340 --> 00:14:35.550
type language. That's exactly it
it's. Yeah. In, in, in

219
00:14:35.550 --> 00:14:39.750
a shop, you have to
bind a value to an

220
00:14:39.750 --> 00:14:43.260
identify, use the keyword lap,
which has a bit like

221
00:14:43.410 --> 00:14:47.070
Kersey C shops, a VAR
C shop three is far

222
00:14:47.910 --> 00:14:50.910
except in a shop. That's
a default. So you don't

223
00:14:50.960 --> 00:14:55.010
normally write any other type
home rotations. And you can

224
00:14:55.010 --> 00:14:57.350
put that in into if
you want, but that's kind

225
00:14:57.350 --> 00:14:59.240
of an optional extra. If
you want to give the

226
00:14:59.240 --> 00:15:02.030
compiler, if you feel you
need to give some compiler

227
00:15:02.030 --> 00:15:04.690
some hence by what you're
doing. Now, one of the

228
00:15:04.690 --> 00:15:06.820
things that I thought was
actually one of the part

229
00:15:06.820 --> 00:15:08.740
of the book I spent
the most time looking at,

230
00:15:08.740 --> 00:15:11.530
just because it took so
much brainpower to get my

231
00:15:11.530 --> 00:15:15.880
head around, was the pattern
matching. Okay. Now it was,

232
00:15:15.940 --> 00:15:18.190
it was very clear, but
I had to like, look

233
00:15:18.190 --> 00:15:21.400
at the book very carefully
and read each word and

234
00:15:21.400 --> 00:15:25.240
digest it. I kept trying
to see that. I kept

235
00:15:25.240 --> 00:15:27.610
trying to see a switch
statement, but pattern matching seems

236
00:15:27.610 --> 00:15:29.680
to be more than that.
Can you talk about pattern

237
00:15:29.680 --> 00:15:33.570
matching and why that's unique
to F sharp? Yeah. There's

238
00:15:33.570 --> 00:15:35.320
a couple of things that
were really nice about pattern

239
00:15:35.320 --> 00:15:37.840
matching, get an F sharp.
I mean, it's like a

240
00:15:37.840 --> 00:15:43.270
switch statement on steroids, I
guess. So, I mean, I

241
00:15:43.270 --> 00:15:45.790
remember a while ago, one
of my friends asked me,

242
00:15:45.790 --> 00:15:49.720
you know, why, why can't
you in C sharp, say

243
00:15:49.750 --> 00:15:52.360
type off and then do
do a switch statement over

244
00:15:52.360 --> 00:15:56.860
that in app shop, they
provide some syntax to, to

245
00:15:56.860 --> 00:15:59.110
do exactly that. So you
can pattern much over that

246
00:15:59.740 --> 00:16:03.940
type of an object. So
say you have an object.

247
00:16:03.940 --> 00:16:05.860
You don't know whether it's
a string or an integer

248
00:16:05.890 --> 00:16:09.010
or a float. You can
do, you can do a,

249
00:16:09.360 --> 00:16:15.460
a pattern matching over that
and run different codes depending

250
00:16:15.460 --> 00:16:20.460
on what the value is,
which is quite a useful

251
00:16:20.470 --> 00:16:24.790
feature. And you can also
pattern match over just values.

252
00:16:24.790 --> 00:16:28.030
You can sort of say
this number, if it's one,

253
00:16:28.660 --> 00:16:30.790
do this, if it's to
do that, or if it's

254
00:16:30.790 --> 00:16:35.110
an doing it, do another,
Oh, so, so any other

255
00:16:35.110 --> 00:16:39.550
value, and this will all
be checked by the ComPilot

256
00:16:39.550 --> 00:16:44.380
to, to make sure that
you have a complete set

257
00:16:44.380 --> 00:16:47.050
of values. If you don't,
it will give you a

258
00:16:47.050 --> 00:16:49.990
warning, which is something you
don't really get Vanessa statements

259
00:16:49.990 --> 00:16:53.380
in C sharp. And also
it goes hand in hand

260
00:16:53.410 --> 00:16:57.340
with another feature of F
shop, which I really liked

261
00:16:57.580 --> 00:17:03.760
called union types. And union
types are interesting because they

262
00:17:03.760 --> 00:17:06.850
don't really, they're not anything
to do with functional programming

263
00:17:06.850 --> 00:17:08.950
per se, but they tend
to crop up a lot

264
00:17:08.950 --> 00:17:12.970
in functional programming, which is,
and I'm not really much

265
00:17:12.970 --> 00:17:18.100
outside them. And so the
idea of a union type

266
00:17:18.100 --> 00:17:21.250
is it's a waived model.
Things are related, but to

267
00:17:21.250 --> 00:17:26.980
not necessarily don't necessarily sync
strata the same structure, that

268
00:17:26.980 --> 00:17:29.340
might seem slightly bizarre if
you're coming from an AOL

269
00:17:29.350 --> 00:17:31.480
world where you kind of
used to build in a

270
00:17:31.480 --> 00:17:34.840
hierarchy. So you start off
with an object with a

271
00:17:34.840 --> 00:17:36.940
fixed number of fields of
properties, and then you can

272
00:17:36.940 --> 00:17:41.650
kind of add stuff. Whereas
a union type is a

273
00:17:41.650 --> 00:17:44.800
way of saying this value
will have a structure that

274
00:17:44.800 --> 00:17:49.800
looks like this, or like
this I, is it like

275
00:17:49.800 --> 00:17:53.340
a union And see a
union? And see, I thought

276
00:17:53.340 --> 00:17:55.050
I was kind of being
like a struct, but it

277
00:17:55.050 --> 00:17:58.850
was a cop out. Yeah.
I it's, it's not really

278
00:17:58.850 --> 00:18:03.200
lucky union. And see, I
think, I think some of

279
00:18:03.200 --> 00:18:08.390
the extensions to, to the
C language do sort of

280
00:18:08.390 --> 00:18:13.460
introduce the kind of discriminating
union type, but it's kind

281
00:18:13.460 --> 00:18:17.540
of quite a bizarre thing
in C When would you

282
00:18:17.540 --> 00:18:19.970
know, when a what's an
appropriate example, when would you

283
00:18:19.970 --> 00:18:22.820
know that a particular problem
was aching for a union

284
00:18:22.820 --> 00:18:26.720
type? Well, there's a very
simple example in the base

285
00:18:26.750 --> 00:18:29.480
that shop based libraries, which
I really like called the,

286
00:18:29.480 --> 00:18:33.980
the option type. And this
is a union type that

287
00:18:33.980 --> 00:18:40.760
has one construct called sum,
which is just of can

288
00:18:40.760 --> 00:18:44.000
be of any value, but
under the construction of not

289
00:18:44.060 --> 00:18:49.250
call norm, which has no
value associated with it. And

290
00:18:49.250 --> 00:18:52.610
so when you'd use, this
is a places in maybe

291
00:18:52.610 --> 00:18:55.640
a C shop library where
you would return no, sometimes.

292
00:18:56.210 --> 00:18:59.420
So say an XML light.
If you're doing Slack for

293
00:18:59.420 --> 00:19:03.920
note and success, and I've
shot. If you're building that

294
00:19:03.920 --> 00:19:08.510
library now sharp would probably
return an option type, which

295
00:19:08.510 --> 00:19:11.150
would return non if the
value didn't exist and then

296
00:19:11.150 --> 00:19:14.990
some with the, the value
itself, if it did exist.

297
00:19:16.700 --> 00:19:18.410
And then what that gives
you is a very clear

298
00:19:18.410 --> 00:19:20.990
medication that you know, that
the can be two different

299
00:19:20.990 --> 00:19:25.640
situations, which you don't really
get when you're returning. No,

300
00:19:26.630 --> 00:19:28.220
I mean, I've seen a
lot of books in code

301
00:19:28.280 --> 00:19:34.370
popup because functions do occasionally
turn rent. No. And the

302
00:19:34.370 --> 00:19:37.460
program has not actually realized
that that can be the

303
00:19:37.460 --> 00:19:41.600
case. And so later on
the spider use Knoll and

304
00:19:41.600 --> 00:19:44.840
you get a no reference
exception. Whereas with this option

305
00:19:44.840 --> 00:19:49.070
type, the program is forced
to write code for the

306
00:19:49.070 --> 00:19:51.800
case where the value does
exist. And when it doesn't.

307
00:19:54.500 --> 00:19:59.000
So then in, in, in
F sharp, the kind of

308
00:20:00.140 --> 00:20:01.880
the kind of type that
I would use that would

309
00:20:01.880 --> 00:20:04.250
feel like a structure or
a class would be a

310
00:20:04.250 --> 00:20:08.240
record type. Yes. And then
the union type offers you

311
00:20:08.240 --> 00:20:13.130
this extra level of flexibility.
Yeah. The, so yeah, F

312
00:20:13.130 --> 00:20:18.260
sharp has record types, which
look very similar to which

313
00:20:18.260 --> 00:20:22.820
are just collection of fields.
Like you get on an

314
00:20:22.820 --> 00:20:27.410
objects and then this union
type is, it's just something

315
00:20:27.410 --> 00:20:33.440
that you use. I guess
when I feel just doesn't

316
00:20:33.440 --> 00:20:38.840
feel appropriate. I mean, another
interesting example of where a

317
00:20:38.840 --> 00:20:42.230
union type is appropriate is
if you were say trying

318
00:20:42.230 --> 00:20:46.780
to model a binary tree,
I think most people have

319
00:20:46.790 --> 00:20:50.620
had to deal with one
of those at some points.

320
00:20:52.180 --> 00:20:54.460
And it's, it's very feasible
to model light in the

321
00:20:54.460 --> 00:20:57.910
language like C sharp, but
you always end up using

322
00:20:57.910 --> 00:21:01.660
this idea of having no
references in some cases, which,

323
00:21:01.690 --> 00:21:07.340
which can be a little
bit dangerous. Whereas in, in

324
00:21:07.360 --> 00:21:10.030
app shop, you can just
say a binary tree is

325
00:21:10.030 --> 00:21:13.300
made up of either a
value or a note, which

326
00:21:13.330 --> 00:21:21.400
has two child notes, and
then to work with that,

327
00:21:21.400 --> 00:21:24.970
you pattern match over it
so that you write code

328
00:21:24.970 --> 00:21:29.230
for the case where you
have the two child nodes

329
00:21:29.260 --> 00:21:32.020
on your right case where
you actually get your value.

330
00:21:34.440 --> 00:21:35.610
And one of the other
things I wanted to talk

331
00:21:35.610 --> 00:21:38.640
to you about was the
F sharp libraries, because as

332
00:21:38.640 --> 00:21:42.420
with all languages, the power
of the language is only

333
00:21:42.420 --> 00:21:45.930
as kind of exploitable as
the L the libraries underneath,

334
00:21:45.960 --> 00:21:50.550
and just as Ruby has
rails and other, other extensions

335
00:21:50.550 --> 00:21:53.310
to the, to Ruby that
sometimes people think of as

336
00:21:53.310 --> 00:21:55.710
being part of the language,
but are really part of

337
00:21:55.710 --> 00:21:59.340
the, the library. There's some
pretty interesting libraries that come

338
00:21:59.340 --> 00:22:04.470
along with F sharp, particularly
around collections and sequences. Yes,

339
00:22:04.470 --> 00:22:06.180
this is going back to
the, sort of the, the

340
00:22:06.180 --> 00:22:10.470
map functions and the fold
functions that I was talking

341
00:22:10.470 --> 00:22:15.900
about earlier. So like, I
guess it's because of this

342
00:22:15.900 --> 00:22:20.610
idea of being able to
take a function as a

343
00:22:20.610 --> 00:22:23.550
value, you can, you can
then take a very generic

344
00:22:23.910 --> 00:22:27.360
view of the world and
say, so as a program

345
00:22:27.360 --> 00:22:29.370
at one of the 10
things, we tend to spend

346
00:22:29.370 --> 00:22:32.160
a lot of time doing
is working with collections. And

347
00:22:32.160 --> 00:22:35.040
then there's this fixed sets
of things that you always

348
00:22:35.040 --> 00:22:40.920
want to do to a
collection, like maybe a change

349
00:22:40.920 --> 00:22:46.230
into another collection. So that's
a map function, and we

350
00:22:46.230 --> 00:22:50.400
can, we can write a
generic function, which applies another

351
00:22:50.400 --> 00:22:55.130
function to, to each value
in the list, turn it

352
00:22:55.130 --> 00:22:59.700
into a different value, or
we might want to create

353
00:22:59.700 --> 00:23:03.780
a summary of that list.
So we have a list

354
00:23:03.780 --> 00:23:10.200
of messages we want to
total them. So we, we

355
00:23:10.200 --> 00:23:12.540
get, in this case, a
generic function called a folding

356
00:23:12.540 --> 00:23:19.800
function where, which takes a
function, which shows, which will

357
00:23:19.800 --> 00:23:22.000
be applied to each member
of the list, and also

358
00:23:22.000 --> 00:23:25.050
acute and accumulator, which will
be used to, to accumulate

359
00:23:25.050 --> 00:23:27.660
the value. In the case
of making an addition, it

360
00:23:27.660 --> 00:23:30.060
would, you know, your function
would just be adding the

361
00:23:30.060 --> 00:23:33.540
value to the accumulator And
to be clear, these, this

362
00:23:33.540 --> 00:23:37.350
list is a specific Microsoft
dot F sharp dot collections

363
00:23:37.350 --> 00:23:40.020
dot list. It's not an
I list, or it's not

364
00:23:40.020 --> 00:23:44.160
a, Yeah, it's, it is
a collection building to F

365
00:23:44.160 --> 00:23:50.480
sharp, but it, I mean,
it does support the IEnumerable

366
00:23:50.480 --> 00:23:54.480
interface. So for example, if
you, if you return an

367
00:23:54.500 --> 00:23:56.930
F sharp list to a
C sharp API, you will

368
00:23:56.930 --> 00:23:59.240
still be able to do
it for each over. It's

369
00:24:00.670 --> 00:24:03.790
See, that gets into my
question about interoperability. If I,

370
00:24:03.790 --> 00:24:06.550
if I do something in,
in F sharp that perhaps

371
00:24:06.550 --> 00:24:09.340
I'm doing it enough sharp,
because it's, it's very elegant.

372
00:24:09.340 --> 00:24:12.070
It's very simple. It's, it's
a natural thing to do,

373
00:24:12.070 --> 00:24:15.760
moving through a matrix or
creating a list of some

374
00:24:15.760 --> 00:24:18.910
kind. And then I return
it out. You know, what

375
00:24:18.910 --> 00:24:20.860
kind of dependencies do I
have? And even though the

376
00:24:20.860 --> 00:24:23.860
type might underlying BA and
F sharp list, it sounds

377
00:24:23.860 --> 00:24:27.970
like as long as the
appropriate system dot collections interfaces

378
00:24:27.970 --> 00:24:31.480
are implemented, she sharp will
never know the difference. Yeah.

379
00:24:31.510 --> 00:24:35.230
I mean, you can create
very good in patrol with

380
00:24:35.260 --> 00:24:38.830
a C shop. I mean,
certainly using C shop functions

381
00:24:38.830 --> 00:24:42.370
from AF shop is, is
a doddle is, is very

382
00:24:42.370 --> 00:24:46.870
straightforward. If you want to
create APIs that in apps

383
00:24:46.870 --> 00:24:50.710
chart that look nice from
C sharp, you do have

384
00:24:50.710 --> 00:24:55.240
to be a little bit
more careful because I show

385
00:24:55.240 --> 00:24:57.970
up to have a few
weird types like union types,

386
00:25:00.190 --> 00:25:02.140
w which don't look so
great when you return them

387
00:25:02.140 --> 00:25:04.570
to C sharp. I mean,
they, they are usable from

388
00:25:04.570 --> 00:25:08.200
C sharp. So what kind
of problem am I going

389
00:25:08.200 --> 00:25:11.230
to want to watch for
as a developer where I

390
00:25:11.230 --> 00:25:14.380
might see that problem and
say, Oh, I could do

391
00:25:14.380 --> 00:25:16.570
this in a thousand lines
of C sharp, but this

392
00:25:16.570 --> 00:25:20.470
kind of thing is so,
so much more easily cracked

393
00:25:20.470 --> 00:25:23.770
by using F sharp. I
guess it's anything that sort

394
00:25:23.770 --> 00:25:30.640
of very focused on, on
algorithm type programming or any

395
00:25:30.640 --> 00:25:33.130
way, any way you have
to manipulate any kind of

396
00:25:33.130 --> 00:25:41.170
tree or act shop's got
great tools for parsing text.

397
00:25:41.710 --> 00:25:44.410
So any kind of passing
tax story, or even binary

398
00:25:44.410 --> 00:25:51.400
data works really well in
our shop. And also if

399
00:25:51.400 --> 00:25:55.570
you wanted to do sort
of language oriented programming, which

400
00:25:55.570 --> 00:26:00.010
is what does that mean?
Well, it's, it's, there's a

401
00:26:00.010 --> 00:26:02.530
lot of different people given
different meanings to it in

402
00:26:02.530 --> 00:26:06.520
the industry, but I, I
try, I try and talk

403
00:26:06.520 --> 00:26:08.560
about it in my little,
one of the latest It's

404
00:26:08.560 --> 00:26:10.990
in the book. Yeah. Chapter
11 is on language oriented

405
00:26:10.990 --> 00:26:13.480
prayer. That's actually the next
time I'm stuck on chapter

406
00:26:13.480 --> 00:26:18.160
10 on distributed applications. Right.
Okay. But, well, I think,

407
00:26:19.750 --> 00:26:21.670
I think that's one of
the strongest chapters of the

408
00:26:21.680 --> 00:26:24.700
book, the, the language or
in his programming, certainly Don

409
00:26:24.700 --> 00:26:28.120
Simes had hit was his
favorites. I want it basically

410
00:26:28.120 --> 00:26:32.620
means in this context is,
or what, what you can

411
00:26:32.620 --> 00:26:34.780
do really well have a
shop that you can't maybe

412
00:26:34.780 --> 00:26:38.350
do so well in other
languages is design data structures

413
00:26:39.370 --> 00:26:44.760
that looked like a little
language inside of Like a

414
00:26:44.760 --> 00:26:48.320
DSL domain. It's like a
DSL, but, but yet still

415
00:26:48.320 --> 00:26:54.230
in app shop still within
your programming language. One of

416
00:26:54.230 --> 00:26:58.310
the really nice examples of
this is I've shot. One

417
00:26:58.310 --> 00:27:00.770
of the half shot libraries
has got an argument pause

418
00:27:00.770 --> 00:27:03.620
that built in. And I
don't know if you've ever

419
00:27:03.620 --> 00:27:09.230
tried to write a command
line argument pausing. It's not

420
00:27:09.230 --> 00:27:11.480
that difficult, but what you
tend to end up writing

421
00:27:11.480 --> 00:27:17.990
is lots of in string
and just full of dirty

422
00:27:17.990 --> 00:27:21.200
string manipulation, bunch of shuffling
data around and marshaling from

423
00:27:21.200 --> 00:27:24.560
time to time. Whereas in
the upshot, what you do

424
00:27:24.560 --> 00:27:28.880
is you just rice, a
list of pairs of values,

425
00:27:30.490 --> 00:27:32.900
one of which has a
string, which is the, the

426
00:27:32.900 --> 00:27:36.800
argument you're expecting. And then
the author tells you what

427
00:27:37.340 --> 00:27:41.690
type of argument that should
receive. And generally you pass

428
00:27:41.740 --> 00:27:45.350
a function to that to
say, what should happen when

429
00:27:45.350 --> 00:27:48.650
I received this link, this
is value. So it turns,

430
00:27:49.370 --> 00:27:51.620
what's usually in a lot
of nasty kind of string

431
00:27:51.620 --> 00:27:56.240
manipulation into something that just
looks very, just looks like

432
00:27:56.240 --> 00:27:58.970
a description of what should
happen. Now, would this be

433
00:27:58.970 --> 00:28:01.430
using the, I understand that
F sharp actually has its

434
00:28:01.430 --> 00:28:06.620
own Lex and yak implementations.
W that, that particular example

435
00:28:06.620 --> 00:28:14.660
isn't using the, the Lexan
yak implementation, but I guess

436
00:28:14.660 --> 00:28:17.780
that is another aspect of
language oriented programming. And it

437
00:28:17.780 --> 00:28:21.890
does have its its own
Alexia, African fermentation, as you

438
00:28:21.890 --> 00:28:25.370
say, No, we, we recently
had John Lamb from the iron

439
00:28:25.370 --> 00:28:29.030
Ruby team and the DLR
combined, right? And a lot

440
00:28:29.030 --> 00:28:33.170
of questions came up around.
What's a good language in

441
00:28:33.170 --> 00:28:36.410
the, in the.net framework and
the dot and ecosystem really

442
00:28:37.130 --> 00:28:40.160
such that one could create
a DSL. You know, Ruby

443
00:28:40.160 --> 00:28:43.160
really lends itself to creating
its own DSLs. And one

444
00:28:43.160 --> 00:28:44.870
of the questions from the
audience was whether or not

445
00:28:44.870 --> 00:28:48.350
the DLR and or iron
Ruby would really lend itself

446
00:28:48.350 --> 00:28:52.370
to creating tiny little languages.
And it sounds like F

447
00:28:52.370 --> 00:28:54.770
sharp might be a better
place to start if one

448
00:28:54.770 --> 00:28:58.550
were going to create their
own DSL. Yeah. I think,

449
00:28:59.030 --> 00:29:00.590
I think I shot would
be a great place to

450
00:29:00.590 --> 00:29:03.830
start. I mean, the company
that I worked for at

451
00:29:03.830 --> 00:29:08.030
the moment lexified does a
lot of work with DSLs.

452
00:29:08.030 --> 00:29:11.270
In fact, I sort of
all our products are based

453
00:29:11.270 --> 00:29:19.120
around at DLS sell for,
for describing financial products, which

454
00:29:19.130 --> 00:29:21.080
is actually recently. And I
came up with that it's

455
00:29:22.490 --> 00:29:25.250
it could be written as
sharp it's it's using the

456
00:29:25.250 --> 00:29:30.410
same kind of ideas that's
available and at shop Now,

457
00:29:31.190 --> 00:29:33.560
did you have to do
anything to sell this kind

458
00:29:33.560 --> 00:29:35.810
of quote unquote, sell this
idea to your company or

459
00:29:35.810 --> 00:29:37.700
because you were already using
old camel, it was an

460
00:29:37.700 --> 00:29:42.160
easy sell. The reason I
ask is I'm trying To

461
00:29:42.160 --> 00:29:46.660
understand how, how can I,
or the, the.net oriented listener,

462
00:29:47.530 --> 00:29:50.920
you know, sell an F
sharp project to their boss.

463
00:29:50.920 --> 00:29:53.170
I mean, I think it's
fair to point out a

464
00:29:53.170 --> 00:29:56.860
remind the listener that this
integrates nicely into visual studio,

465
00:29:56.860 --> 00:30:03.900
2005, right? I mean, the
integration with visual studio 2005

466
00:30:03.930 --> 00:30:06.060
isn't yet perfect. But I
mean, you do get very

467
00:30:06.060 --> 00:30:11.070
good in Telesonics that works
really nicely. You get the

468
00:30:11.070 --> 00:30:14.760
app shop interacts with console
is integrated into visual studio,

469
00:30:15.960 --> 00:30:18.720
which what that means is
you can sort of highlight

470
00:30:18.720 --> 00:30:22.320
a section of your code
as you might do with

471
00:30:22.410 --> 00:30:27.030
a section of SQL that
you're icing and a press

472
00:30:27.040 --> 00:30:30.360
keyboard shortcut, which is all
10, three and half shop's

473
00:30:30.360 --> 00:30:33.330
case. And it goes off
and executes that code for

474
00:30:33.330 --> 00:30:38.870
you. And because of the,
the, the structure of an

475
00:30:38.880 --> 00:30:41.640
upshot program, it generally lends
its well. So having kind

476
00:30:41.640 --> 00:30:44.640
of a little sections of
it executed on its own.

477
00:30:44.670 --> 00:30:50.820
So it's great for kind
of testing your program and

478
00:30:50.820 --> 00:30:54.390
it it's particularly nice when
you're working with wind WinForms

479
00:30:54.420 --> 00:30:56.490
cause we can do sort
of pop up a form

480
00:30:56.990 --> 00:31:00.090
and then dynamically set properties
on it, on the form

481
00:31:00.090 --> 00:31:02.490
and see change and before
your eyes, which is really

482
00:31:02.490 --> 00:31:06.720
quite cool. Yeah. That's interesting
that Ruby, a guy, John Lamb

483
00:31:06.720 --> 00:31:09.150
did a similar demo and
it seems like more and

484
00:31:09.150 --> 00:31:11.980
more people are using demos
like that as a, as

485
00:31:11.980 --> 00:31:14.340
a way to kind of
show the, the usefulness of

486
00:31:14.340 --> 00:31:16.770
an interactive console, that it
was pretty cool to see

487
00:31:16.770 --> 00:31:19.950
him bring up a wind
format and start adding buttons

488
00:31:19.950 --> 00:31:22.320
to it kind of dynamically
and in a quick prototyping

489
00:31:22.320 --> 00:31:25.410
way. Yeah. Just not to
pit you guys against each

490
00:31:25.410 --> 00:31:28.470
other, but I think I'd
be interested in understanding where

491
00:31:28.470 --> 00:31:33.210
a dynamic languages like Byron
Python sit in the ecosystem

492
00:31:33.210 --> 00:31:38.790
next to, you know, statically
typed, but very, very differently

493
00:31:38.790 --> 00:31:41.700
powerful languages like F sharp
in the kind of this

494
00:31:41.700 --> 00:31:44.010
new world order. Suddenly we
have a lot more to

495
00:31:44.010 --> 00:31:48.150
choose from than just C
sharp and VB, almost like

496
00:31:48.150 --> 00:31:50.460
the promise of.net from seven
years ago, it was really

497
00:31:50.460 --> 00:31:54.360
happening. It, it, it does
feel a lot more exciting.

498
00:31:54.380 --> 00:31:56.700
I have to say. I
mean, one of the reasons

499
00:31:56.700 --> 00:31:59.580
that got me in Sasha
originally is when, when you

500
00:31:59.580 --> 00:32:03.830
looked at the B and
C shop, I mean, I,

501
00:32:04.040 --> 00:32:06.240
I really liked both of
those languages, but when you,

502
00:32:06.300 --> 00:32:08.460
if you do put them
next to each other and

503
00:32:08.460 --> 00:32:11.610
compare them, especially the early
versions that they were, they

504
00:32:11.610 --> 00:32:14.340
were really quite similar. One
of the things that attracted

505
00:32:14.850 --> 00:32:17.670
me to have shot was,
you know, you really can

506
00:32:17.670 --> 00:32:22.950
see differences, different ways of
doing things. Now, one thing

507
00:32:23.250 --> 00:32:24.960
we're getting towards the end
of the show here, we're

508
00:32:24.960 --> 00:32:27.000
coming up on a half
an hour. But one thing

509
00:32:27.000 --> 00:32:28.800
I wanted to point out
that I thought was particularly

510
00:32:28.800 --> 00:32:32.790
interesting was that you actually
ported the game of life

511
00:32:32.790 --> 00:32:39.710
sample to Silverlight. Yes, that's
correct. Yeah. That's Silverlight well,

512
00:32:39.710 --> 00:32:42.800
it's, we'll talk Ill. So
you just referenced the correct.

513
00:32:44.210 --> 00:32:46.370
Correct. Several light assemblies and
several, I didn't even know

514
00:32:46.370 --> 00:32:50.020
F sharp was involved. Yes.
That's, that's pretty much it.

515
00:32:51.520 --> 00:32:56.170
Yeah. You can just tell
that shop to, to use

516
00:32:56.230 --> 00:32:59.620
a particular instance of the
CLR. Don, Don Simon spent

517
00:32:59.620 --> 00:33:01.780
some quite a lot of
time working on that so

518
00:33:01.780 --> 00:33:05.530
that the actual Ashok compiler
can be used with the

519
00:33:05.560 --> 00:33:11.230
mano or the, or rotor
as well. So you've got

520
00:33:11.380 --> 00:33:16.840
standard.net framework, rotor, mano, and
Silverlight. Yeah. So it's what

521
00:33:16.860 --> 00:33:19.480
it's all about. Just being
able to reference the right

522
00:33:19.480 --> 00:33:24.310
set of dotnet DLLs, Have
any particular work had to

523
00:33:24.310 --> 00:33:25.810
be done to get that,
to work with server line

524
00:33:25.810 --> 00:33:28.750
or did it just work?
It just worked. I mean,

525
00:33:28.750 --> 00:33:32.320
there's a few things that
didn't, and that's, if you

526
00:33:32.320 --> 00:33:40.300
touched on any methods that
existed in the.net framework 2.0,

527
00:33:40.330 --> 00:33:43.000
but didn't exist in Silverlight
she got a Missy method

528
00:33:43.000 --> 00:33:46.630
exception, but generally that was
quite easily booked. Cause it

529
00:33:46.630 --> 00:33:50.320
just said MiFi method so-and-so
doesn't exist. And you kind

530
00:33:50.320 --> 00:33:53.440
of thought, well, can't use
that API, but I mean,

531
00:33:53.440 --> 00:33:55.990
it was all stuff that
you, you didn't really want

532
00:33:55.990 --> 00:34:02.320
to use, like closing, shutting
down the application because obviously

533
00:34:02.320 --> 00:34:07.420
that's not very desirable and
enterprise. Well I've really, I

534
00:34:07.420 --> 00:34:10.480
am really enjoying your book
foundations of F sharp. It's

535
00:34:10.480 --> 00:34:12.970
one of the yellow and
black books from a press.

536
00:34:13.630 --> 00:34:15.640
And I got to get
through chapter 10 and move

537
00:34:15.640 --> 00:34:18.550
on to chapter 11 on
the DSL in language oriented

538
00:34:18.550 --> 00:34:22.540
programming. What would be a
good way for the, for

539
00:34:22.540 --> 00:34:25.420
the listener to start with
F sharp. I know this

540
00:34:25.430 --> 00:34:28.570
that Don and team just
released a, a new version

541
00:34:28.570 --> 00:34:30.490
of F sharp kind of
on the heels of all

542
00:34:30.490 --> 00:34:34.930
of the different releases this
week F sharp. I think

543
00:34:34.930 --> 00:34:39.790
it's 1.9 0.2 0.7 with
a number of new new

544
00:34:39.790 --> 00:34:43.660
language features and such. And
it integrates again nicely with,

545
00:34:43.840 --> 00:34:45.850
with visual studio. So you
don't feel like you're out

546
00:34:45.850 --> 00:34:48.130
there at the command line
and all alone with notepad,

547
00:34:48.610 --> 00:34:51.370
but what's a good project
for someone to sit down

548
00:34:51.370 --> 00:34:55.840
with and kind of get
their brain around this. I

549
00:34:55.840 --> 00:35:01.510
see. That's a very good
question. Well, I think at

550
00:35:01.510 --> 00:35:05.830
shops distributed with a lot
of samples, I guess I

551
00:35:05.830 --> 00:35:10.660
could ways to take a
look at the samples available,

552
00:35:11.080 --> 00:35:13.780
the game's lifetime pool that
you, you mentioned earlier as

553
00:35:13.780 --> 00:35:17.200
one of the, the most
offense that comes with the,

554
00:35:17.200 --> 00:35:23.920
the compiler itself and otherwise,
you know, there's, there's various

555
00:35:23.920 --> 00:35:28.420
other ones. And another, another
good way would be, I

556
00:35:28.420 --> 00:35:34.270
guess, to Talk to the
people on the, the hub

557
00:35:34.870 --> 00:35:39.630
act shop has its own
community sites started by a

558
00:35:39.630 --> 00:35:43.770
guy called options. Scalper. Where
is that? So, so that's

559
00:35:44.730 --> 00:35:51.650
CS points, hope S all
one word.net.net. All right. And

560
00:35:51.650 --> 00:35:54.980
I'll post that link up
on the, up on the

561
00:35:54.980 --> 00:35:59.510
show website. Yep. Fantastic. Well,
I really appreciate your taking

562
00:35:59.510 --> 00:36:02.450
the time to call her.
Okay. No problem. It was,

563
00:36:03.080 --> 00:36:05.000
it was really nice to
speak to you. I do

564
00:36:05.000 --> 00:36:08.180
appreciate it. This has been
another episode of Hanselminutes and

565
00:36:08.180 --> 00:36:09.200
we'll see you next week.


WEBVTT FILE

1
00:00:12.090 --> 00:00:16.980
From hanselminutes.com. It's Hanselman. It's
a weekly discussion with web

2
00:00:16.980 --> 00:00:21.330
developer and technologist Scott Hanselman.
This is Lawrence Ryan announcing show

3
00:00:21.330 --> 00:00:27.600
number 300 recorded live Tuesday,
January 3rd, 2012. Support for Hansel minutes

4
00:00:27.600 --> 00:00:31.170
is provided by Telerik rad
controls, the most comprehensive suite

5
00:00:31.170 --> 00:00:39.870
of components for windows forms
and asp.net web applications online@wwwdottelerik.com.

6
00:00:40.890 --> 00:00:44.310
In this episode, Scott talks
with Dennis Belott about service

7
00:00:44.310 --> 00:00:48.930
stack. Hi, this is Scott
Hanselman, and this is another

8
00:00:48.930 --> 00:00:52.470
episode of Hansel minutes. It's
the framework series continues. We're

9
00:00:52.470 --> 00:00:55.260
looking at folks that work
on and write and include

10
00:00:56.130 --> 00:00:59.430
the community in their open
source frameworks. And today we've

11
00:00:59.430 --> 00:01:02.310
got Dennis Bell out talking to
us about service stack. You

12
00:01:02.310 --> 00:01:05.970
can check out service stack.net.
How are you, sir? Yeah,

13
00:01:05.970 --> 00:01:09.210
I'm pretty good. Thanks Scott.
Thanks for taking the time

14
00:01:09.210 --> 00:01:13.710
to talk to me today.
So service stack.net, it says

15
00:01:13.710 --> 00:01:17.760
on the site open source.net
and mano rest web services

16
00:01:17.760 --> 00:01:20.850
framework. Is that, is that
all it is? Is it

17
00:01:20.850 --> 00:01:23.280
just a rest in web
services framework? Because it seems

18
00:01:23.280 --> 00:01:25.200
to have some useful things
that I might want to

19
00:01:25.200 --> 00:01:27.420
use, even if I'm not
making a web service framework.

20
00:01:28.590 --> 00:01:34.230
Basically it is primarily around
building high-performance web services, but

21
00:01:34.960 --> 00:01:38.190
it's includes our entire stack
because it's everything would ever

22
00:01:38.190 --> 00:01:41.100
want in order to build
that. So it does have

23
00:01:41.100 --> 00:01:43.770
a lot of other bits
that are just useful in

24
00:01:43.890 --> 00:01:48.030
general purpose, web programming. So
it's, I am including the

25
00:01:48.030 --> 00:01:51.000
entire stack that, but it
is all centered around a

26
00:01:52.050 --> 00:01:55.560
how to build high-performance web
services. And then there's some

27
00:01:55.560 --> 00:01:59.820
sub components that are within
service stack service stack text,

28
00:02:00.060 --> 00:02:03.540
which has texts serializers for
chasing and XML data contracts.

29
00:02:04.140 --> 00:02:09.480
There's a Reddis, which is
a memory caching library. This

30
00:02:09.480 --> 00:02:11.850
is the C-sharp open source,
read his client to the

31
00:02:11.850 --> 00:02:16.650
Reddis backend services. There's also
a, an ORM light or

32
00:02:16.650 --> 00:02:19.110
what we call a micro
ORM. And then there's a

33
00:02:19.110 --> 00:02:22.020
caching section. Cause like I
was thinking there, each of

34
00:02:22.020 --> 00:02:24.780
those is useful just on
its own. It sounds like

35
00:02:24.780 --> 00:02:28.110
you can download those separately
as well. Yeah, yeah, exactly.

36
00:02:28.440 --> 00:02:32.760
So each of those components,
or are all basically useful

37
00:02:32.780 --> 00:02:36.180
in a, in a, in,
in, on itself, each of

38
00:02:36.180 --> 00:02:41.340
those components actually downloadable separately
in their own projects and

39
00:02:41.340 --> 00:02:43.980
dependencies, I actually have a
MVC power pack where you

40
00:02:43.980 --> 00:02:46.830
can actually install service stack
and you get all those

41
00:02:47.760 --> 00:02:49.920
dependencies in your MVC website.
You don't even have to

42
00:02:49.920 --> 00:02:51.720
use a web framework, but
you've got you get access

43
00:02:51.720 --> 00:02:56.340
to all the, the, the
high performance components. But yeah,

44
00:02:56.340 --> 00:02:59.860
so there's the three different,
the main components are, is

45
00:03:00.760 --> 00:03:03.850
the tech civil service sector.
Texts has no dependencies. It's

46
00:03:04.090 --> 00:03:08.920
got a Jason and JSB
sterilizer. It's the F and

47
00:03:08.980 --> 00:03:13.420
CSV sterilizer. Yeah, they're the
fastest serializes of benchmark, but

48
00:03:13.420 --> 00:03:16.690
for.net stack overflow uses because
it's a quite a lot

49
00:03:16.690 --> 00:03:21.130
quicker than what's bundled in
NBC at the moment. But

50
00:03:21.130 --> 00:03:23.170
yeah, it's basically clean. It
all works. It all the,

51
00:03:23.170 --> 00:03:25.870
all the us libraries actually
work with clean pocos, that's

52
00:03:25.870 --> 00:03:27.730
why I'm able to get
a lot of reuse around

53
00:03:27.730 --> 00:03:29.980
it. And I think that
would be actually really useful

54
00:03:30.880 --> 00:03:34.390
if everyone's, if anyone's dealing
with have got their own

55
00:03:34.390 --> 00:03:37.600
clean models, you can actually
use them with, with all

56
00:03:37.600 --> 00:03:41.500
the frameworks, with, yeah. With
all the sub components. And

57
00:03:41.500 --> 00:03:43.780
then you've got arm light,
which is a very nice

58
00:03:43.840 --> 00:03:46.210
Paco RM, you don't need
anything else, but the code

59
00:03:46.210 --> 00:03:49.210
first RMS generates a schema
based on, based on that.

60
00:03:50.160 --> 00:03:53.460
So thinking about each of
the different pieces separately, one

61
00:03:53.460 --> 00:03:54.810
of the things that I
was impressed about when I

62
00:03:54.810 --> 00:03:58.740
visited service stack.net was that
you've got benchmarks. I thought

63
00:03:58.740 --> 00:04:02.340
it was really great that
it's very open in the

64
00:04:02.340 --> 00:04:04.590
sense of like, here's what
we do. Here's what we

65
00:04:04.590 --> 00:04:07.860
offer and click here for
how our speed compares to

66
00:04:07.860 --> 00:04:10.920
the others. And in some
cases you're faster and others

67
00:04:11.010 --> 00:04:13.620
at other cases, you're not,
and that's a, it's pretty

68
00:04:13.620 --> 00:04:17.460
cool. I'm looking at the
serialization benchmarks for taking some

69
00:04:17.460 --> 00:04:20.160
Northwind database rows. And there's
a couple of times where

70
00:04:20.160 --> 00:04:23.250
you're faster. And then there's
another thing called protocol buff.

71
00:04:23.250 --> 00:04:26.640
What is protocol is that
one of your competitors? Well,

72
00:04:26.910 --> 00:04:29.970
protocol buffers is a Google,
the wire format. That's, it's

73
00:04:29.970 --> 00:04:35.820
very optimized for point to
point communication <inaudible>, but right.

74
00:04:35.820 --> 00:04:41.340
The protocol, but implementation is
very fast it's binary, but

75
00:04:41.340 --> 00:04:45.980
it is like, it's probably
the fastest SU binary serializer

76
00:04:46.000 --> 00:04:50.970
for.net in it's closely behind
that would be a message

77
00:04:50.970 --> 00:04:52.800
pack, which has kind of
a newcomer on the scene.

78
00:04:53.070 --> 00:04:58.080
But in all of benchmarks
I've seen protocol buffers basically

79
00:04:58.080 --> 00:05:02.670
be the fastest. And yeah,
so it's basically Google's implementation

80
00:05:02.700 --> 00:05:06.180
of binary, binary serializer. It
ends up being very fast,

81
00:05:06.180 --> 00:05:10.050
very small, very efficient. And
Mark Greville from also that

82
00:05:10.050 --> 00:05:12.810
stack overflow, he wrote a
very excellent implementation of it.

83
00:05:13.080 --> 00:05:16.410
So yeah, in terms of
serializes, he's, he's the he'll

84
00:05:16.410 --> 00:05:20.070
have the best, the fastest
serializer, but in terms of

85
00:05:20.070 --> 00:05:23.970
texts utilization, that's what the
Jason JSB supervisors, I tend

86
00:05:23.970 --> 00:05:28.500
to prefer texted or lessons
from the debug ability standpoint

87
00:05:28.500 --> 00:05:30.570
and also from cause they
are, schemeless, they're actually a

88
00:05:30.570 --> 00:05:32.950
lot easier to work with
and you can actually edit

89
00:05:32.970 --> 00:05:35.760
in line, remove fields and
fields and it all works

90
00:05:35.760 --> 00:05:38.790
really well. So it's actually,
they're all very resilient, but

91
00:05:38.790 --> 00:05:43.350
I, in terms of the
tech services, the assistant supervisors

92
00:05:43.350 --> 00:05:46.410
do very well in terms
of like they'll, they're the

93
00:05:46.410 --> 00:05:50.340
fastest texturized. Yeah. I was
thinking, Sorry. I was thinking

94
00:05:50.340 --> 00:05:54.720
about frameworks in the, in
the context of there's the

95
00:05:54.720 --> 00:05:57.470
existing dotted framework in the
base class library. And then

96
00:05:57.470 --> 00:06:01.220
there's folks that write stuff
that are kind of directly,

97
00:06:01.730 --> 00:06:03.770
I wouldn't say competing, isn't
the word, but there re

98
00:06:03.770 --> 00:06:06.980
implementations about what already exists.
And is there, is it

99
00:06:06.980 --> 00:06:11.210
usually, or always speed in
your sense when someone goes

100
00:06:11.210 --> 00:06:13.220
and writes something that already
exists in the base class

101
00:06:13.220 --> 00:06:17.350
libraries And no, not at
all. My, my, my clean,

102
00:06:17.380 --> 00:06:23.230
my, my initial problems code
first solutions. They always, in

103
00:06:23.230 --> 00:06:26.260
all my experience, I always
promote a more elegant, simpler

104
00:06:26.270 --> 00:06:29.800
solution. And basically I've just
been unhappy with the high

105
00:06:29.800 --> 00:06:34.060
level overweight obstructions, for instance,
like HBO wave forms. I

106
00:06:34.060 --> 00:06:36.760
just thought it was a,
let's say it's a false

107
00:06:36.820 --> 00:06:41.830
suicide leaky obstruction, which didn't
quite work for way. Programming

108
00:06:42.520 --> 00:06:45.760
worked pretty well for a
windows form developers, but I

109
00:06:45.760 --> 00:06:48.460
don't think it in the
end promotes a very usable

110
00:06:48.460 --> 00:06:51.550
code. WCF is also has
a S a service side,

111
00:06:51.940 --> 00:06:55.390
very, very thick, abstract obstructions
as well on the service

112
00:06:55.390 --> 00:06:59.080
side. And yeah, I'd much
prefer a clean, cleaner, simpler

113
00:06:59.290 --> 00:07:03.610
interface where you can easily
implement and easily test taking

114
00:07:03.610 --> 00:07:09.010
clean models, basically as a,
as a pro a developer

115
00:07:09.100 --> 00:07:12.220
practicing solid design principles kind
of thing, where it's light

116
00:07:12.250 --> 00:07:15.220
thin and, and basically fast.
And I, I do prefer

117
00:07:16.660 --> 00:07:19.030
all my software components be
very fast since I do

118
00:07:19.030 --> 00:07:25.270
believe it's probably the primary
feature of enjoyable it's end

119
00:07:25.270 --> 00:07:29.830
user experience. Yeah. Why do
you think that your stuff

120
00:07:29.860 --> 00:07:34.930
is faster than the Microsoft
stuff? Well, all the benchmarks

121
00:07:35.710 --> 00:07:38.110
show that these actually aren't
my benchmarks. These are the

122
00:07:38.110 --> 00:07:40.430
external benchmarks from different sites.
I've got a couple of

123
00:07:40.480 --> 00:07:44.410
them are that are mine,
but basically the ORM, which

124
00:07:44.410 --> 00:07:47.950
shows in three frameworks, like
12 times slower than Deborah

125
00:07:47.950 --> 00:07:51.730
and, and arm light is
these are for depth as

126
00:07:51.730 --> 00:07:55.090
benchmarks. Then someone else did
the civilization for the burning

127
00:07:55.090 --> 00:07:58.900
monk. Basically every benchmark that
we've seen, it's clearly a

128
00:07:58.900 --> 00:08:04.180
lot manufacturer of times faster
than, than Microsoft solutions. I,

129
00:08:04.420 --> 00:08:07.390
there is Microsoft to do
some good things like, well,

130
00:08:07.390 --> 00:08:12.250
the cough, the cough dominant
framework itself is, is fantastic

131
00:08:12.250 --> 00:08:14.410
and a good performance. So
you got to call libraries

132
00:08:14.410 --> 00:08:17.140
like the concurrent diction and
those they're doing really well,

133
00:08:17.140 --> 00:08:19.720
but there is the high
level frameworks that don't perform

134
00:08:19.720 --> 00:08:23.190
so well, WCF is, is
not so great performance. So

135
00:08:23.270 --> 00:08:27.250
is a terrible, terrible. The
JavaScript serializes is like the

136
00:08:27.250 --> 00:08:32.710
worst. It was performance advisors
out there, I think. And

137
00:08:34.090 --> 00:08:38.110
I, I own it. I
think they first, I think

138
00:08:38.200 --> 00:08:41.290
they don't didn't care too
much about Jason because their

139
00:08:41.290 --> 00:08:43.900
data XML data contract is
actually quicker than their adjacent,

140
00:08:43.900 --> 00:08:46.030
and there's got no reason
for it to be. So

141
00:08:46.030 --> 00:08:47.380
I actually think they put
a lot of effort in

142
00:08:47.380 --> 00:08:50.860
their XML data contract sterilizer
and the job script supervisor.

143
00:08:51.130 --> 00:08:54.730
It was a deprecated library
that they've just resurrected and

144
00:08:54.730 --> 00:08:58.590
worked NBC and I, and
I basically don't think they

145
00:08:58.620 --> 00:09:01.290
spent the time to rewrite
a proper Fasten plantation. So

146
00:09:01.290 --> 00:09:03.860
it's because NBC on it
has, has a lot of,

147
00:09:03.870 --> 00:09:07.410
is pretty good in, in,
in a low overall, but

148
00:09:07.410 --> 00:09:11.550
there are definitely some weak
spots that could, could be

149
00:09:12.470 --> 00:09:13.820
The reason I ask is
I'm trying to get my

150
00:09:13.820 --> 00:09:18.560
head around where Microsoft falls
down on, on library stuff.

151
00:09:19.070 --> 00:09:21.950
And I see lots of
open source libraries that go

152
00:09:21.950 --> 00:09:26.000
and do a faster versions
of something. And then there's

153
00:09:26.000 --> 00:09:28.460
a benchmark that proves that,
you know, it's X times

154
00:09:28.460 --> 00:09:31.880
faster, four X, 10 X,
whatever. And then I wonder,

155
00:09:32.030 --> 00:09:34.550
because benchmark's only told half
the story. The other half

156
00:09:34.550 --> 00:09:37.880
of course is, is kind
of compliance how correctly stuff

157
00:09:37.880 --> 00:09:40.970
is. You know, it's easy
to go and say, Hey,

158
00:09:40.970 --> 00:09:43.880
I wrote this open source,
Jason sterilizer, and I, you

159
00:09:43.880 --> 00:09:46.190
know, for each over it
a million times, and it's

160
00:09:46.190 --> 00:09:49.250
better, but it's difficult when
you start thinking about edge

161
00:09:49.250 --> 00:09:53.810
cases and encoding and, you
know, characters that are encoding

162
00:09:53.810 --> 00:09:58.220
regular and coding, correct correctness
as well. And I wonder

163
00:09:58.220 --> 00:10:01.850
if, you know, is this
something where Microsoft drops the

164
00:10:01.850 --> 00:10:06.620
ball on where they are
valuing correctness over speed? Or

165
00:10:06.800 --> 00:10:10.460
are they just not very
good? I, I do. So

166
00:10:10.520 --> 00:10:13.970
I do think Microsoft has
to encompass a lot more

167
00:10:14.420 --> 00:10:20.260
situations educators than otherwise would,
although jason.net for instances is

168
00:10:20.270 --> 00:10:22.730
a very popular adjacency, that
it actually has a lot

169
00:10:22.730 --> 00:10:26.150
more features than, than the
JavaScript supervisor that Microsoft ships,

170
00:10:27.050 --> 00:10:29.750
although the fact that it's
the JavaScript serialize, it might

171
00:10:29.810 --> 00:10:32.510
say that actually does more
than just Jason. It's actually

172
00:10:32.690 --> 00:10:37.370
J JavaScript aware. And I've
noticed this where encodes script

173
00:10:37.430 --> 00:10:41.150
tags for embedded in a
HTML automatically. So that, that's

174
00:10:41.150 --> 00:10:44.960
a nice addition that it
does, but I mean, it's

175
00:10:44.960 --> 00:10:49.370
multiple times slower, so it's
doing something pretty wrong. Like

176
00:10:49.370 --> 00:10:52.250
there's a lot of wasted
CPU cycles, but, but I

177
00:10:52.250 --> 00:10:54.260
do. Yeah, I do think
they do care about edge

178
00:10:54.260 --> 00:10:57.320
cases more than probably performance.
But at the same time,

179
00:10:57.350 --> 00:11:00.800
I have a clear divide
of the call platform team,

180
00:11:00.830 --> 00:11:03.680
the call.net framework, which is
very well performance. And a

181
00:11:03.680 --> 00:11:05.360
lot of all of the
high level frameworks, I don't

182
00:11:05.360 --> 00:11:08.060
want that variable performance. And
for instance, editing entity for

183
00:11:08.060 --> 00:11:10.910
immigrant and that type of
a high, low framing. So

184
00:11:11.120 --> 00:11:13.580
they were originally a GUI
driven and I feel like,

185
00:11:13.730 --> 00:11:18.500
and so it was WCF.
Config is basically a, it's

186
00:11:18.500 --> 00:11:22.420
almost a GUI driven or
config driven solution first. And

187
00:11:22.490 --> 00:11:25.400
I basically in all my
experience at code first always

188
00:11:26.360 --> 00:11:30.470
produces a more elegant, simpler
to how more testable and

189
00:11:30.500 --> 00:11:32.030
basically in the end of
the day, easy and more

190
00:11:32.030 --> 00:11:36.530
maintainable solution. So I, I
think they, they, I think

191
00:11:36.530 --> 00:11:38.810
the biggest problem is that
they try to cater for

192
00:11:39.110 --> 00:11:44.210
the entry level programmers and
have no framework specifically for

193
00:11:44.210 --> 00:11:47.030
pro developers. Cause the prototype
was most of them, I

194
00:11:47.330 --> 00:11:50.030
speak to don't actually care
too much for the GUI

195
00:11:50.060 --> 00:11:54.820
designers or the conflict or
the conflict driven solutions. I

196
00:11:54.820 --> 00:11:57.340
think that's more of a
what we, what I like

197
00:11:57.340 --> 00:12:00.970
to call a drag and
drop developer. Okay. Do you,

198
00:12:00.970 --> 00:12:04.140
do you think that you've
heard the term alt.net? Of

199
00:12:04.140 --> 00:12:06.180
course, I don't know whether
you are self identify as

200
00:12:06.180 --> 00:12:08.580
all.net or whether you think
the concept of all.net is,

201
00:12:09.450 --> 00:12:12.210
is, is still around and
healthy or not, but maybe

202
00:12:12.210 --> 00:12:14.130
we just say alpha geeks
are more kind of more

203
00:12:14.130 --> 00:12:20.490
advanced people. Do you think
that all.net or alpha geeks

204
00:12:20.520 --> 00:12:25.050
are the, are, are people
that love the CLR respect

205
00:12:25.050 --> 00:12:27.690
the base class library, but
the higher up the stack,

206
00:12:27.690 --> 00:12:30.870
they go the higher up
the deliverable from Microsoft directly,

207
00:12:30.870 --> 00:12:35.070
they go the less they
respect this stuff. Yeah, absolutely.

208
00:12:35.610 --> 00:12:38.820
I think everyone still on
the platform, because it's done,

209
00:12:38.820 --> 00:12:41.610
it's not actually the most
vibrant open source platform. And

210
00:12:41.760 --> 00:12:43.440
I mean, that's where I
spend my time, but it

211
00:12:43.440 --> 00:12:46.620
is like, I think is
technically superior it's in terms

212
00:12:46.620 --> 00:12:49.890
of my eyes. Well, on
the server, I don't particularly

213
00:12:49.890 --> 00:12:53.970
like it for creating UIs.
Cause I think is superior

214
00:12:53.990 --> 00:12:57.240
in that regard. But in
on the server, I do

215
00:12:57.240 --> 00:13:00.600
think it's just, it's kind
of leagues above. Like the

216
00:13:00.600 --> 00:13:03.840
competitors would probably be Java
and the JVM and F

217
00:13:03.840 --> 00:13:06.780
shop and they just first
class world class technology. So

218
00:13:06.780 --> 00:13:09.090
I do think everyone has
a massive respect for the

219
00:13:09.120 --> 00:13:11.760
core CLR team. And, but
at the same time, most

220
00:13:11.760 --> 00:13:14.310
of the pro alpha geeks
actually are writing their own

221
00:13:14.310 --> 00:13:17.370
frameworks and they're usually writing
their own frameworks because there's

222
00:13:17.380 --> 00:13:22.290
a problem with the existing
Microsoft solution. And so, yeah,

223
00:13:22.380 --> 00:13:25.560
I basically all the technical
friends in, in, in the

224
00:13:25.560 --> 00:13:28.050
old, on it circle, although
I think I'll do the

225
00:13:28.050 --> 00:13:29.760
next, probably the wrong term.
Cause it was an interesting

226
00:13:29.760 --> 00:13:32.490
community, which I've never was
a part of, but the

227
00:13:32.490 --> 00:13:36.540
pro the pro.net web teams
basically are running their own

228
00:13:36.540 --> 00:13:39.840
trainings or maintain their own
libraries. They're usually on get

229
00:13:39.840 --> 00:13:43.170
hub and, and, and, you
know, a lot of them

230
00:13:43.170 --> 00:13:49.590
are fairly mature libraries, but
yeah, so I don't, I

231
00:13:49.590 --> 00:13:55.140
do well, I personally don't
have a greater respect for

232
00:13:55.140 --> 00:13:57.420
the high level frameworks. For
instance, I, I think they

233
00:13:57.450 --> 00:13:59.520
could be a lot of
things that could have been

234
00:13:59.880 --> 00:14:05.070
done better and foster. So
when, when a person sits

235
00:14:05.070 --> 00:14:07.800
down, when a listener, maybe
who's listening now sits down

236
00:14:07.800 --> 00:14:11.850
and say, I want to
write a framework. Should they

237
00:14:12.420 --> 00:14:14.760
think I want to write
a framework because I'm, I'm

238
00:14:14.760 --> 00:14:16.890
better than the other people
who've written frameworks or should

239
00:14:16.890 --> 00:14:22.320
they go and evaluate existing
existing framework? I, I think

240
00:14:22.320 --> 00:14:24.870
that should look at their
requirements and see what their,

241
00:14:25.380 --> 00:14:27.990
the, the core requirements would
be and definitely check other

242
00:14:28.380 --> 00:14:34.620
frameworks at the time. W
without a doubt, because yeah,

243
00:14:34.680 --> 00:14:37.830
it's something something already written
well already tested is already

244
00:14:37.890 --> 00:14:40.470
a mature Barbara community is
going to be a lot

245
00:14:40.470 --> 00:14:43.290
better than something you write
in your own time. But

246
00:14:43.290 --> 00:14:46.980
if you have different requirements,
it's sometimes it's actually takes

247
00:14:46.980 --> 00:14:49.980
more effort to understand and,
and, and fudge someone else's

248
00:14:49.980 --> 00:14:53.090
API into your, a particular
use case than it is

249
00:14:53.090 --> 00:14:55.400
just to create your own,
which, which you'd know intimately,

250
00:14:56.480 --> 00:14:59.510
for instance, having, having, using
in creating your air and

251
00:14:59.510 --> 00:15:03.110
serialize, I have actually am
able to produce just knowing

252
00:15:03.110 --> 00:15:07.490
the implementation. I'm able to
kind of bypass that the

253
00:15:07.490 --> 00:15:09.740
type system in a way,
and actually produce a lot

254
00:15:09.740 --> 00:15:12.440
more cleaner, succinct code, because
a lot of developers that

255
00:15:12.440 --> 00:15:17.050
didn't write the a D
didn't have intimate knowledge of

256
00:15:17.060 --> 00:15:19.280
what the tools are using.
Aren't actually fully aware of

257
00:15:19.290 --> 00:15:23.030
its capabilities and where it
can be used. So these

258
00:15:23.030 --> 00:15:25.280
are some, this is basically
the trade off between running

259
00:15:25.280 --> 00:15:27.860
your own or using someone
else's. But generally I would

260
00:15:27.860 --> 00:15:29.840
advise to go out and,
and see what's out there,

261
00:15:30.530 --> 00:15:32.570
although it is hard because
there's not real one place

262
00:15:32.570 --> 00:15:35.660
you can look, I generally,
Google can only do so

263
00:15:35.660 --> 00:15:40.750
much, But when I'm, when
someone who's learning about what

264
00:15:40.750 --> 00:15:42.280
they should do or trying
to make a decision about

265
00:15:42.280 --> 00:15:45.670
how to move forward, and
like, if I'm evaluating a

266
00:15:45.670 --> 00:15:47.110
framework, and this is one
of the things I'm trying

267
00:15:47.110 --> 00:15:49.060
to accomplish with it, with
the framework series, I'm not

268
00:15:49.060 --> 00:15:51.130
sure if I'm doing it
yet though, is that I

269
00:15:51.130 --> 00:15:55.030
want to go and I
want to build my, you

270
00:15:55.030 --> 00:15:57.910
know, whatever my banking application
and I'm, I don't know

271
00:15:57.910 --> 00:15:59.770
if the Microsoft stuff is
going to work for me,

272
00:15:59.770 --> 00:16:02.170
but at the same time,
there might be a dozen

273
00:16:02.440 --> 00:16:06.190
opensource frameworks out there. I
could write something myself. I

274
00:16:06.190 --> 00:16:08.650
could use service deck. I
could use something else. I

275
00:16:08.650 --> 00:16:10.690
could use a combination of
all of them. Is it

276
00:16:10.690 --> 00:16:14.920
just trial and error or
are benchmarks enough? I mean,

277
00:16:14.920 --> 00:16:18.640
you had to have sat
down and done some analysis

278
00:16:19.480 --> 00:16:22.000
and really made a strong
case for yourself to go

279
00:16:22.000 --> 00:16:23.500
and write a lot of
this code that you've written.

280
00:16:23.710 --> 00:16:26.560
You couldn't have just done
it because you wanted it

281
00:16:26.560 --> 00:16:30.220
to be your code. Absolutely.
I know I spent two

282
00:16:30.220 --> 00:16:32.020
years at the BBC as
a technical architect, and I

283
00:16:32.020 --> 00:16:35.260
actually had to work on
some really heavy SOA like

284
00:16:35.260 --> 00:16:38.860
systems. And we did use,
we were a heavy usage

285
00:16:38.860 --> 00:16:43.510
of WCF and there was
actually a, the, the first

286
00:16:43.840 --> 00:16:48.160
SOA platform promoted by Microsoft
was called CSF. It was

287
00:16:48.160 --> 00:16:51.850
actually an unmitigated disaster. It
was actually quite a huge,

288
00:16:52.030 --> 00:16:54.160
it was the wrong tool
for the job way over

289
00:16:54.160 --> 00:16:56.980
complex. And basically most of
the teams was like a

290
00:16:56.980 --> 00:17:00.190
10, 12 man team, but
for like six years just

291
00:17:00.190 --> 00:17:03.910
fighting the framework. And, and
we're all following like proper

292
00:17:03.940 --> 00:17:09.280
design principles. We're all into,
into enterprise integration patterns, very,

293
00:17:09.500 --> 00:17:15.610
very solid, very pro developer
teams. And we were basically

294
00:17:15.760 --> 00:17:19.360
constantly fighting the frameworks. So
having got all this experience

295
00:17:19.360 --> 00:17:22.390
about how to build, how
to build web services, what

296
00:17:22.390 --> 00:17:25.000
the correct API should be,
what the correct patterns are.

297
00:17:25.030 --> 00:17:28.120
And, and, and I believe
the, the best patents on

298
00:17:28.120 --> 00:17:30.520
how to build web services,
actually from a Martin Fowler

299
00:17:30.520 --> 00:17:35.080
camp, he's actually wrote some
really nice, the simple patterns

300
00:17:35.080 --> 00:17:40.420
that promote a reasonable services.
And I feel like they're

301
00:17:40.420 --> 00:17:44.080
the ones we probably should
be imitating. And, and so

302
00:17:44.170 --> 00:17:46.030
I didn't actually find that
obviously, if we spent too

303
00:17:46.030 --> 00:17:49.470
much time finding the framework,
so it was very rigid.

304
00:17:49.800 --> 00:17:53.040
It's, it's kind of, it
goes against what the core

305
00:17:53.040 --> 00:17:57.000
essence of a service be,
which is interoperable and, you

306
00:17:57.000 --> 00:18:01.170
know, accessible many clients, not
just clients that are, have

307
00:18:01.170 --> 00:18:04.170
it, not just so clients,
for instance, that you get

308
00:18:04.170 --> 00:18:07.230
to participate in those sessions.
So, yeah, I haven't had

309
00:18:07.230 --> 00:18:09.000
a good idea of what
the framework should be. And

310
00:18:09.000 --> 00:18:11.790
I, there wasn't looking around,
there was nothing at that

311
00:18:11.790 --> 00:18:16.920
time. This was like about
five years ago. So when

312
00:18:16.920 --> 00:18:20.160
I first started, we first
started surf stack and it's

313
00:18:20.160 --> 00:18:23.550
been, it's been like right
up since like major productivity

314
00:18:23.550 --> 00:18:26.160
when it's just, just following
some really simple designs and

315
00:18:26.190 --> 00:18:28.320
really simple things. I don't
like, there's no coaching, there's

316
00:18:28.320 --> 00:18:31.290
no build steps. It's just,
everything's based on clean models,

317
00:18:31.320 --> 00:18:34.830
the frame, instead of inventing
an artificial API, I actually

318
00:18:34.830 --> 00:18:37.560
had the framework bind to
your models. So basically empowers

319
00:18:37.560 --> 00:18:39.510
your model. So it's like
the, the, the API is

320
00:18:39.510 --> 00:18:42.300
invisible. It's much easier to
work with much more productive,

321
00:18:42.360 --> 00:18:46.200
multiple testable. And, and, and
basically it's just a massive

322
00:18:46.200 --> 00:18:48.690
win for myself and all
the products and all the

323
00:18:49.590 --> 00:18:51.330
assistance of, of, of put
it to work in over

324
00:18:51.330 --> 00:18:54.450
the years. So it's, it's,
it's basically a matter of

325
00:18:54.450 --> 00:18:57.570
experience being, being heard, what
we call that first implementers

326
00:18:57.570 --> 00:19:00.780
pain. Having worked with a
lot of external technologies as

327
00:19:00.990 --> 00:19:04.200
an ex Java developer for
many years, got, got to

328
00:19:04.200 --> 00:19:06.810
use a lot of message
cues and other present squishy

329
00:19:06.810 --> 00:19:10.920
patents that basically in many
cases are usually better fit

330
00:19:10.920 --> 00:19:14.190
than web services as well.
And, and yeah, so I've

331
00:19:14.190 --> 00:19:16.470
got a lot of exposure
to a lot of technology

332
00:19:17.070 --> 00:19:20.370
kind of phoned in my
opinion, what the best, what

333
00:19:20.370 --> 00:19:22.860
the best way it is
to, to develop a, a

334
00:19:23.130 --> 00:19:26.790
kind of Sol like systems
and basically built a framework

335
00:19:26.790 --> 00:19:30.740
that promotes that idea. So,
yeah. So trying to, I

336
00:19:30.740 --> 00:19:32.930
mean, forgive me to kind
of harp on this point,

337
00:19:32.930 --> 00:19:36.590
but I want to make
sure I understand that the

338
00:19:36.590 --> 00:19:39.260
kinds of thinking and the
kinds of tools that someone

339
00:19:39.650 --> 00:19:42.040
who is trying to decide
what framework to use or

340
00:19:42.170 --> 00:19:45.710
is trying to write their
own framework should use to,

341
00:19:45.800 --> 00:19:47.630
to make a decision you
were saying that you looked

342
00:19:47.630 --> 00:19:50.360
at at Fowler, and you
looked at some patterns that

343
00:19:50.360 --> 00:19:53.270
were appropriate for deciding as
well as it sounds like

344
00:19:53.300 --> 00:19:57.500
suffering. If I may use
that term with existing frameworks,

345
00:19:57.500 --> 00:19:59.540
that just simply weren't cutting
it. And I'm trying to

346
00:19:59.540 --> 00:20:03.440
understand, should someone immediately assume
that an existing framework is

347
00:20:03.440 --> 00:20:05.240
not going to work for
them, or should they go

348
00:20:05.240 --> 00:20:08.330
and do the work abstract
away, the pieces that aren't

349
00:20:08.330 --> 00:20:13.490
working and swap in entire
subsystems. And, and at what

350
00:20:13.490 --> 00:20:16.160
level, because I, at the
beginning of the talk we

351
00:20:16.160 --> 00:20:20.300
started looking at, you've got
a text manipulation and serialization

352
00:20:20.300 --> 00:20:23.210
library, and that is separate
and downloadable from the caching

353
00:20:23.210 --> 00:20:25.520
one, which is separate in
that little, from these other

354
00:20:25.520 --> 00:20:29.750
ones. D do you create
your systems in that way

355
00:20:29.750 --> 00:20:31.190
where you, you, you say,
you know, I have a

356
00:20:31.190 --> 00:20:33.200
hunch that serialization is going
to be an issue, so

357
00:20:33.200 --> 00:20:35.390
I'm going to make sure
that that is all done

358
00:20:35.600 --> 00:20:38.150
and factored out such that
I can swap in and

359
00:20:38.150 --> 00:20:41.690
out trivially, any number of
libraries and then, you know,

360
00:20:41.690 --> 00:20:46.820
fail fast. Yep. So, yeah,
so I think in every

361
00:20:46.820 --> 00:20:49.780
time, make a massive technology
choice. You should prototype with

362
00:20:49.810 --> 00:20:52.240
the, with the, you should
pick a, a handful of

363
00:20:52.240 --> 00:20:55.300
primary mix that you're evaluating
and definitely prototype solutions with

364
00:20:55.300 --> 00:20:57.970
it. I think that's the
best way to actually work

365
00:20:57.970 --> 00:20:59.560
out if it's going to
be the best fit for

366
00:20:59.560 --> 00:21:02.830
you in terms of how
sort of steak has evolved.

367
00:21:03.070 --> 00:21:09.280
I've basically used all, like
originally used the d.net.net data

368
00:21:09.280 --> 00:21:12.190
contract, Jason sterilizer. But, but
once I did the benchmark,

369
00:21:12.550 --> 00:21:14.230
because this is when I
was working at implant where

370
00:21:14.410 --> 00:21:16.400
we actually try to try
to chase down every waste

371
00:21:16.460 --> 00:21:20.110
moon second, for instance. And,
and so, so for instance,

372
00:21:20.110 --> 00:21:22.870
these were actually problems with
existing tools. So for the

373
00:21:22.870 --> 00:21:27.250
Jason sterilizer, we wanted to
get instant response times. We

374
00:21:27.250 --> 00:21:29.440
were benchmarked with the residual
is where we were actually

375
00:21:29.440 --> 00:21:32.890
quite said to learn that
Jason was actually a lot

376
00:21:32.890 --> 00:21:35.980
slower than, well, it was
a slow than XML and

377
00:21:35.980 --> 00:21:38.350
w and that we need,
that was just not meant

378
00:21:38.350 --> 00:21:42.310
to be. And so we
basically created Jason sterilizer for

379
00:21:42.310 --> 00:21:44.290
that, because we knew that
was, there was a lot

380
00:21:44.290 --> 00:21:47.950
of wasted CPU cycles there.
And for the caching, because

381
00:21:47.950 --> 00:21:51.940
Keisha should be a first
class concept, especially in high

382
00:21:51.940 --> 00:21:55.270
performance systems. And at the
moment the, the mandate to

383
00:21:55.270 --> 00:21:58.960
use XML config is, and,
and it's kinda, it's kind

384
00:21:58.960 --> 00:22:02.200
of crippling in that you
can't integrate it inside your,

385
00:22:03.070 --> 00:22:06.700
we call domain-driven services as
a first class concept because

386
00:22:06.700 --> 00:22:11.500
it becomes it doesn't, it's
not as testable. And, and

387
00:22:11.530 --> 00:22:13.720
basically we just wanted to
clean implantation the way we

388
00:22:13.720 --> 00:22:18.430
could swap out a medication,
redness or fall a dispatch

389
00:22:18.440 --> 00:22:22.750
solution and creating our own
API, which has a clean,

390
00:22:22.750 --> 00:22:26.570
unimpeded interface is, was the
best solution for us. And

391
00:22:26.590 --> 00:22:30.750
it's just adapters to existing
frameworks. We, we, we were

392
00:22:30.750 --> 00:22:33.730
originally using memcache, but then
Rutgers came on the scene

393
00:22:33.730 --> 00:22:36.100
and read us is just
like medication steroids. It has,

394
00:22:36.170 --> 00:22:40.450
it's kind of like a
really elegant, no SQL data

395
00:22:40.450 --> 00:22:43.660
store solution. It's distributed. It's,
it's perfectly written in terms

396
00:22:43.660 --> 00:22:46.840
of like max for maximum
efficiency. It's a single process

397
00:22:46.840 --> 00:22:49.450
like, like my JS, it
runs on a single event

398
00:22:49.450 --> 00:22:52.630
loop, and it basically hosts
a calm side data structures.

399
00:22:52.690 --> 00:22:55.480
And I find that is
extremely elegant because you get

400
00:22:55.480 --> 00:22:59.500
to use the data. The
dustiest is you're familiar with

401
00:22:59.530 --> 00:23:02.350
in your, in your program,
but in a distributed way.

402
00:23:02.350 --> 00:23:04.570
So it was a, it
was a really elegant solution

403
00:23:04.650 --> 00:23:07.480
that way without, cause you
can actually leverage to do

404
00:23:07.480 --> 00:23:09.070
a lot of things like
a lot of live lists

405
00:23:09.070 --> 00:23:12.900
that were using it. Our
start up was, was we

406
00:23:12.900 --> 00:23:18.070
were taking advantage of versus
data structures. And because@thetimetherewasno.net client

407
00:23:18.070 --> 00:23:20.230
sport. Well, we, we took
the, we took the head

408
00:23:20.230 --> 00:23:23.110
of well, cause it's quite
cool. It's quite simple. There

409
00:23:23.110 --> 00:23:25.270
were Miguel had one, but
it was, it was very

410
00:23:25.270 --> 00:23:28.060
a thin wrapper around it.
And, and I decided to

411
00:23:28.060 --> 00:23:29.680
make one more of an
hour M so we can,

412
00:23:30.340 --> 00:23:36.550
it was so the <inaudible>
that's in service stacks is

413
00:23:36.880 --> 00:23:40.030
in ships with three clients.
It has a bite, a

414
00:23:40.030 --> 00:23:42.310
bite only client, which is
a very one-to-one mapping with

415
00:23:42.340 --> 00:23:45.530
the reddest layer. And then
it has a string ETA

416
00:23:45.830 --> 00:23:48.920
for UTF eight strings and
then types poker client. So

417
00:23:48.920 --> 00:23:52.820
it becomes very easy to
deal with generic types as

418
00:23:53.030 --> 00:23:56.360
a claim playing poker. So
once you're at that level,

419
00:23:56.360 --> 00:23:59.420
you actually can do a
lot of functionality with liberal

420
00:23:59.420 --> 00:24:01.880
code cause dealing with complex
types and we hide all

421
00:24:01.880 --> 00:24:07.040
the serialization obstructions away for
you. So, yeah, that was

422
00:24:07.040 --> 00:24:08.660
the, kind of the reason
why we, we originally did

423
00:24:08.660 --> 00:24:10.790
it, but the first kind
of service tech was using

424
00:24:11.810 --> 00:24:15.620
the existing lactose Jason data
contract sterilizer. It was using

425
00:24:15.950 --> 00:24:21.110
memcache using with the asp.net
cation provider. And it was

426
00:24:21.110 --> 00:24:25.310
using ISP dot sessions. But
over time, we've, we've basically

427
00:24:25.310 --> 00:24:27.890
abstracted that out and, and
got to where we are

428
00:24:27.890 --> 00:24:31.600
today. Yeah. So it sounds
like you, you started saying,

429
00:24:31.600 --> 00:24:34.150
I want to make some
clean Jason services on top

430
00:24:34.150 --> 00:24:38.620
of my existing domain model.
Yep. And things kind of

431
00:24:39.160 --> 00:24:43.630
got more and more complicated
and your requirements for performance

432
00:24:43.630 --> 00:24:47.290
were greater and greater. And
then you started factoring things

433
00:24:47.290 --> 00:24:50.650
out and service stack grew
up out of that. Serialization

434
00:24:50.650 --> 00:24:54.550
became a problem. Cashing became
a problem, et cetera. Yeah.

435
00:24:54.700 --> 00:24:59.020
In terms of we were
chasing down every, every inefficiency

436
00:24:59.020 --> 00:25:01.300
basically. So we know, we
know we looked at the

437
00:25:01.300 --> 00:25:02.560
end result and I feel
like this is like the

438
00:25:02.560 --> 00:25:05.020
Google approach as well, where
they actually look at the,

439
00:25:05.130 --> 00:25:08.470
the end result and find
out what's the quickest way

440
00:25:08.470 --> 00:25:10.630
to get there. And what's
the most efficient delivery what's

441
00:25:10.630 --> 00:25:13.150
the most deployment. So if
you look at their, how

442
00:25:13.150 --> 00:25:16.930
they deploy their single page
applications, Gmail and Google Madison,

443
00:25:16.960 --> 00:25:20.140
and that, and that like
is actually very, they're a

444
00:25:20.180 --> 00:25:23.590
development story where they they've
mentored the speedy protocol, they

445
00:25:23.590 --> 00:25:27.460
admitted the protocol buffers just
because they're the best performance

446
00:25:27.490 --> 00:25:31.030
solutions to get to the
end result. And so we

447
00:25:31.030 --> 00:25:34.060
were basically following that path,
whereas, okay, what's the fastest

448
00:25:34.060 --> 00:25:38.050
way to, to deliver this,
this, like these services. And

449
00:25:38.050 --> 00:25:40.210
we're like, okay, we need
Acacia. Okay. We need cashing

450
00:25:40.210 --> 00:25:42.010
it. And we want, rather
than what's the, what's the

451
00:25:42.010 --> 00:25:46.090
most efficient use of casing.
And it's like, <inaudible> instead

452
00:25:46.090 --> 00:25:49.090
of like, based on time,
because time is a, you

453
00:25:49.090 --> 00:25:51.610
don't get the best results.
You don't, you can get

454
00:25:51.610 --> 00:25:54.760
stale cases back. And, and
this is why we want

455
00:25:54.770 --> 00:25:57.550
to make casing first class
concept because in our domain

456
00:25:57.550 --> 00:26:01.690
model, it actually said as
a database shield where we

457
00:26:01.690 --> 00:26:04.720
were getting 90% hit cash
hits for a night and

458
00:26:04.810 --> 00:26:07.870
upwards of that. And so
every time we S we

459
00:26:07.870 --> 00:26:10.180
kind of say that the
domain model, we would invalidate

460
00:26:10.180 --> 00:26:11.860
the case and we'd know
exactly what cases we would

461
00:26:11.860 --> 00:26:14.770
need to invalidate. So basically
what we were having is

462
00:26:14.770 --> 00:26:18.160
we're serving our datasets straight
from Sage, straight from Reddits.

463
00:26:19.090 --> 00:26:22.060
Yeah. So, so in the
end, we, we basically looked

464
00:26:22.060 --> 00:26:24.580
at what were, what our
requirements were and work backwards

465
00:26:24.580 --> 00:26:26.710
as like, okay, now we're
going to have zip layer.

466
00:26:26.710 --> 00:26:30.460
We're going to have, or
a deflate stream. It's going

467
00:26:30.460 --> 00:26:32.770
to be caged. And the,
the actual work. So it's

468
00:26:32.770 --> 00:26:35.210
what service locations is the
one line, right? And it

469
00:26:35.300 --> 00:26:39.160
will actually catch the deflated
version if your browser supports

470
00:26:39.160 --> 00:26:42.100
it of, of the Jason
payload or the, or whatever

471
00:26:42.100 --> 00:26:44.940
end point you're hitting, you
actually get that the final

472
00:26:44.940 --> 00:26:48.360
output case into the reddest
or what a vacation provider

473
00:26:48.360 --> 00:26:50.670
is. And that gets written
directly to the response stream.

474
00:26:50.670 --> 00:26:53.910
So this is like closest
to the pretty, the fuss

475
00:26:53.930 --> 00:26:57.870
where you can serve a,
a web service response in,

476
00:26:58.830 --> 00:27:02.340
in, in Indonesia, in managed
code. And that's kind of

477
00:27:02.340 --> 00:27:04.200
where that's where we, where
we've got to. So we

478
00:27:04.200 --> 00:27:06.180
work our way back. We
work that way, the efficient

479
00:27:06.180 --> 00:27:10.160
inefficiencies, where, and, and, and
basically code will diminish. So

480
00:27:10.160 --> 00:27:14.600
are you using the protocol
buffers technique for communication, you

481
00:27:14.600 --> 00:27:16.910
know, in between tiers, within
your own stuff, and then

482
00:27:16.910 --> 00:27:19.880
you use Jason sterilization when
you kind of exit the

483
00:27:19.880 --> 00:27:25.160
service layer? No, we, we
use Regisford. So w when

484
00:27:25.160 --> 00:27:29.120
we talked to Reddit's, we're
talking to w w we

485
00:27:29.120 --> 00:27:35.000
basically use a D the
Jason's, the JSP survivor I've

486
00:27:35.000 --> 00:27:37.580
invented my own format, which
is quite slightly quicker than

487
00:27:38.000 --> 00:27:40.550
it's quite slightly quicker and
more compact than Jason, because

488
00:27:40.550 --> 00:27:42.680
it uses a CSP, the
style escaping, which actually a

489
00:27:42.680 --> 00:27:47.000
bit more performance than, than
Jason in coding. And we

490
00:27:47.000 --> 00:27:50.030
use that for.net.net services. Cause
it's actually more, a lot

491
00:27:50.030 --> 00:27:53.990
more malleable. So it, I
believe we're about maybe it's

492
00:27:54.110 --> 00:27:56.330
twice as slow as protocol
buffers, maybe a bit more,

493
00:27:56.360 --> 00:27:58.910
but, but what you gain
in vision ability and resilience

494
00:27:58.910 --> 00:28:01.790
of your obvious services and
being able to actually debug

495
00:28:01.790 --> 00:28:04.910
it and, and a version
of a time that is,

496
00:28:05.000 --> 00:28:07.280
is, is something we were,
it was a trade off

497
00:28:07.280 --> 00:28:10.640
we made. So yeah, it
done, it's done and services.

498
00:28:10.640 --> 00:28:14.540
We basically the JSP, which
is the quickest tech serializer.

499
00:28:14.720 --> 00:28:17.420
So I'm confused on when
is the protocol buffers used?

500
00:28:18.020 --> 00:28:19.570
Oh, we don't actually use
it all you don't use.

501
00:28:19.580 --> 00:28:23.750
So you support them. No
stack overflow supports it as

502
00:28:23.750 --> 00:28:26.720
a, as a benchmark, as
protocol buffers was in the

503
00:28:26.720 --> 00:28:30.790
benchmark, but it's not in
service stack. It's a, it's

504
00:28:30.800 --> 00:28:32.900
like an anchor to say
what the fastest sterilizer is.

505
00:28:34.940 --> 00:28:38.060
I see. So protocol buffers
is known to be the

506
00:28:38.060 --> 00:28:40.610
fastest way to serialize something
because of the it's currently.

507
00:28:40.610 --> 00:28:44.480
Cause it's just so very
light, Very light, very efficient.

508
00:28:44.510 --> 00:28:47.450
And Mark has a, has
a really great implementation of

509
00:28:47.450 --> 00:28:50.000
it and Google at the
Y format. And it does

510
00:28:50.000 --> 00:28:52.250
some really neat tricks to
get it really, really, really

511
00:28:52.250 --> 00:28:55.760
small and really fast. Huh.
Interesting. Okay. So what do

512
00:28:55.760 --> 00:28:57.740
you think about service stack
as it relates to the

513
00:28:57.740 --> 00:29:00.290
WCF web API stuff that's
coming out and how should

514
00:29:00.290 --> 00:29:03.050
people, when people are considering
making their own services, where

515
00:29:03.050 --> 00:29:04.970
should they look at where
your things fit and where

516
00:29:04.970 --> 00:29:08.930
the new stuff fits? Okay.
So the web API, they've

517
00:29:08.930 --> 00:29:15.170
got this heavy rest focus,
and I think they, I

518
00:29:15.170 --> 00:29:17.330
mean, I think it's a
lot, it's a, it's a

519
00:29:17.330 --> 00:29:21.800
massive step over WCF and,
and, and, and hopefully WCF

520
00:29:21.800 --> 00:29:29.600
swipe services weed itself out.
I, I probably have different

521
00:29:29.600 --> 00:29:32.870
concerns because I, as in,
they might want to take

522
00:29:33.040 --> 00:29:34.940
every use case where I
would like to provide an

523
00:29:34.940 --> 00:29:37.190
API that's kind of expressive.
So for instance, I will

524
00:29:37.190 --> 00:29:39.890
have a API to return
a dictionary of strings and

525
00:29:39.890 --> 00:29:41.650
that, and there will be
an HP header. I won't

526
00:29:41.650 --> 00:29:44.680
have strong. I went, I'll
have some strong type constants

527
00:29:44.740 --> 00:29:47.470
to indicate the HTP header
name, but I will, I

528
00:29:47.560 --> 00:29:50.140
I'll, I'll leave a very
thin open API that you

529
00:29:50.140 --> 00:29:54.370
can actually return create any
customer HB head, as you

530
00:29:54.370 --> 00:29:59.080
want. I'm more concerned about
being really productive and in

531
00:29:59.080 --> 00:30:02.170
terms of you create models
and every other model will,

532
00:30:03.130 --> 00:30:05.470
the entire framework will actually
bind to your models. So

533
00:30:05.470 --> 00:30:08.080
it's kind of like empowering
your models is completely code

534
00:30:08.080 --> 00:30:11.560
first driven. And it's very
fast as a, as a,

535
00:30:11.560 --> 00:30:14.830
as a key requirement. And
it's all solid design principles

536
00:30:14.980 --> 00:30:18.550
straight through, or your rate,
your service in spaces and

537
00:30:18.790 --> 00:30:21.760
only need to implement like
a single interface that influence

538
00:30:21.820 --> 00:30:26.090
that lives in an interface
implementation free assembly. So I,

539
00:30:26.090 --> 00:30:30.250
I try to keep things
oddly, testable, but basically I

540
00:30:30.250 --> 00:30:33.010
try to be as productive
as possible. I'm more, I'm

541
00:30:33.010 --> 00:30:37.900
more interested in, so the,
the Fowler patterns in, in

542
00:30:37.900 --> 00:30:40.470
how to design remote services,
which is using core screamed,

543
00:30:40.470 --> 00:30:45.970
bashful interfaces, dittos, strong, tight,
generic clients, and, and, and

544
00:30:45.970 --> 00:30:48.370
basically empowering that model, make
it really productive. And I've

545
00:30:48.370 --> 00:30:51.790
got neat features like your
HTML view. We'll, we'll we'll,

546
00:30:52.330 --> 00:30:54.730
if you call your web
services through the HTML browser,

547
00:30:54.890 --> 00:30:58.720
you'll get an automatically, you
get a human readable view

548
00:30:58.720 --> 00:31:00.610
of your sort of status.
So if you return a

549
00:31:00.610 --> 00:31:03.070
list of pocos, you'll get
the sortable haste milk table

550
00:31:03.070 --> 00:31:05.470
view, and it makes it
much easier to visualize your

551
00:31:05.470 --> 00:31:07.540
services. And I do that
because that's part of the

552
00:31:07.840 --> 00:31:10.480
development cycle. So I just
try to be as iterative,

553
00:31:10.750 --> 00:31:16.120
lead, productive as possible. And,
and with a performance focus,

554
00:31:16.120 --> 00:31:19.600
I feel like there is
a different focus, but, you

555
00:31:19.600 --> 00:31:22.650
know, it's, WCFA web APS
is much better than the

556
00:31:22.660 --> 00:31:26.110
previous things as it was
before. I haven't actually done

557
00:31:27.030 --> 00:31:29.200
many benchmarks with it yet,
but there is someone who's

558
00:31:29.200 --> 00:31:31.600
putting the so stack example
projects, and that's probably a

559
00:31:31.600 --> 00:31:34.240
good, a good place to
look for for the differences

560
00:31:34.450 --> 00:31:36.940
between the two. I should,
I should give a link

561
00:31:36.940 --> 00:31:39.730
to you to Atlanta, but
someone's actually porting the, all

562
00:31:39.750 --> 00:31:42.250
the sort of tech example
projects across just so actually

563
00:31:42.250 --> 00:31:44.890
give a good comparison between
the two. So maybe it's

564
00:31:44.890 --> 00:31:47.500
a good, that'd be probably
the best way to, for

565
00:31:47.500 --> 00:31:50.880
people to identify between the
two. Yeah. Yes, definitely. If

566
00:31:50.880 --> 00:31:52.470
you've got a series of
links that you can give

567
00:31:52.470 --> 00:31:53.970
us, we'll put them all
in the show links and

568
00:31:53.970 --> 00:31:55.740
people can check it out
and they can go up

569
00:31:55.740 --> 00:31:58.320
to service stack.net, and they
can also click on showcases

570
00:31:58.320 --> 00:32:01.620
and see examples of websites
that are using service stack.

571
00:32:01.650 --> 00:32:04.410
And there's lots and lots
of good stuff up on

572
00:32:04.410 --> 00:32:07.470
the site, including benchmarks. They
can download the code up

573
00:32:07.470 --> 00:32:09.510
there or they can get
it from a, from nugget

574
00:32:09.510 --> 00:32:11.460
and you've got packages that
will get them started in

575
00:32:11.460 --> 00:32:15.570
NBC or asp.net right away.
Yep. That's correct. Yep. I

576
00:32:15.600 --> 00:32:17.490
probably, then you get, might
be the quickest way to

577
00:32:17.730 --> 00:32:19.940
get started because it's a,
and it gets done in

578
00:32:19.940 --> 00:32:22.080
a really good thing. I
think for open source in

579
00:32:22.080 --> 00:32:24.510
general, it makes it comes
to get us a little

580
00:32:24.510 --> 00:32:27.840
bit of a gateway into
vs.net, which, which was, I

581
00:32:27.840 --> 00:32:31.380
think was a lot of
Dunham projects were suffering because

582
00:32:31.380 --> 00:32:34.170
of the disconnect. Yeah, absolutely.
And then hopefully in the

583
00:32:34.170 --> 00:32:36.900
future, sometime people will be
able to go file new

584
00:32:37.440 --> 00:32:39.770
service stack project, or maybe
add service stack to an

585
00:32:39.770 --> 00:32:42.230
existing project in a, in
a really, really friendly kind

586
00:32:42.230 --> 00:32:44.360
of so easy it's as
easy as falling off a

587
00:32:44.360 --> 00:32:47.610
log kind of a way.
Yeah. Yeah. I, I, again,

588
00:32:47.610 --> 00:32:51.580
I, I, I think there's
a danger that you're, I

589
00:32:51.580 --> 00:32:54.250
do think some sort of
templates is okay, but being

590
00:32:54.250 --> 00:32:58.240
code first it's I do
prefer that model and I

591
00:32:58.240 --> 00:33:01.510
will try not to cater
too much for the designer

592
00:33:01.510 --> 00:33:03.580
driven kind of stuff, because
it is like if you

593
00:33:03.580 --> 00:33:06.280
use ReSharper, it's just infinitely
quicker to write a class,

594
00:33:06.340 --> 00:33:09.220
we factor into the new
file and then, and credit

595
00:33:09.220 --> 00:33:11.650
service off that. And it's
just like take seconds to

596
00:33:11.650 --> 00:33:14.170
build a service and deploy
it and run it. And

597
00:33:14.170 --> 00:33:16.510
I just find that. So
I'm not, I'm not too

598
00:33:18.310 --> 00:33:22.330
concerned about making it palatable
for new new developers. I'm

599
00:33:22.390 --> 00:33:25.690
more concerned about making a
really great productive option for

600
00:33:25.690 --> 00:33:29.320
existing developers. So not, not
trying to be too impeded

601
00:33:29.320 --> 00:33:33.580
by can we design constraints
for instance. Very cool. Well,

602
00:33:33.580 --> 00:33:35.050
thanks a lot for talking
to me. I appreciate it.

603
00:33:35.710 --> 00:33:38.110
Cheers. Thanks Scott. Thanks for
that, man. All right, everyone

604
00:33:38.110 --> 00:33:40.720
can check that out. Service
stack.net. This has been another

605
00:33:40.720 --> 00:33:43.480
episode of Hansel minutes, and
we'll see you again next

606
00:33:43.480 --> 00:33:43.750
week.


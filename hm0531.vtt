WEBVTT FILE

1
00:00:00.420 --> 00:00:03.540
Hi, this is Scott. I
really appreciate our sponsors because

2
00:00:03.540 --> 00:00:06.870
they make the show possible.
Today's show is sponsored by

3
00:00:06.870 --> 00:00:11.160
Tellerik create compelling app experiences
across any screen with the

4
00:00:11.160 --> 00:00:15.990
Tellerik platform Telerx end to
end platform. Uniquely combines industry

5
00:00:15.990 --> 00:00:19.680
leading UI tools with cloud
services to simplify the entire

6
00:00:19.680 --> 00:00:24.180
app development cycle Tellerik offers
everything.net developers need to build

7
00:00:24.180 --> 00:00:33.600
quality apps faster. Try it
free at tellerik.com/platform that's tellerik.com/platform

8
00:00:46.860 --> 00:00:52.800
from hanselminutes.com. It's Hansel minutes,
our weekly discussion with web

9
00:00:52.800 --> 00:00:57.930
developer and technologist Scott Hanselman.
This is Lawrence Ryan announcing show

10
00:00:57.930 --> 00:01:02.730
number 531. In this episode,
Scott talks with Gina Marie

11
00:01:02.730 --> 00:01:10.380
Miami about functional programming with
O'Connell. Hi, this is Scott

12
00:01:10.380 --> 00:01:13.020
Hanselman. This is another episode
of Hansel minutes today. I'm

13
00:01:13.020 --> 00:01:16.770
talking with Gina Marie Miami,
who is a functional programmer

14
00:01:17.130 --> 00:01:18.960
and not just a functional
program with probably the most

15
00:01:18.960 --> 00:01:21.960
passionate functional program I've ever
met. I met you at

16
00:01:21.960 --> 00:01:27.130
Oz con and you were
overflowing with functional programming. I

17
00:01:27.200 --> 00:01:30.890
think that's a common narrative
of anyone who does functional

18
00:01:30.890 --> 00:01:34.340
programming for any nontrivial amount
of time, is that you

19
00:01:34.340 --> 00:01:37.190
just have to share the
love Really. I mean, is

20
00:01:37.460 --> 00:01:39.980
what maybe I've been doing
it wrong for the last

21
00:01:39.980 --> 00:01:43.610
20 years. I mean, you
were like, like, you know,

22
00:01:43.610 --> 00:01:46.520
have you heard the news,
have you accepted Oak camel

23
00:01:46.580 --> 00:01:53.330
as your personal programming language?
I I'm very evangelical. Let's

24
00:01:53.330 --> 00:01:55.640
put it that way. I
I'm a born again. Okay.

25
00:01:55.640 --> 00:02:02.690
I'm I, I did Java
script development for probably too

26
00:02:02.750 --> 00:02:05.990
long, which I guess was,
you know, three years or

27
00:02:05.990 --> 00:02:11.060
whatever. And, you know, just,
just felt like things were

28
00:02:11.060 --> 00:02:13.970
too hard. I couldn't reason
about all the state in

29
00:02:13.970 --> 00:02:17.150
my program. I couldn't, I
couldn't know where bugs would

30
00:02:17.150 --> 00:02:21.220
be. I wrote unit tests,
unit tests didn't do anything

31
00:02:21.220 --> 00:02:25.550
good. And I just decided
one day that I was

32
00:02:25.550 --> 00:02:28.730
going to do something different
and saw someone using a

33
00:02:28.740 --> 00:02:33.200
camel and decided this looked
reasonable, this looked like something

34
00:02:33.200 --> 00:02:36.290
I could do. And I
had tried, you know, Haskell

35
00:02:36.290 --> 00:02:40.400
I think is probably the
most common hacker news trendy,

36
00:02:40.400 --> 00:02:43.970
functional language. I tried Haskell
and kind of felt like

37
00:02:43.970 --> 00:02:47.270
I wasn't was missing a
punchline maybe. I mean, it

38
00:02:47.270 --> 00:02:49.370
seemed a little bit too
hard. It seemed like for

39
00:02:49.370 --> 00:02:52.580
someone who didn't have a
computer science background, you know,

40
00:02:52.880 --> 00:02:55.970
all of these higher kind
of types, you know, monads

41
00:02:55.970 --> 00:03:00.070
galore, you know, I was
really, really lost. So Campbell

42
00:03:00.070 --> 00:03:04.210
was a really good balance
pragmatism and you know, really

43
00:03:04.210 --> 00:03:07.330
beautiful abstraction. So I guess
it's, you know, it's a,

44
00:03:07.360 --> 00:03:11.190
it's a, it's a pragmatic
language. Do you, you know,

45
00:03:11.190 --> 00:03:13.830
some people say that they
look for the programming language

46
00:03:13.830 --> 00:03:16.290
of their soul and you
know, they find it and

47
00:03:16.290 --> 00:03:18.240
it's just like, ah, this
is what I'm supposed to

48
00:03:18.240 --> 00:03:21.450
be programming in. Do you
think you came pre-wired this

49
00:03:21.450 --> 00:03:24.090
way? Did you come out
immediately wired for O'Connell and

50
00:03:24.090 --> 00:03:27.540
didn't know it? Or did
you wire yourself into O'Connell

51
00:03:29.970 --> 00:03:35.370
People who have, that's a
good question. You know, I

52
00:03:35.370 --> 00:03:37.980
had, I hadn't heard that
before, but I like that

53
00:03:37.980 --> 00:03:40.920
metaphor of your soul being,
you know, I don't know.

54
00:03:41.550 --> 00:03:45.390
I think if I was
a programming language, I don't

55
00:03:45.390 --> 00:03:48.210
know, maybe I would be
like COBOL or something like,

56
00:03:48.900 --> 00:03:53.640
you know, imperative and, and
I don't know closeted in

57
00:03:53.640 --> 00:03:57.030
some way. I don't know,
but okay. Will seems unlike

58
00:03:57.030 --> 00:04:00.530
myself, it's a better self,
you know, it's a, Oh,

59
00:04:00.630 --> 00:04:03.750
camel lets you be your
best self. Maybe that's what

60
00:04:03.750 --> 00:04:07.680
it is. It does everything
I could ever want it

61
00:04:07.680 --> 00:04:13.110
to do. It's got like
it's multi paradigm. It compiles

62
00:04:13.110 --> 00:04:16.110
to byte code a compiles
and native code. It plays

63
00:04:16.110 --> 00:04:20.640
nice with C people even
have it running on arm,

64
00:04:20.670 --> 00:04:22.770
you know? I mean, it's,
it's all over the place

65
00:04:23.220 --> 00:04:27.930
and, and somehow, yeah, it's
like an academic language, but

66
00:04:27.960 --> 00:04:31.680
you know, it favors performance.
And as I've said, repeatedly

67
00:04:31.710 --> 00:04:35.220
pragmatism. So, so it's unlike
myself. I would say that

68
00:04:35.220 --> 00:04:39.090
I, I am not like,
okay, So tell me if

69
00:04:39.090 --> 00:04:41.700
this is right and walk
me through this for people

70
00:04:41.700 --> 00:04:44.940
who are, maybe can say
functional programming, but don't really

71
00:04:44.940 --> 00:04:48.120
know like what it is.
Is it true that if

72
00:04:48.120 --> 00:04:51.060
you take something like C
or C sharp or Java

73
00:04:51.870 --> 00:04:54.960
and you problem that you
want to solve, it's basically

74
00:04:54.960 --> 00:04:58.380
okay, computer, here are the
things you need to do

75
00:04:58.860 --> 00:05:01.980
in order to get the
answer for a problem. But

76
00:05:01.980 --> 00:05:04.950
with your functional programming language,
it's just more like, kind

77
00:05:04.950 --> 00:05:07.920
of like, what is the
essence of the problem mathematically

78
00:05:07.920 --> 00:05:11.460
and you figure it out
the computer. Yeah. That's, that's

79
00:05:11.460 --> 00:05:13.680
a good, I mean, you
know, I don't know what

80
00:05:13.680 --> 00:05:17.100
the official definition of functional
programming is. I'm only interested

81
00:05:17.100 --> 00:05:20.460
in yours because I want
the practitioner's perspective. Just, just

82
00:05:20.460 --> 00:05:23.280
as a user, you know,
I've read like, I think

83
00:05:23.280 --> 00:05:26.430
I did functional JavaScript, JavaScript
dollar and J you know,

84
00:05:26.430 --> 00:05:29.160
I've read all these like,
you know, functional JavaScript books.

85
00:05:30.060 --> 00:05:32.250
But now that I work
in a functional language, I

86
00:05:32.250 --> 00:05:37.170
guess I have some, some
more, how can I say

87
00:05:37.170 --> 00:05:43.020
this zealous opinions, I suppose
functional programming is thinking of

88
00:05:43.830 --> 00:05:47.370
data transformation. I guess that
would be, I just think

89
00:05:47.370 --> 00:05:52.200
about my programs differently. Almost
like, you know, it's yeah,

90
00:05:52.200 --> 00:05:54.660
it's very declarative. It's what
you, it's what you just

91
00:05:54.660 --> 00:05:57.680
said, Scott. It's like, you,
you think about what should

92
00:05:57.680 --> 00:06:00.110
this do at a high
level? I often find myself

93
00:06:00.140 --> 00:06:03.770
thinking about before I start
writing a program, what did

94
00:06:03.770 --> 00:06:05.660
it do? What do I
want this to do at

95
00:06:05.660 --> 00:06:08.660
the end of the day?
What it, what is, what

96
00:06:08.660 --> 00:06:12.170
am I talking about? And
whatever I'm talking about, those

97
00:06:12.170 --> 00:06:18.320
just become types. And then
I just transform things and

98
00:06:18.320 --> 00:06:21.920
value some, some data. And
that's basically what my program

99
00:06:21.920 --> 00:06:24.050
ends up being, which sounds
like I don't even know

100
00:06:24.050 --> 00:06:26.900
what I just said, but
that's, that's sort of, that's

101
00:06:26.900 --> 00:06:30.050
sort of what happens. It's
very different than do this,

102
00:06:31.610 --> 00:06:35.120
you know, manipulate this and
then you almost find your

103
00:06:35.120 --> 00:06:38.330
eye kind of going back
up in your program to

104
00:06:38.330 --> 00:06:41.720
like manipulate some previous thing.
Okay. Well, programs don't look

105
00:06:41.720 --> 00:06:44.690
like that. There are flow.
They, they really are just

106
00:06:44.960 --> 00:06:48.470
here's the world. Here's what
happens in this world. And

107
00:06:48.470 --> 00:06:52.460
then this is the result
and that's, I dunno, it's,

108
00:06:52.460 --> 00:06:55.250
it's it's it tends to
mirror human thought a little

109
00:06:55.250 --> 00:06:58.150
bit better. I think functional
programming, Right? You're building kind

110
00:06:58.150 --> 00:07:01.840
of a pipeline as you
move shapes and structures and

111
00:07:01.840 --> 00:07:05.770
data structures from one form
to another, without concern for

112
00:07:05.770 --> 00:07:09.820
a state and a state
changing randomly. Cause it doesn't

113
00:07:09.850 --> 00:07:16.480
count. Yeah, exactly. State doesn't
change randomly. Although Campbell is

114
00:07:16.480 --> 00:07:18.760
different than Haskell in the
way that it doesn't necessarily

115
00:07:18.760 --> 00:07:21.910
track States. So for example,
you could write a function

116
00:07:22.460 --> 00:07:24.310
and in the middle of
it, throw a print statement

117
00:07:24.310 --> 00:07:28.030
in there and you know,
that won't be nothing. That's

118
00:07:28.030 --> 00:07:31.300
fine. You know, that's that's,
you can do that, which

119
00:07:31.330 --> 00:07:36.460
again, you know, is, is
a more pragmatic approach because,

120
00:07:36.460 --> 00:07:38.560
you know, I enjoy being
able to put a random

121
00:07:38.560 --> 00:07:42.550
print statement in, in my
life, but, you know, I

122
00:07:42.550 --> 00:07:44.320
don't have, That would be
shocked if I would like

123
00:07:44.350 --> 00:07:46.360
who would, who would be
against that? That seems like

124
00:07:46.360 --> 00:07:49.300
a very noncontroversial thing to
want to do. Well, then

125
00:07:49.330 --> 00:07:51.730
you're printing to the outside
world. I mean, that's a

126
00:07:51.730 --> 00:07:54.340
trivial example, but you know,
you could do any sort

127
00:07:54.340 --> 00:07:58.270
of side effect in the
middle of your function that

128
00:07:58.270 --> 00:08:01.120
takes an in and returns
an end. And you know,

129
00:08:01.480 --> 00:08:03.400
the type system wouldn't know
any better. I mean, in,

130
00:08:03.400 --> 00:08:05.940
in, in terms of the
signature of the function, it's,

131
00:08:05.940 --> 00:08:09.520
it's unchanged. So that's, that's
a little bit, a little

132
00:08:09.520 --> 00:08:11.530
bit different. You couldn't quite
do that in Haskell. So

133
00:08:11.530 --> 00:08:14.260
it isn't exactly. I mean,
you still have to wear

134
00:08:14.260 --> 00:08:18.100
your, your conscious programmer hat,
but at the cost of,

135
00:08:18.970 --> 00:08:22.450
you know, I don't know,
it's convenient. I so far,

136
00:08:22.450 --> 00:08:26.800
I haven't really been burned
badly with that, but, you

137
00:08:26.800 --> 00:08:30.100
know, I suppose one could
be, So one of the

138
00:08:30.100 --> 00:08:33.760
things that makes things like
Ocala and functional programming languages

139
00:08:33.760 --> 00:08:37.090
like, Oh, camel safer and
correct me if I'm wrong

140
00:08:37.090 --> 00:08:39.160
because I'm just learning here.
Is it because it's a

141
00:08:39.160 --> 00:08:44.890
pass by value, functional programming
language Pass by value. I

142
00:08:44.890 --> 00:08:46.930
don't really know what that
means. Like as opposed to

143
00:08:46.930 --> 00:08:49.090
pass by reference, I can't
give you a reference to

144
00:08:49.090 --> 00:08:51.850
an integer and have you
mess with it. Mm. Actually

145
00:08:51.850 --> 00:08:54.820
you can and no camel.
So there's actually a keyword.

146
00:08:54.820 --> 00:08:56.850
Well, not a keyword. It's
actually just a function called

147
00:08:56.850 --> 00:09:01.650
ref, which makes something that
has a mutable value to

148
00:09:01.650 --> 00:09:03.330
it. So you could say,
you know, you could have

149
00:09:03.330 --> 00:09:06.720
a counter that is mutable,
so Campbell again, another, another

150
00:09:06.720 --> 00:09:09.390
trade off here, anytime you
want to make immutable data

151
00:09:09.390 --> 00:09:13.080
structure or something, something mutable
you can with explicitly with

152
00:09:13.080 --> 00:09:15.750
a keyword. So it's kind
of like, okay, you're the

153
00:09:15.750 --> 00:09:18.240
boss. If you want to
make this mutable, that's great.

154
00:09:18.240 --> 00:09:20.340
We're just going to represent
this in the type system

155
00:09:20.430 --> 00:09:24.540
and we're going to know
about it. So actually it's

156
00:09:24.540 --> 00:09:26.670
like when there is a
bug, you know exactly where

157
00:09:26.670 --> 00:09:28.940
to look, Oh, I was
going to ask you like,

158
00:09:28.940 --> 00:09:30.770
wait a second. I thought
we were talking about the

159
00:09:30.770 --> 00:09:33.320
magic of not having state
and side effects. And here

160
00:09:33.320 --> 00:09:37.280
you just said, well, there's
a, like, don't eat pork.

161
00:09:37.940 --> 00:09:41.390
If you do, here are
some great recipes. Well look,

162
00:09:41.390 --> 00:09:45.650
I think, you know, sometimes
an imperative solution makes sense.

163
00:09:45.680 --> 00:09:47.840
You know, so Kamal has
four loops. It has wild

164
00:09:47.840 --> 00:09:52.520
loops. It has mutable stuff.
You can have, you know,

165
00:09:53.060 --> 00:09:56.570
variable length arrays. I think.
So. I mean, you can,

166
00:09:56.570 --> 00:09:59.660
you can have these mutable
things. It's just a, it's

167
00:09:59.660 --> 00:10:02.090
just, you gotta wear your
big kid hat and know

168
00:10:02.090 --> 00:10:05.180
when to use them. So
sometimes, sometimes a four loop

169
00:10:05.210 --> 00:10:07.940
is a good solution. There's,
you know, no, one's, you

170
00:10:07.940 --> 00:10:10.370
know, you don't have to
use a, you know, some

171
00:10:10.370 --> 00:10:15.140
sort of recursive, you know,
looping through a list for

172
00:10:15.140 --> 00:10:17.600
everything. You know, sometimes you
want a sorting algorithm that's

173
00:10:17.600 --> 00:10:21.080
going to mutate, what would
you give it? But I

174
00:10:21.080 --> 00:10:23.750
rarely reach for those things.
It's interesting. Okay. Well also

175
00:10:23.750 --> 00:10:27.960
has an object system. That's
very great. And you know,

176
00:10:27.960 --> 00:10:32.630
I'd never use it. And
actually it's funny, there was

177
00:10:32.630 --> 00:10:35.060
a stack overflow question the
other day about when should

178
00:10:35.060 --> 00:10:38.750
I use object oriented Stefano,
camel. And the answer was

179
00:10:38.750 --> 00:10:41.900
well, it's never really worth
it. And I think that's

180
00:10:41.900 --> 00:10:44.690
funny, it's like, you know,
this added complexity of objects

181
00:10:44.720 --> 00:10:48.110
just isn't worth it. And
that seems to be the

182
00:10:48.110 --> 00:10:51.230
viewpoint I've seen mainly in
my limited time in the

183
00:10:51.230 --> 00:10:56.900
Oklahoma community. But, but yeah,
people do use objects, but

184
00:10:57.290 --> 00:11:01.040
again, rarely reach for them.
Same thing with mutable mutability.

185
00:11:01.070 --> 00:11:03.740
I mean, it's there, but
you rarely reach for it.

186
00:11:04.430 --> 00:11:06.530
Interesting. Cause what I'm trying
to get a sense of

187
00:11:06.530 --> 00:11:09.950
is that every language has
its own. You know, you

188
00:11:09.950 --> 00:11:12.380
talk about religion or picking
religion and how you're very

189
00:11:13.370 --> 00:11:17.390
enthusiastic evangelist of this thing.
You know, how intense of

190
00:11:17.390 --> 00:11:19.010
a religion is it? You
know what I mean? Like

191
00:11:19.010 --> 00:11:21.620
is it that will shout,
not use objects when I

192
00:11:21.620 --> 00:11:22.980
don't hear some objects, you
can use it, but you

193
00:11:22.980 --> 00:11:25.400
really probably shouldn't, you know
what I mean? It, it

194
00:11:25.440 --> 00:11:27.740
is a bit that is
kind of a paradox, right?

195
00:11:27.740 --> 00:11:30.860
Cause it's like functional programming
is life, but also here's

196
00:11:30.860 --> 00:11:34.340
some objects, but I guess,
you know, the thing is

197
00:11:34.340 --> 00:11:39.290
they represent objects in, in
a coherent way in the

198
00:11:39.290 --> 00:11:42.530
type system. I think they
do a pretty good job

199
00:11:42.530 --> 00:11:48.980
of that. But you know,
really the only religious, I

200
00:11:48.980 --> 00:11:53.170
would say quality of Oak
camel is all hail the

201
00:11:53.170 --> 00:11:58.690
ML type system, all hail
pragmatism and you know, all

202
00:11:58.690 --> 00:12:02.230
hail performance. Okay. Well, you
know, has, because of just

203
00:12:02.380 --> 00:12:05.440
how great the type inferences
and how sound the type

204
00:12:05.440 --> 00:12:08.380
system is, you can do
all of these static checks

205
00:12:08.900 --> 00:12:11.950
and then basically for performance,
you erase most of the

206
00:12:11.950 --> 00:12:15.550
type stuff at runtime. So
you get really blazing, fast

207
00:12:15.550 --> 00:12:20.620
performance with a really sound
type system. And that's pretty

208
00:12:20.620 --> 00:12:24.460
great. And it's also, you
know, yeah, it's just, it's,

209
00:12:24.540 --> 00:12:26.860
it's like a great general
purpose language. So like for

210
00:12:26.860 --> 00:12:29.140
pretty much anything you could
ever want to do, you

211
00:12:29.140 --> 00:12:32.860
know, whether it's systems coding,
whether, you know, I was,

212
00:12:32.980 --> 00:12:35.380
I was talking to, to,
you know, our mutual friend,

213
00:12:35.380 --> 00:12:38.020
Rachel at jet and they
use F sharp, which is,

214
00:12:38.320 --> 00:12:42.190
you know, a basic copy
of <inaudible> and you know,

215
00:12:42.190 --> 00:12:45.820
they use F sharp for
various end points for, you

216
00:12:45.820 --> 00:12:51.490
know, just like funneling glue
in between different services, you

217
00:12:51.490 --> 00:12:54.010
know, so you can use
it for anything and it

218
00:12:54.040 --> 00:12:57.190
pretty much works great. So
yeah, it's, you know, you

219
00:12:57.190 --> 00:12:59.770
can use mutability, you can
use objects, all that stuff.

220
00:13:00.610 --> 00:13:02.320
And I will say whenever
I have a bug, I

221
00:13:02.320 --> 00:13:05.670
always know where to look.
Okay. So you threw a,

222
00:13:05.760 --> 00:13:07.920
when people talk about subjects
that they're really familiar with,

223
00:13:08.640 --> 00:13:11.700
they throw out acronyms and
terms that people aren't necessarily

224
00:13:11.700 --> 00:13:14.820
familiar with. So you just
threw out the, you said

225
00:13:14.820 --> 00:13:18.630
all hail the ML type
system and ML was a

226
00:13:18.630 --> 00:13:21.390
functional programming language. That's as
old as I am that

227
00:13:21.390 --> 00:13:24.120
Robyn Milner made in the
seventies. What is the ML

228
00:13:24.120 --> 00:13:28.230
type system? What does that
mean to camel? That ML

229
00:13:28.230 --> 00:13:32.340
type system to Oko means?
Yeah, that's, that's a good

230
00:13:32.340 --> 00:13:37.500
question. The Henry Milner algorithm
for type stuff, you know,

231
00:13:37.500 --> 00:13:39.810
I'm not a, I know
nothing about type theory, but

232
00:13:40.020 --> 00:13:42.600
we have a, we have
like higher kind of types.

233
00:13:42.600 --> 00:13:46.320
So we have, you know,
let's see when I met

234
00:13:46.320 --> 00:13:48.150
you at the conference, I
went to a type theory,

235
00:13:48.150 --> 00:13:51.330
one Oh one class. Right.
So they were talking about,

236
00:13:51.930 --> 00:13:55.830
you know, stuff I had
heard before monads monitors and

237
00:13:55.830 --> 00:13:58.920
Funkster's right. I mean all
that stuff. So Kamal has

238
00:13:58.920 --> 00:14:03.420
Funkster's yeah. This is the
kind of thing where people

239
00:14:03.420 --> 00:14:06.930
say the Lambda calculus casually
over lunch. Yeah. It's like

240
00:14:07.080 --> 00:14:11.220
modules, parameterized over modules. So,
you know, we, so funders

241
00:14:11.220 --> 00:14:14.430
or something I literally never
use, but they're there and

242
00:14:14.430 --> 00:14:17.880
there's actually great ways to
use them. The unikernel project

243
00:14:17.880 --> 00:14:21.960
I work on uses Funkster's
galore, there's even a library

244
00:14:21.960 --> 00:14:25.460
called funk Toria to make
your funders better. So it's

245
00:14:25.980 --> 00:14:30.180
turtles all the way down,
you know? And so yeah,

246
00:14:30.180 --> 00:14:33.360
we have all these, you
know, there's, there's, there's even

247
00:14:33.360 --> 00:14:37.470
polymorphic types, which are types
where, you know, you can,

248
00:14:37.470 --> 00:14:39.720
you don't necessarily have to
specify what type they will

249
00:14:39.720 --> 00:14:43.020
be. And as the program
goes along, you can sort

250
00:14:43.020 --> 00:14:46.980
of add to that type
with different types. So it

251
00:14:46.980 --> 00:14:49.200
gives you sort of a
dynamic typing type of thing.

252
00:14:49.210 --> 00:14:52.010
So there's open types and
all of these different types

253
00:14:52.010 --> 00:14:57.470
of types that allow you
to do dynamic ish type

254
00:14:57.470 --> 00:15:03.590
things. And yeah. So, but
basically what that means on

255
00:15:03.590 --> 00:15:06.560
a day to day basis
for me is that when

256
00:15:06.560 --> 00:15:11.330
I write a function that
takes something and uses another

257
00:15:11.330 --> 00:15:13.760
function. Like for example, let's
say I wanted to make

258
00:15:13.760 --> 00:15:16.730
my, you know, genus some
that's like, let's say, let

259
00:15:16.730 --> 00:15:20.630
Gina some take I and
J right. And then I'm

260
00:15:20.630 --> 00:15:24.440
going to, I plus J
there's only one thing that

261
00:15:24.440 --> 00:15:26.270
these I and J could
ever be. And that's an

262
00:15:26.270 --> 00:15:30.600
integer. Why? Because I'm using
a plus. So it's, it's

263
00:15:30.650 --> 00:15:35.210
going to only unify with
one type. And that unification

264
00:15:35.210 --> 00:15:38.330
is done by some very
fancy type thing that I

265
00:15:38.330 --> 00:15:40.850
really know nothing about nor
do I really need to

266
00:15:40.850 --> 00:15:43.390
know anything about it. So
that's some kind of type

267
00:15:43.390 --> 00:15:46.300
inference that is happening. And
it's like, okay, I see

268
00:15:46.300 --> 00:15:48.190
the two ans going in,
there's an incoming coming out.

269
00:15:48.190 --> 00:15:51.040
And that's, that's the end
of it. Exactly. And this

270
00:15:51.040 --> 00:15:52.930
can be kind of a
hurdle for people who are

271
00:15:52.930 --> 00:15:55.390
just starting. I think, because,
you know, if you're coming

272
00:15:55.390 --> 00:15:58.720
from something like Ruby or
Python or JavaScript, you might

273
00:15:58.720 --> 00:16:04.090
not realize what it means
to have a fully coherent

274
00:16:04.780 --> 00:16:08.290
constraint system. So for example,
you might be using a

275
00:16:08.290 --> 00:16:10.450
variable in a certain way
and sort of a more

276
00:16:10.450 --> 00:16:14.260
dynamic style and then unaware
that, you know, you've actually

277
00:16:14.260 --> 00:16:17.500
created a pretty incomplete system.
It saves you from bugs,

278
00:16:17.890 --> 00:16:20.170
for sure. But in the
beginning you might be like,

279
00:16:20.170 --> 00:16:22.690
why can't I just do
this? Why, why is it

280
00:16:22.690 --> 00:16:24.790
yelling at me? Why am
I getting these warnings from

281
00:16:24.790 --> 00:16:27.400
the compiler? Why is it,
why is it, why is

282
00:16:27.400 --> 00:16:29.920
it not a, I don't
know why isn't it giving

283
00:16:29.920 --> 00:16:31.930
me the head on this
list while you've you have

284
00:16:31.930 --> 00:16:34.330
a nested list and you
didn't realize it, or you've

285
00:16:34.330 --> 00:16:38.200
used it away where this
function was expecting a string,

286
00:16:38.200 --> 00:16:40.540
but you gave it a
list. And even though it

287
00:16:40.540 --> 00:16:43.360
might've worked in something like
Python, it won't work in

288
00:16:43.360 --> 00:16:46.120
Ocala because the type system
makes sure that everything is

289
00:16:46.120 --> 00:16:53.140
formally correct. Camel was made
for formal verification. This episode

290
00:16:53.140 --> 00:16:55.300
of Hansel minutes is brought
to you by brain tree

291
00:16:55.300 --> 00:16:58.270
payments. By next year, maybe
even next week, there could

292
00:16:58.270 --> 00:16:59.950
be a whole new way
to pay. Maybe it will

293
00:16:59.950 --> 00:17:02.170
be the next Bitcoin or
the next Apple pay. Maybe

294
00:17:02.170 --> 00:17:06.220
even both fortunately brain tree's
full stack payment platform is

295
00:17:06.220 --> 00:17:08.770
easily adaptable to whatever the
future holds. So you can

296
00:17:08.770 --> 00:17:12.220
adapt easily to, you can
accept everything from pounds to

297
00:17:12.220 --> 00:17:15.100
PayPal, to that next big
innovation from any device with

298
00:17:15.100 --> 00:17:18.430
one integration. And when that
new payment method comes out,

299
00:17:18.670 --> 00:17:20.140
all you have to do
is update a few lines

300
00:17:20.140 --> 00:17:24.340
of code no late nights,
no complicated recoding, no stress

301
00:17:24.340 --> 00:17:26.770
about staying ahead of the
curve. Braintree payments is here

302
00:17:26.770 --> 00:17:33.370
to help. You can learn
more@braintreepayments.com slash Hanselman that's Braintree

303
00:17:33.370 --> 00:17:40.240
payments.com/hanselman. The SDK is available
in lots of languages, including.net

304
00:17:40.240 --> 00:17:46.450
node, Java, Perl, and Python,
Ruby, check it out. So

305
00:17:46.450 --> 00:17:49.830
backing up and kind of
paraphrasing. So this type system,

306
00:17:49.830 --> 00:17:52.950
the, the ML type system
or the, the Hindley Miller

307
00:17:52.950 --> 00:17:55.590
type system was this kind
of classical system that was

308
00:17:55.590 --> 00:17:58.530
discovered and then described, and
someone got a PhD over

309
00:17:58.530 --> 00:18:01.110
it. And then you can
make like monotypes and poly

310
00:18:01.110 --> 00:18:02.850
types and free types and
do all this kind of

311
00:18:02.850 --> 00:18:06.330
stuff. But Oak camel has
the static type system. And

312
00:18:06.330 --> 00:18:10.320
then also does inference and
gives you less rope with

313
00:18:10.320 --> 00:18:13.350
which to hang yourself. So
while in other languages, you

314
00:18:13.350 --> 00:18:15.870
can cast a string to
an int and let the,

315
00:18:16.200 --> 00:18:19.920
let the grenade start flying.
You're you're more constrained in

316
00:18:19.920 --> 00:18:21.900
a language like this, cause
it has to be correct.

317
00:18:22.020 --> 00:18:24.650
Is that fair to say?
Totally fair to say, but,

318
00:18:24.710 --> 00:18:28.190
but want to denim, even
though it is statically typed,

319
00:18:28.190 --> 00:18:30.080
it's not the same, you
know, some people listening might

320
00:18:30.080 --> 00:18:33.050
be thinking, Oh, like Java,
not like Java in the

321
00:18:33.050 --> 00:18:36.500
sense that you have to
explicitly state types. You don't,

322
00:18:36.500 --> 00:18:39.290
I never have to say
into I and J I

323
00:18:39.290 --> 00:18:42.770
can it's I can totally
do that in some, in

324
00:18:42.770 --> 00:18:45.800
some cases where maybe you've
I know now maybe it's

325
00:18:45.800 --> 00:18:48.620
something, there are some cases
where you have to explicitly

326
00:18:48.620 --> 00:18:50.780
give the compiler a little
help. You might find that

327
00:18:50.780 --> 00:18:53.360
every now and then, but
you won't. And just the

328
00:18:53.360 --> 00:18:56.090
way that you use it,
it will only unify with,

329
00:18:56.090 --> 00:18:59.540
with one type. And sometimes
that's any type, but, you

330
00:18:59.540 --> 00:19:02.300
know, or like, you know,
you'll see those in, in

331
00:19:02.360 --> 00:19:05.840
type signatures, alpha beta, right.
You know, like let's say,

332
00:19:06.020 --> 00:19:08.360
you know, the type signature
of map, right. It takes

333
00:19:08.360 --> 00:19:10.820
a let's see, it takes
a function that takes a

334
00:19:10.820 --> 00:19:13.520
to B it takes a
list of a, and gives

335
00:19:13.520 --> 00:19:15.620
you a list of B,
right? So that those are

336
00:19:15.620 --> 00:19:20.660
like generic types. But, but
most of the time it'll,

337
00:19:20.690 --> 00:19:23.240
it'll unify correctly for you.
You don't have to explicitly

338
00:19:23.240 --> 00:19:27.080
state any type. Okay. I
got ya. Now, one of

339
00:19:27.080 --> 00:19:29.300
the cool features of O'Connell
and other languages have this,

340
00:19:29.300 --> 00:19:32.000
but we're talking about Oak
camel is this concept of

341
00:19:32.000 --> 00:19:35.930
an, of an FFI or
a foreign function interface. Have

342
00:19:35.940 --> 00:19:38.690
you used those? I haven't
really, but I know that

343
00:19:38.690 --> 00:19:41.450
it makes talking to see
really great. So if I

344
00:19:41.450 --> 00:19:43.370
understand correctly, not only does
it mean that you can

345
00:19:43.370 --> 00:19:46.340
call C, but you can
also even make a library,

346
00:19:46.340 --> 00:19:48.620
you know, camel and then
expose it as C. So

347
00:19:48.620 --> 00:19:51.560
a C programmer would actually
not even know that it

348
00:19:51.560 --> 00:19:55.310
was old camel. Yeah. I've,
I've heard this before an

349
00:19:55.310 --> 00:19:59.090
IRC. There's also a great
library called C types. I've

350
00:19:59.090 --> 00:20:02.090
never used it, but, but
that's a thing and people

351
00:20:02.090 --> 00:20:05.030
love doing it. That's a
thing. And people love doing

352
00:20:05.030 --> 00:20:07.010
it. I think what's cool
about that though. Is it

353
00:20:07.010 --> 00:20:09.860
reminds me that old camel
isn't an Island. It's not

354
00:20:09.860 --> 00:20:11.930
like, Oh, you must be
this way. And you must

355
00:20:11.930 --> 00:20:14.480
live in our world. You
know, that's a recognition that,

356
00:20:14.500 --> 00:20:17.600
that you do have to
interrupt at some point. Yeah,

357
00:20:17.630 --> 00:20:20.870
no, it's, it's very much
about interoperability. Like the project

358
00:20:20.870 --> 00:20:23.690
I'm working on right now.
So I write in Oak

359
00:20:23.690 --> 00:20:27.230
camel, I compile the old
camel bytecode. Then I take

360
00:20:27.230 --> 00:20:29.660
that bite code and I
use a program called JS

361
00:20:29.830 --> 00:20:33.500
camel, which makes JavaScript. And
then I run this Java

362
00:20:33.500 --> 00:20:37.070
script in the node run
time. So I'm actually writing

363
00:20:37.070 --> 00:20:40.460
a camel and I have
an electron app. So it's

364
00:20:40.460 --> 00:20:43.250
like kind of like some,
a lot of song and

365
00:20:43.250 --> 00:20:45.980
dance, a lot of witchcraft,
but it's a really nice

366
00:20:45.980 --> 00:20:49.420
development flow. And I'm, that's
possible because people wrote these

367
00:20:49.420 --> 00:20:53.170
amazing bindings to know JS
and bindings to, you know,

368
00:20:53.170 --> 00:20:56.320
express and all these JavaScript
libraries. So they did all

369
00:20:56.320 --> 00:20:58.660
the type work ahead of
time for me to use

370
00:20:58.660 --> 00:21:01.540
this stuff. And, and that's,
that's really great. The whole

371
00:21:01.540 --> 00:21:04.930
camel community is really, really
great. I can't stress that

372
00:21:04.930 --> 00:21:09.210
enough. And you said this
was called J S of,

373
00:21:09.360 --> 00:21:12.960
okay. Yes. I believe this
came out of the, the

374
00:21:12.960 --> 00:21:17.190
oxygen project, which had a
couple of different, really interesting

375
00:21:17.190 --> 00:21:20.100
things. It was, it was
a web project. They had

376
00:21:20.100 --> 00:21:23.730
like LWT, which is a
cooperative threading library, which is,

377
00:21:24.000 --> 00:21:27.810
you know, really bread and
butter in O'Connell it's used

378
00:21:27.810 --> 00:21:30.960
in pretty much everything. There's
a lot of cool stuff

379
00:21:30.960 --> 00:21:34.410
that came out of that
project. Thai XML is another

380
00:21:34.410 --> 00:21:37.260
one that's, that's pretty popular.
So they have a lot

381
00:21:37.260 --> 00:21:39.300
of different frameworks that came
out of that, that I

382
00:21:39.300 --> 00:21:43.260
think are potentially more popular
than, than the rest of

383
00:21:43.260 --> 00:21:45.150
the project. But I, you
know, I, I don't really

384
00:21:45.150 --> 00:21:49.320
know. And the, the, now
of course the resulting JavaScript,

385
00:21:49.350 --> 00:21:52.080
can't be really recognizable. I
assume it looks just like

386
00:21:52.350 --> 00:21:55.530
magic, you know, VAR one,
VAR zero. I mean, you

387
00:21:55.530 --> 00:21:57.600
don't really think about it
like that. You're using JavaScript

388
00:21:57.900 --> 00:22:00.450
as its own runtime. Aren't
you like a virtual machine

389
00:22:00.450 --> 00:22:06.750
of its own, Actually Bloomberg
made John Campbell to JavaScript a

390
00:22:06.750 --> 00:22:12.270
tool and that actually produces
readable JavaScript. So it's possible

391
00:22:12.270 --> 00:22:14.940
that JSO came well, might
make that a thing. I

392
00:22:14.940 --> 00:22:18.060
don't know if it is
a thing I don't usually

393
00:22:18.090 --> 00:22:20.520
need it. I've never had
like, usually if there's a

394
00:22:20.520 --> 00:22:22.350
serious bug, I can kind
of figure out what it

395
00:22:22.350 --> 00:22:25.050
is without needing to even
read the Java script. But

396
00:22:26.640 --> 00:22:30.210
also because I am familiar
with web, but, but yeah,

397
00:22:30.210 --> 00:22:33.180
that's, that's a feature in,
in other tools. So that's

398
00:22:33.180 --> 00:22:35.400
interesting. Did you know about
this? Like you said, you

399
00:22:35.400 --> 00:22:38.460
were in node and JavaScript,
you are a web person,

400
00:22:38.460 --> 00:22:40.680
you didn't really feel it.
You found Oak camel, and

401
00:22:40.680 --> 00:22:43.770
then here you are back
compiling it into JavaScript again.

402
00:22:44.700 --> 00:22:47.160
Yeah. Well, I can't, I
mean, the node ecosystem is

403
00:22:47.160 --> 00:22:50.430
amazing and I definitely think
a lot of functional communities

404
00:22:50.430 --> 00:22:54.300
can learn from JavaScript tools
in the sense that people

405
00:22:54.300 --> 00:22:57.390
who, who write stuff in
JavaScript tend to make things

406
00:22:57.390 --> 00:23:01.860
that are usable very quickly.
They make great tools, even

407
00:23:01.860 --> 00:23:07.120
though, you know, NPM like
the left pad. So, you

408
00:23:07.120 --> 00:23:09.780
know, I, there was a
lot of discussion. We have

409
00:23:09.780 --> 00:23:13.410
a package manager called OPM
and it's really great. It's

410
00:23:13.410 --> 00:23:16.530
like the best package manager
I've ever used. I will

411
00:23:16.530 --> 00:23:19.620
say if you're starting a
camel, Oh, Pam get really

412
00:23:19.620 --> 00:23:25.500
comfortable with it. It's fabulous.
I brought this up for

413
00:23:25.500 --> 00:23:28.170
a reason. What was the
reason? Yeah. So left pad.

414
00:23:28.200 --> 00:23:30.480
So, you know, after that
whole, you know, that guy

415
00:23:30.480 --> 00:23:33.510
took off that really important
package and, you know, then

416
00:23:33.780 --> 00:23:37.410
package disappeared. Yeah. And of
course there was a discussion,

417
00:23:37.410 --> 00:23:40.320
you know, like a little
bit of, well, Oh, Pam

418
00:23:40.320 --> 00:23:42.570
has been criticized a bit
for being slow, you know,

419
00:23:42.570 --> 00:23:47.360
there's like a review process
and that of thing. And

420
00:23:47.480 --> 00:23:48.890
you know, it was kind
of like, well, which is

421
00:23:48.890 --> 00:23:50.420
better. I mean, you know,
it's like you have a

422
00:23:50.420 --> 00:23:54.230
sea of garbage or like
a tiny collection of treasures,

423
00:23:54.230 --> 00:23:59.300
right. It's like, which is
better. Something like unmaintainable or

424
00:23:59.300 --> 00:24:02.060
something that's like overly maintained.
I don't know what the

425
00:24:02.060 --> 00:24:04.940
right answer is, but it's
interesting, like the difference in

426
00:24:04.940 --> 00:24:07.370
those communities and kind of
making tools that sort of

427
00:24:07.370 --> 00:24:12.290
bridge those communities, Facebook just
released reason, which is so,

428
00:24:12.290 --> 00:24:15.890
so very hot. The syntax
looks like JavaScript, but it

429
00:24:15.890 --> 00:24:18.590
is Ocampo under the hood.
And they even have tools

430
00:24:18.590 --> 00:24:21.230
that turn your old camel
project into a reason project.

431
00:24:22.010 --> 00:24:24.470
So lots of cool stuff
there, and I'm sure they

432
00:24:24.470 --> 00:24:28.700
will continue to dump talent
into that. So, you know,

433
00:24:28.730 --> 00:24:31.280
if you're listening to this
and you're wondering, Oh, well,

434
00:24:31.310 --> 00:24:33.410
this is great, but this
has nothing to do with

435
00:24:33.410 --> 00:24:36.500
my life or the things
I build. Definitely check out

436
00:24:36.500 --> 00:24:41.050
reason. Those people are really
smart. Interesting, backing up a

437
00:24:41.050 --> 00:24:43.330
little bit to give people
a little bit of context.

438
00:24:43.330 --> 00:24:49.810
You've got 1,213 packages in
OPM. Oh, Pam, the old

439
00:24:49.810 --> 00:24:52.390
camel package manager, you've got
over a quarter of a

440
00:24:52.390 --> 00:24:55.150
million in NPM. So that
definitely gives you the sense

441
00:24:55.150 --> 00:24:58.570
of what's, you know, do
you, do you want a

442
00:24:58.570 --> 00:25:01.750
highly curated and exclusive library
where everything is guaranteed to

443
00:25:01.750 --> 00:25:04.600
work, you know, or do
you want 15 copies of

444
00:25:04.630 --> 00:25:07.480
pad lift each one of
which is possibly guaranteed to

445
00:25:07.480 --> 00:25:10.960
work? You know, I, you
know, I think these are

446
00:25:10.960 --> 00:25:14.320
unanswerable questions. They are great
on it as with all

447
00:25:14.320 --> 00:25:17.080
good religions. They are the
great financial questions. So I'm

448
00:25:17.080 --> 00:25:18.880
teasing, I'm teasing a little
bit. I'm going to get

449
00:25:18.880 --> 00:25:21.760
emails from angry note people
now. Oh no, I love

450
00:25:21.760 --> 00:25:25.570
node. Yeah. I love the
ecosystem. I love, you know,

451
00:25:25.750 --> 00:25:28.420
I love working and, and
the no JS bindings, it's

452
00:25:28.420 --> 00:25:31.690
its own camel, but it's
still node, you know, it's,

453
00:25:31.720 --> 00:25:35.020
it's still streams. It's still
all that good stuff. It's

454
00:25:35.020 --> 00:25:37.330
still like, you know, still
all the stuff you want

455
00:25:37.330 --> 00:25:39.970
to note. So, So let's
talk, talk to me a

456
00:25:39.970 --> 00:25:42.160
little bit more about this
reason, reason for a second.

457
00:25:42.160 --> 00:25:43.600
I've read up a little
bit about it. You didn't

458
00:25:43.600 --> 00:25:48.880
see it at facebook.github.io/reason. And
by the way, if this

459
00:25:48.880 --> 00:25:50.770
is not proof that we've
officially run out of things,

460
00:25:50.770 --> 00:25:54.670
to call things a try,
try Googling for reason and

461
00:25:54.670 --> 00:25:57.670
finding the programming language called
reason and not be literally

462
00:25:57.670 --> 00:26:00.790
everything else in the planet
called reason, but it's an

463
00:26:00.790 --> 00:26:03.190
interface to Oak camel, right?
It's a dialect kind of

464
00:26:03.190 --> 00:26:07.420
ML language, but is this
another, what is this? This

465
00:26:07.430 --> 00:26:10.690
is another old camel. That's
a good question. I think

466
00:26:10.690 --> 00:26:13.120
it's a lot of it
is to be determined. It's

467
00:26:13.330 --> 00:26:16.180
a new language I think
is how it's being marketed,

468
00:26:17.380 --> 00:26:21.250
which is Oak Hamill. So
it's, you know, it's got

469
00:26:21.250 --> 00:26:25.210
the type system it's got
all that. Goodness. But the

470
00:26:25.210 --> 00:26:28.630
syntax is really just all
it's changed, which a lot

471
00:26:28.630 --> 00:26:33.040
of people have been bemoaning
a bit in the <inaudible>

472
00:26:33.060 --> 00:26:36.670
community. I mean, there are
warts in Okemos syntax, but

473
00:26:36.820 --> 00:26:40.060
I wouldn't say that the
syntax is the most painful

474
00:26:40.060 --> 00:26:42.220
part of a camel, like
far from it, in my

475
00:26:42.220 --> 00:26:45.300
opinion. But I'm, I do
think it's a noble task

476
00:26:45.300 --> 00:26:47.910
to try to draw more
people into a camel and

477
00:26:47.910 --> 00:26:52.080
remove any boundaries to getting
started. So if that's what

478
00:26:52.080 --> 00:26:55.130
the goal is, then like
I'm all for it. Yeah.

479
00:26:55.160 --> 00:26:57.860
It's interesting. You know, this
may be completely ignorant thing

480
00:26:57.860 --> 00:26:59.330
to say. And I hope
that people who are listening

481
00:26:59.330 --> 00:27:01.760
will email me and say,
you're ignorant, not you me,

482
00:27:02.900 --> 00:27:07.040
but, Well also email me
if I'm accurate, I will

483
00:27:07.040 --> 00:27:10.250
forward all of my emails
to you. So, you know,

484
00:27:10.310 --> 00:27:14.240
people like JavaScript, but JavaScript
has some problems. So then

485
00:27:14.240 --> 00:27:16.850
someone goes and makes, you
know, coffee script or even

486
00:27:16.850 --> 00:27:20.630
more dramatically TypeScript. And then
you say, Oh, well you

487
00:27:20.630 --> 00:27:23.930
can have, you know, JavaScript
files are TypeScript. And also

488
00:27:23.930 --> 00:27:27.470
you can have TypeScript files.
It seems like reason is

489
00:27:27.470 --> 00:27:28.940
like a way of saying,
well, here's another way of

490
00:27:28.940 --> 00:27:31.850
thinking about, Oh, camel and
the old camel build, you

491
00:27:31.850 --> 00:27:34.310
know, we're going to replace
that. Okay. Mobility gets replaced

492
00:27:34.310 --> 00:27:36.770
with this thing called rebuild.
So now you can build

493
00:27:36.770 --> 00:27:39.650
reason files and Oak Hamill
files. So it seems like

494
00:27:39.650 --> 00:27:42.590
to me, ignorantly, you know,
TypeScript is to JavaScript as

495
00:27:42.590 --> 00:27:44.840
reason as to Oak camel.
It's almost like a rapper,

496
00:27:45.080 --> 00:27:47.960
but it's compatible and it's
friendly. And let's just see

497
00:27:47.960 --> 00:27:51.200
where this takes us. Well,
I think replacing old camel

498
00:27:51.200 --> 00:27:54.530
build is very noble. The
building of camel is a

499
00:27:54.530 --> 00:27:58.340
hundred percent the worst part
of Oak camel, no question.

500
00:27:58.850 --> 00:28:04.280
It's very difficult. And I'm
constantly searching man pages, documentation.

501
00:28:04.550 --> 00:28:06.470
I mean, pretty much every
project I have to keep

502
00:28:06.470 --> 00:28:08.600
it open. It's something that's
still really hard for me.

503
00:28:09.740 --> 00:28:12.110
Yeah. Why is it just
like install old camel and

504
00:28:12.110 --> 00:28:16.190
type do it, and then
it works. It's confusing. Like

505
00:28:16.190 --> 00:28:18.500
how you set up your
interface, files, how you like

506
00:28:18.500 --> 00:28:22.340
link with like shared libraries,
how you make libraries very

507
00:28:22.340 --> 00:28:25.430
complicated. There's a couple tools
that make it better. The

508
00:28:25.430 --> 00:28:28.130
other, the other thing that's
difficult is there's the state

509
00:28:28.130 --> 00:28:31.280
of the build tools is
extremely fragmented. You know, there's

510
00:28:31.280 --> 00:28:34.220
like 20 and there's no
consensus on what's the best

511
00:28:34.220 --> 00:28:37.820
one at least, you know,
in my limited view, I'm

512
00:28:37.820 --> 00:28:41.240
sure I can already, like,
I can feel the Twitter

513
00:28:41.240 --> 00:28:44.960
DMS. Like I can feel
them coming, but yeah, there's

514
00:28:44.990 --> 00:28:47.420
a, yeah. I mean, there's
no real consensus. I would

515
00:28:47.420 --> 00:28:50.030
say that another tip to
people who are just beginning

516
00:28:50.420 --> 00:28:53.780
really look at Utah, which
is the top level interpreter

517
00:28:54.050 --> 00:29:00.350
just in the beginning, just
yes, you top and do

518
00:29:00.350 --> 00:29:06.260
that because it'll make your
life a lot better. And,

519
00:29:06.440 --> 00:29:08.540
and then look at a
waste, a waste. This is

520
00:29:08.540 --> 00:29:12.110
a, basically it generates a,
you know, cross platform make

521
00:29:12.110 --> 00:29:15.500
files, I believe. And anyway,
that's got a quick start

522
00:29:15.500 --> 00:29:17.960
functionality, if you just want
to set up a project

523
00:29:17.960 --> 00:29:21.080
and just get it to
work, you know, I embarrassingly

524
00:29:21.080 --> 00:29:24.830
use make files. I mean,
there's probably, I'm sure I'm

525
00:29:24.830 --> 00:29:26.810
going to get again. I
can feel the DMS. I'm

526
00:29:26.810 --> 00:29:30.050
sure. I'm sure there's something
better, but that's what I'm

527
00:29:30.050 --> 00:29:33.980
using right now to build
my projects. Interesting. I would,

528
00:29:34.160 --> 00:29:35.990
somehow I would have expected
it just to be this

529
00:29:35.990 --> 00:29:38.900
like joy. Like I've heard
everything about the programming language

530
00:29:38.900 --> 00:29:41.950
and the environment to be
joyous. And then it's like,

531
00:29:41.950 --> 00:29:43.720
and then you got to
build a thing and it

532
00:29:43.720 --> 00:29:46.240
sounds like, you know, eventually
you hit, you know, the

533
00:29:46.240 --> 00:29:49.540
abstraction isn't perfect anymore. And
then reality hits in and

534
00:29:49.540 --> 00:29:52.410
building stuff, You know, I'm
sure there are people like,

535
00:29:52.440 --> 00:29:55.200
I remember, I don't know,
camel meetup, some guy who

536
00:29:55.200 --> 00:29:57.300
had been doing dev ops
for like, you know, 30

537
00:29:57.300 --> 00:30:00.990
years, I don't know before
the internet, before anybody like

538
00:30:01.020 --> 00:30:07.530
before. And he was like,
well, you know, I don't

539
00:30:07.530 --> 00:30:10.170
really know what you guys
are expecting. You know, this

540
00:30:10.170 --> 00:30:12.660
is not really that bad,
blah, blah, blah, blah, blah.

541
00:30:12.840 --> 00:30:16.230
But inevitably, I mean, I've
just, just peripherally on the

542
00:30:16.230 --> 00:30:18.900
old camel channel. And Freenode,
that's like the question of

543
00:30:18.900 --> 00:30:20.580
the day. I mean, there
must be at least five

544
00:30:20.580 --> 00:30:22.830
questions a day about how
to build a camel. So

545
00:30:23.490 --> 00:30:25.740
yeah. So I think it's,
you know, I think it's

546
00:30:25.740 --> 00:30:28.170
going to, so that's why
I'm also excited for reason

547
00:30:28.170 --> 00:30:32.220
is I just want easier
ways to do that. So,

548
00:30:32.430 --> 00:30:35.340
you know, that doesn't have
me combing documentation, but I

549
00:30:35.340 --> 00:30:37.020
think one day you just
wake up and you know,

550
00:30:37.020 --> 00:30:38.940
all the things and then
this is no longer a

551
00:30:38.940 --> 00:30:42.150
problem. So once I get
there, maybe the, but that

552
00:30:42.150 --> 00:30:44.490
really is the only ugly
part for me. I mean,

553
00:30:44.490 --> 00:30:51.960
everything else is fabulous. It's
just that really? Yeah. So

554
00:30:51.960 --> 00:30:54.120
are you, what do you
run it on? I'm looking

555
00:30:54.120 --> 00:30:56.910
on their website and I
see all kinds of Linux

556
00:30:56.910 --> 00:31:01.320
flavors mentioned. I see, you
know, Mac mentioned, but I

557
00:31:01.320 --> 00:31:04.650
also see a windows gets
kind of a yeah. And

558
00:31:04.650 --> 00:31:08.550
also windows, a bit of
a comment and there's different

559
00:31:08.760 --> 00:31:12.150
ports and kind of, it
doesn't seem like it's like

560
00:31:12.150 --> 00:31:14.760
super Epic on windows. What's,
what's the, what's the story.

561
00:31:14.760 --> 00:31:16.920
And what's the best, the
best operating system to try

562
00:31:16.920 --> 00:31:19.560
this on. You know, I
don't know. I mean, Mac

563
00:31:19.560 --> 00:31:23.310
worked really great for me
OSX, but I use fedora.

564
00:31:23.370 --> 00:31:27.750
So I'm the red link
Caesar, but you know, anything

565
00:31:27.750 --> 00:31:31.350
Unix is going to be
great windows. I know the

566
00:31:31.350 --> 00:31:34.320
situation is a bit precarious.
I'm not, I'm not really

567
00:31:34.320 --> 00:31:39.000
sure. I've never tried to
run on windows. So I

568
00:31:39.000 --> 00:31:42.750
don't know the answer. Well,
I am, as we are

569
00:31:42.750 --> 00:31:46.320
sitting here talking, installing it,
using a wound to on

570
00:31:46.320 --> 00:31:48.930
windows and see if that
will work. So I will

571
00:31:48.930 --> 00:31:51.570
have a wound to running
on windows and see if

572
00:31:51.570 --> 00:31:53.760
I can get something to
go on. It's very interesting

573
00:31:53.760 --> 00:31:56.340
though. There seem to be
also some different ways to

574
00:31:56.340 --> 00:31:59.100
do it. It looks like
it does run. Yeah. So

575
00:31:59.100 --> 00:32:04.260
I just ran, Oh, Pam
config, ENV, and what's where

576
00:32:04.260 --> 00:32:05.820
are some places I would
go and learn about this?

577
00:32:05.820 --> 00:32:08.580
What's some good code examples
to play with. That's great.

578
00:32:08.580 --> 00:32:11.460
So I've got some stuff
on my GitHub. Let's see.

579
00:32:11.460 --> 00:32:15.570
I've got some, I think
there's a repository on my

580
00:32:15.570 --> 00:32:19.410
GitHub called example, camel example,
dash of camels. So that's

581
00:32:21.720 --> 00:32:28.980
yeah. So it's good hub.com/wired
sister. That's wired as in

582
00:32:29.490 --> 00:32:33.690
cables and then sister as
in your sister and Fugler

583
00:32:34.260 --> 00:32:38.970
example, camel. So that's D
so slash example, dash camel,

584
00:32:39.560 --> 00:32:42.560
you get a raw pository
that me and this other

585
00:32:42.560 --> 00:32:47.240
guy, FX factorial used to
do presentations. If you click

586
00:32:47.240 --> 00:32:52.850
the examples directory, maybe click
the, some odds.ml file. Here's

587
00:32:52.850 --> 00:32:55.850
something functions for just summing
odds. And this is kind

588
00:32:55.850 --> 00:32:59.060
of interesting. Cause you can
see in the bottom I

589
00:32:59.060 --> 00:33:01.460
have an imperative solution. So
that might be, remember we

590
00:33:01.460 --> 00:33:04.460
were talking about mutability. So
here you see that rep

591
00:33:04.460 --> 00:33:09.740
zero as the counter, right.
And then that bang counter

592
00:33:09.740 --> 00:33:13.210
is sort of D referencing
that type of idea. So

593
00:33:13.210 --> 00:33:15.310
I would say that old
camel is probably of all

594
00:33:15.310 --> 00:33:17.260
the languages, the one that
is least likely to be

595
00:33:17.260 --> 00:33:21.520
explained syntactically on a podcast,
but you know what I

596
00:33:21.520 --> 00:33:26.650
mean? Totally, totally valid. Yeah.
I'm like, you know, list

597
00:33:26.680 --> 00:33:28.690
like list dot fold, right.
And I'm like, Oh, that's

598
00:33:28.690 --> 00:33:30.520
an Roe thingy. What do
we call that? You know,

599
00:33:31.030 --> 00:33:33.160
I'm sure that there's like
a, you know, what do

600
00:33:33.160 --> 00:33:36.520
you call it? Hash rocket
or super bang or I'm,

601
00:33:36.550 --> 00:33:41.020
I'm pretty primitive. I just
say arrow there's no other

602
00:33:41.680 --> 00:33:45.340
arrows. I mean, there's, there's
a left arrow for any

603
00:33:45.340 --> 00:33:47.890
way that doesn't it. I
know I'm going to put

604
00:33:47.890 --> 00:33:49.630
a link to this though
in the show notes. So

605
00:33:49.630 --> 00:33:54.070
then people can, can see
that. So, and then once

606
00:33:54.070 --> 00:33:55.780
I've got this down, like,
do I just say, Oh,

607
00:33:55.780 --> 00:33:57.280
camel, and the name of
the file that it's in

608
00:33:57.280 --> 00:33:59.080
or how do you run
these things? Yeah. So it's

609
00:33:59.080 --> 00:34:02.020
just a, you can use,
okay, we'll see. Or Kamal

610
00:34:02.020 --> 00:34:04.720
off. So that's the native
code is opt and then

611
00:34:04.720 --> 00:34:09.610
the bike code is C
so yeah, just let's see.

612
00:34:10.330 --> 00:34:14.710
Okay. I'm, we'll see, you
know, and then just your

613
00:34:14.710 --> 00:34:17.410
program and it should go,
I think just as standard

614
00:34:17.410 --> 00:34:20.560
out, but let's see. But
the other thing you can

615
00:34:20.560 --> 00:34:23.440
do, which I think is
better for people just starting,

616
00:34:23.860 --> 00:34:26.860
it is Utah and then
paste in Utah and then

617
00:34:26.860 --> 00:34:29.500
you use two semi-colons and
hit enter, and then it'll

618
00:34:29.500 --> 00:34:32.400
evaluate whatever you drop in.
And that's kind of, I

619
00:34:32.410 --> 00:34:35.830
don't know. I prefer redeveloped
print loops for, Okay. So

620
00:34:35.830 --> 00:34:37.870
Utah is the rebel and
that's where I spend my

621
00:34:37.870 --> 00:34:40.360
time. Yeah. And you can
just open them, install that.

622
00:34:41.560 --> 00:34:43.540
Okay. Very cool. And actually,
you know, I'm going to

623
00:34:43.540 --> 00:34:45.340
just while we're sitting here
for a second, I just

624
00:34:45.340 --> 00:34:51.700
say, Oh, Pam install. UCAB
that says, Oh, just make

625
00:34:51.700 --> 00:34:54.790
sure that you specify opium
in it. Oh, Pam Annette.

626
00:34:54.850 --> 00:34:59.290
Yes. Yes, sir. It, it,
it gives you great help.

627
00:34:59.350 --> 00:35:01.600
It really does. Well. Yeah.
It seems to be very,

628
00:35:01.630 --> 00:35:03.940
very clear on, on what
it's doing. And it tells

629
00:35:03.940 --> 00:35:06.130
me it's giving me nice
instructions and stuff. And then,

630
00:35:07.180 --> 00:35:09.730
and then I'm often doing
it. Cool. Well, this has

631
00:35:09.730 --> 00:35:12.400
been super educational and we
can learn about this, of

632
00:35:12.400 --> 00:35:16.270
course, at Oak camel.org. And
then on your get hub,

633
00:35:16.450 --> 00:35:18.790
your get hub name is
wired sister, and I want

634
00:35:18.790 --> 00:35:23.260
to include your example, Oak
camel stuff up there. And

635
00:35:23.260 --> 00:35:26.800
then the other thing was
J S underscore of underscore

636
00:35:26.800 --> 00:35:29.800
Ocala, JSO, camel. And then
the other thing we talked

637
00:35:29.800 --> 00:35:33.130
about was reason from Facebook
would sound super interesting And,

638
00:35:33.150 --> 00:35:37.030
and last, last, but not
least if you're using an

639
00:35:37.140 --> 00:35:40.290
a, you know, Emacs or
them or whatever your setup

640
00:35:40.290 --> 00:35:44.400
is, look into Merlin, which
is a plugin that'll help

641
00:35:44.400 --> 00:35:48.390
you get a lot of
really cool type checking stuff.

642
00:35:48.750 --> 00:35:52.410
And that has made my
life incredibly easy. So that's

643
00:35:52.410 --> 00:35:55.410
just one other tool I
would throw out there is

644
00:35:55.410 --> 00:35:58.760
Merlin. Okay, cool. I will
send all of that in

645
00:35:58.760 --> 00:36:01.670
the show notes and I
really appreciate your time. Yeah,

646
00:36:01.670 --> 00:36:04.700
absolutely. You know, take everything
I say with a grain

647
00:36:04.700 --> 00:36:08.720
of salt, I'm still still
learning, but okay. What org

648
00:36:08.720 --> 00:36:12.470
has great stuff. Please feel
free to ask people on

649
00:36:12.470 --> 00:36:17.120
IRC. They're so nice. They're
they're not like those, I

650
00:36:17.120 --> 00:36:21.050
don't know these stereotypical mean
functional programmers. They're very nice.

651
00:36:22.250 --> 00:36:24.350
I know what the stereotype
would be. Maybe like ranger

652
00:36:24.350 --> 00:36:28.310
hats and like, you know,
those strappy sandals or something.

653
00:36:28.340 --> 00:36:31.040
I don't know, but they're
not that they're very nice.

654
00:36:31.820 --> 00:36:34.100
Very cool. Well, thank you
so much, Gina Marie Miami

655
00:36:34.400 --> 00:36:37.640
for your time today. Yeah,
no problem. This has been

656
00:36:37.640 --> 00:36:40.340
another episode of Hanselminutes and
we'll see you again next

657
00:36:40.340 --> 00:36:40.640
week.


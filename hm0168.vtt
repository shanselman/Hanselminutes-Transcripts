WEBVTT FILE

1
00:00:12.060 --> 00:00:16.620
From Hanselman it's dot com.
It's Hanselman. It's a weekly

2
00:00:16.620 --> 00:00:20.820
discussion with web developer and
technologists. Scott Hanselman hosted by

3
00:00:20.820 --> 00:00:25.620
Carl Franklin. This is Lawrence Ryan announced
some show number one 68

4
00:00:25.680 --> 00:00:30.930
recorded live Thursday, June 25th, 2009. Support
for Hanselman it's just provided

5
00:00:30.930 --> 00:00:34.950
by Tellerik rad controls, the
most comprehensive suite of components

6
00:00:34.950 --> 00:00:45.570
for windows forms and asp.net
web applications online@wwwdottelerikdotcomandby.net developers journal

7
00:00:45.600 --> 00:00:51.390
the world's leading.net developer magazine
online at www dot <inaudible>

8
00:00:51.540 --> 00:00:55.830
dot com. In this episode,
Scott talks with Aaron over

9
00:00:55.830 --> 00:01:01.710
of Novell about the banshee
project. Hi, this is Scott

10
00:01:01.710 --> 00:01:03.870
Hanselman, and this is another
episode of Hansel minutes. And

11
00:01:03.870 --> 00:01:06.450
today I've got an opportunity
to talk to Aaron Bach

12
00:01:06.450 --> 00:01:09.240
over Aaron works for Novell,
and he's the founder of

13
00:01:09.240 --> 00:01:12.840
the banshee project. And also
the lead maintainer banshee is

14
00:01:12.840 --> 00:01:16.590
a really interesting project that
is written in mano and

15
00:01:17.040 --> 00:01:20.040
runs on gosh, just about
every platform that there is.

16
00:01:20.520 --> 00:01:23.700
Thanks Aaron, for chatting with
me today. Thanks for having

17
00:01:23.700 --> 00:01:28.190
me. So, so what's the
story with banshee? So Batu

18
00:01:28.190 --> 00:01:32.150
is a project I started,
I guess, early in 2005,

19
00:01:33.080 --> 00:01:35.540
the original goal was just
that there was a gap

20
00:01:35.570 --> 00:01:39.560
on the Linux desktop that
we wanted to fill. Namely,

21
00:01:39.620 --> 00:01:43.340
there wasn't a really good
media player. So the original

22
00:01:43.340 --> 00:01:45.950
goal was to just develop
a media player that was

23
00:01:45.950 --> 00:01:49.610
sort of like iTunes and
we were doing this on

24
00:01:49.610 --> 00:01:53.330
the, on the mano platform.
So that's just kind of

25
00:01:53.330 --> 00:01:57.890
how it evolved. And over
time we ended up kind

26
00:01:57.890 --> 00:02:00.110
of really growing it into
more than just the Linux

27
00:02:00.110 --> 00:02:02.930
app. So four or five
years ago, that's 2005. That's

28
00:02:02.930 --> 00:02:05.870
like 50 years ago in,
in internet years. You, you

29
00:02:05.870 --> 00:02:09.440
took a bet on mano
that long ago. So many

30
00:02:09.440 --> 00:02:11.600
people ask the question is
mano ready? Is it ready

31
00:02:11.600 --> 00:02:14.150
for prime time? You thought
it was ready five years

32
00:02:14.150 --> 00:02:17.360
ago. Yes, that's correct. So
one of the original goals

33
00:02:17.360 --> 00:02:19.310
with Bantu was that we
actually wanted to use it

34
00:02:19.880 --> 00:02:23.300
as sort of a showcase
application for mano itself. It

35
00:02:23.300 --> 00:02:26.150
was a time at Novell
when we were writing actually

36
00:02:26.150 --> 00:02:28.790
a lot of desktop applications
in mano. So we wrote

37
00:02:28.790 --> 00:02:31.640
F spot as well, which
is a, it's a photo

38
00:02:31.640 --> 00:02:35.480
management application and tomboy, which
is a note taking application

39
00:02:35.510 --> 00:02:38.420
and you can collaborate with
it and that's, and these,

40
00:02:38.450 --> 00:02:41.390
these other projects have grown
and evolved in similar fashions

41
00:02:41.390 --> 00:02:45.470
as well. And what happened
is, you know, as we're

42
00:02:45.470 --> 00:02:49.520
developing banshee and F spot
and tomboy and beagle our

43
00:02:49.520 --> 00:02:54.530
search strategy, we're actually finding
problems in Moto and we're

44
00:02:54.530 --> 00:02:58.190
fixing problems in motto. So
by way of, of using

45
00:02:58.190 --> 00:03:01.330
motto at an early, we're
actually helping grow motto as

46
00:03:01.330 --> 00:03:03.610
a platform. So it's a
way of, of, you know,

47
00:03:03.610 --> 00:03:08.140
seriously dogfooding our, our, our
platform here. So, you know,

48
00:03:08.140 --> 00:03:13.050
everything kind of mixes together
and grows as one. So

49
00:03:13.050 --> 00:03:16.740
banshee was kind of a
forcing function to push mano

50
00:03:16.740 --> 00:03:19.620
kind of to its limits.
Yeah, correct. And you know,

51
00:03:19.620 --> 00:03:22.080
for the first couple of
years, or two or three

52
00:03:22.080 --> 00:03:24.900
years here, you know, we
would run into problems all

53
00:03:24.900 --> 00:03:28.920
the time where, you know,
we might not otherwise run

54
00:03:28.920 --> 00:03:31.710
into, so yeah, we pushed
back on motto and motto

55
00:03:31.710 --> 00:03:33.810
pushes back on us and,
and ultimately we end up

56
00:03:33.840 --> 00:03:37.680
with better products all around
there is for instance, really

57
00:03:37.680 --> 00:03:41.660
early on when we were
just getting generic support in,

58
00:03:41.700 --> 00:03:44.700
in, in the C sharp
compiler, the Montessori sharp compiler

59
00:03:46.110 --> 00:03:49.080
Batu was actually the first
project to, to actually switch

60
00:03:49.080 --> 00:03:52.860
to D to generics. So
we ran into of course,

61
00:03:52.860 --> 00:03:56.790
a bunch of bugs in
the compiler interpreting, you know,

62
00:03:56.820 --> 00:04:00.060
the, the C sharp spec
on generics. So we ultimately,

63
00:04:00.090 --> 00:04:02.730
we would fix bugs in
the compiler, but then the

64
00:04:02.900 --> 00:04:09.870
distributions, the Linux distributions that
actually shipped the compiler, we

65
00:04:09.870 --> 00:04:11.820
couldn't use that. So we
had to actually bundle our

66
00:04:11.820 --> 00:04:15.150
own compiler as part of
the build process for banshee

67
00:04:15.690 --> 00:04:19.740
to sort of bootstrap until
the mano project actually had

68
00:04:19.740 --> 00:04:23.970
kind of released those changes
into the wild Yikes. That's

69
00:04:23.970 --> 00:04:27.180
pretty bleeding edge. So yeah,
but you know, the end

70
00:04:27.180 --> 00:04:30.260
result is, is the model
platform at this stage. And

71
00:04:30.260 --> 00:04:34.320
in 2009, especially with the
two dot four release, which

72
00:04:34.320 --> 00:04:38.220
is a long term support
release, you know, we have

73
00:04:38.220 --> 00:04:41.750
full C-sharp three, you know,
with link and generics and,

74
00:04:41.750 --> 00:04:45.570
and all that good stuff.
So we're, we're definitely, you

75
00:04:45.570 --> 00:04:47.370
know, it's a real platform
that should really be looked

76
00:04:47.370 --> 00:04:51.210
at seriously. Now, a lot
of people have probably heard

77
00:04:51.210 --> 00:04:54.270
of mano, maybe they've read,
you know, Miguel's blog, or

78
00:04:54.270 --> 00:04:57.120
they've looked at some stuff
online, but just to, just

79
00:04:57.120 --> 00:04:58.620
to be clear, we should
probably talk a little bit

80
00:04:58.620 --> 00:05:02.340
about motto that people who
work on mano haven't looked

81
00:05:02.340 --> 00:05:04.890
at the dotnet source code.
They're basically doing a complete

82
00:05:05.370 --> 00:05:12.330
black box implementation of, of.net
reading from the specs. It's

83
00:05:12.330 --> 00:05:16.410
a complete reimagination, but, but
it's, it's, it's L compatible.

84
00:05:16.410 --> 00:05:20.460
I mean, I can, I
can compile something on mano

85
00:05:20.610 --> 00:05:24.540
on Linux and it'll run
on windows. Yes, that's correct.

86
00:05:24.540 --> 00:05:27.720
And you know, so mano
is a very, very large

87
00:05:27.720 --> 00:05:32.550
project. And at the very
core is we have implementations

88
00:05:32.580 --> 00:05:36.420
of the C sharp compiler,
and then there's a, an

89
00:05:36.420 --> 00:05:39.630
implementation of the jet and
the garbage collector and all

90
00:05:39.630 --> 00:05:44.460
that. And of course that's
written in C and then

91
00:05:44.490 --> 00:05:46.590
the third kind of tier
that, that is the core

92
00:05:46.590 --> 00:05:49.860
of them on a project
are actually implementations at the

93
00:05:49.860 --> 00:05:52.830
class library. So, you know,
system XML and that's core

94
00:05:52.830 --> 00:05:59.180
lab. And so on those,
those class implementations are actually

95
00:05:59.870 --> 00:06:05.270
written based on the public
API. So the actual code

96
00:06:05.270 --> 00:06:09.200
underneath there between dotnet and
Moto, or are completely separate

97
00:06:09.200 --> 00:06:13.220
libraries, but they're, they're API
compatible, they're API compatible. So

98
00:06:13.220 --> 00:06:18.350
you can take a MSI
L code generated by the.net

99
00:06:18.440 --> 00:06:21.020
C-sharp compiler CSC, and you
can run it on Moto

100
00:06:21.080 --> 00:06:25.450
and vice versa. So that
means if I use system.io

101
00:06:25.450 --> 00:06:28.750
dot file, no matter whether
I do it on windows

102
00:06:28.750 --> 00:06:31.090
and our.net compiler and my
models and yours, when it

103
00:06:31.090 --> 00:06:33.280
all gets linked up, it's
going to, it's going to

104
00:06:33.290 --> 00:06:37.750
work, Correct. It'll work on
either platform. Okay. And this

105
00:06:37.750 --> 00:06:40.060
is interesting because talking about
this will get us into

106
00:06:40.060 --> 00:06:42.480
some of the challenges that
you got into on, on

107
00:06:42.490 --> 00:06:47.530
banshee. So I did this
article a long, long time

108
00:06:47.530 --> 00:06:51.310
ago that we called the
myth of dotnet purity. This

109
00:06:51.310 --> 00:06:54.370
was back when sun had
started their a hundred percent

110
00:06:54.400 --> 00:06:56.560
Java thing. And they were
saying, are you a hundred

111
00:06:56.560 --> 00:07:00.810
percent Java is your code
100% pure Java? And it

112
00:07:00.810 --> 00:07:02.440
was kind of a reminder.
The article was meant to

113
00:07:02.440 --> 00:07:05.080
be a reminder that at
some point somebody is going

114
00:07:05.080 --> 00:07:07.210
to get onto the metal.
You know, someone's going to

115
00:07:07.210 --> 00:07:10.450
call load library, and someone's
going to call C code

116
00:07:10.870 --> 00:07:14.110
that, that, you know, pure
managed code is kind of

117
00:07:14.110 --> 00:07:18.250
a myth with all of
these libraries. You know, you

118
00:07:18.250 --> 00:07:20.890
may be calling system diode
on a file, but someone's

119
00:07:20.890 --> 00:07:24.430
going to call some low
level C runtime function. That's

120
00:07:24.430 --> 00:07:26.890
going to, you know, get
down on the metal. Does

121
00:07:26.890 --> 00:07:29.110
that mean that in, in
mano, there are, there are

122
00:07:29.140 --> 00:07:32.740
two implementations of system that
I would not file one

123
00:07:32.740 --> 00:07:35.770
for, we have a three,
actually one for Mac and

124
00:07:35.770 --> 00:07:37.960
one for Lennox, and one
for windows that, that actually

125
00:07:37.960 --> 00:07:41.140
do the work of opening
the file. Yes, that's correct.

126
00:07:41.140 --> 00:07:43.780
So there's a couple different
things to look at here.

127
00:07:44.140 --> 00:07:49.690
One is the actual.net library.
So system.io, for instance, it

128
00:07:49.690 --> 00:07:54.580
has to obviously be compatible
function-wise, you know, if there

129
00:07:54.580 --> 00:07:56.710
are any bugs, which, you
know, of course there aren't,

130
00:07:57.400 --> 00:08:00.340
is there any bugs in
Microsoft's implementation? We have to

131
00:08:00.340 --> 00:08:05.770
be bug for bug compatible.
So, so, you know, if,

132
00:08:06.220 --> 00:08:07.810
if there's a, if there's
a code path that you

133
00:08:07.810 --> 00:08:12.220
hit in, in a.net API,
that is an optimal, then

134
00:08:12.220 --> 00:08:14.170
we sort of have to
take that hit as well

135
00:08:14.170 --> 00:08:17.650
to ensure that we stay
compatible. So that being said,

136
00:08:18.550 --> 00:08:20.500
and, and I'll use this
I'll use system. IO is

137
00:08:20.500 --> 00:08:24.370
a great example when you
use the system IO APIs

138
00:08:24.370 --> 00:08:27.220
on Linux or on a
POSIX operating system. So this

139
00:08:27.460 --> 00:08:31.750
means the Mac as well,
or, or a BSD, you

140
00:08:31.750 --> 00:08:33.970
actually incur a little, a
little bit of a performance

141
00:08:33.970 --> 00:08:36.430
hit when you use these
API APIs. Some of that's

142
00:08:36.430 --> 00:08:40.600
related to sort of workarounds
and compatibilities that have to

143
00:08:40.600 --> 00:08:43.990
be met on the underlying
implementation and Moto, and some

144
00:08:43.990 --> 00:08:46.810
of that's because there are
pieces of the system IO

145
00:08:46.900 --> 00:08:51.640
API that don't really make
sense. They're not really conducive

146
00:08:51.640 --> 00:08:56.040
to performance. One of these
examples is say that get

147
00:08:56.040 --> 00:09:00.570
files method on, on system
IO directory. It returns an

148
00:09:00.570 --> 00:09:04.710
array instead of being IEnumerable.
So what happens if you're

149
00:09:04.710 --> 00:09:07.680
walking a large directory and
we ran into this specifically

150
00:09:07.680 --> 00:09:09.990
in banshee, where we're, where
we would crawl your media

151
00:09:09.990 --> 00:09:13.770
directory, recursively, to look for
files to load, we would

152
00:09:13.770 --> 00:09:15.690
have to walk the directory,
but you couldn't act on

153
00:09:15.690 --> 00:09:19.020
any of those files until
the actual directory recursion was

154
00:09:19.020 --> 00:09:21.570
complete because the array had
to be created and then

155
00:09:21.570 --> 00:09:24.360
returned. So you end up
with a lot of stack

156
00:09:24.360 --> 00:09:26.520
and heap overhead there, but
you also can't act on

157
00:09:26.520 --> 00:09:29.370
what you're looking for until
that that array has created.

158
00:09:30.630 --> 00:09:33.780
So that sucks. So yeah,
we have, you know, that's

159
00:09:33.780 --> 00:09:36.540
a problem on.net, but it
also by extension is a

160
00:09:36.540 --> 00:09:39.720
problem on mano to be
compatible, right? So the mano

161
00:09:39.720 --> 00:09:44.760
project has implemented tons and
tons and tons of extra

162
00:09:44.760 --> 00:09:49.650
libraries that work on both
mano and.net. There is a

163
00:09:49.650 --> 00:09:53.910
layer called mano dot Unix
or monitor dot POSIX, which

164
00:09:53.910 --> 00:09:56.640
is a separate API that
sort of allows you to

165
00:09:56.640 --> 00:09:59.700
work around these problems. So
there's a, there's like a,

166
00:09:59.880 --> 00:10:02.730
and this isn't exactly the
right API name, but there's

167
00:10:03.150 --> 00:10:08.370
a mano.posix.io, for instance, with
an API, similar to the

168
00:10:08.370 --> 00:10:11.550
system IO API, but it
provides a get files method

169
00:10:11.550 --> 00:10:15.810
that uses innumerable innumerable instead.
And, you know, it does

170
00:10:15.810 --> 00:10:19.560
things like yield, yield returns,
files as they're walked. So

171
00:10:19.560 --> 00:10:22.950
it's that implementation is allowed
to use the direct POSIX

172
00:10:23.320 --> 00:10:27.120
API, the C API, which
is much, much faster than

173
00:10:27.570 --> 00:10:31.290
the sort of safe and
compatible implementation inside of system.io.

174
00:10:32.310 --> 00:10:35.820
So the way this is
kind of architected in batches,

175
00:10:35.820 --> 00:10:40.950
we have an actual IO
abstraction layer and the default

176
00:10:40.950 --> 00:10:45.540
implementation of that abstraction uses
system.io. So that that implementation

177
00:10:45.540 --> 00:10:48.420
will work. It'll, it's functionally
correct on all platforms, be

178
00:10:48.420 --> 00:10:51.930
it windows, Mac, or Linux.
But if we detect that

179
00:10:51.930 --> 00:10:56.520
you're running on a POSIX
compatible system, we load our

180
00:10:56.610 --> 00:11:00.600
POSIX IO backend instead, and
that, and that backend implements

181
00:11:00.690 --> 00:11:08.910
are abstracted. IOPI using the
mano POSIX implementation. So we

182
00:11:08.910 --> 00:11:12.510
ended up actually, you know,
performing better and in a

183
00:11:12.510 --> 00:11:14.820
lot of cases on Linux
than we do on windows.

184
00:11:15.630 --> 00:11:17.810
Interesting. And that, and that
kind of does, it's a

185
00:11:17.810 --> 00:11:22.040
perfect example of the, the
myth of, of purity in

186
00:11:22.040 --> 00:11:24.380
the sense that here's an
application that, you know, you

187
00:11:24.380 --> 00:11:29.780
write once and basically debug
it, Right? So, I mean,

188
00:11:30.200 --> 00:11:33.770
that's just a small example.
We have similar abstractions for,

189
00:11:33.780 --> 00:11:38.390
for hardware, for integration into
desktop environments. So for example,

190
00:11:39.410 --> 00:11:44.450
in genoma a desktop environment
for Linux, there's an API

191
00:11:44.450 --> 00:11:46.400
that we can use to
inhibit the screensaver when you're

192
00:11:46.400 --> 00:11:50.030
playing video and full screen.
So of course that API

193
00:11:50.030 --> 00:11:52.850
doesn't exist on windows or
in Mac. So we have

194
00:11:53.560 --> 00:11:56.320
a few layers that we
have a hardware layer that,

195
00:11:56.320 --> 00:11:59.860
and these are abstractions. So
you would implement a hardware

196
00:11:59.860 --> 00:12:03.400
backend for Mac, a hardware
backend for, for Linux and

197
00:12:03.400 --> 00:12:05.980
one for windows. And then
we have platform abstraction layers

198
00:12:07.660 --> 00:12:10.840
where you implement sort of
specific things for desktop environments

199
00:12:10.840 --> 00:12:14.020
or, or the operating system.
So we would implement the

200
00:12:14.020 --> 00:12:16.360
screensaver thing for windows, Mac,
and Linux. And these are

201
00:12:16.360 --> 00:12:21.940
all actually mano adding extensions.
So everything is, is fully

202
00:12:21.940 --> 00:12:26.650
dynamic. None of this non-core
code is actually compiled into

203
00:12:26.650 --> 00:12:30.490
banshee itself. They're all written
as separate assemblies or extensions

204
00:12:30.490 --> 00:12:33.830
that load in at runtime
based on the environment and

205
00:12:33.910 --> 00:12:37.200
the actual startup profile for
banshee. Nice. So this is,

206
00:12:37.200 --> 00:12:39.930
this is nice. So this,
this is moving really beyond

207
00:12:39.930 --> 00:12:42.390
the, the old style of
things that we used to

208
00:12:42.390 --> 00:12:44.880
do in Java. When we
would say, basically we have

209
00:12:44.880 --> 00:12:47.190
a big switch statement, you
know, and if, if on

210
00:12:47.190 --> 00:12:50.430
Macintosh, do this else do
that, you've really pulled that

211
00:12:50.430 --> 00:12:53.610
stuff out. And you just
pointed out mano dot addins,

212
00:12:53.610 --> 00:12:57.390
which is a plugin model
that's that came before meth,

213
00:12:57.420 --> 00:13:01.110
the managing sensibility framework, which
I think now is open

214
00:13:01.110 --> 00:13:03.450
source and is something that
mano could potentially use if,

215
00:13:03.750 --> 00:13:07.230
if you wanted to. Right.
Correct. So, so mono Adams

216
00:13:07.250 --> 00:13:10.170
has been around for a
couple of years, and the

217
00:13:10.170 --> 00:13:15.180
idea was just that you
define extension points, which are,

218
00:13:15.210 --> 00:13:17.730
which are APIs that could
be interfaces, or they could

219
00:13:17.730 --> 00:13:22.260
be, you know, sort of
factory classes. And then you

220
00:13:22.260 --> 00:13:27.360
define addins that implement certain
extension points. And at runtime,

221
00:13:27.360 --> 00:13:30.900
mano addins sort of reflects
over any assemblies you give

222
00:13:30.900 --> 00:13:33.420
it. And it looks for
these resource files, which are,

223
00:13:33.600 --> 00:13:37.350
they're basically XML files that
describe whether a certain class

224
00:13:37.350 --> 00:13:41.270
and that extension extends any
extension point defined in the

225
00:13:41.340 --> 00:13:45.750
core application. Of course, reflecting
is, can be very slow.

226
00:13:46.080 --> 00:13:48.870
So mano addins on the
first run. It will, it

227
00:13:48.870 --> 00:13:52.170
will reflect the assemblies, but
it also creates a database,

228
00:13:52.170 --> 00:13:55.920
a binary database of the
extension points that are the

229
00:13:55.920 --> 00:13:58.800
extensions and the extension points
that should sort of mix

230
00:13:58.800 --> 00:14:01.620
in that environment. So then
on a subsequent run or

231
00:14:01.620 --> 00:14:05.520
until any, any of the
assemblies change, you're not, it's

232
00:14:05.520 --> 00:14:08.790
not reflecting again. So it's
very, very fast, at least

233
00:14:08.790 --> 00:14:11.280
on the second startup. Okay.
So it's a little, a

234
00:14:11.280 --> 00:14:14.650
little jitter there to make
those extension points Correct. And

235
00:14:14.670 --> 00:14:17.100
depending on the build environment,
or, you know, if we're

236
00:14:17.100 --> 00:14:19.620
shipping a runtime build or,
I mean, a, if we're

237
00:14:19.620 --> 00:14:21.810
not shipping a debug build,
for instance, we can actually

238
00:14:21.810 --> 00:14:25.380
generate that, that extension database
ahead of time. Cause we

239
00:14:25.380 --> 00:14:28.020
can guarantee that the assemblies
aren't going to change for

240
00:14:28.020 --> 00:14:30.750
a given release, so that,
so that, you know, if

241
00:14:30.750 --> 00:14:34.050
you're not in a debug
environment, you won't actually incur

242
00:14:34.050 --> 00:14:38.640
that startup cost on the
first run, but, but you

243
00:14:38.640 --> 00:14:41.520
know, meth came around fairly
recently, I guess within the

244
00:14:41.520 --> 00:14:43.350
last year we've heard a
lot of meth noise and

245
00:14:43.350 --> 00:14:47.520
it became open source, which
is fantastic and mono addins,

246
00:14:47.580 --> 00:14:51.200
they're, they're very similar, but
I think, and I haven't

247
00:14:51.200 --> 00:14:53.480
looked into meth too extensively,
but I think mano Adams

248
00:14:53.480 --> 00:15:00.020
is probably a little more
detailed. In fact, one of

249
00:15:00.020 --> 00:15:02.810
the, one of the proposals
is to rebase Moto addons

250
00:15:03.140 --> 00:15:07.160
on meth itself. So meth
is a little more low

251
00:15:07.160 --> 00:15:09.710
level. It does a lot
of the same things ultimately,

252
00:15:10.100 --> 00:15:12.620
but what mano addons provides
is a greater sort of

253
00:15:12.620 --> 00:15:16.670
description model of your extensions.
So that's, so you can

254
00:15:16.700 --> 00:15:19.850
ultimately achieve the same thing
with both frameworks, but it'd

255
00:15:19.850 --> 00:15:22.250
be really interesting to see
mano addins actually rebased on

256
00:15:22.250 --> 00:15:25.370
top of meth. And of
course, Moto addons itself is,

257
00:15:25.850 --> 00:15:27.530
you know, runs on all
the platforms. So you can

258
00:15:27.530 --> 00:15:31.220
use motto addins with just
a regular.net application. You don't,

259
00:15:31.520 --> 00:15:34.370
you're not actually tied to
mano here. You could, you

260
00:15:34.370 --> 00:15:37.910
know, you load the mano
addins assemblies in visual studio

261
00:15:38.540 --> 00:15:40.400
and you just start using
the API and you distribute

262
00:15:40.400 --> 00:15:44.570
those assemblies with your application,
which of course are MIT

263
00:15:44.570 --> 00:15:47.260
X, 11 license, which is
very similar to the, the

264
00:15:47.450 --> 00:15:51.800
new MSPL from Microsoft. So
there's no, no worry of

265
00:15:51.800 --> 00:15:54.580
distribution problems here. Okay. So
just to make sure that,

266
00:15:54.580 --> 00:15:56.770
that, that we're clear and
correct me if I'm wrong

267
00:15:56.770 --> 00:16:00.070
here, that this means that
a windows developer using visual

268
00:16:00.070 --> 00:16:03.550
studio might want to bring
in mano dot something one

269
00:16:03.550 --> 00:16:06.340
of those names basis, because
it provides actual functionality. They

270
00:16:06.340 --> 00:16:08.590
wouldn't necessarily be using mano
in the sense that the

271
00:16:08.590 --> 00:16:11.830
runtime isn't mano, but they
could definitely look at those

272
00:16:11.830 --> 00:16:16.490
libraries if they provided value
to them. Correct. Absolutely. And

273
00:16:16.600 --> 00:16:19.330
there's, you know, we have
dozens of, of sort of

274
00:16:19.330 --> 00:16:23.230
add on libraries that kind
of just belong under the

275
00:16:23.230 --> 00:16:27.070
motto project as a giant
umbrella, but aren't specifically related

276
00:16:27.070 --> 00:16:31.060
to motto as, as a
platform. Another example is another

277
00:16:31.060 --> 00:16:36.100
library maintained called mono zero
camp, and it's a, it's

278
00:16:36.100 --> 00:16:39.550
an API that's built on
motto admins as well, that

279
00:16:40.090 --> 00:16:43.660
implements the bone as your,
or, or zero COVID API

280
00:16:43.660 --> 00:16:49.540
from Apple and on windows
that uses the actual C

281
00:16:49.570 --> 00:16:53.380
library from Apple called Bonjour.
But on Linux, it uses

282
00:16:55.180 --> 00:17:00.160
another platform called <inaudible>, which
is just kind of a

283
00:17:00.160 --> 00:17:04.780
completely separate MD and SSD
implementation, but it allows basically

284
00:17:04.780 --> 00:17:07.960
an application to use a
single API regardless of the

285
00:17:07.960 --> 00:17:10.510
underlying zero COVID platform on
a given system. So on

286
00:17:10.510 --> 00:17:12.790
Mac and windows, it uses
the same library on Linux.

287
00:17:12.790 --> 00:17:15.760
It can use the actual
of library as well or

288
00:17:15.820 --> 00:17:19.120
a separate platform, the platform.
So we have lots of

289
00:17:19.120 --> 00:17:21.640
umbrella projects like that. Okay.
And just to be clear

290
00:17:21.640 --> 00:17:24.610
to those listeners that don't
necessarily speak English, a zero

291
00:17:24.610 --> 00:17:28.450
comp means zero configuration, right?
Right. It's a, it's a,

292
00:17:29.200 --> 00:17:33.250
it's a broadcast networking protocol.
So it allows devices on

293
00:17:33.250 --> 00:17:35.140
a network on a local
network to discover each other

294
00:17:35.140 --> 00:17:39.550
without actually knowing in advance
IP addresses and so on.

295
00:17:40.870 --> 00:17:45.370
So for instance, you can
locate printers or SSH servers.

296
00:17:45.370 --> 00:17:47.560
And so on, on a
given network, I wrote Moana

297
00:17:47.560 --> 00:17:51.750
zero cough because we needed
to work with iTunes is

298
00:17:52.320 --> 00:17:58.740
digital audio sharing protocol. And
that's the discovery mechanism underneath

299
00:17:58.740 --> 00:18:00.300
there. So you can see
in banshee, you can see

300
00:18:00.300 --> 00:18:04.490
all the iTunes shares. Very
cool. Now you can play

301
00:18:04.490 --> 00:18:09.950
videos too, right? Correct. As
of our latest sort of

302
00:18:09.950 --> 00:18:12.920
generation of anti we support
videos, vantage has gone through

303
00:18:13.130 --> 00:18:16.130
it's about three generations, I
guess, where we've had to

304
00:18:16.130 --> 00:18:19.820
pretty complete refactoring and rewrite.
And the second one, the

305
00:18:19.820 --> 00:18:23.600
goal was to, to use
motto addons and, and be

306
00:18:23.600 --> 00:18:26.300
completely modular. So, you know,
only the core part of

307
00:18:26.300 --> 00:18:29.390
Angie is written in pure
C sharp and it'll run

308
00:18:29.390 --> 00:18:33.710
anywhere, anywhere there's we would
introduce or need for performance

309
00:18:33.710 --> 00:18:36.860
reasons or for, you know,
to improve the user experience.

310
00:18:37.640 --> 00:18:41.510
We always abstract something so
that we can implement the

311
00:18:41.510 --> 00:18:46.100
best use of the actual
users resources in a given

312
00:18:46.100 --> 00:18:51.230
system. And so one of
those ends is actually video

313
00:18:51.230 --> 00:18:56.810
support. We use the G
streamer backend, hopefully universally, we're

314
00:18:56.810 --> 00:19:00.080
trying to use G streamer
everywhere because juice rumor now

315
00:19:00.080 --> 00:19:04.640
runs on windows, Linux, or
Mac, and g-string herself is

316
00:19:04.640 --> 00:19:09.200
plugin based. So it uses
for instance, direct show indirect

317
00:19:09.200 --> 00:19:12.320
X on, on, on windows
to do video rendering and,

318
00:19:12.550 --> 00:19:17.060
and audio playback. It uses
the, the core audio core

319
00:19:17.060 --> 00:19:21.350
video support in OSX to
do video rendering and playback.

320
00:19:21.830 --> 00:19:24.320
And then it uses whatever's
available on Linux. Be it

321
00:19:25.160 --> 00:19:28.730
open GL rendering, or rendering
straight to the X server

322
00:19:28.730 --> 00:19:31.250
or whatnot. No. Then that
G stream is written in

323
00:19:31.250 --> 00:19:36.890
C though. Yes. Just remember
a C library. Actually, the

324
00:19:36.890 --> 00:19:39.170
only piece of banshee that's
not written in C sharp

325
00:19:39.170 --> 00:19:46.070
right now is our media
pipeline API, which actually integrates

326
00:19:46.070 --> 00:19:49.460
with G streamer. It's a
small amount of C it's

327
00:19:49.490 --> 00:19:52.430
probably around 3000 lines of
C code that we then

328
00:19:52.430 --> 00:19:58.340
bind. We P invoke into
from our abstracted media player

329
00:19:58.400 --> 00:20:01.490
API. Hi, this is Scott
Hanselman with a word from

330
00:20:01.490 --> 00:20:04.160
our sponsor. Do you know
how to build web 2.0

331
00:20:04.160 --> 00:20:07.940
Ajax applications with web 1.0
components? You really can't. If

332
00:20:07.940 --> 00:20:10.340
you want to do the
next generation web applications you'll

333
00:20:10.340 --> 00:20:12.890
need next generation components. Just
like the ones that our

334
00:20:12.890 --> 00:20:15.850
friends at Telerik have got
their rad controls for ESPN

335
00:20:15.850 --> 00:20:18.680
and Ajax. It's a huge
pack of web controls built

336
00:20:18.680 --> 00:20:23.240
on top of asp.net, Ajax
that lab previously impossible performance

337
00:20:23.250 --> 00:20:27.020
interactivity to your next project.
The new controls mirror, the

338
00:20:27.050 --> 00:20:31.460
Ajax API from asp.net. So
development is really straightforward. The

339
00:20:31.460 --> 00:20:33.710
client scripts are shared. So
loading time is not a

340
00:20:33.710 --> 00:20:36.110
problem. If you just set
a couple of properties and

341
00:20:36.110 --> 00:20:38.360
you'll be able to automatically
bind a web services for

342
00:20:38.360 --> 00:20:42.220
a really efficient operation, the
new rad editor from ESPN

343
00:20:42.260 --> 00:20:45.800
Ajax, Telerik loads up to
four times faster than before.

344
00:20:46.010 --> 00:20:48.460
And the new rad grid
handles thousands of records and

345
00:20:48.460 --> 00:20:51.310
just milliseconds, but as always,
it's best to try for

346
00:20:51.310 --> 00:20:55.270
yourself. So you can visit
<inaudible> dot com slash ASP,

347
00:20:55.270 --> 00:20:58.840
net Ajax, and download a
trial. Thanks a lot. Okay.

348
00:20:58.840 --> 00:21:00.550
And this is the part
that I wanted to understand

349
00:21:00.550 --> 00:21:04.030
the most and forgive my
ignorance. But so there's a

350
00:21:04.030 --> 00:21:08.440
G streamer C implemented. There's
a G streamer implementation that

351
00:21:08.440 --> 00:21:11.590
is available for each of
these different platforms. It's not

352
00:21:11.590 --> 00:21:15.450
the same binary, right? Right.
It's not the same binary

353
00:21:16.530 --> 00:21:18.210
at this level where we're
at. See, so it has

354
00:21:18.210 --> 00:21:21.360
to be compiled for each
given architecture and platform. All

355
00:21:21.360 --> 00:21:23.220
right. So I want to
be clear for our listeners,

356
00:21:23.220 --> 00:21:27.300
there's three or four different
implementations of shimmer and kind

357
00:21:27.300 --> 00:21:30.210
of thinking about things in
terms of the way I

358
00:21:30.210 --> 00:21:32.070
always think about it as
terms of the left hand

359
00:21:32.070 --> 00:21:34.290
and the right hand. In
this case, you might have

360
00:21:34.290 --> 00:21:36.690
a version of G streamer
for windows and the right

361
00:21:36.690 --> 00:21:39.870
hand is talking to a
direct show, but the left

362
00:21:39.870 --> 00:21:43.680
hand looks exactly the same
as the G streamer API

363
00:21:43.680 --> 00:21:47.430
for Mac or for Linux.
Right? So, so G streamer

364
00:21:47.430 --> 00:21:50.010
itself is sort of written
in a similar way only

365
00:21:50.970 --> 00:21:53.130
it's, it's written in C
it's written in a similar

366
00:21:53.130 --> 00:21:56.310
way as in terms of
its abstraction as, as banshee,

367
00:21:56.310 --> 00:21:58.530
for instance, and that it
has its own internal plugin

368
00:21:58.530 --> 00:22:02.640
model. So all the core
G streamer stuff, it's only,

369
00:22:02.640 --> 00:22:06.030
there's only one implementation it's
written in C and it

370
00:22:06.060 --> 00:22:09.120
can be compiled on, on
any platform and architecture, but

371
00:22:09.120 --> 00:22:12.660
the actual plugins, the say
the plugin that provides video

372
00:22:12.660 --> 00:22:16.830
rendering on windows or audio
rendering on the Mac there

373
00:22:16.830 --> 00:22:21.270
specific implementations to that platform.
Right. Exactly. Okay. So then

374
00:22:21.720 --> 00:22:24.420
with, with gene shimmer, then,
so then you have a,

375
00:22:24.700 --> 00:22:28.620
a P invoke UUP invoke
into G streamer, and you

376
00:22:28.620 --> 00:22:31.680
have structures that are, that
are handling that marshaling and

377
00:22:31.680 --> 00:22:36.450
that are g-string were specific
managed structures. And then you,

378
00:22:36.450 --> 00:22:39.960
you, you talk to those,
Right? So at the bench

379
00:22:39.970 --> 00:22:43.490
level, we only talked to
G streamer in terms of,

380
00:22:43.490 --> 00:22:45.990
of the common API. And
there, there are a couple

381
00:22:45.990 --> 00:22:50.790
of, you know, very small
in cases where we don't

382
00:22:50.790 --> 00:22:54.330
do that, where we know
that an optimal path on

383
00:22:54.330 --> 00:22:56.460
windows is going to be
to go ahead and just

384
00:22:56.700 --> 00:23:00.180
load the direct show plugins
instead of trying to search

385
00:23:00.180 --> 00:23:02.130
for them in a registry
to figuring out which is

386
00:23:02.130 --> 00:23:04.140
the best one, cause on
Linux, there are a number

387
00:23:04.140 --> 00:23:06.690
of options that that could
be the right path, but

388
00:23:06.690 --> 00:23:09.330
on windows, there's only one.
So if we detect and

389
00:23:09.330 --> 00:23:14.070
live banshee the actual underlying
C library for banshee, if

390
00:23:14.070 --> 00:23:16.140
we detect that we're on
windows, then we don't do

391
00:23:16.140 --> 00:23:19.230
the kind of dynamic registry
loading thing. We instead just

392
00:23:19.680 --> 00:23:24.270
directly create these direct show
elements for the pipeline. So

393
00:23:24.360 --> 00:23:27.210
we have some cases where
we will definitely optimize code

394
00:23:27.210 --> 00:23:30.330
paths for the given platform,
just for sheer performance reasons.

395
00:23:31.320 --> 00:23:33.360
Can you talk a little
bit about where you hide

396
00:23:33.360 --> 00:23:36.540
those things? Because whenever I
hear, when we detect that

397
00:23:36.540 --> 00:23:38.430
we're on windows, or when
we notice we're on a

398
00:23:38.430 --> 00:23:42.000
Mac, I kind of remember
some of the horrible sins

399
00:23:42.000 --> 00:23:46.250
that I committed in Java
detecting where I was when

400
00:23:46.250 --> 00:23:48.980
I wasn't supposed to be
knowing these things at what

401
00:23:48.980 --> 00:23:52.160
layer of abstraction do you
bury all of this? If

402
00:23:52.160 --> 00:23:54.920
on the Mac, if on
windows, is this code or

403
00:23:54.920 --> 00:23:57.800
is this in the mano
add ins XNL files? Where

404
00:23:57.800 --> 00:24:01.270
do Most of the time
and in the best cases,

405
00:24:01.720 --> 00:24:03.910
and we've kind of diverse
a little bit from dotnet

406
00:24:03.910 --> 00:24:05.800
here talking about G streamers.
So let me kind of

407
00:24:05.800 --> 00:24:11.230
circle back around if most
of the time it's actually

408
00:24:11.230 --> 00:24:13.990
just in the, the solution
file, the, the visual studio

409
00:24:13.990 --> 00:24:17.500
solution file. And I should
mention, we use actual the

410
00:24:17.500 --> 00:24:20.650
actual SLN and CS proj
files to build all of

411
00:24:20.650 --> 00:24:25.000
banshee. So the project builds
with <inaudible> on Linux, I'm

412
00:24:25.000 --> 00:24:28.390
using monitor develop the, the,
the IDE that's very much

413
00:24:28.390 --> 00:24:31.570
like visual studio that runs
on actually now it as

414
00:24:31.570 --> 00:24:36.160
well runs on windows, Mac,
and Linux, but it supports,

415
00:24:36.190 --> 00:24:39.940
you know, visual studio, 2005,
eight and 10 solution to

416
00:24:39.940 --> 00:24:43.870
NCS profiles. So if, if
you run on Linux, if

417
00:24:43.870 --> 00:24:47.500
you have five on Linux
and monitor, develop the actual

418
00:24:47.560 --> 00:24:51.040
ms build conditions and so
on fulfill that platform detection.

419
00:24:51.820 --> 00:24:55.870
So basically if we say
that a given ad in

420
00:24:55.870 --> 00:25:00.280
or assembly is specific to
windows, then that never even

421
00:25:00.280 --> 00:25:03.820
gets built on Linux or
Mac. But if we open

422
00:25:03.820 --> 00:25:06.730
the solution file in visual
studio on windows, then the

423
00:25:06.730 --> 00:25:10.000
EMIS bill conditions will pick
all the assemblies or projects

424
00:25:10.030 --> 00:25:12.040
that will build only for
windows. So it will build

425
00:25:12.040 --> 00:25:14.200
the core which builds everywhere,
and then it will build

426
00:25:14.200 --> 00:25:18.580
any specific platform extensions to
windows. So at the ideal

427
00:25:18.580 --> 00:25:21.040
level, it's all just taken
care of by way of,

428
00:25:21.130 --> 00:25:25.660
of ms. Build. And then
you, there are some cases

429
00:25:25.720 --> 00:25:31.030
inside of the core that
we do know for sure

430
00:25:31.030 --> 00:25:33.670
that, you know, on the,
on windows, this was definitely

431
00:25:33.940 --> 00:25:36.730
an optimal path, or we
don't need to do this.

432
00:25:38.320 --> 00:25:41.920
And we can just use
the system dot environment dot,

433
00:25:42.940 --> 00:25:45.610
like system environment, platform, or
something. And that's just an

434
00:25:45.640 --> 00:25:47.440
email and they'll tell you
which platform you're running on.

435
00:25:47.830 --> 00:25:50.080
And so that's perfectly valid.
It works on windows, it

436
00:25:50.080 --> 00:25:53.140
works on motto and so
on, but there's very, very

437
00:25:53.140 --> 00:25:56.260
few uses of that in
our code. We try not

438
00:25:56.260 --> 00:26:01.510
to do any platform detection
at runtime, unless it's, you

439
00:26:01.510 --> 00:26:03.460
know, a super critical code
path that we know we

440
00:26:03.460 --> 00:26:07.840
can optimize safely. I just
mean that there's a banshee

441
00:26:07.840 --> 00:26:11.350
dot exe kind of, you
know, the, the ultimate build

442
00:26:11.350 --> 00:26:15.070
artifact that is specific to
each platform. Yes. That can

443
00:26:15.070 --> 00:26:19.630
be the case. We don't
recommend topping the core assemblies

444
00:26:19.660 --> 00:26:22.870
for, for like a Linux
build. Well, actually, it, it

445
00:26:22.870 --> 00:26:25.660
depends as well Trying to
ask, is that, is it,

446
00:26:25.720 --> 00:26:28.360
is it a reasonable dream
to have one bill that

447
00:26:28.360 --> 00:26:31.810
produces one artifact that works
everywhere? Because I'm happy that

448
00:26:31.810 --> 00:26:35.740
banshee is probably the best
example of a.net application that

449
00:26:35.740 --> 00:26:38.860
can run on a half
dozen Linux implementations, Mac and

450
00:26:38.860 --> 00:26:42.880
windows. And if someone, a
listener is going to think

451
00:26:42.900 --> 00:26:46.140
about doing this, should they
just prepare themselves now to

452
00:26:46.140 --> 00:26:48.990
have conditional builds? Like you've
got, or should they aim

453
00:26:48.990 --> 00:26:52.500
for some, some magical food
dot exe? That'll do it

454
00:26:52.500 --> 00:26:57.590
all. No. So even the
windows, for instance, well, I'll

455
00:26:57.590 --> 00:27:00.770
use the windows, you know,
extensions as an example, they

456
00:27:00.770 --> 00:27:03.230
would build on, on Linux
or Mac, cause it's just

457
00:27:03.230 --> 00:27:06.770
managed code, but at runtime
they might crash because, you

458
00:27:06.770 --> 00:27:09.950
know, they expect something or
some service provided by windows

459
00:27:09.950 --> 00:27:12.800
to be there. So it's
really, it's not so much

460
00:27:12.800 --> 00:27:17.270
about adapting your code to
do certain things based on,

461
00:27:17.290 --> 00:27:20.090
on the platform you're running
on. When you're using a

462
00:27:20.090 --> 00:27:23.690
proper kind of abstraction layer
that mano Adams provides. It's

463
00:27:23.690 --> 00:27:26.060
more about picking the right
assemblies that are going to

464
00:27:26.060 --> 00:27:27.980
be in that directory. I
want to give him a

465
00:27:27.980 --> 00:27:31.190
platform you run on. I
see. Okay. So as long

466
00:27:31.190 --> 00:27:34.010
as you've got the interfacing
lined up the way that

467
00:27:34.010 --> 00:27:37.580
you want, it's just the
couple of platforms specific DLLs

468
00:27:37.580 --> 00:27:38.990
that, that you need to
be aware of. And as

469
00:27:38.990 --> 00:27:41.300
long as they're ready at
the time at, at runtime,

470
00:27:41.330 --> 00:27:45.440
then you'll be okay. Right.
So, but, and then there's

471
00:27:45.440 --> 00:27:47.420
the M it's build optimization
where it's, you know, if

472
00:27:47.420 --> 00:27:50.870
we're creating a build on,
on, on Linux, don't even

473
00:27:50.870 --> 00:27:52.670
try to build the windows
ones. Cause you're not going

474
00:27:52.670 --> 00:27:55.190
to use them. That being
said as part of our

475
00:27:55.190 --> 00:27:58.340
actual release process, when we
do a public release and

476
00:27:58.340 --> 00:28:02.270
we create the DMG file
for, for Mac and we

477
00:28:02.270 --> 00:28:06.050
create the RPMs and the
tarballs for Linux, we actually

478
00:28:06.050 --> 00:28:09.860
run the build on all
those on those separate machines

479
00:28:09.860 --> 00:28:11.720
so that you get, you
know, you don't have to

480
00:28:11.720 --> 00:28:14.240
worry about it at release
time. When you just download

481
00:28:14.240 --> 00:28:16.310
a release from the website,
you download the DMG and

482
00:28:16.310 --> 00:28:18.410
it's, and it's just what
we need to give you

483
00:28:18.410 --> 00:28:21.830
on the Mac. You install
the RPM and it's just

484
00:28:21.830 --> 00:28:24.170
what you get on Linux.
Okay. So you build a

485
00:28:24.170 --> 00:28:27.140
DMG on a Mac Formax
and you build an RPM

486
00:28:27.170 --> 00:28:32.870
on Lenox for Lennox. Correct?
So I, I should say

487
00:28:32.870 --> 00:28:37.250
that we have not actually
made a, an official release

488
00:28:37.250 --> 00:28:41.030
on windows yet, but it,
it absolutely builds and runs

489
00:28:41.600 --> 00:28:45.080
and we're just polishing a
few things up. And hopefully

490
00:28:45.110 --> 00:28:47.900
before the end of the
summer, we'll finally have an

491
00:28:47.900 --> 00:28:50.600
officially sanctioned and stable release
out for windows. So if

492
00:28:50.600 --> 00:28:56.520
anyone's interested in helping out
on the windows port, I

493
00:28:56.570 --> 00:28:58.880
shouldn't call it a port
because it's the same code,

494
00:28:58.880 --> 00:29:02.630
but on the windows release,
then they should definitely get

495
00:29:02.630 --> 00:29:04.460
in touch with us. I
know that you're not a

496
00:29:04.460 --> 00:29:07.100
fan of, of living and
working in the windows world.

497
00:29:07.100 --> 00:29:10.370
So definitely if someone has
some expertise in this area

498
00:29:10.370 --> 00:29:12.110
that might want to jump
in and help you out,

499
00:29:12.110 --> 00:29:13.940
that would keep you off
of windows. Right. And that

500
00:29:13.940 --> 00:29:16.040
would be a good thing.
Well, you know, I'm not

501
00:29:16.040 --> 00:29:18.830
opposed to windows. I just,
you know, my environment is,

502
00:29:18.860 --> 00:29:22.700
is Linux. And in fact
that's what made that, the

503
00:29:22.700 --> 00:29:26.390
reason why we got the
OSX port out first was

504
00:29:26.390 --> 00:29:28.310
just because it was a
more familiar environment for us.

505
00:29:29.390 --> 00:29:32.060
So, I mean, yeah, I'm
running windows right now, but

506
00:29:34.120 --> 00:29:36.080
you know, it's a little
foreign in terms of, you

507
00:29:36.080 --> 00:29:39.860
know, search paths and that
kind of stuff. Yeah, totally.

508
00:29:40.610 --> 00:29:43.030
So any, any help from
the windows world is much

509
00:29:43.030 --> 00:29:46.300
appreciated. We'd love to have
more windows users actively involved

510
00:29:46.300 --> 00:29:48.990
in the community. No, I
think that when this thing

511
00:29:48.990 --> 00:29:51.840
comes out, when you get
your, your actual official binary

512
00:29:51.840 --> 00:29:54.810
release on windows, I think
that's going to be pretty

513
00:29:54.810 --> 00:29:58.050
amazing because to be clear
that like the OSX people,

514
00:29:58.050 --> 00:30:00.480
they don't really know, I
guess like most end users

515
00:30:00.480 --> 00:30:06.180
don't realize this is like.net/motto.
That's really significant. Yeah. I

516
00:30:06.180 --> 00:30:09.280
mean, that's, you know, it's
sort of a goal is,

517
00:30:09.280 --> 00:30:11.160
is you, you really want
to focus on the user

518
00:30:11.160 --> 00:30:13.770
experience and the application and
not really burden the user

519
00:30:13.770 --> 00:30:16.860
with what's running underneath it.
So you're official, like you're

520
00:30:16.860 --> 00:30:19.500
the official media player of
a number of Linux distributions,

521
00:30:19.500 --> 00:30:23.910
is that correct? Correct. And
so there are a number

522
00:30:23.910 --> 00:30:26.970
of mano applications that have
made their way onto Linux

523
00:30:26.970 --> 00:30:29.640
distributions, such that they just,
they run and they look

524
00:30:29.640 --> 00:30:32.190
and they act like any
other application. And that really

525
00:30:32.190 --> 00:30:34.830
no one who doesn't care
has any idea that it's

526
00:30:34.830 --> 00:30:38.070
happening. So that sounds like
a pretty, pretty achieved goal.

527
00:30:38.070 --> 00:30:40.380
That's a pretty good thing.
Yeah. I mean, there's, you

528
00:30:40.380 --> 00:30:42.780
know, there's, at this point,
there's, there's very widespread motto

529
00:30:42.780 --> 00:30:45.480
adoption and you know, not
just in the Linux sector,

530
00:30:45.480 --> 00:30:49.080
but you know, in, in
a lot of other places

531
00:30:49.080 --> 00:30:52.860
too, you probably want to
talk to Miguel more specifically

532
00:30:52.860 --> 00:30:56.160
about, about that kind of
adoption, but it's definitely grown

533
00:30:57.150 --> 00:31:00.300
and, and it's only gonna,
it's only getting bigger. So

534
00:31:00.300 --> 00:31:02.190
if people can get their
brains or if our listeners

535
00:31:02.190 --> 00:31:04.320
can get their brains around
that and all the kind

536
00:31:04.320 --> 00:31:06.810
of the plugin and the
hardware abstraction layers that you've

537
00:31:06.870 --> 00:31:09.450
achieved in banshee on top
of all of that and

538
00:31:09.450 --> 00:31:12.270
being a really awesome media
player. And I think you

539
00:31:12.270 --> 00:31:13.710
said it was the first
media player that works with

540
00:31:13.710 --> 00:31:18.360
the <inaudible> phone It's it's.
So I just implemented hardware

541
00:31:18.840 --> 00:31:22.350
support for the <inaudible>. So
that if you, for instance,

542
00:31:22.350 --> 00:31:25.440
use the, the Amazon MP3
store on your phone and

543
00:31:25.440 --> 00:31:29.130
you purchase music, banshee will
detect that you have actually

544
00:31:29.130 --> 00:31:32.280
purchased music and it'll allow
you to sort of integrate

545
00:31:32.280 --> 00:31:34.680
that into your library and
you can sync across it

546
00:31:34.680 --> 00:31:38.550
just like with iPod. So
we support iPods and MTP,

547
00:31:38.580 --> 00:31:41.580
like the, you know, the,
the place for short devices,

548
00:31:41.580 --> 00:31:44.880
which I think now is
that spec is called something

549
00:31:44.880 --> 00:31:47.700
about Vista, but, but we
work with those devices as

550
00:31:47.700 --> 00:31:51.570
well. So, but on top
of all of this, you,

551
00:31:51.570 --> 00:31:55.230
you also have scripting support
that you originally did in,

552
00:31:55.500 --> 00:31:58.530
in BU Right? So actually
this, this is kind of

553
00:31:58.530 --> 00:32:03.540
an interesting story, how this
evolved, BU which is a,

554
00:32:03.600 --> 00:32:06.570
it's a, it's not quite
dynamic, but it allows you

555
00:32:06.570 --> 00:32:10.740
to, to run code at
runtime. It, but it it's

556
00:32:10.740 --> 00:32:13.890
a language that's very similar
to Python and it works

557
00:32:13.890 --> 00:32:17.730
on.net works on motto. And
I think two years ago,

558
00:32:17.730 --> 00:32:20.190
maybe I tried adding boost
support to banshee with the

559
00:32:20.190 --> 00:32:23.190
idea that we, you know,
you could write plugins and

560
00:32:23.200 --> 00:32:25.770
C sharp and compile them,
they load in banshee, but

561
00:32:25.770 --> 00:32:29.010
I wanted to be able
to actually use our, our

562
00:32:29.010 --> 00:32:32.130
internal API APIs at runtime,
just by typing a little

563
00:32:32.130 --> 00:32:35.790
bit of code. And what
I found was that I

564
00:32:35.790 --> 00:32:39.650
was able to easily integrate
BU but a lot of

565
00:32:39.650 --> 00:32:42.650
our API APIs were, were
very, very internal and that

566
00:32:42.920 --> 00:32:45.380
they didn't really make sense
unless you were running in

567
00:32:45.710 --> 00:32:48.440
you're actually hacking or writing
code in the context of

568
00:32:48.440 --> 00:32:51.620
the entire application. So it
was very difficult to actually

569
00:32:52.070 --> 00:32:53.870
get little things done without
having to go into the

570
00:32:53.870 --> 00:32:58.490
core and make changes. So
integrating BU actually led to

571
00:32:59.570 --> 00:33:03.260
this major refactoring with mano
addins and, and kind of

572
00:33:03.260 --> 00:33:05.360
put us in the mindset
that any API we write,

573
00:33:05.360 --> 00:33:07.340
it needs to be, it
needs to make sense. It

574
00:33:07.340 --> 00:33:11.930
needs to work well with
others. And, and that's sort

575
00:33:11.930 --> 00:33:13.910
of when you go through
that kind of evolution of

576
00:33:13.910 --> 00:33:16.460
an application, you end up
with an app that is

577
00:33:16.460 --> 00:33:20.000
sort of automatically scriptable because
the API is makes sense.

578
00:33:21.740 --> 00:33:24.680
So with the rewrite, we
wrote a book section, in

579
00:33:24.680 --> 00:33:29.030
fact, BU boost support for
banshee is actually provided and

580
00:33:29.030 --> 00:33:31.940
hosted in an extension that
extends the core. So it's

581
00:33:31.940 --> 00:33:36.860
not actually there in, in
the default core application, but

582
00:33:36.860 --> 00:33:40.190
it's provided as an extension.
And anything that loads into,

583
00:33:41.570 --> 00:33:46.010
into memory in the process
can actually execute against any

584
00:33:46.010 --> 00:33:49.280
of the API in the
abdomen. So by loading BU

585
00:33:49.280 --> 00:33:51.860
into the add in which
in turn gets loaded into

586
00:33:52.010 --> 00:33:55.280
Tibet itself, any boost scripts
that have user rights or

587
00:33:55.280 --> 00:33:58.340
is executed, can pretty much
do anything and has all

588
00:33:58.340 --> 00:34:01.790
the power that any, any
of Banshees core or add

589
00:34:01.790 --> 00:34:04.420
in stuff as well, Just
that'd be dangerous at all.

590
00:34:04.660 --> 00:34:07.030
Can, can you hurt yourself
with an evil boost script?

591
00:34:07.900 --> 00:34:10.960
Sure. You can. I mean,
you know, you have the

592
00:34:10.960 --> 00:34:14.650
power of, of the application
at your fingertips. You have

593
00:34:14.770 --> 00:34:18.970
access to all the APIs.
So certainly this isn't something

594
00:34:18.970 --> 00:34:22.660
that you would want to
execute based on untrusted code

595
00:34:22.660 --> 00:34:27.250
from say online, but, but
yeah, I mean, it's a

596
00:34:27.250 --> 00:34:31.120
very powerful, powerful mechanism to
allow you to extend applications

597
00:34:31.120 --> 00:34:33.790
without having, without having to
get into like the build

598
00:34:33.790 --> 00:34:37.390
environment and so on. You
can just pretty much execute

599
00:34:37.390 --> 00:34:41.440
arbitrary code by plopping a
file on the disc. I

600
00:34:41.440 --> 00:34:44.680
put a, a whatever dot
BU file in my banshee

601
00:34:44.680 --> 00:34:48.610
scripts folder. And that doesn't
compile what's, what's the experience

602
00:34:48.610 --> 00:34:50.860
like, man, I don't have
IntelliSense. It's all very dynamic.

603
00:34:50.860 --> 00:34:53.680
It's just a text file
on a folder. You know,

604
00:34:53.770 --> 00:34:55.870
how do I, how do
I write this? I mean,

605
00:34:55.870 --> 00:34:59.740
how do I debug this?
Just keep trying, Well, there's

606
00:34:59.740 --> 00:35:02.440
two things. One, if it
doesn't load, you'll see batchy,

607
00:35:02.440 --> 00:35:06.010
we'll print out the actual
compiler error to the terminal,

608
00:35:06.040 --> 00:35:09.670
to the console. So if,
if your, the idea is

609
00:35:09.670 --> 00:35:11.410
that if you're writing a
boost script and you, and

610
00:35:11.410 --> 00:35:14.140
you, if, you know, you
want to script your matcha,

611
00:35:14.140 --> 00:35:16.570
you should probably be running
from a console while you're

612
00:35:16.570 --> 00:35:19.870
developing that script. So that's
where the error message goes

613
00:35:19.870 --> 00:35:21.480
and you'll, and it'll be
able to tell you, you

614
00:35:21.520 --> 00:35:24.580
know, this API doesn't exist
at this line in your

615
00:35:24.580 --> 00:35:26.440
boost script. And so you
go back and fix it.

616
00:35:26.440 --> 00:35:30.760
It's, it's just like any
normal, you know, code writing

617
00:35:30.760 --> 00:35:33.310
process that you might go
through. The difference is you

618
00:35:33.310 --> 00:35:35.020
don't need to worry about
the build overhead and all

619
00:35:35.020 --> 00:35:37.060
that kind of stuff. So,
you know, you can sit

620
00:35:37.530 --> 00:35:40.500
at a, at a machine
that has banshee installed by

621
00:35:40.500 --> 00:35:42.900
default, and it's just there,
but you, but you don't

622
00:35:42.900 --> 00:35:45.480
have the ability to compile
anything or you don't have

623
00:35:45.480 --> 00:35:48.060
monitor develop installed. So you
can't bootstrap the project and

624
00:35:48.060 --> 00:35:51.000
build it yourself. You're just
running the system version and

625
00:35:51.000 --> 00:35:52.980
you'll still be able to
actually extend it just by

626
00:35:52.980 --> 00:35:55.740
writing the script. Now, if
you really get into it

627
00:35:55.740 --> 00:35:58.980
and you do have that
build environment, you can actually

628
00:35:59.460 --> 00:36:02.730
cause monitor, develop, support the
BU as well. It supports

629
00:36:02.730 --> 00:36:06.480
the syntax, and then it
can do the IntelliSense. If

630
00:36:06.480 --> 00:36:10.740
you, if you load the
assemblies, the Bantu assemblies into

631
00:36:10.740 --> 00:36:14.070
the monitor develop project, then
as you're typing blue code,

632
00:36:14.070 --> 00:36:17.250
it can actually do the
intelligence against the banshee API.

633
00:36:17.610 --> 00:36:22.320
So you can develop scripts.
You know, even if you

634
00:36:22.320 --> 00:36:25.050
don't know, I guess the
API is as well as,

635
00:36:25.500 --> 00:36:28.650
as, as we do. And
then of course we have

636
00:36:30.150 --> 00:36:32.640
API documentation as well that
you can look at. It's

637
00:36:32.640 --> 00:36:36.030
not, yeah, the documentation is
there. So you can see

638
00:36:36.030 --> 00:36:38.620
the API structures, but we
don't have a lot of,

639
00:36:38.670 --> 00:36:42.180
of actual like comments in
the documentation yet, which is

640
00:36:42.180 --> 00:36:45.910
another thing that we would
love community health for Now.

641
00:36:45.910 --> 00:36:48.710
You've also got support for
the DLR, is that correct?

642
00:36:49.430 --> 00:36:53.780
Correct. So Microsoft now has
the dynamic language runtime, which

643
00:36:53.780 --> 00:36:56.900
runs on on now. It
runs, you know, fall asleep

644
00:36:56.930 --> 00:36:59.300
on the, on the latest
version of the modern runtime,

645
00:36:59.300 --> 00:37:02.690
the two dot four version
and the deal our allows

646
00:37:02.690 --> 00:37:05.780
us to, to execute a
number of languages, not just

647
00:37:05.780 --> 00:37:10.190
BU so the DLR supports
Ruby and Python, for instance,

648
00:37:10.910 --> 00:37:14.300
so that your users can
now extend back to using

649
00:37:14.570 --> 00:37:19.070
Python or Ruby as well.
The DLR extension is not

650
00:37:19.070 --> 00:37:22.820
yet in our main, in
our main get branch. So

651
00:37:23.540 --> 00:37:25.520
cause I'm still hacking on
it, but it does work.

652
00:37:26.240 --> 00:37:29.090
And it's, it's actually a
much nicer experience than BU

653
00:37:30.380 --> 00:37:33.080
simply because, you know, you
can use languages that are,

654
00:37:33.080 --> 00:37:35.570
that are more familiar while
BU is easy to pick

655
00:37:35.570 --> 00:37:39.110
up. Especially if you know,
Python, it's still not, it's

656
00:37:39.140 --> 00:37:43.760
not Python, it's very Python
inspired, but I think, you

657
00:37:43.760 --> 00:37:46.400
know, working in Ruby or
Python itself is actually much

658
00:37:46.400 --> 00:37:49.670
better user experience. And I
think there's even a, an

659
00:37:49.670 --> 00:37:52.160
effort or at least there
was to actually rebase the

660
00:37:52.160 --> 00:37:54.980
core of goo on top
of DLR. So you actually

661
00:37:54.980 --> 00:37:57.680
get the boot language, but
running on the DLR. So

662
00:37:57.680 --> 00:37:59.720
with the scripting support, they've
got the ability to do

663
00:37:59.720 --> 00:38:01.160
anything that they want to.
I mean, I suppose that

664
00:38:01.160 --> 00:38:03.770
they're limited only by their
imagination, but what, what might,

665
00:38:03.860 --> 00:38:06.350
what might I want to
do to a media player?

666
00:38:06.350 --> 00:38:07.730
Why would I want to
script a media player? Do

667
00:38:07.730 --> 00:38:09.230
you have any examples of
the kind of things that

668
00:38:09.230 --> 00:38:13.370
I would do? So one
of the first things that,

669
00:38:13.520 --> 00:38:17.600
that we had a script
for was well, okay. So

670
00:38:17.600 --> 00:38:20.000
in the, in the Linux
world, you've got a lot

671
00:38:20.000 --> 00:38:23.270
of kind of old school
Unix guys who, you know,

672
00:38:23.270 --> 00:38:25.100
they don't like spaces in
their file names. They don't

673
00:38:25.100 --> 00:38:28.340
like uppercase letters and this
kind of stuff, but we're

674
00:38:28.340 --> 00:38:30.530
not trying to, we're trying
to cater more to end

675
00:38:30.530 --> 00:38:34.580
users and, and sorta be
platform agnostic. So we don't

676
00:38:34.580 --> 00:38:37.120
want to assume that we
have a bunch of windows

677
00:38:37.120 --> 00:38:38.920
users. We don't want to
assume we they're, you know,

678
00:38:38.920 --> 00:38:40.840
they're all Linux users and
Mac users. We want things

679
00:38:40.840 --> 00:38:45.550
to make sense. So in,
in, in the preferences dialogue,

680
00:38:45.910 --> 00:38:47.890
you can choose how you
want your media library on

681
00:38:47.890 --> 00:38:50.290
disc to be laid out.
So you can say that

682
00:38:50.290 --> 00:38:55.720
I want my folders should
be artists slash album name

683
00:38:56.290 --> 00:39:00.340
slash, and then the file
name should be, you know,

684
00:39:00.400 --> 00:39:04.510
track number dash track, title
dot file extension, right? It's

685
00:39:04.510 --> 00:39:07.780
something people are very passionate
about. Yeah, there are definitely

686
00:39:07.780 --> 00:39:10.840
people passionate about the way
their, their, their library's laid

687
00:39:10.840 --> 00:39:12.610
out on disc. So we
allow you to configure that,

688
00:39:12.610 --> 00:39:17.860
but we don't allow in
the UI super complicated patterns

689
00:39:18.400 --> 00:39:20.290
cause we don't want to
clutter or confuse the actual

690
00:39:20.290 --> 00:39:23.200
UI. So we, we define,
you know, six or seven

691
00:39:24.040 --> 00:39:27.430
sensible and common file or
directory layout. And we define,

692
00:39:27.430 --> 00:39:30.130
you know, a handful of
file name layouts as well.

693
00:39:30.370 --> 00:39:34.090
So there's just a dropdown.
You can choose if you

694
00:39:34.090 --> 00:39:36.490
go in and you edit
the actual like config file,

695
00:39:36.520 --> 00:39:41.410
you can actually change the
pattern yourself by hand. So

696
00:39:41.650 --> 00:39:44.230
it's just an expression that
expands to a, against a

697
00:39:44.230 --> 00:39:47.410
given track. So you can,
you can enter arbitrary data

698
00:39:47.590 --> 00:39:51.640
and banshee will fill that
out for you. But what

699
00:39:51.640 --> 00:39:54.550
we had was users who
weren't even satisfied with the

700
00:39:54.550 --> 00:39:58.900
ability to control the path
layout by hand, and that

701
00:39:59.500 --> 00:40:02.020
they didn't like spaces and
they didn't like uppercase letters

702
00:40:02.020 --> 00:40:04.360
and so on. So you
can write a boost script

703
00:40:04.360 --> 00:40:09.070
that actually hooks into the
path formatting API, and it

704
00:40:09.070 --> 00:40:11.290
runs these hooks that you
can then define in your

705
00:40:11.290 --> 00:40:14.350
script. So you can basically
give it a regular expression

706
00:40:14.350 --> 00:40:16.300
to run against the full
path when it's done or

707
00:40:16.300 --> 00:40:19.960
components of the path. So
you can choose, you know,

708
00:40:19.990 --> 00:40:23.050
they specify the exact pattern
they want with, you know,

709
00:40:23.620 --> 00:40:26.470
timestamps and or any arbitrary
data that you can pull

710
00:40:26.470 --> 00:40:29.230
from the database. Anything that's
that's in the of database,

711
00:40:29.590 --> 00:40:32.650
you can, you could put
into this final name, but

712
00:40:32.650 --> 00:40:35.020
then they run an expression
on it that says translate

713
00:40:35.020 --> 00:40:38.110
all the lower or upper
case letters, lowercase change spaces

714
00:40:38.110 --> 00:40:40.990
to dashes and so on.
So that's, that was like

715
00:40:40.990 --> 00:40:43.450
one of the first examples
of a script where we

716
00:40:43.450 --> 00:40:46.780
had these diehard Unix guys
who, who weren't happy with

717
00:40:46.780 --> 00:40:48.850
the way their files load,
but I wasn't about to

718
00:40:49.150 --> 00:40:55.090
disrupt the UI 4.005% of
our user base. They were

719
00:40:55.420 --> 00:40:57.730
happy with the script, but
you shut, you shut up,

720
00:40:58.080 --> 00:41:00.700
you know, 0.05% of your
user base by giving them

721
00:41:00.790 --> 00:41:02.350
the ability to script it.
So now they can do

722
00:41:02.350 --> 00:41:05.040
anything that they want to,
right. So, you know, the

723
00:41:05.080 --> 00:41:08.620
scripting is definitely for, for
power users, but it's for,

724
00:41:08.740 --> 00:41:10.540
I like to think of
it as a, as a,

725
00:41:10.600 --> 00:41:14.470
as a user feature for
power users, but also as

726
00:41:14.470 --> 00:41:18.250
a way of, of getting
new contributors who are otherwise

727
00:41:18.250 --> 00:41:21.970
kind of, you know, it's
a daunting process to actually

728
00:41:21.970 --> 00:41:23.860
get the whole build environment
set up. So it's a

729
00:41:23.860 --> 00:41:25.390
way that you can sort
of get your feet wet

730
00:41:26.110 --> 00:41:28.960
with both just learning code
and then actually see it

731
00:41:29.290 --> 00:41:32.710
happen in real life. And
also, you know, if you

732
00:41:32.710 --> 00:41:34.700
want to contributing to the
project, it's an easy way

733
00:41:34.700 --> 00:41:37.190
to get started. Very cool.
So it's kind of a

734
00:41:37.190 --> 00:41:41.330
segue into the, into the
real hardcore, you know, programming,

735
00:41:41.330 --> 00:41:44.060
but, but it's also a
user feature for these really

736
00:41:44.060 --> 00:41:48.250
diehard, you know, power users.
Well, I think a lot

737
00:41:48.250 --> 00:41:50.410
of the listeners are our
windows folks and it sounds

738
00:41:50.410 --> 00:41:52.120
like you're going to have
a windows version towards the

739
00:41:52.120 --> 00:41:54.220
end of the summer. And
as we said before, if

740
00:41:54.340 --> 00:42:01.900
people are interested, they can
find you@avock.org, a box.org, and

741
00:42:01.900 --> 00:42:06.190
they can find the banshee
project@bansheehyphenproject.org, and I'll have links

742
00:42:06.190 --> 00:42:08.410
to all of that in
the, in the show notes.

743
00:42:09.160 --> 00:42:11.110
I really appreciate you taking
the time to sit down

744
00:42:11.110 --> 00:42:14.470
and help me understand that,
how to make cross-platform applications

745
00:42:14.810 --> 00:42:17.740
with mano and banshee is
a really great example of

746
00:42:17.740 --> 00:42:20.980
that. Great. I'm really pleased
that you me Cool. Well,

747
00:42:20.980 --> 00:42:23.470
this has been another episode
of Hansel minutes and we'll

748
00:42:23.470 --> 00:42:24.550
see you again next week.


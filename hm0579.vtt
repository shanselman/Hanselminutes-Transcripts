WEBVTT FILE

1
00:00:00.180 --> 00:00:03.360
Hi, this is Scott. I
really appreciate our sponsors because

2
00:00:03.360 --> 00:00:06.300
they make the show possible.
Today's show is sponsored by

3
00:00:06.300 --> 00:00:10.500
developer express, become a UI
superhero with dev express controls

4
00:00:10.500 --> 00:00:15.030
and libraries. Deliver elegant.net solutions
that address customer needs today

5
00:00:15.420 --> 00:00:19.500
by leveraging your existing knowledge,
you can build next generation

6
00:00:19.500 --> 00:00:23.610
touch enabled solutions for tomorrow,
you can download your free

7
00:00:23.700 --> 00:00:45.630
30 day trial@dxdothanselminutes.com. That's dx.hanselminutes.com.
Hi, this is Scott Hanselman.

8
00:00:45.630 --> 00:00:47.820
This is another episode of
Hansel minutes. And today I'm

9
00:00:47.820 --> 00:00:56.250
talking with Eric Norman. He's the
chief instigator@purelyfunctional.tv. That's purely functional.tv.

10
00:00:56.250 --> 00:00:59.550
Very nice top level domain
there. Hey, thanks a lot.

11
00:01:00.210 --> 00:01:03.660
That's pretty cool. And there's
a ton of resources up

12
00:01:03.660 --> 00:01:07.020
there. Video courses and courses
with free content. And there's

13
00:01:07.020 --> 00:01:11.220
a whole section on getting
jobs around functional programming. You're

14
00:01:11.220 --> 00:01:14.400
kind of building your, your
own portal here to introduce

15
00:01:14.400 --> 00:01:18.960
people to functional programming specifically
as a career. That's right.

16
00:01:18.990 --> 00:01:21.090
Thanks for making me feel
old by the way about

17
00:01:21.090 --> 00:01:25.890
portals, but yeah, I'm, I'm
trying to help people who

18
00:01:25.890 --> 00:01:28.710
want to get a job
in closure, transition their career

19
00:01:28.710 --> 00:01:33.060
to functional programming and just
provide like a ramp for

20
00:01:33.060 --> 00:01:36.840
that. Why do I want
to transition my career? Can

21
00:01:36.840 --> 00:01:41.130
I have my cake and
eat it too? So there's

22
00:01:41.130 --> 00:01:44.430
a lot of people out
there who have been doing

23
00:01:44.430 --> 00:01:48.840
Java or some other language
and been unhappy with it.

24
00:01:48.870 --> 00:01:50.490
You know, they are just
like, this is all there

25
00:01:50.490 --> 00:01:53.220
is. And now with all
this like booming of new

26
00:01:53.220 --> 00:01:58.200
languages, they actually have a
lot of choice and they

27
00:01:58.260 --> 00:02:01.320
are, you know, older, they
have a family, so they

28
00:02:01.320 --> 00:02:06.090
can't really risk a like
a pay cut. And so

29
00:02:06.240 --> 00:02:09.360
there, there's a lot of
fear about changing careers at

30
00:02:09.360 --> 00:02:12.990
this point in their life.
So I'm, I'm trying to

31
00:02:13.110 --> 00:02:16.200
be there and, you know,
hold their hand and show

32
00:02:16.200 --> 00:02:19.560
them that it is possible.
So why, why closure? Why

33
00:02:19.560 --> 00:02:22.050
did you focus on closure
as your entry drug into

34
00:02:22.050 --> 00:02:26.130
the functional world? So that's
a good question. I've always

35
00:02:26.130 --> 00:02:30.420
been into lisp. I guess
I started back in college,

36
00:02:31.560 --> 00:02:36.240
you know, 15 or 16
years ago, and I was

37
00:02:37.020 --> 00:02:41.370
kind of a smug lisp
weenie using common lisp. And

38
00:02:41.370 --> 00:02:45.030
then when closure came out,
I gave it a shot

39
00:02:45.060 --> 00:02:48.870
and like haven't looked back.
So I just, I just

40
00:02:48.870 --> 00:02:53.250
really like closure what I'm
going to parse something maybe

41
00:02:53.250 --> 00:02:56.490
more than I need to.
You said smug. And I,

42
00:02:56.730 --> 00:03:00.430
I think that it's, it's
okay to say that sometimes

43
00:03:00.880 --> 00:03:04.180
People who aren't functional programmers
feel a little afraid to

44
00:03:04.180 --> 00:03:07.660
get into functional programming, not
just because it's scary and

45
00:03:07.660 --> 00:03:10.030
they have to figure out
what a monad is, but

46
00:03:10.030 --> 00:03:13.360
that there's a certain amount
of, of barrier to entry

47
00:03:14.230 --> 00:03:17.230
around the personalities of, of
the, or what may be

48
00:03:17.230 --> 00:03:19.870
perceived as personalities in the
functional programming world. Do you

49
00:03:19.870 --> 00:03:23.670
think that that's true? I,
I definitely see that the,

50
00:03:23.830 --> 00:03:27.810
the perception, the perception is
there and I can see

51
00:03:27.810 --> 00:03:31.290
why. So How do we
break that down? And why

52
00:03:31.290 --> 00:03:33.810
is that perception there? Is
it just because mathematicians go

53
00:03:33.810 --> 00:03:36.540
into functional programming or, you
know, how did we get

54
00:03:36.540 --> 00:03:38.910
that, that stereotype and how
do we break through that

55
00:03:38.910 --> 00:03:42.390
stereotype? Wow. I wish I
could break through the stereotype.

56
00:03:42.930 --> 00:03:49.080
The, the reason I see
it's there is that functional

57
00:03:49.080 --> 00:03:54.870
programming because it's more mathematical
has been much more target

58
00:03:54.900 --> 00:03:59.970
of academic research. So a
lot of the people who

59
00:04:00.300 --> 00:04:06.780
write stuff online who write
papers, they're actually researching Lino,

60
00:04:06.780 --> 00:04:14.280
new computer science techniques and
concepts. And so they're, they're

61
00:04:14.280 --> 00:04:17.820
just used to speaking in
a more academic way and

62
00:04:17.820 --> 00:04:20.790
much less practical. They're not
even worried about the practical

63
00:04:20.790 --> 00:04:24.030
at the moment. They're just
trying to get a paper

64
00:04:24.030 --> 00:04:28.050
published. And so when you
read a blog post, it

65
00:04:28.050 --> 00:04:31.500
could be someone who's like
exploring this stuff. They could

66
00:04:31.500 --> 00:04:34.950
be a researcher and it
might seem like it's totally

67
00:04:34.950 --> 00:04:38.340
inaccessible. Like they're using, you
know, half the words that

68
00:04:38.340 --> 00:04:40.680
they use. You don't even
understand why it would take

69
00:04:40.680 --> 00:04:43.530
you 10 years to read
up on all the stuff

70
00:04:43.530 --> 00:04:45.690
that they know to get
to the point where they're

71
00:04:45.690 --> 00:04:50.220
at. But the thing is
functional programming is, is very

72
00:04:50.220 --> 00:04:55.800
practical and doesn't have to
reach those Heights of, you

73
00:04:55.800 --> 00:05:00.330
know, novelty that you get
in the academic papers. Okay.

74
00:05:00.330 --> 00:05:02.550
So I don't have to
be an academic. I don't

75
00:05:02.550 --> 00:05:04.710
have to have a master's
degree if I want to

76
00:05:04.710 --> 00:05:06.990
get started in thinking about
functional programming and I can

77
00:05:06.990 --> 00:05:09.240
really do practical work. I
can, you know, people who

78
00:05:09.240 --> 00:05:12.720
are listening might be doing
a text boxes over data,

79
00:05:12.780 --> 00:05:15.660
you know, to a website
and they want to do

80
00:05:15.660 --> 00:05:17.850
it in a different way
and maybe a better way

81
00:05:18.090 --> 00:05:21.180
For sure. And one of
the things that closure has,

82
00:05:22.020 --> 00:05:24.390
you know, just as an
example, is it's, it's just

83
00:05:24.390 --> 00:05:30.180
got this pragmatic philosophy it's
built to be hosted on

84
00:05:30.180 --> 00:05:34.080
the JVM. And one of
the reasons behind that was

85
00:05:34.080 --> 00:05:37.680
to take advantage all of,
all of the JVM libraries

86
00:05:37.680 --> 00:05:40.140
that are out there. So
it has really good inter-op.

87
00:05:40.470 --> 00:05:43.260
So if you just need
to, you know, send some

88
00:05:43.260 --> 00:05:45.990
web requests or read some
files off of your disc

89
00:05:45.990 --> 00:05:48.660
or whatever, you can just
do it by calling into

90
00:05:48.660 --> 00:05:52.500
Java and you don't have
to worry about, you know,

91
00:05:52.560 --> 00:05:55.320
whether you've got the right
types and things like that,

92
00:05:55.320 --> 00:06:00.380
like you would in some
functional languages. Do you think

93
00:06:00.410 --> 00:06:03.350
that the, and this is
going to be kind of

94
00:06:03.350 --> 00:06:06.110
a trick question, not a
trick question, I'm setting you

95
00:06:06.110 --> 00:06:08.810
up here. Do you think
that we made a mistake

96
00:06:08.810 --> 00:06:12.950
as a, as a community
or as a, as a

97
00:06:13.340 --> 00:06:17.420
practice that maybe imperative programming
shouldn't have one and that

98
00:06:17.420 --> 00:06:19.730
functional programming should evolve. It
should have been the thing

99
00:06:19.730 --> 00:06:22.940
that became mainstream, that things
should be, it should be

100
00:06:22.940 --> 00:06:28.030
inverted. Hmm. You're opening up
a can of worms. Well,

101
00:06:28.030 --> 00:06:29.650
but it's, you know, an
opinion is an opinion and

102
00:06:29.650 --> 00:06:31.960
it's a valid one. I
go, beta max was a

103
00:06:31.960 --> 00:06:37.810
superior videotape format, but the
AHS one, but that doesn't

104
00:06:37.990 --> 00:06:40.090
change the fact that beta
max was in fact better.

105
00:06:40.750 --> 00:06:43.240
Yeah. But when you say
that about beta max, you

106
00:06:43.240 --> 00:06:47.180
don't have a flame more
like ready to start. Well,

107
00:06:47.180 --> 00:06:48.730
I don't want to start
a flame war. I want

108
00:06:48.730 --> 00:06:51.490
to enable people who are
listening to make a decision

109
00:06:51.490 --> 00:06:53.500
that maybe there's a better
world out there. I haven't

110
00:06:53.500 --> 00:06:56.290
decided yet for myself. Maybe
the answer is somewhere in

111
00:06:56.290 --> 00:07:00.670
between. Sure. Well, like all
joking aside. I think that

112
00:07:00.670 --> 00:07:07.990
procedural is actually pretty a
pretty good model for how

113
00:07:07.990 --> 00:07:10.990
things work. What I would
say is it's the object

114
00:07:10.990 --> 00:07:16.840
oriented that is not so
great. That procedural is great

115
00:07:16.840 --> 00:07:19.900
for a single threaded, you
know, just go through step

116
00:07:19.900 --> 00:07:23.380
by step, get something done.
And you know, a lot

117
00:07:23.380 --> 00:07:25.900
of my code is just
like that even in closure.

118
00:07:27.010 --> 00:07:30.790
But what happens is once
you have multiple threads, you

119
00:07:30.790 --> 00:07:33.760
actually want the language to
help you a lot more.

120
00:07:33.910 --> 00:07:38.530
So you want immutable values.
You want pure functions, you

121
00:07:38.530 --> 00:07:44.170
want some primitive, some concurrency
primitives to help you put

122
00:07:44.170 --> 00:07:46.300
the, you know, you have
all these threads working. You

123
00:07:46.300 --> 00:07:48.880
need to put the answer
back together once they're all

124
00:07:48.880 --> 00:07:52.510
done. So you need something
to help do that. So

125
00:07:52.720 --> 00:07:56.830
I would say that that
it's the object oriented where

126
00:07:56.830 --> 00:07:59.320
you kind of put a
little bit of state in

127
00:07:59.320 --> 00:08:02.860
every object and just like
make this big graph of

128
00:08:03.160 --> 00:08:08.260
objects. I would say that
that was the mistake. Interesting.

129
00:08:08.260 --> 00:08:11.260
And that's, that doesn't seem
nearly as controversial as I

130
00:08:11.260 --> 00:08:14.470
think people would, would think.
So it sounds to me

131
00:08:14.470 --> 00:08:17.110
like, if you want to
just, maybe we can back

132
00:08:17.110 --> 00:08:19.720
up a little bit and
juxtapose, you know, functional programming

133
00:08:19.720 --> 00:08:22.300
and nonfunctional programming. It sounds
like it all starts at

134
00:08:22.300 --> 00:08:28.090
side effects. Like that's the
big argument. Yeah. State side

135
00:08:28.090 --> 00:08:32.740
effects. And so like, just
to be clear, like I,

136
00:08:32.800 --> 00:08:35.350
no one thinks that side
effects are bad. They're actually

137
00:08:35.350 --> 00:08:38.410
necessary. Like if your program,
all I did was like

138
00:08:38.410 --> 00:08:41.020
use the CPU and then
you never knew what happened.

139
00:08:41.770 --> 00:08:46.990
It wouldn't be very useful,
but what's happened is that

140
00:08:47.140 --> 00:08:53.560
we've realized that having side
effects all throughout your code,

141
00:08:53.590 --> 00:08:59.310
that aren't necessary are actually
making it harder to reuse

142
00:08:59.310 --> 00:09:02.100
your code. They're making it
harder to think about what

143
00:09:02.100 --> 00:09:06.930
your code is going to
do by separating out the

144
00:09:06.930 --> 00:09:09.990
side effect or the effect.
Let's not, you know, they're

145
00:09:09.990 --> 00:09:12.810
not all side effects. Some
of them are, you know,

146
00:09:12.810 --> 00:09:16.050
why you call the function,
but by separating it out

147
00:09:16.740 --> 00:09:23.070
and having a pure calculation
over, over values, you, you

148
00:09:23.070 --> 00:09:27.210
can actually do a lot
more reasoning. You can put

149
00:09:27.480 --> 00:09:30.780
the calculation on different threads,
you can put it on

150
00:09:30.780 --> 00:09:36.060
different machines. And so that's,
that's really the sort of

151
00:09:36.600 --> 00:09:45.500
umbrella under which the functional
programming works. So State that

152
00:09:45.570 --> 00:09:48.710
when people say that the
problems with nonfunctional languages are

153
00:09:48.980 --> 00:09:51.110
our managing state, it's not
the state of the side

154
00:09:51.110 --> 00:09:55.880
effects. It's the complexity that
comes from those state machines

155
00:09:55.880 --> 00:09:57.590
that we end up managing
that, you know, you add

156
00:09:57.590 --> 00:10:00.140
a Boolean, it's fine. Okay.
There's two States. Now you

157
00:10:00.140 --> 00:10:02.840
add five or six bullions
and now it's this, this

158
00:10:02.870 --> 00:10:07.520
Cartesian product, of course. Plexity.
Yeah, for sure. And when

159
00:10:07.520 --> 00:10:11.750
you have something that is
supposed to read a value,

160
00:10:11.780 --> 00:10:16.460
but it actually also counts
the number of reads or

161
00:10:16.490 --> 00:10:19.490
it is supposed to send
a message, but it also

162
00:10:19.490 --> 00:10:24.530
writes something to a local
variable or a global variable

163
00:10:24.830 --> 00:10:28.070
and those things like you've
got you, can't separate them

164
00:10:28.070 --> 00:10:30.380
out. And so you think
I'm just, I'm just sending

165
00:10:30.380 --> 00:10:33.740
an email when you're also
changing all these other things.

166
00:10:34.610 --> 00:10:38.300
And when you, when you
are actually just doing a

167
00:10:38.300 --> 00:10:42.200
calculation, like let's say you're,
I mean, I don't think

168
00:10:42.200 --> 00:10:45.020
anybody does this anymore. I
hope people don't. But when

169
00:10:45.020 --> 00:10:47.690
I was writing, see back
in the day, like we

170
00:10:47.690 --> 00:10:51.680
would reuse global variables, you
know, like, Oh, this, this

171
00:10:51.680 --> 00:10:53.660
is an end. I need
an end. Let me just

172
00:10:53.660 --> 00:10:57.980
use that one. And you
know, now it sounds, it

173
00:10:57.980 --> 00:11:01.010
seems silly, but that's what,
that's what we did back

174
00:11:01.010 --> 00:11:05.300
in the day. And, you
know, you would set it

175
00:11:05.300 --> 00:11:08.690
to zero and then start
counting into it and then

176
00:11:08.690 --> 00:11:11.090
you would be done with
it. And the other code

177
00:11:11.090 --> 00:11:13.640
was just supposed to know,
like, don't touch that while

178
00:11:13.640 --> 00:11:21.350
I'm working. Right. And those
kinds of assumptions, like they

179
00:11:21.350 --> 00:11:24.920
require discipline. And if you
could turn that discipline into

180
00:11:24.920 --> 00:11:28.880
just a constraint that the
language imposes on you, you

181
00:11:28.880 --> 00:11:31.970
actually don't have to worry.
You can relax a lot

182
00:11:31.970 --> 00:11:36.560
more. You can use that,
you know, that same construct

183
00:11:36.590 --> 00:11:41.330
in different ways, you don't
have the mutability. So you're,

184
00:11:41.350 --> 00:11:44.240
you're able to count lots
of different stuff instead of

185
00:11:44.240 --> 00:11:48.560
just the one loop that
you had, that's supposed to

186
00:11:48.560 --> 00:11:51.150
be counting, you know, you
can count different things at

187
00:11:51.150 --> 00:11:55.270
the same time. And there's
There's so there's inputs and

188
00:11:55.270 --> 00:11:57.610
there's outputs. But I understand
that. One of the things

189
00:11:57.610 --> 00:12:00.670
that we forget about when
we're writing kind of declarative

190
00:12:00.670 --> 00:12:03.490
code or parative code or
parental program or programmatic step-by-step

191
00:12:03.520 --> 00:12:08.260
code is a hidden inputs.
And the things that are

192
00:12:08.260 --> 00:12:11.530
not explicitly called out as
an input. Like, for example,

193
00:12:11.530 --> 00:12:14.440
if you knew up a
date in the middle of

194
00:12:14.440 --> 00:12:17.320
a function, even, you know,
that date is going to

195
00:12:17.320 --> 00:12:19.810
change, it's now become a
hidden input, but it's buried

196
00:12:19.840 --> 00:12:22.870
10 lines in somewhere. And
because you're not explicit about

197
00:12:22.870 --> 00:12:25.480
it, it's, it's a dependency
in there that you're not

198
00:12:25.480 --> 00:12:29.250
realizing that part to test.
Yeah, exactly. It's, it's super

199
00:12:29.250 --> 00:12:31.830
hard to test because every
time you call it, it's

200
00:12:31.830 --> 00:12:37.020
a different time. And yeah.
So in a functional world,

201
00:12:37.290 --> 00:12:39.180
what you would do is
you would pass that date

202
00:12:39.180 --> 00:12:42.060
in. And so then you
could construct the date in

203
00:12:42.060 --> 00:12:46.710
your test, however you want.
And that way, you know,

204
00:12:46.710 --> 00:12:51.960
your test is always gonna
do the same thing. So

205
00:12:52.200 --> 00:12:55.920
can that be built into
the language too? Like, so

206
00:12:55.920 --> 00:12:57.810
you could be forced not
to do that. Is that

207
00:12:57.810 --> 00:13:00.120
how we do end up
doing things like inversion of

208
00:13:00.120 --> 00:13:06.960
control and dependency injection in
nonfunctional languages? Yeah. So the

209
00:13:06.960 --> 00:13:09.750
way that you would do
that is using the type

210
00:13:09.750 --> 00:13:13.830
system. So if you had
a Haskell style type system

211
00:13:14.910 --> 00:13:22.740
that includes type inference and
concept of IO, that's part

212
00:13:22.740 --> 00:13:25.140
of the type system. And
also part of, part of

213
00:13:25.140 --> 00:13:29.940
the language itself, IO is
supposed to capture all of

214
00:13:29.940 --> 00:13:34.200
that. You know, whether it's,
you know, IO, like I

215
00:13:34.200 --> 00:13:38.010
slash O input output. So
anything coming off the network,

216
00:13:38.040 --> 00:13:42.600
writing to disk, anything that
the like process in memory

217
00:13:42.600 --> 00:13:46.740
doesn't control also the time
the clock is another input.

218
00:13:47.280 --> 00:13:51.210
So in Haskell, the way
it works is if you

219
00:13:51.210 --> 00:13:52.980
want to do something like
that, you have to be

220
00:13:52.980 --> 00:13:56.340
very explicit and you actually
have to pass that value

221
00:13:56.340 --> 00:14:00.840
in from the top. So
you can, you can't just

222
00:14:00.840 --> 00:14:03.120
like in the middle of
a function, that's supposed to

223
00:14:03.120 --> 00:14:06.360
be, you know, summing some
numbers, grab a grab a

224
00:14:06.360 --> 00:14:11.040
time or a random number
or something like that. Okay.

225
00:14:11.730 --> 00:14:16.380
Is that what's called a
pure function. Oh, good question.

226
00:14:16.470 --> 00:14:21.660
So yeah, pure function is
a function that is only

227
00:14:21.660 --> 00:14:24.900
a calculation from the arguments
and all it does is

228
00:14:24.900 --> 00:14:28.860
return the value. Okay. So
then if all the inputs

229
00:14:28.860 --> 00:14:31.710
are declared or called out
as inputs and nothing's hidden,

230
00:14:32.190 --> 00:14:37.080
then that is pure or
quote unquote superior to one

231
00:14:37.080 --> 00:14:39.870
that might have hidden inputs
or outputs. Right, Right. Superior

232
00:14:39.870 --> 00:14:43.800
in, in the way that
you, you get some guarantees.

233
00:14:43.830 --> 00:14:47.070
Right. You know that every
time I call this, I'm

234
00:14:47.070 --> 00:14:49.200
going to get the same
answer back and I can

235
00:14:49.200 --> 00:14:51.530
call it as many times
as I want. I'm not

236
00:14:51.530 --> 00:14:54.950
gonna, I'm not going to
have effects on the world.

237
00:14:55.130 --> 00:14:59.000
Right. So, you know, the
classic example is it's firing

238
00:14:59.000 --> 00:15:01.760
a missile. You can't call
that function twice cause it'll

239
00:15:01.760 --> 00:15:06.410
shoot off two missiles. And
so you want to have

240
00:15:06.410 --> 00:15:09.950
a function that say calculates
all the, you know, the

241
00:15:09.950 --> 00:15:12.950
number of missiles that it
needs to fire separate from

242
00:15:12.950 --> 00:15:18.910
actually firing them. Okay. Well,
if I know if I

243
00:15:18.910 --> 00:15:22.090
know about side effects, if
I know about what's bad

244
00:15:22.090 --> 00:15:24.490
and what's good and what's
pure and what's impure from

245
00:15:24.490 --> 00:15:29.170
a functional perspective, couldn't I
go and write Java or

246
00:15:29.170 --> 00:15:32.290
C sharp as if I
were writing a functional programming

247
00:15:32.290 --> 00:15:34.570
language, I could make sure
all my inputs and outputs

248
00:15:34.570 --> 00:15:38.230
are called out. I could
change my style. And would

249
00:15:38.230 --> 00:15:40.330
I be turning it into
a functional programming language? Or

250
00:15:40.330 --> 00:15:43.540
would I just be leaning
in that direction? So you

251
00:15:43.540 --> 00:15:47.230
can definitely do that. A
lot of people have tried.

252
00:15:48.760 --> 00:15:53.710
So the, there are success
stories in that area, especially

253
00:15:53.710 --> 00:15:56.920
now that Java has Lambdas,
it's a little bit easier

254
00:15:56.920 --> 00:16:03.040
to, to write those kinds
of things. What I've heard

255
00:16:03.040 --> 00:16:07.120
though from the like non
success stories is that it's

256
00:16:07.120 --> 00:16:11.260
more code, right? Cause you're,
you're actually going to be

257
00:16:12.280 --> 00:16:17.230
writing around the idioms that
have been like optimized in

258
00:16:17.230 --> 00:16:21.760
Java. And then also your
teammates are going to be

259
00:16:21.760 --> 00:16:28.360
mad because, because they've learned
all these other idioms and

260
00:16:28.360 --> 00:16:32.620
style stylistic choices, and now
you're breaking all of that

261
00:16:33.190 --> 00:16:35.680
and they don't know what
your code is supposed to

262
00:16:35.680 --> 00:16:37.630
be doing anymore. You know,
they don't want to take

263
00:16:37.630 --> 00:16:40.000
the time to learn all
this stuff that, you know.

264
00:16:41.110 --> 00:16:45.370
Okay. So then that implies
that a functional programming language

265
00:16:45.370 --> 00:16:47.770
is one that is encouraging
me or pointing me in

266
00:16:47.770 --> 00:16:50.980
that direction to avoid side
effects and to avoid impure

267
00:16:50.980 --> 00:16:56.020
functions without it messing up,
everyone else's flow. It's right.

268
00:16:56.050 --> 00:17:02.140
It's, it's more a matter
of defaults. And like you

269
00:17:02.140 --> 00:17:06.490
said, like pushing you in
that direction, for instance, enclosure,

270
00:17:06.520 --> 00:17:09.880
you know, writing a function
is really easy. All the

271
00:17:09.880 --> 00:17:14.380
immutable, all the data structures
are immutable by default. So

272
00:17:14.440 --> 00:17:18.820
you can get that. And
there's no guarantee that your

273
00:17:18.820 --> 00:17:24.760
function is pure, but it's
super easy to write one

274
00:17:24.760 --> 00:17:28.750
that's pure because the, you
know, the functions are very

275
00:17:28.750 --> 00:17:31.300
short and you know, it's
just easy to see that

276
00:17:31.300 --> 00:17:33.790
you're not calling something like
a print line or something.

277
00:17:35.380 --> 00:17:40.180
There's a great blog by
Chris Jenkins about functional programming.

278
00:17:40.690 --> 00:17:45.280
And in it, they say
that a, a functional programming

279
00:17:45.280 --> 00:17:50.160
language is actively hostile to
side-effects. Yeah. That might Be

280
00:17:50.160 --> 00:17:52.620
a good way to put
it. Yeah. I like to

281
00:17:52.620 --> 00:17:56.160
think of it. Like, so
if you want to go

282
00:17:56.160 --> 00:18:00.330
to the store and buy
some stuff, right, you're going

283
00:18:00.330 --> 00:18:05.640
grocery shopping and you let's
say you, you need two

284
00:18:05.640 --> 00:18:08.220
gallons of milk. So you
go to the store. Once

285
00:18:08.220 --> 00:18:10.350
you buy a gallon of
milk, you come home and

286
00:18:10.350 --> 00:18:11.790
then you go back to
the store and you buy

287
00:18:11.790 --> 00:18:15.820
a second gallon of milk
and come home. Like, if

288
00:18:15.840 --> 00:18:18.990
all you had was a
function like buy or a

289
00:18:18.990 --> 00:18:22.290
method, go buy a gallon
of milk. Like that's how

290
00:18:22.290 --> 00:18:24.960
you would have to buy
two things. Right. But what

291
00:18:24.960 --> 00:18:28.080
you could do instead is
sit at home and on

292
00:18:28.080 --> 00:18:30.720
a piece of paper, you
make a list and you're

293
00:18:30.720 --> 00:18:33.450
doing all this calculation in
your head, like, what do

294
00:18:33.450 --> 00:18:36.270
I need? And you're making
a note, you're making like

295
00:18:36.600 --> 00:18:39.930
a representation of all the
stuff you want to buy.

296
00:18:40.260 --> 00:18:43.440
And then you have a
function that takes you to

297
00:18:43.440 --> 00:18:46.170
the store and you give
it a list and it

298
00:18:46.170 --> 00:18:49.020
will just run through the
list and buy everything on

299
00:18:49.020 --> 00:18:53.400
your list. And so that
separate calculation is something we

300
00:18:53.400 --> 00:18:58.980
do every day in our
lives. But somehow in computer

301
00:18:58.980 --> 00:19:01.350
programming, we like mix it
all up. And you're like,

302
00:19:01.380 --> 00:19:02.880
well, I'm right in the
middle of this loop. I

303
00:19:02.880 --> 00:19:06.030
might as well just like
fire off this email instead

304
00:19:06.030 --> 00:19:09.030
of calculating all the emails
I'm going to need ahead

305
00:19:09.030 --> 00:19:14.450
of time. Right. Okay. So
when I let's talk about

306
00:19:14.450 --> 00:19:17.570
this in the context of
getting a job, this isn't

307
00:19:17.570 --> 00:19:20.000
a matter of just like
learn, you know, go and

308
00:19:20.000 --> 00:19:22.940
read about closure and say,
I'm going to learn all

309
00:19:22.940 --> 00:19:27.290
of the, the key words.
It's how do you express

310
00:19:27.320 --> 00:19:29.270
as you're trying to go
out there and transition your

311
00:19:29.270 --> 00:19:32.600
job, that you really understand
this from an idiomatic perspective

312
00:19:32.630 --> 00:19:36.020
that you, you understand what
it means to be functional,

313
00:19:36.020 --> 00:19:38.870
as opposed to just being
able to hack something together.

314
00:19:39.740 --> 00:19:44.870
That's a really good question.
So when, so understanding this

315
00:19:44.870 --> 00:19:49.880
idea of pure functions is
super important. You'll probably, if

316
00:19:49.880 --> 00:19:52.250
you're in an interview, you
would probably be asked to

317
00:19:52.250 --> 00:19:54.650
explain, you know, what's a
side effect, what is a

318
00:19:54.650 --> 00:19:57.770
pure function? Oh, good. I'm
glad they listened to this

319
00:19:57.770 --> 00:20:00.860
show. Yeah. Now, now, you
know, you got your job,

320
00:20:00.890 --> 00:20:07.700
right? The, the other thing
is that when you, when

321
00:20:07.700 --> 00:20:12.470
you start to like build
more complex systems and something

322
00:20:12.470 --> 00:20:15.980
that just calculates one value,
you start to build like

323
00:20:16.010 --> 00:20:20.270
data transformation pipelines. And it's
kind of like when you're

324
00:20:20.270 --> 00:20:23.960
doing bash scripting on the
command line where you're piping

325
00:20:23.990 --> 00:20:29.270
commands together, you, you know,
you have one function, that's

326
00:20:29.300 --> 00:20:32.570
calculating something. And then another
thing is taking that value

327
00:20:32.570 --> 00:20:35.510
that it calculated and turning
it into something else. And

328
00:20:35.510 --> 00:20:38.660
then another thing that's turning
it into something else. And

329
00:20:38.690 --> 00:20:41.180
then at the end you
can take that and maybe

330
00:20:41.180 --> 00:20:43.550
just run a loop over
it and like, you know,

331
00:20:44.210 --> 00:20:48.400
send off your emails or
whatever you're doing. And so

332
00:20:48.400 --> 00:20:54.040
that's another kind of milestone
on your journey when you're,

333
00:20:54.040 --> 00:20:56.950
when you're becoming a functional
programmer. So I would talk

334
00:20:56.950 --> 00:21:00.250
about that at the interview.
The next thing is, is

335
00:21:00.370 --> 00:21:06.160
getting to higher order programming.
And that means functions that

336
00:21:07.240 --> 00:21:13.120
take functions as arguments. And
so, because you're using pure

337
00:21:13.120 --> 00:21:17.050
functions, you actually feel very
safe just giving your function

338
00:21:17.050 --> 00:21:21.070
to another function, to run
for you. And this is

339
00:21:21.280 --> 00:21:26.530
often called dependency injection in
the object oriented world, except

340
00:21:26.530 --> 00:21:31.240
you're not injecting a, an
object, a piece of state

341
00:21:31.240 --> 00:21:35.470
with methods, you're injecting the
function. So you might say,

342
00:21:35.800 --> 00:21:40.060
Hey, I have a list.
Give me a new list,

343
00:21:40.060 --> 00:21:43.480
but with all the even
numbers removed, right? And so

344
00:21:43.480 --> 00:21:47.560
you're passing in to the
filter function. If you want,

345
00:21:47.560 --> 00:21:50.260
all the even numbers removed,
you would pass in the

346
00:21:50.320 --> 00:21:55.420
odd, the odd predicate. So
an, a function that returns

347
00:21:55.420 --> 00:21:58.900
true. If the number is
odd and so filter odd

348
00:21:58.990 --> 00:22:02.530
and then your list and
you get back all of,

349
00:22:02.920 --> 00:22:05.740
you know, a list, a
new list, cause it's immutable.

350
00:22:05.740 --> 00:22:09.400
So a new list of
only the odd numbers. And

351
00:22:09.400 --> 00:22:12.010
so w once you start
thinking, in terms of that,

352
00:22:12.310 --> 00:22:15.370
you, you realize that there
aren't that many useful shapes

353
00:22:15.370 --> 00:22:19.510
of data, you know, and
there's like ordered lists, there's

354
00:22:19.780 --> 00:22:25.930
associative data structures, like hash
maps, dictionaries, where you have

355
00:22:25.930 --> 00:22:31.690
a key value. And, and,
and then there's this, basically

356
00:22:31.690 --> 00:22:35.500
it there's sets, which are
like bags of stuff, non

357
00:22:35.500 --> 00:22:39.960
ordered. And then there, each
item is unique. So when

358
00:22:39.960 --> 00:22:41.850
I hear this word predicate,
and I hear all these

359
00:22:41.850 --> 00:22:44.520
different kind of computer sciency
words, those are the ones

360
00:22:44.520 --> 00:22:46.890
I think that scare people
off. Like we said, right.

361
00:22:47.430 --> 00:22:49.740
But it predicates, like it's
like Phil, it's like a

362
00:22:49.740 --> 00:22:53.160
filter criteria, right? Like that's
the thing that returns true

363
00:22:53.160 --> 00:22:55.560
or false. And then you
use it to filter lists

364
00:22:55.560 --> 00:22:59.070
of things. That's right. It's
just a regular function, a

365
00:22:59.070 --> 00:23:02.880
pure function that will take
an argument and return to

366
00:23:02.880 --> 00:23:05.850
our false. So it does
some, some check on the

367
00:23:05.850 --> 00:23:10.200
argument. So you could have
a function called OD that

368
00:23:10.890 --> 00:23:14.220
takes a number or integer,
and it returns true. If

369
00:23:14.220 --> 00:23:16.830
it's an odd number, you
could have one that called

370
00:23:16.860 --> 00:23:20.550
even that returns true. If
it's even, so you can

371
00:23:20.550 --> 00:23:24.360
then pass this into a
function that expects a predicate,

372
00:23:24.900 --> 00:23:30.360
like filter a filter will
take a sequence or some

373
00:23:30.360 --> 00:23:34.590
collection and return a new
collection with all this with

374
00:23:34.590 --> 00:23:38.010
only keeping the stuff that
passes the predicate. So they

375
00:23:38.010 --> 00:23:40.890
have a list of numbers
and you pass it to

376
00:23:40.890 --> 00:23:44.520
filter with the odd predicate,
you'll get a new list

377
00:23:44.520 --> 00:23:50.270
of numbers, only the odd
numbers in it. And because

378
00:23:50.270 --> 00:23:53.960
there's only certain shapes of
data. So filter works on

379
00:23:53.960 --> 00:23:58.490
a sequence, right? And then
there's like associative shapes. So

380
00:23:58.490 --> 00:24:01.340
sequences have an order associated,
doesn't have an order, but

381
00:24:01.340 --> 00:24:04.670
it has like this relationship
between the key value, keys

382
00:24:04.670 --> 00:24:10.880
and values, and then there's
sets, which are just collections

383
00:24:10.880 --> 00:24:14.540
with no order, but you
can check if something is

384
00:24:14.540 --> 00:24:17.420
in there and you can
also like put the same

385
00:24:17.420 --> 00:24:19.370
thing in twice. And it
only gets put in once.

386
00:24:21.290 --> 00:24:24.410
And because there's only these
certain shapes, you just learn

387
00:24:24.800 --> 00:24:29.570
a bunch of these higher
order functions that operate on

388
00:24:29.570 --> 00:24:33.960
the shapes and put them
in a pipeline. And you're,

389
00:24:33.960 --> 00:24:36.770
you're just piping stuff through.
I mean, I guess it's

390
00:24:36.770 --> 00:24:39.410
kind of like, you know,
if your audience is familiar

391
00:24:39.410 --> 00:24:44.630
with some of the Unix
commands, like the early Unix

392
00:24:44.630 --> 00:24:48.800
commands where, you know, LS
just lists all the files

393
00:24:48.800 --> 00:24:50.840
in the directory, one on
each line, and then you

394
00:24:50.990 --> 00:24:53.600
grip it and it shows
you all the ones that

395
00:24:53.600 --> 00:24:56.630
match, and then you, you
pipe it to something else

396
00:24:57.080 --> 00:25:00.170
and, you know, maybe you
sort them, and then you

397
00:25:00.170 --> 00:25:01.970
count them, you know, you
can do all sorts of

398
00:25:01.970 --> 00:25:06.350
stuff with them and you
you're just chaining up these

399
00:25:06.350 --> 00:25:09.610
commands together. Right. That's a
really clean way to explain

400
00:25:09.610 --> 00:25:12.730
it to people like LS
doesn't change anything. It never

401
00:25:12.970 --> 00:25:16.540
LS is guaranteed to never
change stuff. Right. And grip

402
00:25:16.630 --> 00:25:19.390
doesn't change stuff either. Right.
All it does is in

403
00:25:19.390 --> 00:25:22.420
lines and then only writes
out a subset of those

404
00:25:22.420 --> 00:25:24.820
lines. Okay. So then this
kind of brings us to

405
00:25:24.820 --> 00:25:28.870
function composition, where I go
and take five or six

406
00:25:28.870 --> 00:25:32.140
functions and OCHIN set and
grip and, and G you

407
00:25:32.140 --> 00:25:35.410
know, Jason C or whatever,
and combine them, and then

408
00:25:35.410 --> 00:25:37.390
I could make them their
own function and then combine

409
00:25:37.390 --> 00:25:40.360
that. And then now you're,
now you're building stuff up,

410
00:25:40.390 --> 00:25:43.480
except you're doing it with
pieces of functions and functions

411
00:25:43.480 --> 00:25:46.990
of functions, as opposed to,
as I'd like to say

412
00:25:47.170 --> 00:25:50.590
multiple nested for loops. Right.
Which is what it ends

413
00:25:50.590 --> 00:25:54.670
up being in a, in,
in nonfunctional. Exactly. I mean,

414
00:25:54.670 --> 00:25:57.490
because what happens in Unix
is all you really have

415
00:25:57.490 --> 00:26:01.210
are lines of text, right?
Like that's what everything understands.

416
00:26:01.510 --> 00:26:05.380
So it's very flat. If
you need to do anything

417
00:26:05.740 --> 00:26:09.790
more sophisticated than just, you
know, read it as text,

418
00:26:09.790 --> 00:26:12.490
maybe like it's a Jason
per line. Well, then you

419
00:26:12.490 --> 00:26:16.330
need another like, program that
can go in and read

420
00:26:16.390 --> 00:26:19.300
the line of Jason and
you, like, I don't know.

421
00:26:19.300 --> 00:26:20.950
I don't even know how
you do this in Unix,

422
00:26:20.950 --> 00:26:25.780
but you need to run
that command for every line.

423
00:26:25.780 --> 00:26:28.600
And then inside that it's
like, now it's nested. So

424
00:26:28.600 --> 00:26:30.640
you have to do all
this stuff inside of that.

425
00:26:30.820 --> 00:26:33.880
And it gets really complicated,
which is why in a

426
00:26:33.880 --> 00:26:38.200
functional language, you will get
more nesting in your data

427
00:26:38.200 --> 00:26:41.890
structure. But because you're operating
at a higher order, you're

428
00:26:41.890 --> 00:26:45.900
often able to, I guess,
Keep the pipeline flat is

429
00:26:45.900 --> 00:26:50.730
how, how you'd think of
it. Very cool. So you

430
00:26:50.730 --> 00:26:58.140
can go to purely functional.tv,
which is Eric's website, and

431
00:26:58.140 --> 00:27:01.710
he's got video courses. He's
got a guide that he

432
00:27:01.710 --> 00:27:03.630
can, you can get on
his mailing list. There's a

433
00:27:03.630 --> 00:27:08.100
whole section on job resources
for both Haskell and closure.

434
00:27:08.640 --> 00:27:11.850
And you can basically get
onto the newsletter to start

435
00:27:11.880 --> 00:27:14.400
and check out some of
his great video courses. He's

436
00:27:14.400 --> 00:27:16.260
got a whole system and
the whole focus of your

437
00:27:16.260 --> 00:27:19.170
website. I really liked this
because rather than just saying,

438
00:27:19.530 --> 00:27:21.450
here's a bunch of videos,
here's a bunch of stuff.

439
00:27:21.660 --> 00:27:24.480
Your focus is, if you
want to move your career,

440
00:27:24.480 --> 00:27:27.300
you want to change your
job from doing imperative programming

441
00:27:27.300 --> 00:27:31.440
to functional programming. You're basically
setting people up for success

442
00:27:31.710 --> 00:27:35.490
with that, with that being
the goal. Yeah. And now,

443
00:27:35.520 --> 00:27:38.760
now you should understand the
purely in the functional, it's

444
00:27:38.760 --> 00:27:42.330
like a play on words.
That's all I talk about

445
00:27:42.330 --> 00:27:45.030
is functional and it's pure,
and yeah, there you go.

446
00:27:45.210 --> 00:27:47.550
That's great. And I'm going
to put links to all

447
00:27:47.550 --> 00:27:50.730
of this in the show
notes, as well as some

448
00:27:50.730 --> 00:27:53.970
of the great free courses.
He's got like 13 hours

449
00:27:53.970 --> 00:27:57.630
of great free courses about
closure dot test and data

450
00:27:57.630 --> 00:27:59.430
modeling and all kinds of
stuff. So you can see

451
00:27:59.430 --> 00:28:03.360
his style of, of teaching.
And if you check it

452
00:28:03.360 --> 00:28:06.750
out, maybe purchase some things.
Thanks so much for chatting

453
00:28:06.750 --> 00:28:10.140
with me today. Thanks so
much, Scott. This has been

454
00:28:10.140 --> 00:28:13.230
another episode of Hanselminutes and
we'll see you again next

455
00:28:13.230 --> 00:28:13.440
week.


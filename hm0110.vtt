WEBVTT FILE

1
00:00:12.030 --> 00:00:16.920
From Hanselman it's dot com
it's Hansel minutes or weekly

2
00:00:16.920 --> 00:00:21.210
discussion with web developer and
technologists. Scott Hanselman hosted by

3
00:00:21.210 --> 00:00:26.370
Carl Franklin. This is Lawrence Ryan announcing
show number one 10 recorded

4
00:00:26.370 --> 00:00:32.520
live Tuesday, April 22nd, 2008. Support for
Hansel minutes is provided by

5
00:00:32.550 --> 00:00:36.360
Telerik rad controls, the most
comprehensive suite of components to

6
00:00:36.360 --> 00:00:46.200
windows forms and asp.net web
applications online@wwwdottelerik.com. Support is also

7
00:00:46.200 --> 00:00:50.010
provided by Dutton and developers
journal. The world's leading.net developer

8
00:00:50.010 --> 00:00:55.920
magazine online at www dot
<inaudible> dot com. In this

9
00:00:55.920 --> 00:00:59.610
episode, Scott talks with Rustin
and Mike from the Microsoft

10
00:00:59.610 --> 00:01:05.700
research group about the spec
sharp programming language. Hi, this

11
00:01:05.700 --> 00:01:07.410
is Scott Hanselman and this
is another episode of Hansel

12
00:01:07.410 --> 00:01:11.190
minutes, and I'm sitting here@theall.net
conference in Seattle, Washington with

13
00:01:11.190 --> 00:01:14.760
Rustin and Mike from the
Microsoft research group, working on

14
00:01:14.760 --> 00:01:17.130
a product called spec sharp
that they've just demo it

15
00:01:17.130 --> 00:01:19.890
to the all.net crowd here.
Thank you gentlemen, for sitting

16
00:01:19.890 --> 00:01:23.730
down with me today. Thanks
for having us. So spec

17
00:01:23.730 --> 00:01:25.920
sharp, it says sharp. That
must mean it has something

18
00:01:25.920 --> 00:01:28.680
to do with C sharp,
possibly the.net framework. What does

19
00:01:28.680 --> 00:01:31.830
spec sharp do? Spec sharp
is a superset of C

20
00:01:31.830 --> 00:01:35.070
sharp of the C sharp
language. And it adds to

21
00:01:35.070 --> 00:01:38.280
the language specifications, which is
where the language gets its

22
00:01:38.280 --> 00:01:42.420
name. The specifications are contracts
like pre and post conditions.

23
00:01:42.450 --> 00:01:46.470
And we also enhance the
type system with nonmetal types,

24
00:01:46.500 --> 00:01:49.740
for example, and with those
contracts, you can, you can

25
00:01:49.740 --> 00:01:52.620
record your design decisions in
the, in the program text

26
00:01:53.070 --> 00:01:56.520
and, and have them be
checked by, by various tools.

27
00:01:57.090 --> 00:01:59.340
So you are a super
set of C sharp. So

28
00:01:59.340 --> 00:02:01.710
you're saying that here are
some keywords and some things

29
00:02:01.710 --> 00:02:03.440
that are not in C-sharp
that we've added, you can

30
00:02:03.450 --> 00:02:07.470
enhance the language itself. That's
correct. So the, so we

31
00:02:07.470 --> 00:02:10.140
add a few keywords, a
few new constructs here and

32
00:02:10.140 --> 00:02:13.500
there. Are you your own
compiler or are you a

33
00:02:13.500 --> 00:02:19.680
post compiler? We're a full
fledged compiler. So it's not

34
00:02:19.680 --> 00:02:23.700
a source to source transformation.
It takes the surface syntax

35
00:02:23.730 --> 00:02:26.490
and compiles it all the
way down to aisle and

36
00:02:26.490 --> 00:02:31.140
creates a valid.net assemblies just
as the VB compiler or

37
00:02:31.140 --> 00:02:34.110
the C sharp compiler do.
So did you have to

38
00:02:34.110 --> 00:02:36.240
recreate work that was already
done by the C sharp

39
00:02:36.240 --> 00:02:39.210
compiler? Yes. Cause it's completely
independent. So I mean, it's,

40
00:02:39.230 --> 00:02:42.840
it does a full, you
know, parsing and co-generation and

41
00:02:42.840 --> 00:02:46.410
it's the code base is
absolutely separate from the C

42
00:02:46.410 --> 00:02:48.420
sharp compiler. Is that a
good thing or a bad

43
00:02:48.420 --> 00:02:52.500
thing? It was a good
thing for quickly getting a,

44
00:02:54.690 --> 00:02:57.930
the compiler up and running.
It was a bad thing

45
00:02:57.930 --> 00:03:00.400
in the sense that now
we are a superset of

46
00:03:00.400 --> 00:03:03.450
C tooo and not a
super set of seizure. I

47
00:03:03.450 --> 00:03:06.090
see. But of course the
intent is to make this

48
00:03:06.090 --> 00:03:07.980
something that's useful for everyone.
Cause you're trying to take

49
00:03:07.980 --> 00:03:09.960
the notion of a specification
and add it to all

50
00:03:09.960 --> 00:03:13.200
dominant languages. That's right. So
one of the things we're

51
00:03:13.200 --> 00:03:16.050
looking at now is a
non-language based solution and we

52
00:03:16.170 --> 00:03:19.980
use spec sharp as a
way to sort of paint

53
00:03:19.980 --> 00:03:21.600
a picture of the future
of what it could look

54
00:03:21.600 --> 00:03:24.330
like. If a language was
to fully embrace the idea

55
00:03:24.330 --> 00:03:27.750
of design by contract and
make specifications of first class

56
00:03:27.750 --> 00:03:33.360
citizen. But we're also working
on we've designed spec sharp

57
00:03:33.360 --> 00:03:35.550
in a way that has
made it possible to peel

58
00:03:35.550 --> 00:03:40.740
off layers and potentially get
those layers implemented in all.net

59
00:03:40.740 --> 00:03:44.190
language. Huh? So you've added
a number of keywords to

60
00:03:44.190 --> 00:03:47.790
C-sharp in order to allow
this dynamic design by contract

61
00:03:48.390 --> 00:03:51.000
concept. What are some of
the keywords and explain how

62
00:03:51.000 --> 00:03:53.100
I would decorate one of
my methods with these keywords.

63
00:03:53.940 --> 00:03:57.570
The first one is the
upon runs across is not

64
00:03:57.570 --> 00:03:59.760
the key word at all,
but just another symbol, which

65
00:03:59.760 --> 00:04:02.940
is the exclamation point, the
bang. So if you write,

66
00:04:03.030 --> 00:04:05.820
if you write the reference
type like T or string

67
00:04:05.820 --> 00:04:08.880
or object and you follow
it by bang, making it

68
00:04:08.880 --> 00:04:12.420
string bang or object bang
T bang, what you're saying

69
00:04:12.420 --> 00:04:14.700
is that that type is
a type that holds a

70
00:04:14.700 --> 00:04:17.980
reference that is not no.
And that's something that, that

71
00:04:18.450 --> 00:04:20.760
you tend to use all
over. So in, in the

72
00:04:20.760 --> 00:04:24.630
spectrum type system, we allow
programs to use non mold

73
00:04:24.630 --> 00:04:28.200
types. And then the, the
type system that compiler will,

74
00:04:28.410 --> 00:04:31.560
we'll make sure that just
as, as you use types

75
00:04:31.560 --> 00:04:33.720
elsewhere in the program, that
you don't give a Boolean,

76
00:04:33.720 --> 00:04:37.110
when a string is expected
here, it also does that

77
00:04:37.110 --> 00:04:39.540
for, for normal entities. This
is a kind of an

78
00:04:39.540 --> 00:04:42.690
assertion where I'm, I'm making
a declaration that the type

79
00:04:42.690 --> 00:04:45.660
T shall never be no,
That's correct. That is a

80
00:04:45.660 --> 00:04:48.060
kind of assertion like that.
Or you, some people even

81
00:04:48.060 --> 00:04:51.120
call that they're a contract
as well. Okay. So I'm

82
00:04:51.120 --> 00:04:54.600
strengthening, I'm, I'm constraining the
system such that the system

83
00:04:54.600 --> 00:04:56.280
can not get into a
state, which is not what

84
00:04:56.280 --> 00:04:59.010
I want. That's correct. And
for the, for the non

85
00:04:59.010 --> 00:05:01.710
all types themselves, we also
support a mode where you

86
00:05:01.710 --> 00:05:05.610
switch the defaults, where, where
the, the types stand for

87
00:05:05.610 --> 00:05:08.310
normal types. And if you
want to the knowledgeable versions

88
00:05:08.340 --> 00:05:10.700
you do like you do
with value types today in,

89
00:05:10.700 --> 00:05:12.780
in C sharp, which is
to add a question Mark

90
00:05:12.780 --> 00:05:15.120
afterwards, Right? So people are
familiar with being able to

91
00:05:15.120 --> 00:05:18.060
say something like, and question
Mark, where suddenly a value

92
00:05:18.060 --> 00:05:20.700
type, which for many years
has not been nullable it

93
00:05:20.700 --> 00:05:25.270
becomes knowable. Right? Exactly. And
I can do the, the,

94
00:05:25.270 --> 00:05:29.400
the inverse now with, you
know, class person, which would

95
00:05:29.400 --> 00:05:31.380
initially start out in all,
if I said Persian P

96
00:05:31.380 --> 00:05:34.620
equals no. And now if
I said, if it person

97
00:05:34.830 --> 00:05:38.220
bang, I can't assign null
to it. That's never be

98
00:05:38.220 --> 00:05:41.250
known within the scope of
the project. Exactly. Right. So

99
00:05:41.250 --> 00:05:44.070
that's the, that's the simplest
keyboard or a thing that

100
00:05:44.070 --> 00:05:47.280
we're adding to, to the
language simplest, at least syntactically

101
00:05:47.850 --> 00:05:52.290
then the other things that
you see next are precon

102
00:05:52.410 --> 00:05:55.410
preconditions and post conditions. And
they are written with the,

103
00:05:55.440 --> 00:05:59.450
with a requires and ensures
which follow the signature of

104
00:05:59.450 --> 00:06:02.270
the method. So you would
write a void M and

105
00:06:02.270 --> 00:06:05.390
give the parameters and the
closed parenthesis, and then you

106
00:06:05.390 --> 00:06:08.360
would say requires, and you
would give a Boolean condition

107
00:06:09.260 --> 00:06:14.300
that says what under which
conditions the method is allowed

108
00:06:14.300 --> 00:06:16.930
to be called. Okay. So
trying to visualize this, remembering

109
00:06:16.930 --> 00:06:19.390
that we've got people commuting
in an audio world, and

110
00:06:19.390 --> 00:06:21.760
we don't have any video
to show them, I've created

111
00:06:21.760 --> 00:06:24.520
a method that takes a
string and an integer, and

112
00:06:24.520 --> 00:06:27.910
before the opening curly brace,
but after the method's signature,

113
00:06:27.910 --> 00:06:30.370
I'm going to say that
it is the case that

114
00:06:30.370 --> 00:06:33.040
the string and this integer
meet these conditions. If one

115
00:06:33.040 --> 00:06:35.110
is going to be allowed
to call this method, Right?

116
00:06:35.170 --> 00:06:37.930
For example, you might say
that the, that the integer

117
00:06:38.170 --> 00:06:41.440
is less than the length
of the string as an

118
00:06:41.440 --> 00:06:46.840
example. Interesting. So when I
express a method, a contract,

119
00:06:46.840 --> 00:06:48.880
right now, the extent of
that method contract is that

120
00:06:48.880 --> 00:06:51.850
it takes these types. And
I can expand that contract

121
00:06:51.850 --> 00:06:54.460
by adding overloads. And a
lot of people have asked

122
00:06:54.460 --> 00:06:57.560
for things like optional parameters
and C-sharp, but you're, you're

123
00:06:57.610 --> 00:07:00.790
tightening the noose as it
were. And saying that not

124
00:07:00.790 --> 00:07:03.190
only w might I say
that this string must be

125
00:07:03.190 --> 00:07:05.350
this length or that this
integer must be below this

126
00:07:05.350 --> 00:07:08.140
value, but that they can
interrelate to each other. That's

127
00:07:08.140 --> 00:07:10.810
correct. So the, so what
we do with types on

128
00:07:10.810 --> 00:07:14.680
typically just express this, something
about each variable independently, and

129
00:07:14.680 --> 00:07:17.290
with the contracts like pre
and post conditions, you can

130
00:07:17.290 --> 00:07:22.270
very, very easily and naturally
constrain several variables at one

131
00:07:22.270 --> 00:07:26.650
time. Now, the what about
the result that would be

132
00:07:26.650 --> 00:07:29.320
coming back? Cause you made
the comment to avoid em,

133
00:07:29.320 --> 00:07:30.790
but let's say that I've
take a string and an

134
00:07:30.790 --> 00:07:33.010
integer, but I'm going to
be returning some value. And

135
00:07:33.010 --> 00:07:37.180
another string, perhaps Spec sharp
has added a context, sensitive

136
00:07:38.020 --> 00:07:43.720
context, dependent keyword result, and
the, that keyword can appear

137
00:07:43.720 --> 00:07:47.170
in a post condition and
insurers clause, which guarantees to

138
00:07:47.170 --> 00:07:51.670
callers of the method, some
condition involving the return value.

139
00:07:52.060 --> 00:07:54.190
And so it stands for
the value that's being returned

140
00:07:54.190 --> 00:07:56.560
from the method in the
condition. So just like when

141
00:07:56.560 --> 00:07:59.200
I'm creating a property and
I'm doing a property center

142
00:07:59.200 --> 00:08:01.960
and I have this keyword
called value, that is context

143
00:08:01.960 --> 00:08:04.210
specific returning to the value
that's coming in to the

144
00:08:04.210 --> 00:08:07.660
center. This is a keyword
that refers to what's exiting

145
00:08:07.840 --> 00:08:11.260
exactly. Now I can make
posts, conditions and preconditions now

146
00:08:11.260 --> 00:08:13.720
by putting in a debug
that assert at the beginning

147
00:08:14.020 --> 00:08:16.480
or debug at assert at
the, at as I exit.

148
00:08:16.900 --> 00:08:20.860
But why would this be
more desirable to use spec

149
00:08:20.860 --> 00:08:22.870
sharp for that it's particularly
on the exit case, Right?

150
00:08:22.870 --> 00:08:27.280
So the crucial difference is
that if you use debug

151
00:08:27.290 --> 00:08:31.510
dot assert inside of your
method, body, it is something

152
00:08:31.510 --> 00:08:34.840
that is visible to you
and to the program only

153
00:08:34.840 --> 00:08:38.950
internally inside of that method,
callers of that method are

154
00:08:38.950 --> 00:08:40.960
not able to take advantage
of the fact that you

155
00:08:40.960 --> 00:08:45.130
happen to have put those
conditions on the code. If

156
00:08:45.130 --> 00:08:48.280
you use spec sharp, then
the contracts are visible to

157
00:08:48.280 --> 00:08:51.010
all callers of the method.
And the spectrum of tools

158
00:08:51.010 --> 00:08:53.770
can be applied to those
callers to guarantee that the

159
00:08:53.770 --> 00:08:57.360
caller will not violate the
preconditions of the method being

160
00:08:57.360 --> 00:09:01.110
called and can enjoy the
benefits of what the post

161
00:09:01.110 --> 00:09:05.430
condition guarantees them. For instance,
if you call string dot

162
00:09:05.430 --> 00:09:10.260
can cat there's no, there's
not necessarily a guarantee that

163
00:09:10.260 --> 00:09:12.660
will comes back as non
no, but if concat had

164
00:09:12.660 --> 00:09:15.330
a post-condition, which said the
result is non Knoll, then

165
00:09:15.330 --> 00:09:17.670
you would know that you
can freely D reference the

166
00:09:17.760 --> 00:09:20.310
result that comes back from
that method without having to

167
00:09:20.310 --> 00:09:22.050
do a runtime check, to
make sure that it was

168
00:09:22.050 --> 00:09:26.700
non-metal to add to that
as an, as an analogy

169
00:09:26.910 --> 00:09:30.660
you might consider making all
of your methods, take object

170
00:09:30.750 --> 00:09:33.180
as parameters. And that is
that the type of all

171
00:09:33.180 --> 00:09:35.460
of them would be object.
And inside of your method,

172
00:09:35.460 --> 00:09:38.100
you would immediately cast them
to an integer or a

173
00:09:38.100 --> 00:09:40.530
string or whatever it is
that you want. But by

174
00:09:40.530 --> 00:09:42.780
instead of making them part
of the method signature, you're

175
00:09:42.780 --> 00:09:45.840
telling callers that that's what
you expect in a similar

176
00:09:45.840 --> 00:09:49.200
way by instead of using
debug that dissert inside of

177
00:09:49.200 --> 00:09:51.780
your method, body, you put
pre and post conditions on

178
00:09:51.780 --> 00:09:54.860
the method. You're telling something
to, to your color. That

179
00:09:54.860 --> 00:09:56.540
is a really interesting way
to put it just by

180
00:09:56.540 --> 00:10:00.560
having the type a signature
there you are constraining that

181
00:10:00.560 --> 00:10:03.620
contract. I could certainly have
an, a, a method that

182
00:10:03.620 --> 00:10:07.160
took an array of object
of indeterminate length and where

183
00:10:07.160 --> 00:10:09.440
each object is. I've even
determined it type. And unfortunately

184
00:10:09.440 --> 00:10:11.780
I've seen method signatures like
that in the wild that

185
00:10:11.780 --> 00:10:13.490
returned then an array of
objects. And I would have

186
00:10:13.490 --> 00:10:15.230
really no way of knowing
other than this is a

187
00:10:15.230 --> 00:10:20.030
method called M and I'm
constraining that by adding something

188
00:10:20.030 --> 00:10:24.560
as simple as method types.
So we continue to tighten

189
00:10:24.560 --> 00:10:28.010
things up. So we're saying
that the domain of what

190
00:10:28.010 --> 00:10:31.010
this method is responsible for
is, is smaller and smaller

191
00:10:31.010 --> 00:10:34.400
and smaller. Does that make
it easier to test That

192
00:10:34.580 --> 00:10:37.010
that makes, first of all,
it makes the requirements clear

193
00:10:37.010 --> 00:10:39.080
what, what is expected of
the caller and what is

194
00:10:39.080 --> 00:10:42.200
expected of the implementation. But
it also means that when

195
00:10:42.200 --> 00:10:46.610
you, when you analyze your,
the implementation, which you could

196
00:10:46.610 --> 00:10:50.300
do either by testing, which
is how it's frequently done,

197
00:10:50.690 --> 00:10:53.420
or, or by some other
tools, like, for example, our

198
00:10:53.420 --> 00:10:57.160
static verifier, then we only
need to consider those inputs

199
00:10:57.160 --> 00:11:03.020
States that satisfy those, those
preconditioned constraints. So I'm hearing

200
00:11:03.020 --> 00:11:05.450
both, do you have runtime
checking, which would be the

201
00:11:05.450 --> 00:11:07.100
equivalent of what I was
saying or doing a debug

202
00:11:07.100 --> 00:11:10.330
that assert, so that's happening
at runtime, but this, this

203
00:11:10.340 --> 00:11:13.130
is the importance of this
being static. You have tightened

204
00:11:13.130 --> 00:11:16.700
up the message signature, such
that callers of that method

205
00:11:16.700 --> 00:11:20.390
signature are, are aware of
that contract, Right? W we

206
00:11:20.390 --> 00:11:22.850
want to support dynamic checking
because it's an easy way

207
00:11:22.850 --> 00:11:26.600
to get into the using
contracts. One adds a little

208
00:11:26.600 --> 00:11:28.280
bit of code, just like
you would add to debug

209
00:11:28.280 --> 00:11:30.500
that, to search somewhere. And
it's going to check some

210
00:11:30.500 --> 00:11:32.660
condition when you're, when you're
running it. And at the

211
00:11:32.660 --> 00:11:35.360
same time, you're recording your
design decisions in the code,

212
00:11:35.720 --> 00:11:38.300
but we want to go
a step further. And so

213
00:11:38.300 --> 00:11:41.330
in our, in our research,
we've spent a good bit

214
00:11:41.330 --> 00:11:45.020
of effort on trying to
statically verify these things. What

215
00:11:45.020 --> 00:11:49.760
we do there is we
technologically is we take the

216
00:11:49.760 --> 00:11:52.760
program and convert it into
a mathematical formula, a very

217
00:11:52.760 --> 00:11:58.960
large mathematical formula, but it's
typically mathematically shallow, meaning we're

218
00:11:58.960 --> 00:12:02.440
not trying to prove for
a maths lesson last conjecture

219
00:12:02.440 --> 00:12:05.380
or something like that. So
what we do, but there

220
00:12:05.380 --> 00:12:07.210
are lots and lots of
details to check. So we

221
00:12:07.210 --> 00:12:11.320
pass that to an automatic
theorem prover and the which

222
00:12:11.320 --> 00:12:14.230
then analyzes the mathematical formula
to see if it's a

223
00:12:14.230 --> 00:12:16.810
valid logical formula. And if
it is, that means that

224
00:12:16.810 --> 00:12:19.840
the program is correct. If
it isn't, the, the theorem

225
00:12:19.840 --> 00:12:24.280
prover will return to us
some mathematical counter example that

226
00:12:24.280 --> 00:12:28.480
shows that it's not a
mathematically valid formula. And then

227
00:12:28.480 --> 00:12:31.930
we have kept enough information.
So we can take that

228
00:12:31.930 --> 00:12:35.050
mathematical counter example and bring
it back into an error

229
00:12:35.050 --> 00:12:38.110
message that the, that the
programmer, the dotnet programmer will

230
00:12:38.110 --> 00:12:41.800
understand things like here, you're
calling a method and you

231
00:12:41.800 --> 00:12:45.310
don't satisfy the precondition, or
here you're trying to index

232
00:12:45.310 --> 00:12:48.540
in array outside its bounds.
Now, previously on this podcast,

233
00:12:48.540 --> 00:12:52.470
I'd spoken to palliate Dale,
Lou, and Nikolai about their

234
00:12:52.470 --> 00:12:55.050
product packs. And they had
spoken of the way that

235
00:12:55.050 --> 00:12:56.580
they had layered it such
that they could peel off

236
00:12:56.580 --> 00:12:58.980
pieces. And they spoke to
the solver that they pass

237
00:12:58.980 --> 00:13:01.440
information into. Is this in
fact, the same component? In

238
00:13:01.440 --> 00:13:04.290
fact, it is the same
on the particular theorem. Prover

239
00:13:04.290 --> 00:13:07.170
is called <inaudible> and it's
also developed at Microsoft research.

240
00:13:08.040 --> 00:13:11.700
Interesting. So there's a relationship
between the kinds of things

241
00:13:11.700 --> 00:13:14.010
that PEX is trying to
solve, which is to prove

242
00:13:14.010 --> 00:13:17.310
that code will run as
it is written, and that

243
00:13:17.310 --> 00:13:20.220
it will, it appropriately meets
the spec and what you

244
00:13:20.220 --> 00:13:24.720
guys are trying to do.
Yeah, absolutely. I'll I'll, I

245
00:13:24.720 --> 00:13:28.800
would say all formal tools
like PAX and spec sharp

246
00:13:30.090 --> 00:13:36.990
function by treating a program
as a mathematical object, which

247
00:13:36.990 --> 00:13:39.150
it is because it's a
set of formal symbols, which

248
00:13:39.240 --> 00:13:41.100
have to be that way
so that the computer can

249
00:13:41.970 --> 00:13:46.020
understand it and execute the
program. And then you make

250
00:13:46.020 --> 00:13:50.880
progress by using different mathematical
theories to analyze properties of

251
00:13:50.880 --> 00:13:54.390
that program. Now, a lot
of talk has been made

252
00:13:54.390 --> 00:13:57.450
lately of, of F sharp
and the notion of a

253
00:13:57.450 --> 00:14:01.290
functional language being more easily,
mathematically provable by its very

254
00:14:01.290 --> 00:14:04.470
nature. One can say that
this is proven to work

255
00:14:04.500 --> 00:14:07.890
thusly. Are we trying to
take C-sharp and that same

256
00:14:07.890 --> 00:14:09.810
kind of a direction, or
would it be more appropriate

257
00:14:09.810 --> 00:14:11.670
to simply use a language
that was provable by its

258
00:14:11.670 --> 00:14:16.560
nature? If one looks at
the, at the research that

259
00:14:16.560 --> 00:14:18.690
has been done for program
verification, most of it has

260
00:14:18.690 --> 00:14:21.900
been done for imperative programs,
not so much for the

261
00:14:21.900 --> 00:14:25.980
functional languages, which is, which
is unfortunate. And we, because

262
00:14:25.980 --> 00:14:29.130
the functional languages start off
with something that is while

263
00:14:29.130 --> 00:14:31.200
as you perhaps thought of
it, that's more correct that

264
00:14:31.200 --> 00:14:34.140
it's, it's, it's more rigorous
in, in some, in some

265
00:14:34.140 --> 00:14:36.030
ways, you know, more things
about the things in the

266
00:14:36.030 --> 00:14:40.470
program, but there's still many
different, many difficult issues in

267
00:14:40.690 --> 00:14:45.180
trying to apply program verification,
even to functional programs. But

268
00:14:45.210 --> 00:14:47.700
what we're trying to do
from the spectrum perspective is

269
00:14:48.420 --> 00:14:51.800
we find many places where,
where, where would like to

270
00:14:51.830 --> 00:14:55.100
specify that a method has
no side effects. And then

271
00:14:55.370 --> 00:14:57.260
we give the opportunity to
say that it is a

272
00:14:57.260 --> 00:14:59.480
pure method. Or if you
want to say that the

273
00:14:59.480 --> 00:15:04.430
class is something that once
it's instances are constructed, they

274
00:15:04.430 --> 00:15:07.730
don't change. You can Mark
that class to be immutable.

275
00:15:07.970 --> 00:15:10.010
And those things do help
in the, in the static

276
00:15:10.010 --> 00:15:13.430
verification of the programs. And
in addition, the annotations that

277
00:15:13.430 --> 00:15:16.670
we have give additional documentation
to the program. Of course.

278
00:15:17.450 --> 00:15:18.940
Interesting. All right. Well, I'm
going to just take a

279
00:15:18.940 --> 00:15:20.950
very brief moment and we're
going to thank our sponsors

280
00:15:21.400 --> 00:15:24.760
and we'll come right back.
Hi, it's Scott here from

281
00:15:24.760 --> 00:15:26.680
another place in time. I
hope you're enjoying the show

282
00:15:26.680 --> 00:15:29.320
so far. I apologize for
interrupting it, but I wanted

283
00:15:29.320 --> 00:15:31.300
to let you know that
assembling a podcast like this

284
00:15:31.300 --> 00:15:34.390
every week, isn't free. Certainly
the bandwidth bill crushes us

285
00:15:34.390 --> 00:15:35.800
every month. So I wanted
to let you know that

286
00:15:35.800 --> 00:15:38.470
this show is sponsored by
Tellerik. They make the show

287
00:15:38.470 --> 00:15:40.540
possible and it makes it
pretty cool products as well.

288
00:15:41.230 --> 00:15:43.150
For example, if you're trying
to build a web 2.0

289
00:15:43.150 --> 00:15:46.450
Ajax application, trying to use
the web 1.0 components, it's

290
00:15:46.450 --> 00:15:48.640
kind of difficult. You got
to get the next gen

291
00:15:48.640 --> 00:15:50.740
stuff. If you want to
build the next gen websites.

292
00:15:50.740 --> 00:15:52.690
And that's exactly what the
folks at Tellerik have got

293
00:15:53.080 --> 00:15:55.240
and their new upcoming product,
which is code named rad

294
00:15:55.240 --> 00:15:58.570
controls. Prometheus's, it's a big
pack. A web controls built

295
00:15:58.570 --> 00:16:01.480
entirely on top of the
Microsoft ASP net Ajax stuff

296
00:16:01.480 --> 00:16:03.400
that you already understand. It's
going to give you a

297
00:16:03.400 --> 00:16:06.490
lot of performance interactivity on
your next project. They mirror

298
00:16:06.490 --> 00:16:09.550
the ASP net Ajax API.
So the development's really straightforward

299
00:16:10.030 --> 00:16:13.510
client scripture's shared loading time
is pretty fast. You set

300
00:16:13.510 --> 00:16:15.190
a couple of properties. You
can even bind a web

301
00:16:15.190 --> 00:16:18.760
services for really efficient operation.
The new rad editor for

302
00:16:18.760 --> 00:16:20.920
ESPN at Ajax loads up
to four times faster than

303
00:16:20.920 --> 00:16:23.890
before. And the red grid
will do thousands of records

304
00:16:23.890 --> 00:16:26.590
in milliseconds. But of course
it's better to try these

305
00:16:26.590 --> 00:16:29.080
things for yourself. So you
can visit <inaudible> dot com

306
00:16:29.080 --> 00:16:32.380
slash ASP, net Ajax, and
download a trial. Thanks a

307
00:16:32.380 --> 00:16:34.000
lot for listening and we'll
get right back to the

308
00:16:34.000 --> 00:16:37.750
show. So this notion of,
of side effects and an

309
00:16:37.750 --> 00:16:40.240
object changing when it maybe
shouldn't change or entering a

310
00:16:40.240 --> 00:16:42.670
state in which it is
inappropriate, I saw that you

311
00:16:42.670 --> 00:16:46.540
had a keyword for invariant,
Correct. When people think of

312
00:16:46.540 --> 00:16:49.420
contracts, they typically first think
of pre and post conditions,

313
00:16:49.450 --> 00:16:53.170
but a very important aspect
of a, of a contract

314
00:16:53.170 --> 00:16:56.800
is also the, the invariant,
which States properties that are,

315
00:16:57.010 --> 00:16:59.710
that you intend to hold
of the status steady state

316
00:16:59.710 --> 00:17:02.590
of the, of, of a
data structure. That is the

317
00:17:02.590 --> 00:17:06.670
invariant says what the, what
the internal consistency of your

318
00:17:06.670 --> 00:17:10.810
data structures are to verify
a program statically you need

319
00:17:10.810 --> 00:17:14.620
to have in variants and
invariants are difficult to deal

320
00:17:14.620 --> 00:17:18.460
with because they are not
entirely invariant. They do change

321
00:17:18.490 --> 00:17:21.100
that is, there are some
points in your program where,

322
00:17:21.100 --> 00:17:23.890
where the variants do not
hold. And that has probably

323
00:17:23.890 --> 00:17:27.490
been one of the largest
scientific contributions that we've done

324
00:17:27.560 --> 00:17:31.240
in the spectrum research project
to try to figure out

325
00:17:31.240 --> 00:17:35.200
and wrestle with when, when
doing variants hold and what

326
00:17:35.200 --> 00:17:37.780
do we do when they,
when they don't hold. So

327
00:17:37.780 --> 00:17:40.330
that other parts of the
program don't rely on them

328
00:17:40.330 --> 00:17:43.600
holding at that point. So
we do, we do allow

329
00:17:43.600 --> 00:17:46.570
in variance, the variants are
checked at the end of

330
00:17:46.570 --> 00:17:50.670
the constructor. And we also,
from the runtime perspective, we

331
00:17:50.670 --> 00:17:53.610
only check them at the
end of of exposed statements.

332
00:17:53.880 --> 00:17:57.840
So we have an exposed
statement, inspect sharp, which, which

333
00:17:57.840 --> 00:18:01.380
is like a block of
code. It looks a bit

334
00:18:01.380 --> 00:18:04.380
like a lock statement in
concurrent code. And it says

335
00:18:04.380 --> 00:18:08.070
that within the exposed statement,
you're allowed to modify the

336
00:18:08.070 --> 00:18:11.100
variables. The invariant might not
hold throughout that, but at

337
00:18:11.100 --> 00:18:12.810
the end of the exposed
block, we check that the

338
00:18:12.810 --> 00:18:16.740
variant holes again, interesting. So
statically in the static verifier,

339
00:18:16.740 --> 00:18:19.710
we also checked the invariants
at those points. But in

340
00:18:19.710 --> 00:18:22.860
addition, if you modify state
outside in the back of

341
00:18:22.860 --> 00:18:25.770
an exposed block, we check
that that every assignment that

342
00:18:25.770 --> 00:18:29.100
you do outside an explosive
exposed block will indeed maintain

343
00:18:29.100 --> 00:18:31.250
the variance. Okay. So just
to make sure I'm hearing

344
00:18:31.250 --> 00:18:34.010
correctly, the word you're using
is expos exp O S

345
00:18:34.040 --> 00:18:36.440
E that's correct. So for,
for the, for the moment

346
00:18:36.440 --> 00:18:37.880
that I, for the time
that I am in that

347
00:18:37.880 --> 00:18:40.190
block, I am exposed. I
am in States that may

348
00:18:40.190 --> 00:18:43.520
very well be inappropriate, but
I'm calling it out explicitly

349
00:18:43.940 --> 00:18:46.220
and saying that by the
time I leave, I best

350
00:18:46.220 --> 00:18:50.240
to be back in my
appropriate state. That's correct. Interesting.

351
00:18:50.450 --> 00:18:53.120
I really like the, the
words that you you've chosen.

352
00:18:53.190 --> 00:18:55.580
I find that when I'm,
you know, in object oriented

353
00:18:55.580 --> 00:18:58.070
programming, certainly naming is everything.
And if you can name

354
00:18:58.070 --> 00:19:03.500
it appropriately and that name
feels correct, it feels natural

355
00:19:03.500 --> 00:19:07.040
that it will, it will
just allow you to use

356
00:19:07.040 --> 00:19:08.300
it in a comfortable way.
And I see that you've

357
00:19:08.300 --> 00:19:13.730
got assume requires insurers expose.
They're all words of similar

358
00:19:13.730 --> 00:19:15.440
length. And they all feel
that they're kind of from

359
00:19:15.440 --> 00:19:18.050
the same family. And it
seemed like there's a natural

360
00:19:18.620 --> 00:19:23.270
extension to the language. Thank
you, keyboards are important. And

361
00:19:23.690 --> 00:19:26.210
sometimes we wrestle with them
and wish we had better

362
00:19:26.210 --> 00:19:29.490
ones, but the, but that's
our, our part of our

363
00:19:29.510 --> 00:19:32.540
current staff. So fundamental to
what spectrum is trying to

364
00:19:32.540 --> 00:19:36.380
accomplish is this notion of
really encouraging design by contract.

365
00:19:36.410 --> 00:19:39.740
And from my point of
view, the most obvious contract

366
00:19:39.740 --> 00:19:41.990
that we have available to
us in, in C-sharp is

367
00:19:41.990 --> 00:19:44.420
this notion of an interface.
That's a very high level

368
00:19:44.420 --> 00:19:46.550
construct that I can say,
I want you to can

369
00:19:46.880 --> 00:19:50.030
be constrained to this interface,
to inter implement this interface,

370
00:19:50.690 --> 00:19:54.380
but that's just a series
of methods that take certain,

371
00:19:55.760 --> 00:19:59.090
certain parameters of certain types.
Can I apply these kinds

372
00:19:59.090 --> 00:20:01.280
of spec sharp constructs to
an interface to say, not

373
00:20:01.280 --> 00:20:03.230
only do I want you
to look like this, but

374
00:20:03.230 --> 00:20:06.830
I wish that you behave
like this. Exactly. Spec sharp

375
00:20:06.830 --> 00:20:09.740
allows all of the same
constructs. We've been talking about

376
00:20:09.740 --> 00:20:13.370
it, the method level on
interface methods as well. And

377
00:20:13.370 --> 00:20:18.590
it's precisely to give interfaces
behavioral descriptions that then every

378
00:20:18.590 --> 00:20:22.580
implementation is obligated to live
up to. And it allows

379
00:20:23.240 --> 00:20:26.480
the promise of, of, of
component programming where the only

380
00:20:26.480 --> 00:20:29.420
thing you know about a
component is its interface to

381
00:20:29.960 --> 00:20:32.780
have a semantic basis, as
well as just knowing that

382
00:20:32.780 --> 00:20:36.470
you've conformed to the method
signatures. Yes, in retrospect, looking

383
00:20:36.470 --> 00:20:39.110
at an interface and saying
that syntactically, this is anywhere

384
00:20:39.110 --> 00:20:41.600
near appropriate of what I
need to get my job

385
00:20:41.630 --> 00:20:44.990
done. When the semantics are
really transmitted out of band,

386
00:20:45.350 --> 00:20:47.410
where out of band might
be a word document, which

387
00:20:47.410 --> 00:20:50.770
is a completely inappropriate way
for, to pass semantics for

388
00:20:50.770 --> 00:20:53.410
an interface. But you're saying
I can actually impose this

389
00:20:53.410 --> 00:20:55.960
on things that have yet
to be written. That seems

390
00:20:55.960 --> 00:20:58.270
to kind of miraculous. That
seems kind of creepy almost.

391
00:20:58.270 --> 00:21:01.570
You're saying that someone can
come in totally later and

392
00:21:01.570 --> 00:21:05.140
implement that interface. And you're
going to walk up back

393
00:21:05.140 --> 00:21:08.260
up to the interface and
see, and con and confirm

394
00:21:08.260 --> 00:21:11.200
that I am conforming to
the, the requirements to the

395
00:21:11.200 --> 00:21:14.940
specification. As long as that
eventual implementation is written in

396
00:21:14.940 --> 00:21:18.060
inspect sharp, then yes, the
spectrum compiler will make sure

397
00:21:18.060 --> 00:21:21.180
that that implementation conforms to
all of the requirements that

398
00:21:21.630 --> 00:21:28.080
the interface specifications spell out.
In addition, because spectrum is

399
00:21:28.080 --> 00:21:31.050
an object oriented language, the
same holds true for subtypes.

400
00:21:31.230 --> 00:21:36.120
And that's crucial in object
oriented programming, because if you're

401
00:21:36.360 --> 00:21:38.760
the static type of a
parameter is a type T

402
00:21:39.120 --> 00:21:42.210
when you receive that type
at runtime, it could be

403
00:21:42.210 --> 00:21:44.640
a subtype of T it
doesn't necessarily have to be

404
00:21:44.640 --> 00:21:48.150
a tea itself. And so
contracts in virtual methods are

405
00:21:48.150 --> 00:21:52.020
also binding upon all overrides
of those methods. And that's

406
00:21:52.020 --> 00:21:54.630
the way you can guarantee
the robustness of a system

407
00:21:54.630 --> 00:21:59.070
that you write the system
today, and it's robust against

408
00:21:59.070 --> 00:22:03.330
future evolution, or at least
more robust against future evolution

409
00:22:03.330 --> 00:22:07.710
because you know, that whatever
the eventual subtype is, it

410
00:22:07.710 --> 00:22:09.960
will conform to the contract
that you know about the

411
00:22:09.960 --> 00:22:13.350
static. And this applies to
even abstract base classes, which

412
00:22:13.350 --> 00:22:17.430
is another kind of an
interface. Yes, exactly the same

413
00:22:17.430 --> 00:22:20.850
exact detailed supply to abstract
based classes. So, so what

414
00:22:20.850 --> 00:22:22.920
about exceptions now? I'm starting
to feel like there's something

415
00:22:22.920 --> 00:22:25.620
like checked exceptions in Java,
which people have always asked

416
00:22:25.620 --> 00:22:27.570
for when it comes to
C-sharp, they're saying, where am

417
00:22:27.570 --> 00:22:30.150
I checked exceptions? Maybe tell
us what the checked exceptions

418
00:22:30.150 --> 00:22:31.830
are for our listeners who
may not be familiar with

419
00:22:31.830 --> 00:22:35.940
that technology Check. The exceptions
are ones that the, that

420
00:22:35.940 --> 00:22:38.760
the compiler will look at
how they can flow in

421
00:22:38.760 --> 00:22:41.340
the, in the program so
that you can, you can

422
00:22:41.340 --> 00:22:43.440
make sure that there is
some handler for, for the

423
00:22:43.440 --> 00:22:45.150
check, the exception. So it's
an actually a way of

424
00:22:45.150 --> 00:22:48.900
enforcing. I'm going to call
method Fu and internally somewhere,

425
00:22:48.900 --> 00:22:51.690
it could throw an argument
in all exception, but what

426
00:22:51.690 --> 00:22:53.550
currently in C-sharp, there's no
way for me to know

427
00:22:53.550 --> 00:22:56.910
that. And there's also no
way to force the color

428
00:22:56.940 --> 00:23:00.750
of Fu to have a
try catch block. That's exactly

429
00:23:00.750 --> 00:23:02.700
right. So the, if you
want to, if you want

430
00:23:02.700 --> 00:23:05.610
to track that in the
compiler and force the caller

431
00:23:05.610 --> 00:23:08.820
to either catch it or
admit itself that it might

432
00:23:08.880 --> 00:23:11.760
let one of those exceptions
through, then you would use

433
00:23:11.760 --> 00:23:17.190
a checked exception. Now check
the exceptions. Are there certain

434
00:23:17.190 --> 00:23:19.950
kinds of conditions in your
program where you really would

435
00:23:19.950 --> 00:23:22.500
like to use the check?
The exception, an example might

436
00:23:22.500 --> 00:23:26.970
be a socket closed exception
where the programmer really needs

437
00:23:26.970 --> 00:23:29.370
to be aware of the
possibility that the, that the

438
00:23:29.370 --> 00:23:32.550
socket might close, but you
don't want to check it

439
00:23:32.550 --> 00:23:34.860
on, on every call. That
is, you don't want a

440
00:23:34.860 --> 00:23:38.340
return code from every call
and have to check that

441
00:23:38.340 --> 00:23:41.010
on the integration Argument against
checked exceptions, that suddenly it

442
00:23:41.010 --> 00:23:45.150
litters my system with try
catch blocks or explicit calling

443
00:23:45.170 --> 00:23:46.730
out that I don't care
that that's going to throw

444
00:23:46.730 --> 00:23:49.240
an exception. That's right. And
in, in, in the cases

445
00:23:49.240 --> 00:23:51.880
where checked exceptions are appropriate,
you would have a block

446
00:23:51.880 --> 00:23:55.030
of code that, that operates
on on some object or

447
00:23:55.030 --> 00:23:57.610
objects. And then you would
have a catch block at

448
00:23:57.610 --> 00:24:00.040
the end. And in those
cases, the programmer really would

449
00:24:00.040 --> 00:24:03.790
like to know that that
the exception is not missed.

450
00:24:03.850 --> 00:24:06.760
And that's what checked exceptions
give you. Now, if you

451
00:24:06.790 --> 00:24:10.270
decide then to, to let
such an exception rip through,

452
00:24:10.300 --> 00:24:12.070
then, then you have to
admit to that. And then

453
00:24:12.070 --> 00:24:14.380
it's the, the, the next
caller in line that, that

454
00:24:14.380 --> 00:24:16.870
gets to, to deal with
it. But this is different

455
00:24:16.870 --> 00:24:20.200
from the example you gave
a minute ago was the,

456
00:24:20.200 --> 00:24:26.200
the NOL exception, null pointer
exception, which we consider to

457
00:24:26.410 --> 00:24:29.500
not be one of these
checked exceptions, because it's not

458
00:24:29.500 --> 00:24:32.590
something that, that a caller
can reasonably do something with

459
00:24:32.620 --> 00:24:34.990
that is if you get
one of those exceptions or,

460
00:24:36.070 --> 00:24:39.340
or an auto memory exception,
sometimes you can, you can

461
00:24:39.340 --> 00:24:43.390
recover from that or, or
a CLR internal error exception,

462
00:24:43.390 --> 00:24:46.690
or something like that. There's
those things could happen. And

463
00:24:46.750 --> 00:24:50.230
if, if they occur, there's
something disastrous that has happened

464
00:24:50.230 --> 00:24:52.870
in your program, and you
don't really expect to catch

465
00:24:52.870 --> 00:24:55.240
them except maybe at the,
at the backstop and in

466
00:24:55.240 --> 00:24:58.090
your main program. So Different
classes of exceptions, those ones

467
00:24:58.090 --> 00:25:00.250
that I can do something
about, and there's ones that

468
00:25:00.250 --> 00:25:02.650
are truly exceptional, which it
would be a really inappropriate

469
00:25:02.650 --> 00:25:05.230
to call out. Correct. And
that's why we give you

470
00:25:05.230 --> 00:25:09.430
the, the possibility to make,
check the exceptions for when

471
00:25:09.430 --> 00:25:11.680
you want those and, and
leave. The other ones is

472
00:25:11.680 --> 00:25:15.700
unchecked ones. And the, and
we, we can then do

473
00:25:15.700 --> 00:25:17.590
more tracking in the compiler
of the, of the checked

474
00:25:17.590 --> 00:25:20.830
ones. So if I had
a giant library, maybe even

475
00:25:20.830 --> 00:25:23.920
a base class library, I
like the BCL full of

476
00:25:23.920 --> 00:25:26.260
thousands and thousands and thousands
of methods that I would

477
00:25:26.260 --> 00:25:28.720
want to be able to
call now that I've got

478
00:25:28.720 --> 00:25:31.240
the suspect sharp mindset, I
would really say, Oh, well,

479
00:25:31.270 --> 00:25:34.600
gosh, I hope that the
base class library, that.net framework

480
00:25:34.600 --> 00:25:37.750
system.star was, you know, instrumented
with all of this good

481
00:25:37.750 --> 00:25:40.450
information, but that's an example
of a huge chunk of

482
00:25:40.450 --> 00:25:43.660
C sharp code, not spec
sharp code. And certainly, I

483
00:25:43.660 --> 00:25:45.160
don't think that they're going
to convert that to spec

484
00:25:45.160 --> 00:25:47.440
sharp anytime soon. How do
I get the benefits of

485
00:25:47.440 --> 00:25:51.490
spec sharp? When I don't
have a spectrum library, We've

486
00:25:52.030 --> 00:25:54.310
created a set of what
we call out of band

487
00:25:54.310 --> 00:25:59.020
contracts for the entire base
class library. Spec sharp compiler

488
00:25:59.020 --> 00:26:02.560
can be run in a
special mode where it will

489
00:26:02.560 --> 00:26:05.110
compile a file that contains
no code, but only the

490
00:26:05.110 --> 00:26:10.630
contracts and marks the resulting
assembly, such that the rest

491
00:26:10.630 --> 00:26:14.710
of the spec sharp tools
look glued together. The original

492
00:26:14.710 --> 00:26:17.710
runtime assembly, such as ms.
Core lib and the out

493
00:26:17.710 --> 00:26:19.930
of band contract for ms.
Coral hub. So that it

494
00:26:19.930 --> 00:26:23.740
looks inside the tool as
if the contracts had been

495
00:26:23.740 --> 00:26:27.280
there from the beginning. Now,
in one sense, that's a

496
00:26:27.280 --> 00:26:30.730
lie because the contracts weren't
there. And so we created

497
00:26:30.730 --> 00:26:33.670
these contracts. We think they're
reasonable. We think they're accurate,

498
00:26:33.760 --> 00:26:38.020
but it would be so
much better if the actual

499
00:26:38.020 --> 00:26:41.320
library itself came with its
own contracts that were guaranteed

500
00:26:41.590 --> 00:26:43.620
by having been written in
the code in the place.

501
00:26:43.650 --> 00:26:47.310
And we are, you know,
have been exploring for several

502
00:26:47.310 --> 00:26:50.610
years now with different product
groups in Microsoft to try

503
00:26:50.610 --> 00:26:54.240
to, to make progress on
that front and be able

504
00:26:54.240 --> 00:26:59.460
to provide a mechanism where
the library providers will provide

505
00:26:59.460 --> 00:27:02.210
their own form of the
library of the contracts. Interesting.

506
00:27:02.210 --> 00:27:05.720
We have out of band
documentation, we have PDB files,

507
00:27:06.020 --> 00:27:08.570
and then we could potentially
have these contract files. Certainly

508
00:27:08.570 --> 00:27:10.040
it would be ideal if
this were built into the

509
00:27:10.040 --> 00:27:13.520
language. So it seems to
me like, I would want

510
00:27:13.520 --> 00:27:16.900
to press start pressuring Anders,
the inventor of C-sharp, and

511
00:27:17.420 --> 00:27:19.400
maybe the listeners would want
to know what's the best

512
00:27:19.400 --> 00:27:22.760
way they can get C-sharp
spec sharp built in. You

513
00:27:22.760 --> 00:27:25.310
guys are Microsoft research, right?
You're not a product group.

514
00:27:25.700 --> 00:27:29.180
You're doing this to push
the concept forward, but I

515
00:27:29.180 --> 00:27:31.100
assume you've met with Anders
and you've told them about

516
00:27:31.100 --> 00:27:33.680
this several times, but he's
got a lot on his

517
00:27:33.680 --> 00:27:35.900
plate. How can the listeners
get involved? How can we

518
00:27:35.900 --> 00:27:39.140
get people to, to force
Anders, to listen at this

519
00:27:39.140 --> 00:27:42.080
great idea and get this
built into C sharp? Well,

520
00:27:42.080 --> 00:27:44.810
every time we've talked to
unders he's been quite supportive

521
00:27:44.840 --> 00:27:48.920
of both the goals of
the spectra project and the

522
00:27:48.920 --> 00:27:51.440
things we've been able to
accomplish the tools we've produced.

523
00:27:53.060 --> 00:27:57.290
He is indicated that the
important thing is to know

524
00:27:57.290 --> 00:27:59.960
that there's users out there
that want it, and that

525
00:28:01.220 --> 00:28:03.800
can take advantage of it.
And so I would say

526
00:28:04.310 --> 00:28:07.190
for any listener, who's interested,
they should download spec sharp,

527
00:28:07.220 --> 00:28:10.670
which is publicly available for
free from the Microsoft research

528
00:28:11.270 --> 00:28:15.650
website and, you know, use
it and see if it's

529
00:28:15.650 --> 00:28:19.460
useful for their code and
then make noise about it

530
00:28:19.460 --> 00:28:22.340
and makes either send email
or post, you know, on

531
00:28:22.340 --> 00:28:26.510
blogs or Yeah. Presenters or
groups. Exactly. Whatever it takes.

532
00:28:26.510 --> 00:28:29.360
Absolutely. So in conclusion here,
I want to make sure

533
00:28:29.360 --> 00:28:32.030
I understand the scope of
this because it's not just

534
00:28:32.480 --> 00:28:36.140
runtime type checking. There's this
fundamental notion of being able

535
00:28:36.140 --> 00:28:39.920
to statically prove that this
is, is correct. When I

536
00:28:39.920 --> 00:28:42.140
saw your demo earlier, I
got, I got to see

537
00:28:42.140 --> 00:28:45.710
a little green squiggly and
I had, we've seen squiggles

538
00:28:45.710 --> 00:28:49.040
before in, in visual studio.
Red squiggly is that I

539
00:28:49.250 --> 00:28:52.340
usually can compare it to
being like spelling errors is

540
00:28:52.340 --> 00:28:54.680
your syntactical issues. And I
had made the comment to

541
00:28:54.680 --> 00:28:57.530
you that the green squiggly
is, felt like a grammar

542
00:28:57.530 --> 00:28:59.990
issue, but you had made
you use it. That was

543
00:29:00.020 --> 00:29:04.430
wrongheaded because you can extend
this grammar Right. In, in

544
00:29:04.430 --> 00:29:07.160
the wonderful squiggly that we're
used to in, in Microsoft

545
00:29:07.160 --> 00:29:09.350
word, both the, the red
one for spelling mistakes and

546
00:29:09.350 --> 00:29:13.100
the green one for, for
gram grammatical errors D are

547
00:29:13.250 --> 00:29:16.460
quite similar to, to what
we provide in that the

548
00:29:16.760 --> 00:29:18.830
wheel has come up at
design time. That is, as

549
00:29:18.830 --> 00:29:22.250
you're sitting there typing your
program and the, the squeak

550
00:29:22.250 --> 00:29:24.740
least appear and go away.
And, and as you go

551
00:29:24.740 --> 00:29:28.310
along, the difference is that
that with our squeak lease,

552
00:29:28.310 --> 00:29:30.890
when they, when they appear,
there are ways that you

553
00:29:30.890 --> 00:29:33.170
can suppress them. That is,
they warn you about some

554
00:29:33.170 --> 00:29:36.260
condition in, in Microsoft word.
If you've made a grammar

555
00:29:36.500 --> 00:29:39.530
mistake, you can fix it.
But in some cases, the

556
00:29:39.530 --> 00:29:42.250
grammar checker is just not
clever to do what you,

557
00:29:42.310 --> 00:29:44.080
what you wanted to do.
And then, then you can

558
00:29:44.080 --> 00:29:46.810
just turn off the, the
check, but in spectrum, you

559
00:29:46.810 --> 00:29:48.820
can do something better, which
is that, that you can

560
00:29:48.820 --> 00:29:53.050
explain to him why this
is correct. For example, if

561
00:29:53.050 --> 00:29:56.770
you, if you use one
of your parameters as an,

562
00:29:56.830 --> 00:29:59.590
as an array index, perhaps
inside your inside of your

563
00:29:59.590 --> 00:30:03.370
method, and you get to
complain about it, then maybe

564
00:30:03.370 --> 00:30:05.650
the way to do it,
to, to tell the checker

565
00:30:05.650 --> 00:30:07.480
that you're still doing. The
right thing is to add

566
00:30:07.480 --> 00:30:09.730
a precondition to your method
that says, well, this is

567
00:30:09.730 --> 00:30:12.580
not my responsibility. It's the
responsibility of the caller to

568
00:30:12.580 --> 00:30:15.280
give me a good value.
And then the, the green

569
00:30:15.280 --> 00:30:18.010
squiggly will go away. Your
code remains as it is,

570
00:30:18.010 --> 00:30:23.070
but now you've made that
contract explicit. Yeah. Interesting, fantastic.

571
00:30:23.070 --> 00:30:25.260
So people can go and
download spec sharp. Now they

572
00:30:25.260 --> 00:30:28.110
can play with this. Now
they can instrument their code.

573
00:30:28.530 --> 00:30:30.480
You had mentioned that there
were two different modes for

574
00:30:30.480 --> 00:30:32.460
this. There was a C
sharp mode and a spec

575
00:30:32.460 --> 00:30:36.480
sharp mode, Right? The, the
standard mode that, that we

576
00:30:36.480 --> 00:30:39.900
use in inside, for example,
our program verifier itself, which

577
00:30:39.900 --> 00:30:43.500
is written in spec sharp,
it's maybe about 65,000 lines

578
00:30:43.530 --> 00:30:46.350
of spec sharp right now
is to use the, the

579
00:30:46.350 --> 00:30:50.850
spec sharp mode in visual
studio. Unfortunately, that's that mode

580
00:30:51.600 --> 00:30:54.240
has some drawbacks because we
have not put in all

581
00:30:54.240 --> 00:30:56.850
of the whizzbang functionality that
you get in the, in

582
00:30:56.850 --> 00:31:04.500
the seizure visual C-sharp mode
for, in, in visual studio.

583
00:31:04.560 --> 00:31:08.550
Okay. That means that, that
you, you get our additional

584
00:31:08.890 --> 00:31:12.450
design time support in, in
that mode, but for programmers

585
00:31:12.450 --> 00:31:14.970
who, who either would like
to, to keep all of

586
00:31:14.970 --> 00:31:19.830
the refactoring and all of
the code formatting and features

587
00:31:19.860 --> 00:31:22.080
that are really nice to
use in C sharp, they

588
00:31:22.080 --> 00:31:25.920
can use, they can download
spectrum. Then in the properties

589
00:31:25.920 --> 00:31:29.520
tab, properties, pain of the,
of the project, we add

590
00:31:29.520 --> 00:31:32.040
a new contracts tab, and
one can turn on contracts.

591
00:31:32.400 --> 00:31:35.580
What happens then is when
you then compile your C

592
00:31:35.580 --> 00:31:38.730
sharp program, you first run
the C sharp compiler, and

593
00:31:38.730 --> 00:31:42.510
then immediately afterwards, we run
the spectrum, compiler the spec

594
00:31:42.510 --> 00:31:46.620
sharp compiler then would produce
the same result as the

595
00:31:46.620 --> 00:31:49.770
C sharp compiler. But, but
the spectrum of compiler is

596
00:31:49.770 --> 00:31:53.160
also going to peek into
specially marked comments. So what

597
00:31:53.160 --> 00:31:55.110
you can do with a
precondition is if you put

598
00:31:55.110 --> 00:31:57.240
it into a comment that
begins with a carrot sign,

599
00:31:57.540 --> 00:31:59.970
then it that's just a
common to the C sharp

600
00:31:59.970 --> 00:32:02.520
compiler, but the spectrum of
compiler will, we'll read it

601
00:32:02.520 --> 00:32:05.340
and understand it and generate
code based on that. Now

602
00:32:05.340 --> 00:32:07.650
I'm realizing that some listeners
who are a little more

603
00:32:07.890 --> 00:32:09.900
familiar with these kinds of
concepts may think that this

604
00:32:09.900 --> 00:32:12.030
is a lot, like some
of the aspect oriented compilers

605
00:32:12.030 --> 00:32:14.550
that have come out, prosy
sharp, like X, C sharp,

606
00:32:14.550 --> 00:32:19.200
where you could decorate C-sharp
with a, an attribute and

607
00:32:19.200 --> 00:32:21.780
say that I wish to
insert tracing pre and post

608
00:32:21.780 --> 00:32:24.030
conditions. How is this different
from those kinds of aspect

609
00:32:24.030 --> 00:32:28.620
oriented things? In many ways,
it's quite similar. A pre

610
00:32:28.620 --> 00:32:30.810
and post conditions of course
can be thought of as

611
00:32:30.810 --> 00:32:35.310
aspects because they slice into
a particular well-defined joint point.

612
00:32:36.030 --> 00:32:40.670
The difference with spec sharp
is that the Checking we

613
00:32:40.670 --> 00:32:44.060
do is something that goes
the static checking we do

614
00:32:44.060 --> 00:32:46.880
is something that goes far
beyond what an aspect oriented

615
00:32:46.880 --> 00:32:50.300
tool would be capable of.
And aspect oriented tool is

616
00:32:50.300 --> 00:32:54.890
capable of injecting code into
the runtime for dynamic behavior.

617
00:32:55.040 --> 00:33:01.730
But our static verification relies
upon a particular discipline of

618
00:33:01.730 --> 00:33:05.300
how you write your programs
and use your fields in

619
00:33:05.300 --> 00:33:10.580
your objects to guarantee their
correctness and robustness against future

620
00:33:10.580 --> 00:33:15.230
code evolution. And so the,
the surface syntax in that

621
00:33:15.230 --> 00:33:17.270
sense would be the same.
It's like putting an attribute

622
00:33:17.270 --> 00:33:20.150
on a method. It's something
that the C-sharp compiler ignores,

623
00:33:20.570 --> 00:33:24.200
but the value then is
in the tools that we

624
00:33:24.200 --> 00:33:26.540
can apply to that code
afterwards. And I say, okay,

625
00:33:26.540 --> 00:33:29.360
so I could see myself
using an aspect oriented type

626
00:33:29.360 --> 00:33:32.060
of a system in conjunction,
respect sharp, but other than

627
00:33:32.060 --> 00:33:35.330
that initial superficial similarity in
that there are pre and

628
00:33:35.330 --> 00:33:37.070
post conditions. And these are
like, as you said, the

629
00:33:37.070 --> 00:33:40.100
joint points, that's about where
the similarity ends. And it's

630
00:33:40.100 --> 00:33:43.860
really about static verification of
the correctness of, of, of

631
00:33:43.880 --> 00:33:46.250
your application. So presumably then
I should be able to

632
00:33:46.250 --> 00:33:49.910
access that information and then
generate documentation from it. Yes.

633
00:33:49.910 --> 00:33:52.730
The, the information is there.
And one could extract it

634
00:33:52.730 --> 00:33:56.450
into, into a document that
reads in English or with

635
00:33:56.450 --> 00:33:59.750
the, with a formula tube
to describe what the documentation

636
00:33:59.780 --> 00:34:02.240
ought to say. So was
almost like spec sharp enforces

637
00:34:02.240 --> 00:34:06.530
my comments. Yes. The it's
a way to formalize your

638
00:34:06.530 --> 00:34:08.840
comments, that he's put them
into something that is going

639
00:34:08.840 --> 00:34:11.330
to be read by the
machine. And if you won't

640
00:34:11.330 --> 00:34:13.970
do that, also checked by
machine by, by the machine

641
00:34:13.970 --> 00:34:15.820
to make sure that they're
up to date with the,

642
00:34:15.820 --> 00:34:18.110
with the current program text.
Very cool. I think that

643
00:34:18.110 --> 00:34:21.290
anything that allows the programmer
to more explicitly and formally

644
00:34:21.290 --> 00:34:25.190
express their intent, such that
it is unambiguous and in

645
00:34:25.190 --> 00:34:27.650
a machine readable format is
definitely a really good thing.

646
00:34:27.860 --> 00:34:31.040
That's right. It's expressing intent
is all about what contracts

647
00:34:31.040 --> 00:34:33.680
are about. Cool. Well, thank
you very much. Rusden and

648
00:34:33.680 --> 00:34:36.770
Mike, from the Microsoft research
team, and again, the product

649
00:34:36.770 --> 00:34:38.840
is spec sharp, and you
can download that. We'll have

650
00:34:38.840 --> 00:34:41.630
links up on the show
site. Thank you very much.

651
00:34:42.590 --> 00:34:45.080
Thank you. And this has
been another episode of Hanselminutes

652
00:34:45.140 --> 00:34:46.370
and we'll see you again
next week.


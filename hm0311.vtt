WEBVTT FILE

1
00:00:12.090 --> 00:00:17.400
From hanselminutes.com. It's Hanselman. It's
all weekly discussion with web

2
00:00:17.400 --> 00:00:22.200
developer and technologists. Scott Hanselman.
This is Lawrence Ryan announcing show

3
00:00:22.200 --> 00:00:28.350
number three 11 recorded live
Thursday, March 22nd, 2012. Support for Hansel

4
00:00:28.350 --> 00:00:31.440
minutes is provided by Tellerik
offering the best and developer

5
00:00:31.440 --> 00:00:40.170
tools and support online@wwwdottelerik.com. In
this episode, Scott talks with

6
00:00:40.200 --> 00:00:43.560
Richard minor, rich and Phillip
Turtleford about using F sharp

7
00:00:43.590 --> 00:00:49.530
and.net projects. Hi, this is
Scott Hanselman. This is another

8
00:00:49.530 --> 00:00:53.040
episode of Hansel minutes today.
We've got two people on

9
00:00:53.040 --> 00:00:55.530
the phone. We've got Richard
Meinrad. She's calling in from

10
00:00:55.530 --> 00:00:58.320
New York and we've got Phillip
trial for calling in from

11
00:00:58.530 --> 00:01:03.120
London. How's it going, gentlemen?
How are you a little

12
00:01:03.120 --> 00:01:05.490
bit low today? I've lost
an octave, I think, but

13
00:01:05.670 --> 00:01:08.370
I will survive. It's I've
got the cold. Everyone's got

14
00:01:08.370 --> 00:01:12.630
it right now. So you
guys are both user group

15
00:01:12.630 --> 00:01:16.140
leads of, of F sharp
user groups, and you're doing

16
00:01:16.140 --> 00:01:19.200
F sharp in your, in
your everyday life. You're thinking

17
00:01:19.200 --> 00:01:22.920
about F sharp. I know
Richard, you're an MVP and

18
00:01:22.920 --> 00:01:24.690
Philip, you do games and
you can learn in business

19
00:01:24.690 --> 00:01:29.070
applications. You do a lot
of opensource. I, I still

20
00:01:29.070 --> 00:01:31.620
haven't quite gotten my brain
around why I should care

21
00:01:31.680 --> 00:01:37.490
about, about F sharp. I
mean, Richard, is this, is

22
00:01:37.490 --> 00:01:39.960
this just a researcher's language?
I mean, how did F

23
00:01:39.960 --> 00:01:42.390
sharp come up so fast
and really as a C

24
00:01:42.390 --> 00:01:45.350
sharp developer? Why should I
care? Well, there's a lot

25
00:01:45.350 --> 00:01:48.290
of good reasons to use
F sharp, but I would

26
00:01:48.290 --> 00:01:52.070
say the best reason of
all is maintenance. Because when

27
00:01:52.070 --> 00:01:55.580
you write your code with
a sharp, it really becomes

28
00:01:55.580 --> 00:01:59.720
a much, it provides a
much safer environment in code

29
00:01:59.720 --> 00:02:01.580
because of human ability and
the way the types fit

30
00:02:01.580 --> 00:02:06.410
together. This really means that
one developer, right? I work

31
00:02:06.440 --> 00:02:09.920
primarily by myself and I
can build like a really

32
00:02:09.920 --> 00:02:12.860
big app really fast because
it's so terse. And then

33
00:02:12.890 --> 00:02:17.480
the maintenance is very low
because changes don't necessarily ripple

34
00:02:17.480 --> 00:02:19.790
through the system the same
way they do. And then

35
00:02:19.790 --> 00:02:23.840
I'll be starting to language.
And also the, the type

36
00:02:23.840 --> 00:02:29.300
system is a form of
protection against bugs. Phillip Richard

37
00:02:29.300 --> 00:02:32.240
said immutability. And he, he,
he said it like, it

38
00:02:32.240 --> 00:02:35.390
was a very obvious thing.
What does that mean for

39
00:02:35.390 --> 00:02:37.370
people who may not necessarily
be familiar with that, that

40
00:02:37.400 --> 00:02:39.770
why that is such a
fundamental aspect of F sharp

41
00:02:39.770 --> 00:02:43.100
and why it's such a
useful thing? Well, it means

42
00:02:43.100 --> 00:02:48.560
that instead of changing something
directly, like going and injecting,

43
00:02:48.560 --> 00:02:50.900
coming into the first element
of our array, you might

44
00:02:50.900 --> 00:02:54.560
return something new. Now that
sounds like it might be

45
00:02:54.860 --> 00:02:57.830
really inefficient, but it's not
because of there's fancy data

46
00:02:57.830 --> 00:03:00.310
structures. You don't need to
worry about the hood and

47
00:03:00.310 --> 00:03:06.120
handle most of that. It's
really quite nice. So Phillip,

48
00:03:06.150 --> 00:03:11.460
in, in London, so he's
saying that rather than changing

49
00:03:11.460 --> 00:03:14.250
things and changing the state
of something, you're always returning

50
00:03:14.250 --> 00:03:20.160
something, something new. Yeah. And,
and I've shown it's not

51
00:03:20.160 --> 00:03:24.030
purely functional language, so you
can, I've a COVID mutual.

52
00:03:24.030 --> 00:03:28.530
So not change, create a
new instance, or you can

53
00:03:28.530 --> 00:03:34.590
mutate if performance is, is
what you're after more often

54
00:03:34.590 --> 00:03:39.150
than not for body 80
20 rule, you know, you

55
00:03:39.150 --> 00:03:43.110
know, always in a high
performance area. And you're looking

56
00:03:43.110 --> 00:03:49.830
for correctness that said, I
mean, 12 objects on a

57
00:03:49.830 --> 00:03:54.750
garbage collects environment on that
sheet. I expensive the gobs

58
00:03:54.750 --> 00:03:58.290
collect for the likes tracing
and collecting lots of small

59
00:03:58.290 --> 00:04:02.640
objects. So you get that
correctness and with very little

60
00:04:02.640 --> 00:04:05.790
cost, Phillip doesn't that mean
that I have to fundamentally

61
00:04:05.790 --> 00:04:08.940
change the way I think
about solving a problem that

62
00:04:08.940 --> 00:04:11.700
if I try to go
and simply translate how I

63
00:04:11.700 --> 00:04:14.430
write C-sharp into writing F
sharp, that I won't really

64
00:04:14.430 --> 00:04:16.890
be writing idiomatic F sharp.
I won't be writing F

65
00:04:16.890 --> 00:04:18.420
sharp in the way that
it wants to be written.

66
00:04:19.710 --> 00:04:22.620
Absolutely. I think you're right
though, if it is a

67
00:04:22.650 --> 00:04:26.760
change of the way you
thinking, so you can start

68
00:04:26.790 --> 00:04:31.890
out with an imperative view
with falling Smith, Haitian and

69
00:04:32.430 --> 00:04:36.900
AF shell, but it's more
naturally a functional language. The

70
00:04:37.770 --> 00:04:40.500
types are a mutual by
default. So if you want

71
00:04:40.500 --> 00:04:44.670
to Mark something as being
changeable, you actually science measle.

72
00:04:46.680 --> 00:04:52.050
So you, you want to
move towards a more transformational

73
00:04:52.710 --> 00:04:57.540
mindset. So instead of thinking
about mutating and doing things,

74
00:04:57.570 --> 00:05:00.390
there's a recipe. You think
how I want to go

75
00:05:00.390 --> 00:05:04.590
from high to be, and
how do I, how do

76
00:05:04.590 --> 00:05:10.990
I transform from those two
things? Now that sounds that

77
00:05:10.990 --> 00:05:15.000
that is quite a bit
of a mind set shift,

78
00:05:15.060 --> 00:05:17.730
but in this world where
we're trying to deal with

79
00:05:17.760 --> 00:05:22.470
concurrency and multiple processes, if
we look at problems from

80
00:05:22.470 --> 00:05:28.120
a transformational point of view
where we're not mutating small

81
00:05:28.430 --> 00:05:31.470
state, then we have that
safety and we can actually

82
00:05:31.470 --> 00:05:38.610
run all programs across multi-core
in parallel or concurrently and

83
00:05:38.910 --> 00:05:41.790
things don't go wrong. So
that's going to be actually

84
00:05:42.570 --> 00:05:46.980
that initial thought will cost
you a lot less for

85
00:05:47.100 --> 00:05:51.900
you, and a lot less
problems in, in the multicolor

86
00:05:51.900 --> 00:05:54.740
environment. I just want to
mention that when I learned

87
00:05:54.750 --> 00:05:56.610
at sharp, I had been
at CSR program or for

88
00:05:56.610 --> 00:05:59.450
years, and I had never
done a functional programming language

89
00:05:59.450 --> 00:06:01.670
outside of college before. So
I didn't really know what

90
00:06:01.670 --> 00:06:05.390
I was doing, but it
really is gonna be treated

91
00:06:05.420 --> 00:06:09.170
sort of like a more
Python version of a C-sharp.

92
00:06:09.260 --> 00:06:11.840
And then you can build
your way up and learning

93
00:06:11.840 --> 00:06:15.230
the constructs over time. And
that's sharp has its sort

94
00:06:15.230 --> 00:06:18.110
of feature that it's hard
to describe, but it pushes

95
00:06:18.110 --> 00:06:20.270
you in a direction and
the ability and the ability

96
00:06:20.270 --> 00:06:22.580
to just so much more
convenient, but in using it

97
00:06:22.580 --> 00:06:24.800
over a period of time,
you'll get more and more

98
00:06:24.800 --> 00:06:27.590
immutable and you'll learn more
and more about where you

99
00:06:27.590 --> 00:06:32.240
need to do them, you
patient in order to, and

100
00:06:32.890 --> 00:06:35.330
in a way, and in
order to be like her

101
00:06:35.330 --> 00:06:39.020
foreman. So it's not like
you have to learn all

102
00:06:39.020 --> 00:06:41.000
these features out of the
gate and be able to

103
00:06:41.000 --> 00:06:43.550
write this fancy code. It
really can just be like

104
00:06:43.630 --> 00:06:48.640
a purser version of C
sharp at first. So Phillips

105
00:06:48.640 --> 00:06:52.270
said something really interesting there
that if I start doing

106
00:06:52.270 --> 00:06:56.110
my, my, my functions as
kind of mathematical functions in

107
00:06:56.110 --> 00:06:59.260
that something comes in is
transformed and then comes out

108
00:06:59.260 --> 00:07:02.320
change. And I chain them
together like that. That, that

109
00:07:02.320 --> 00:07:05.740
allows me to do things
over multiple processors. What is

110
00:07:05.740 --> 00:07:08.500
it about F sharp that,
that makes that so friendly

111
00:07:08.520 --> 00:07:13.630
that, that idea of, of
immutability enabling things over multiprocessors

112
00:07:13.630 --> 00:07:17.710
does that mean that changing
state itself makes an application

113
00:07:18.010 --> 00:07:21.550
not, not easy to scale
across more than one processor

114
00:07:22.720 --> 00:07:26.770
Saying stay does it doesn't
necessarily stop here, but it

115
00:07:28.090 --> 00:07:32.470
adding an extra level of
complexity. As soon as you

116
00:07:32.470 --> 00:07:35.650
do that, you, you find
yourself potentially adding a log

117
00:07:36.040 --> 00:07:40.750
or some sort of reading
primitive to protect changes happening.

118
00:07:41.260 --> 00:07:43.690
Now, if you creating new
objects each time, you just

119
00:07:43.690 --> 00:07:47.080
don't have to worry about
that. Now that said that

120
00:07:47.560 --> 00:07:52.000
the classic example of from
a performance level is a

121
00:07:52.000 --> 00:07:59.560
dictionary, would a dictionary. The
performance is just ridiculous, higher

122
00:07:59.620 --> 00:08:02.410
on a meta level, a
dictionary, the standard dose, don't

123
00:08:02.410 --> 00:08:07.540
that one compared to creating
a tree each time. So

124
00:08:08.410 --> 00:08:14.710
there are points where you
should be choosing meta type

125
00:08:14.710 --> 00:08:19.390
structures. And with anything, when
you doing a Pullman's critical

126
00:08:19.390 --> 00:08:23.740
code, you should be guided
by timings rather than sort

127
00:08:23.740 --> 00:08:28.630
of pure conjecture and or
denotation you need, you need,

128
00:08:30.340 --> 00:08:34.300
you need some real values
to know that. So what

129
00:08:34.300 --> 00:08:36.010
you're saying is that there's
nothing in F sharp that

130
00:08:36.190 --> 00:08:40.660
makes me like automatically get
magical powers for free, or

131
00:08:40.660 --> 00:08:43.900
at least not magical multiprocessor
powers, but some of the

132
00:08:43.900 --> 00:08:46.360
powers that I'm, that I
might get, like, like Richard

133
00:08:46.360 --> 00:08:49.510
said, they're, they're much easier
to, to maintain and manage

134
00:08:49.510 --> 00:08:51.490
because things are plugged in.
There's a lot of, a

135
00:08:51.490 --> 00:08:54.760
lot less things changing without
me explicitly knowing about it.

136
00:08:55.310 --> 00:08:56.880
I mean, a lot of
the, kind of the bugs,

137
00:08:57.270 --> 00:08:59.340
or as my friend likes
to say highs and bugs

138
00:08:59.640 --> 00:09:03.600
that we bump into in,
in C-sharp are something changed.

139
00:09:03.690 --> 00:09:05.880
And I don't know why.
And then we ended up

140
00:09:05.880 --> 00:09:11.070
stepping through and wondering how
that, that this static variable

141
00:09:11.070 --> 00:09:13.230
or this, this thing I
wasn't thinking about, or this

142
00:09:13.230 --> 00:09:16.080
property switched values in the
middle of, in the middle

143
00:09:16.080 --> 00:09:19.290
of my work. Do those
kinds of bugs go away

144
00:09:19.290 --> 00:09:25.220
in an F sharp Phillip?
Yeah, absolutely. So this is

145
00:09:25.790 --> 00:09:29.030
been reported quite widely in
the F sharp community idea.

146
00:09:30.110 --> 00:09:33.230
The language kind of guides
you by default, it's a

147
00:09:33.230 --> 00:09:38.090
musical. So by default, you're
guided into not getting so

148
00:09:38.090 --> 00:09:44.090
many concurrency issues with, with
the immutability. We've also got

149
00:09:44.090 --> 00:09:49.730
the pacing workflows feature, which
we'll be seeing in see

150
00:09:49.730 --> 00:09:54.110
shot falling when that comes
along. It's a basically has

151
00:09:54.770 --> 00:09:58.940
some of the features of
F sharp that, so we've

152
00:09:58.940 --> 00:10:05.750
called it great way of
describing asynchronous flows, asynchronous work,

153
00:10:06.380 --> 00:10:12.980
and yeah, we've been using
async and the mutual objects

154
00:10:13.490 --> 00:10:16.100
on the approaching side been
on for the last few

155
00:10:16.100 --> 00:10:20.810
years. And we've had very
few concurrency issues. Mostly we

156
00:10:20.810 --> 00:10:23.870
just press our five and
it works, which is the

157
00:10:23.870 --> 00:10:28.970
happy place. Really just, just
as an aside, we using

158
00:10:29.960 --> 00:10:33.920
a mixture of C sharp
and F sharp. So typically

159
00:10:33.920 --> 00:10:38.150
we'll use C-sharp for the
UI elements cause we've got

160
00:10:38.150 --> 00:10:43.580
the Gregg tool and around
this AML code behind, and

161
00:10:43.610 --> 00:10:46.730
when we want to do
something that's asynchronous and concurrent

162
00:10:47.090 --> 00:10:50.840
or some business transformations, then
we'll, we'll use F shell.

163
00:10:52.310 --> 00:10:55.280
See that, that gets us
into a really interesting place

164
00:10:55.340 --> 00:10:57.110
that I wanted to talk
about. And maybe Richard, you

165
00:10:57.110 --> 00:11:00.320
could say something about this.
How do I know when

166
00:11:00.530 --> 00:11:03.140
a problem is such a
classic F sharp problem? Cause

167
00:11:03.140 --> 00:11:06.320
I think there's a lot
of C-sharp and VB developers

168
00:11:06.380 --> 00:11:09.440
that are listening, and they'd
like to answer, answer the

169
00:11:09.440 --> 00:11:13.520
question, I've got a problem,
and I'm not sure if

170
00:11:13.520 --> 00:11:15.470
this is something that I
could do in 10 lines

171
00:11:15.470 --> 00:11:17.420
of F sharp, as opposed
to a thousand lines of

172
00:11:17.420 --> 00:11:20.080
C sharp. And when I
go and do it, and

173
00:11:20.080 --> 00:11:23.210
if I do use a
F sharp, could it, is

174
00:11:23.210 --> 00:11:25.220
it okay to have a
hybrid like that? Is it

175
00:11:25.220 --> 00:11:27.950
okay to have an application
that's part one language and

176
00:11:27.950 --> 00:11:32.960
part and other, Well, first
off, I certainly like almost

177
00:11:32.960 --> 00:11:38.000
every production in cooperation with
sharp. It's just because he

178
00:11:38.010 --> 00:11:41.210
sharp has amazing UI tooling.
It's like better than anything

179
00:11:41.570 --> 00:11:44.210
out there pretty much. And
then you can just sort

180
00:11:44.210 --> 00:11:50.780
of integrate seamlessly with now.
It's also really good at,

181
00:11:51.530 --> 00:11:57.640
you know, as Phil said,
business parallel, asynchronous, any kind

182
00:11:57.640 --> 00:12:02.440
of complicated algorithm, or even
like, if you have a

183
00:12:02.530 --> 00:12:04.630
pseudo code for an algorithm,
from a book or something,

184
00:12:04.630 --> 00:12:07.090
and you want to turn
it into regular code, it

185
00:12:07.090 --> 00:12:09.010
actually ends up looking a
lot more like the book

186
00:12:10.000 --> 00:12:12.550
and F sharp most of
the time. So there's a

187
00:12:12.550 --> 00:12:15.640
lot of things about a
sharp. Usually whenever the code

188
00:12:15.640 --> 00:12:18.250
is complicated and can go
wrong badly, that's when you

189
00:12:18.250 --> 00:12:20.830
want to reach for at
sharp, because it has offered

190
00:12:20.830 --> 00:12:25.060
so many protections. That's really,
what's great about it is,

191
00:12:25.360 --> 00:12:30.400
you know, there's this sort
of anecdote by the guy

192
00:12:30.400 --> 00:12:33.010
who makes gpu.net. He said,
you know, the thing with

193
00:12:33.010 --> 00:12:34.450
that sharp is once you
make a part of your

194
00:12:34.450 --> 00:12:36.520
code base, you rarely ever
have to go back and

195
00:12:36.520 --> 00:12:41.440
change it because it's so
composable. And also, so like

196
00:12:41.590 --> 00:12:43.630
there's not a lot of
interacting pieces. You just paste

197
00:12:43.630 --> 00:12:46.210
them together in a way
you can't do without writing

198
00:12:46.300 --> 00:12:49.510
actual complicated code in C
sharp. So it really is

199
00:12:49.690 --> 00:12:52.560
great for solving hard problems.
It's so hard to talk

200
00:12:52.560 --> 00:12:56.190
about a quote unquote foreign
languages on a podcast when

201
00:12:56.190 --> 00:12:58.770
you can't really show someone
that, but I keep hearing

202
00:12:58.770 --> 00:13:01.410
more that more and more
that if you, if you

203
00:13:01.680 --> 00:13:05.160
think that you could potentially
get in trouble and you're

204
00:13:05.160 --> 00:13:06.870
going to be writing to
them, it's a very computationally

205
00:13:06.870 --> 00:13:14.910
intensive, very mathematically focused, very,
very functional financial things, transformations

206
00:13:14.910 --> 00:13:17.220
of matrices and things that
you really look at at

207
00:13:17.220 --> 00:13:19.560
F sharp, because there's so
many things that will keep

208
00:13:19.560 --> 00:13:23.490
you from shooting yourself in
the foot. Phillip, do you,

209
00:13:23.520 --> 00:13:26.850
do you have any particular
idea ideas of, of a

210
00:13:26.850 --> 00:13:29.670
classic problem that you just
couldn't think of using anything

211
00:13:29.670 --> 00:13:35.040
but F sharp four? I
think, you know, everything's possible

212
00:13:35.040 --> 00:13:38.040
in FMLA and really what
it comes down to is

213
00:13:38.040 --> 00:13:42.270
time. Right? So one of
the things I've come from

214
00:13:42.270 --> 00:13:45.450
a C sharp background before
that I did C plus

215
00:13:45.450 --> 00:13:48.390
last night, actually, before that
I wrote video games in

216
00:13:48.390 --> 00:13:53.640
assembler thing for me, starting
from C plus last to

217
00:13:53.640 --> 00:13:57.840
see show was a huge
gain in productivity. And again,

218
00:13:57.840 --> 00:14:00.930
with going from seashell sweatshop,
there just the cloth is

219
00:14:00.930 --> 00:14:03.780
a problems that I can
do perhaps in a few

220
00:14:03.780 --> 00:14:06.960
hours that might take me
a day and C sharp.

221
00:14:06.960 --> 00:14:10.800
And I might, this makes
a difference between getting done

222
00:14:10.800 --> 00:14:14.010
or not Donald being voluble
within the timeframe that I

223
00:14:14.010 --> 00:14:18.870
have. So one of my
favorite examples is let's say

224
00:14:19.100 --> 00:14:23.280
domain modeling. So we have
say, we want to describe

225
00:14:23.760 --> 00:14:28.950
the retail domain. We, we,
I have, I have an

226
00:14:28.950 --> 00:14:33.420
example of this that I
do it's hoax, and we're

227
00:14:33.420 --> 00:14:38.160
able to create a domain
and about 10 lines of

228
00:14:38.160 --> 00:14:42.660
code using the F shop
type system. So in the

229
00:14:42.660 --> 00:14:45.570
face, you can model your
domain in a page and

230
00:14:45.570 --> 00:14:49.890
you can actually see, see
the problems, solve them quickly

231
00:14:50.220 --> 00:14:53.990
and move on to new
and more interesting problems. I

232
00:14:53.990 --> 00:14:57.590
think that that's one of
the key elements me. So

233
00:14:57.950 --> 00:15:02.360
the similar class hierarchy in
C sharp would be spread

234
00:15:02.360 --> 00:15:06.620
across eight or nine files,
and that's introducing quite a

235
00:15:06.620 --> 00:15:10.030
lot of accidental complex. Okay.
Phillips. So let's, let's dig

236
00:15:10.030 --> 00:15:12.730
into that a little bit.
I think we can, we

237
00:15:12.730 --> 00:15:15.280
can, we we're, we're hearing
that F sharp is amazing,

238
00:15:15.280 --> 00:15:17.770
and we're hearing that there
are certain things you could

239
00:15:17.770 --> 00:15:19.000
do, and you just brought
up the issue of like

240
00:15:19.060 --> 00:15:21.130
creating a class hierarchy that
where an F sharp, it

241
00:15:21.130 --> 00:15:24.160
could be very terse. If
I were writing something like

242
00:15:24.160 --> 00:15:28.030
that in C-sharp, where is
all of the verbosity? Where

243
00:15:28.030 --> 00:15:30.970
is all of the mess?
Is it, is it, is

244
00:15:30.970 --> 00:15:35.440
it curly braces? Is it
unnecessary keywords? What is it

245
00:15:35.500 --> 00:15:39.370
that is taking up too
much room too much, too

246
00:15:39.370 --> 00:15:45.310
much intellectual noise. Yeah. I
mean, C sharp is a

247
00:15:45.310 --> 00:15:48.910
massive improvement over C plus
class and had a file,

248
00:15:49.690 --> 00:15:52.530
but it's still a lot
of cheap vacation. So I

249
00:15:52.540 --> 00:15:55.450
have like a comedy phrase,
I who the local government

250
00:15:55.450 --> 00:15:59.890
patent, where you doing things
in triplicate to get things

251
00:15:59.890 --> 00:16:04.480
done. So let's say we
have a person class, and

252
00:16:04.510 --> 00:16:06.400
on that class, we have
a night, even a night.

253
00:16:07.180 --> 00:16:12.760
We would potentially describe that
three times over we'll we'll

254
00:16:12.760 --> 00:16:17.200
have some sort of private
property, or, well, sorry, private

255
00:16:17.200 --> 00:16:22.930
field, perhaps we'll, we'll have
a guest, a Cropsey we'll

256
00:16:23.200 --> 00:16:25.930
describe it again and not
even the age in the

257
00:16:25.930 --> 00:16:30.880
constructor. And then as the
parameters to the construction. And

258
00:16:30.880 --> 00:16:34.600
then finally we'll in that
construct who will then say

259
00:16:34.660 --> 00:16:38.230
name equals name and age
equals age. So, w we've

260
00:16:38.230 --> 00:16:42.550
we've filled in a form
in trip, in effect with

261
00:16:42.550 --> 00:16:46.480
our shop, with the, we
can describe that with a

262
00:16:46.480 --> 00:16:49.990
record site. When we say
a person has a name

263
00:16:50.320 --> 00:16:53.410
and an age, and that's
it, it's the single line.

264
00:16:55.000 --> 00:16:58.290
Do you think maybe Richard,
do you think that, that

265
00:16:58.360 --> 00:17:00.220
the kind of thing that
Phillip's describing is, is an

266
00:17:00.220 --> 00:17:03.580
opportunity for C sharp to,
to take things like that

267
00:17:03.610 --> 00:17:08.080
from F sharp, and why
does F sharp shouldn't be

268
00:17:08.080 --> 00:17:10.210
better designed? Or is it,
is it because it came

269
00:17:10.210 --> 00:17:14.380
afterwards that this is like
this, It's more about the

270
00:17:14.470 --> 00:17:19.600
family heritage and about being
able, you just can't take

271
00:17:19.870 --> 00:17:23.140
stuff out of that sharp
and, and throw it into

272
00:17:23.140 --> 00:17:27.370
C sharp easily, because sharp
comes from a different lineage

273
00:17:27.370 --> 00:17:30.670
of languages. It split off
a long time ago. I

274
00:17:30.670 --> 00:17:33.310
know this is sort of
like, sounds like evolution or

275
00:17:33.310 --> 00:17:36.130
something, but it really ends
up being that way. So

276
00:17:36.130 --> 00:17:38.470
just there's certain ideas I
can be sort of plucked

277
00:17:38.470 --> 00:17:42.580
out, but there's features in,
at sharp leg, discriminate unions

278
00:17:42.940 --> 00:17:44.530
are one of the best
examples of one of the

279
00:17:44.860 --> 00:17:49.120
most amazing things and that
sharp. They allow you to

280
00:17:49.320 --> 00:17:52.200
multiple return types of many
function, local input types for

281
00:17:52.200 --> 00:17:55.740
any variable and describe trees
and all kinds of cool

282
00:17:55.740 --> 00:17:59.490
data structures and tiny amount
of code, any like any

283
00:17:59.490 --> 00:18:05.250
place you find yourself using
inheritance hierarchies, you can pretty

284
00:18:05.250 --> 00:18:10.890
much drop in. And this
feature, there's no way for

285
00:18:10.890 --> 00:18:13.530
it to work effectively without
a lot of enhancements of

286
00:18:13.530 --> 00:18:19.110
C sharp. So some things
will make it over and

287
00:18:19.110 --> 00:18:24.030
some of the ideas already
have, but it tends to

288
00:18:24.030 --> 00:18:26.870
be more of like the,
we can add this functionality

289
00:18:26.880 --> 00:18:31.050
of the compiler in terms
of like sync feature. Like

290
00:18:31.050 --> 00:18:33.060
we really think of solving
a problem in F sharp.

291
00:18:33.070 --> 00:18:35.430
Does it really well? Let's
do something like that. And

292
00:18:35.430 --> 00:18:40.500
less like, you know, language
feature about how we treat

293
00:18:40.500 --> 00:18:44.100
data. Those tend to, those
don't tend to make it

294
00:18:44.100 --> 00:18:48.020
over because it's hard. It's
a lot harder. Phillip, you

295
00:18:48.020 --> 00:18:50.150
had a really good example
of something that I don't

296
00:18:50.150 --> 00:18:52.730
think I could do in,
in C sharp when you

297
00:18:52.730 --> 00:18:54.830
were talking about, I think
it was you on your

298
00:18:54.830 --> 00:18:58.430
blog about the game of
life doing it in, in

299
00:18:58.430 --> 00:19:00.110
F sharp. Could you say
something about the game of

300
00:19:00.110 --> 00:19:03.260
life and, and why doing
it Neff sharp was so

301
00:19:03.260 --> 00:19:11.930
terse. Sure. Yeah. So game
of life. So <inaudible> a

302
00:19:11.930 --> 00:19:15.770
way to learn a new
language. You see, a lot

303
00:19:15.770 --> 00:19:20.990
of people are cutting toe
Jos trying, doing the problem

304
00:19:21.350 --> 00:19:25.850
in a new way, pairing
up with somebody. So I've

305
00:19:26.240 --> 00:19:29.210
gone a little bit further
with that and pushed that

306
00:19:29.210 --> 00:19:37.370
into a tweet into 137
characters. And I'm actually thumb

307
00:19:38.060 --> 00:19:43.100
a bunch of different ways,
but some of the features,

308
00:19:43.880 --> 00:19:50.780
a unique Swift Shaw Hara,
particularly pen matching, you have

309
00:19:51.180 --> 00:19:58.010
a list literally matching. Is
she usually powerful If I

310
00:19:58.010 --> 00:19:59.690
may, who back up for
just a moment to make

311
00:19:59.690 --> 00:20:02.060
sure that not everyone's familiar
with the game, but the

312
00:20:02.060 --> 00:20:06.170
idea is that there's a
grid of cells, right? And

313
00:20:06.170 --> 00:20:08.150
they're either on or off
through they're alive or dead.

314
00:20:08.930 --> 00:20:11.480
And then there's some transitions
based on whether or not

315
00:20:11.480 --> 00:20:14.870
you have a neighbor. So
it's fairly straightforward. Like, it's

316
00:20:14.870 --> 00:20:16.880
very simple in that if
you read the rules, I

317
00:20:16.880 --> 00:20:19.070
think there's about four rules,
and then there's an initial

318
00:20:19.070 --> 00:20:22.940
pattern. And then you simply
let the game run. And

319
00:20:22.940 --> 00:20:25.130
the, the, the grid changes
and the grid could be

320
00:20:25.130 --> 00:20:29.000
expressed as ones and zeros
or dots or visually, it

321
00:20:29.000 --> 00:20:31.160
doesn't really matter, but it
is a, it's a grid.

322
00:20:31.190 --> 00:20:33.260
You set an initial state,
you follow some rules and

323
00:20:33.260 --> 00:20:37.430
you say, go, and it
can be explained to someone

324
00:20:37.480 --> 00:20:39.710
just about that quickly. I
think there's, there's four rules.

325
00:20:39.710 --> 00:20:45.050
Is that correct? Yeah, pretty
much. Yeah. So in effect,

326
00:20:45.270 --> 00:20:49.720
you updating life of a
grid of notes and ones,

327
00:20:50.440 --> 00:20:53.770
and do you update that
life by looking at all

328
00:20:53.770 --> 00:20:57.070
of the notes and ones
that around a particular cell,

329
00:20:57.670 --> 00:21:01.000
I'm counting out the numbers,
and then we apply some

330
00:21:01.000 --> 00:21:03.720
roles to that. And we
say, if the count is

331
00:21:03.730 --> 00:21:09.010
free, regardless of what the
current value is, it becomes

332
00:21:09.010 --> 00:21:14.200
one. If the value of
around the cell is two,

333
00:21:15.580 --> 00:21:18.040
we take the number that
preexisted. So if it was

334
00:21:18.040 --> 00:21:21.040
life before the still life,
if there was no life,

335
00:21:23.260 --> 00:21:27.430
there's no life again. And
the other rule is anything

336
00:21:27.430 --> 00:21:33.190
else means no life. And
actually those in fact, free,

337
00:21:33.190 --> 00:21:38.560
simple rules can make life
appear to happen in front

338
00:21:38.560 --> 00:21:43.540
of you. So it's, it's
a beautiful problem. So, wonderful

339
00:21:43.540 --> 00:21:46.720
thing about pattern matching is
it's kind me like a

340
00:21:46.720 --> 00:21:51.670
switch statement on steroids. So
we would have switched case.

341
00:21:51.700 --> 00:21:55.840
And faceoff when we'd be
able to say in the

342
00:21:55.840 --> 00:21:59.090
case, then we have the
value of three or two,

343
00:21:59.090 --> 00:22:02.620
or, but in, in X
shell, we can say, we

344
00:22:02.620 --> 00:22:05.530
can match against two things
at once like a table.

345
00:22:05.860 --> 00:22:08.950
So we can say, if
it's anything on the count,

346
00:22:08.970 --> 00:22:13.540
it's free and there's life.
If there's a number and

347
00:22:13.540 --> 00:22:15.970
the count is two, then
it goes to that number.

348
00:22:16.480 --> 00:22:18.640
And if there's anything else,
we go to zero, right?

349
00:22:19.000 --> 00:22:22.180
So looking at it now
so that we can explain

350
00:22:22.330 --> 00:22:27.340
the main rules in that
pattern match in about 15

351
00:22:27.340 --> 00:22:31.210
characters, which is ridiculously fast,
but at the same time,

352
00:22:32.290 --> 00:22:38.260
beautifully readable, because we're actually
declaring the algorithm. And, you

353
00:22:38.260 --> 00:22:39.580
know, you look at it,
you go, that's what he

354
00:22:39.580 --> 00:22:44.970
does is this accidental complexity.
Again, See if I'm trying

355
00:22:44.970 --> 00:22:46.980
to, I'm trying to mentally
write this. And I'm seeing

356
00:22:46.980 --> 00:22:49.740
a lot of, a lot
of if statements and already

357
00:22:49.740 --> 00:22:52.020
my C-sharp program is going
to be very, very long.

358
00:22:52.020 --> 00:22:54.420
What is it about F
sharp that, that makes it

359
00:22:54.420 --> 00:22:56.580
so crisp? Is it, is
it because there's just built

360
00:22:56.580 --> 00:22:59.790
in functions and notion of
matching and mapping is fundamental

361
00:22:59.790 --> 00:23:04.050
to the language, Power matching
is it's a huge win.

362
00:23:04.050 --> 00:23:07.080
And it's one of those
features that you see in

363
00:23:08.400 --> 00:23:14.370
most functions in the functional
programming languages, much more rarely.

364
00:23:14.430 --> 00:23:20.580
And so Cece and fax
the imperative style languages. This

365
00:23:20.580 --> 00:23:24.210
is one of the things
in this particular snippet, the

366
00:23:24.210 --> 00:23:29.700
list syntax in an F
shelf in it, again, guy,

367
00:23:29.840 --> 00:23:33.540
most functional languages is you
open a square bracket and

368
00:23:33.540 --> 00:23:37.110
then you just run the
values with a separator. So

369
00:23:37.260 --> 00:23:41.700
you don't have to say
new and square bracket or

370
00:23:41.910 --> 00:23:45.230
a curly brace and, and
ride the values out. You

371
00:23:45.230 --> 00:23:49.010
literally just get the, write
the list as you would

372
00:23:49.010 --> 00:23:51.650
expect to see if you're
reading it in a book

373
00:23:51.650 --> 00:23:55.790
or something. And then F
shops type inference says, Oh,

374
00:23:56.030 --> 00:24:00.440
I see numbers there. So
that must be a list

375
00:24:00.440 --> 00:24:03.650
of numbers. And, you know,
you haven't declared a time.

376
00:24:04.900 --> 00:24:08.410
So that saves you time
and space as well. It

377
00:24:08.410 --> 00:24:10.690
doesn't, it lets you just
fight this on the problems

378
00:24:10.990 --> 00:24:14.080
that you're trying to solve.
And again, removes the accidental

379
00:24:14.080 --> 00:24:18.700
complexity from me. One of
the peaceful things about type

380
00:24:18.700 --> 00:24:23.620
inference and is this sort
of automatic refactoring that you

381
00:24:23.620 --> 00:24:27.460
can get with it. So
instead of having most of

382
00:24:27.460 --> 00:24:30.100
code with declaring types, then
you want to refine it

383
00:24:30.100 --> 00:24:32.470
so you can go in
and edit. And so he,

384
00:24:32.470 --> 00:24:36.400
you some sort of tool
like ReSharper with F Shaw,

385
00:24:36.400 --> 00:24:39.730
if you just changed the
route type in one place

386
00:24:40.120 --> 00:24:42.130
and in first the type
all the way for your

387
00:24:42.130 --> 00:24:46.450
program for you. So that
that reflects definitely even required.

388
00:24:47.260 --> 00:24:52.150
So beautiful gravy, Richard, both
of you guys work with

389
00:24:52.150 --> 00:24:55.210
user groups in the U
S and in the UK,

390
00:24:55.600 --> 00:24:57.910
are these well attended? Are
there a lot of people

391
00:24:57.910 --> 00:24:59.860
doing F sharp and going
to users groups, or is

392
00:24:59.860 --> 00:25:01.990
this just four or five
really smart guys that are

393
00:25:01.990 --> 00:25:05.590
doing this work? Oh, no.
It's really quite big here

394
00:25:05.590 --> 00:25:07.450
in New York city, at least
in that. I'm pretty sure

395
00:25:07.450 --> 00:25:09.940
it's big in London too,
from the pictures I've seen.

396
00:25:10.420 --> 00:25:12.700
I mean, we've had probably
an average of 50, but

397
00:25:12.700 --> 00:25:17.410
when Don came, we had
over a hundred attendees. So

398
00:25:18.280 --> 00:25:22.150
the groups were pretty well
attended and we're seeing a

399
00:25:22.150 --> 00:25:25.390
lot of people and especially
in New York and finance using

400
00:25:25.390 --> 00:25:31.510
it at their companies. So
finance, you mentioned finance, this,

401
00:25:31.510 --> 00:25:32.920
this is, this gets to
what we were talking about

402
00:25:32.920 --> 00:25:36.370
before is that, you know,
very tourist, very clear, very

403
00:25:36.370 --> 00:25:39.430
crisp, but very functional type
problems. I keep, I keep

404
00:25:39.430 --> 00:25:43.360
hearing more and more about
entire libraries being written in

405
00:25:43.690 --> 00:25:47.830
F sharp to support finance
and then having C-sharp call

406
00:25:47.840 --> 00:25:52.000
those lines. Oh, definitely. Yeah.
You filled your UI in

407
00:25:52.000 --> 00:25:55.600
C sharp, and then you
put your complicated finance logic

408
00:25:55.600 --> 00:25:57.160
in the back and an
easy to read. If you

409
00:25:57.160 --> 00:26:01.330
didn't have a domain expert
validate and that's a big

410
00:26:01.330 --> 00:26:06.940
win for everybody involved, What
kind of books do you

411
00:26:06.940 --> 00:26:09.400
or, or websites is there
like a tri F sharp?

412
00:26:09.430 --> 00:26:11.050
The way we think of
like, try Ruby. Like if

413
00:26:11.050 --> 00:26:12.910
I was going to, if
a listener was going to

414
00:26:12.910 --> 00:26:14.680
S you know, get to
get to work on their

415
00:26:14.680 --> 00:26:17.860
commute now and take 15,
20 minutes and learn about

416
00:26:18.640 --> 00:26:20.440
F sharp, what would they
do? How would they spend

417
00:26:20.440 --> 00:26:25.030
that 15, 20 minutes? Absolutely.
Try off shelf to hold.

418
00:26:25.390 --> 00:26:28.630
Yeah. Exists. You're kidding. I
just guessed, so try F

419
00:26:28.630 --> 00:26:32.920
sharp.org to do that right
now. Yeah, you can. If

420
00:26:32.920 --> 00:26:36.100
you've got some silver light,
you can actually run it

421
00:26:36.790 --> 00:26:41.230
in the browser. So if
you're on Mac or PC,

422
00:26:41.230 --> 00:26:44.700
you don't even need to
install visual studio. You can

423
00:26:44.700 --> 00:26:48.510
just go ahead and write
some code, and it's beyond

424
00:26:48.510 --> 00:26:54.270
that. You can actually do
graphical. You can implement graphics

425
00:26:54.930 --> 00:26:58.290
in, in the browser. So
I've actually got a couple

426
00:26:58.290 --> 00:27:02.100
of games that you can
run a snippet, so you

427
00:27:02.100 --> 00:27:05.550
can just load in there
and play with. So there's

428
00:27:05.550 --> 00:27:10.290
a missile command example of
kind of like Tetris that

429
00:27:10.290 --> 00:27:13.470
runs in the browser. And
you can just go and

430
00:27:13.560 --> 00:27:16.290
edit and tweak the variables.
So have quite a lot

431
00:27:16.290 --> 00:27:21.930
of fun. There, there's a
website for snippets called Fs

432
00:27:21.990 --> 00:27:29.700
net. So on that, and
I see hundreds of snippets

433
00:27:29.700 --> 00:27:32.580
being put up that by
the community, just like sure.

434
00:27:32.640 --> 00:27:37.650
Examples of pieces of code
you might find. Interesting little

435
00:27:37.650 --> 00:27:44.360
gangs, all sorts. Really. That's
very interesting. The idea that

436
00:27:44.360 --> 00:27:47.220
of a snippet website, typically
in, in, I know in

437
00:27:47.240 --> 00:27:50.960
C sharp, if you find
code online, it's probably garbage

438
00:27:51.260 --> 00:27:52.790
and you certainly don't want
to be copy pasting and

439
00:27:52.790 --> 00:27:55.340
into your stuff, but in
a world that is more

440
00:27:55.340 --> 00:27:58.910
functional and immutable, it seems
like a snippet would make

441
00:27:58.910 --> 00:28:01.370
a lot more sense. Like
is a snippet Richard much

442
00:28:01.370 --> 00:28:03.200
more useful in F sharp
than it is in C

443
00:28:03.200 --> 00:28:07.430
sharp. Definitely. And I would
say that because that's sharp,

444
00:28:07.430 --> 00:28:10.730
it's so young and early
adopter crowd has written most

445
00:28:10.730 --> 00:28:14.450
of this stuff. It's all
pretty workable. Now. That's not

446
00:28:14.450 --> 00:28:17.840
to say there's not a,
probably 10 different examples of

447
00:28:18.530 --> 00:28:20.900
like commuting a list on
there, but, you know, you

448
00:28:20.900 --> 00:28:24.310
just pick the one that
is most understandable or performance

449
00:28:24.320 --> 00:28:28.640
that's been using the tiny
function and the sharp interactive,

450
00:28:29.030 --> 00:28:30.890
and you can do pretty
well that way. Definitely. It's

451
00:28:30.890 --> 00:28:34.580
not hard. And it's pretty
cool. The best thing about

452
00:28:34.580 --> 00:28:40.340
it that's by far is
actually a neat, neat thing

453
00:28:40.340 --> 00:28:45.410
that partially compiled the snippet
and actually gives you the

454
00:28:45.410 --> 00:28:47.510
types with now it's over
in the browser, which is

455
00:28:47.510 --> 00:28:51.770
wicked. Cool. Wow. Okay. So
Phillip, if I was going

456
00:28:51.770 --> 00:28:55.040
to introduce F sharp into
my organization, but maybe the

457
00:28:55.040 --> 00:28:57.500
bosses or the CTOs are
gonna say, ah, I don't

458
00:28:57.500 --> 00:29:01.040
know, this is some obscure
research language. This is a,

459
00:29:01.070 --> 00:29:03.350
this is built into visual
studio though now, right? So

460
00:29:03.380 --> 00:29:06.530
someone could do this without
fear that it's not that

461
00:29:06.530 --> 00:29:10.190
it's going to go away.
Absolutely. You know, we've had

462
00:29:11.600 --> 00:29:15.620
have shop in visual studio
was a plugin visual studio,

463
00:29:15.620 --> 00:29:18.530
2005. How do you can
see it in the visual

464
00:29:19.160 --> 00:29:26.420
studio 11 now? So it's
not going anywhere, but, and

465
00:29:26.810 --> 00:29:29.870
I had wires going everywhere
in a good way. We've

466
00:29:29.870 --> 00:29:32.710
called it a shelf free
coming in on the basis

467
00:29:32.710 --> 00:29:38.000
of what a really exciting
type providers feature. So, yeah.

468
00:29:38.030 --> 00:29:40.040
Well, tell me a little
bit very briefly in the

469
00:29:40.040 --> 00:29:42.730
end here about F sharp
three, like where's F sharp

470
00:29:42.730 --> 00:29:44.530
heading. And what kind of,
I know that like a

471
00:29:44.530 --> 00:29:47.590
lot of async things have
happened in C-sharp what, what

472
00:29:47.590 --> 00:29:51.780
improvements are being made to
F So the, the real

473
00:29:51.780 --> 00:29:59.100
big ticket item is writers
and time providers is putting

474
00:29:59.100 --> 00:30:03.750
into the language, the ability
to connect to big data,

475
00:30:04.650 --> 00:30:09.450
connect to web services, to
tight spaces, to Excel, to

476
00:30:09.450 --> 00:30:15.060
vinyl, to DSLs, just for
IntelliSense, by pressing doll. So

477
00:30:15.960 --> 00:30:17.640
who, the example I kind
of think of, let's say

478
00:30:17.640 --> 00:30:21.030
we wanted to my shop
and we've got some values

479
00:30:21.030 --> 00:30:24.330
and Excel. We want to
pull some data down from

480
00:30:25.290 --> 00:30:28.620
the world bank. We want
to go some data on

481
00:30:28.620 --> 00:30:32.520
a database. We can do
that free time providers. We

482
00:30:32.520 --> 00:30:36.360
can pull that all in,
and that will give us

483
00:30:36.900 --> 00:30:40.380
tight data through press dot.
We can, we can look

484
00:30:40.380 --> 00:30:41.730
how you've at a time.
We're not going to take

485
00:30:41.730 --> 00:30:45.150
anybody's tables and fields, and
we can join all of

486
00:30:45.150 --> 00:30:48.600
those together. In one, in
fact, we won't have to

487
00:30:48.870 --> 00:30:53.160
go Jan or anything like
that. And seconds, minutes later,

488
00:30:53.430 --> 00:30:55.590
you can have that value.
We can have that mashed

489
00:30:55.590 --> 00:31:01.380
out. So she usually hugely
valuable in that area, the

490
00:31:01.380 --> 00:31:04.590
data mining. Interesting. And that's
all in I'm in dotnet

491
00:31:04.590 --> 00:31:06.210
four or five, or what
do we call that F

492
00:31:06.210 --> 00:31:11.130
sharp At shop, right? Three
that's included with visual studio

493
00:31:11.130 --> 00:31:17.910
11. Absolutely. Yeah. Very exciting
feature. You should check out

494
00:31:17.910 --> 00:31:22.650
some of the videos online.
Thomas pathtrack is talking about

495
00:31:22.650 --> 00:31:29.310
it recently, Q con and
conference in London last week,

496
00:31:29.370 --> 00:31:33.540
Don's then out for a
year, announced talking about it,

497
00:31:34.020 --> 00:31:39.240
amazing demos, and you can
do that mash up. You

498
00:31:39.240 --> 00:31:42.870
can do that data access
from F sharp and then

499
00:31:42.900 --> 00:31:47.730
access that really easily from
C-sharp. So you can get

500
00:31:47.730 --> 00:31:51.720
those final values and push
that into you business application.

501
00:31:52.710 --> 00:31:54.450
And just to make it
clear in case it wasn't

502
00:31:54.450 --> 00:31:56.880
clear to folks who've been
listening to this whole time.

503
00:31:57.420 --> 00:31:59.190
These are just, it's just
all I L I can

504
00:31:59.190 --> 00:32:01.050
go and add reference, and
I can pick an F

505
00:32:01.050 --> 00:32:03.150
sharp library and call those
methods. And as long as

506
00:32:03.150 --> 00:32:06.840
I'm using things within the
dotnet base class library that

507
00:32:06.840 --> 00:32:09.510
are shared amongst all dotnet
languages, I can move data

508
00:32:09.510 --> 00:32:11.820
in and out. No problem
between F sharp and C.

509
00:32:12.600 --> 00:32:17.910
Absolutely. Yeah. I like that.
Well, thank you so much.

510
00:32:18.120 --> 00:32:21.090
Phillip Telford and Richard migrants.
I really like all the

511
00:32:21.090 --> 00:32:23.250
different links that we talked
about as well as other

512
00:32:23.250 --> 00:32:25.050
ones that Richard and Philip
think are useful and we'll

513
00:32:25.050 --> 00:32:26.760
put Philip think are useful,
and we'll put them in

514
00:32:26.760 --> 00:32:29.100
the show notes, including the
one that I'm checking out

515
00:32:29.100 --> 00:32:31.410
right now at tri F
sharp at your time. Thank

516
00:32:31.410 --> 00:32:36.780
you, gentlemen. This has been
another episode of Hanselminutes and

517
00:32:36.780 --> 00:32:38.130
we'll see you again next
week.


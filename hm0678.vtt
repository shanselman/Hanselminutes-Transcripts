WEBVTT FILE

1
00:00:00.240 --> 00:00:03.480
As a software engineer, chances
are you've crossed paths with

2
00:00:03.480 --> 00:00:06.120
Mongo DB. At some point,
whether you're building an app

3
00:00:06.120 --> 00:00:08.370
for millions of users, or
just figuring out your side

4
00:00:08.370 --> 00:00:12.300
hustle, it's the most popular
non-relational database. Mongo DB is

5
00:00:12.300 --> 00:00:16.170
intuitive and incredibly easy for
development teams to use. Now

6
00:00:16.170 --> 00:00:19.230
with Mongo DB Atlas, you
can take advantage of Mongo

7
00:00:19.230 --> 00:00:23.040
DBS, flexible document data model
as a fully automated cloud

8
00:00:23.040 --> 00:00:27.720
service. Mongo DB Atlas handles
all the costly database operations

9
00:00:27.720 --> 00:00:30.090
and admin tasks that you'd
rather not spend time on

10
00:00:30.510 --> 00:00:35.220
like security, high availability, data
recovery monitoring, and elastic scaling.

11
00:00:35.760 --> 00:00:44.670
Try Mongo DB Atlas for
free today. Visit www.mongodb.com/cloud. To

12
00:00:44.670 --> 00:01:03.200
learn more. That's Mongo db.com/cloud.
Hi, this is Scott Hanselman,

13
00:01:04.220 --> 00:01:07.070
Hansel minutes. And today I'm
chatting with Adam Barr. He's the

14
00:01:07.100 --> 00:01:10.310
author of the book, The
problem with software. Why smart

15
00:01:10.310 --> 00:01:13.760
engineers write bad code? You
worked at Microsoft for many

16
00:01:13.760 --> 00:01:16.760
years. Didn't you, sir? Yes.
I worked there for a

17
00:01:16.760 --> 00:01:20.900
little over 23 years in
two different stints, 10 years,

18
00:01:20.900 --> 00:01:25.100
and then 13 years as
developer, definitely dev manager and

19
00:01:25.100 --> 00:01:28.400
then a couple of other
jobs and you've you've since

20
00:01:28.400 --> 00:01:33.140
escaped and are consulting and
hopefully enjoying yourself. Yeah. So

21
00:01:33.170 --> 00:01:36.650
I there's things I've missed
about Microsoft, but overall I'm

22
00:01:36.650 --> 00:01:39.380
happy to be, have a
little more flexibility in my

23
00:01:39.380 --> 00:01:43.010
schedule. Well, when you took
a sabbatical, you went off

24
00:01:43.010 --> 00:01:45.410
and wrote this book, the
problem with software, and I

25
00:01:45.410 --> 00:01:48.830
was fortunate enough to get
an early copy. And I've

26
00:01:48.830 --> 00:01:51.170
actually, I'm on the back
of the, of the cover

27
00:01:51.170 --> 00:01:53.270
there, where the little quote
about why I think this,

28
00:01:53.360 --> 00:01:55.400
this book is great. And
one of the things that

29
00:01:55.400 --> 00:01:57.920
I, I said about it
was that it was an

30
00:01:57.950 --> 00:02:01.790
unflinching view of what sucks
about software and how you

31
00:02:01.790 --> 00:02:05.180
can potentially solve it. It's
a really dense book. And

32
00:02:05.180 --> 00:02:07.160
I say that in the
kindest way of the word

33
00:02:07.160 --> 00:02:10.550
dense, there's a lot of
information shoved into 300 pages

34
00:02:10.550 --> 00:02:13.220
in this book, right? The
idea was I wanted a

35
00:02:13.220 --> 00:02:17.510
book that was readable by
a non programmer, but also

36
00:02:18.170 --> 00:02:21.350
could be read by programmers.
So the non-programmers would get

37
00:02:21.350 --> 00:02:25.340
some insight into what was
going on with programmers and

38
00:02:25.340 --> 00:02:28.850
the programmers would hopefully get
a little self reflection about

39
00:02:28.850 --> 00:02:31.370
what they could do better.
So my concern with it,

40
00:02:31.370 --> 00:02:35.420
I'd make some comments about
what example is, I'd say,

41
00:02:35.420 --> 00:02:38.570
well, a byte is eight
bits and then some programmer

42
00:02:38.570 --> 00:02:40.280
in their mind would jump
up and say, well, no,

43
00:02:40.280 --> 00:02:43.190
actually, you know, there's this
example referenced in the original

44
00:02:43.190 --> 00:02:46.580
K NRC book where a
bite is nine beds. How

45
00:02:46.580 --> 00:02:49.760
can you say such an
uninformed statement? So I tried

46
00:02:49.760 --> 00:02:54.260
to put the, the details
like that, proving my programming

47
00:02:54.260 --> 00:02:56.660
chops into the end though.
It's cause the programmers will

48
00:02:56.660 --> 00:02:59.380
read those and then the
regular people will just skip

49
00:02:59.380 --> 00:03:01.960
the end notes and Hopefully
get a little more of

50
00:03:01.960 --> 00:03:06.310
a story without all these
random tangents explaining these really

51
00:03:06.310 --> 00:03:09.700
esoteric details about stuff that
only a programmer would, would

52
00:03:09.700 --> 00:03:12.940
care about. I'm trying to
avoid the situation. When you

53
00:03:12.940 --> 00:03:16.360
read a book about programming,
Clive Thompson just came out

54
00:03:16.360 --> 00:03:18.250
with his book coders and
I was leafing through it.

55
00:03:18.250 --> 00:03:20.920
And even just reading it
he's, he's not really a

56
00:03:20.920 --> 00:03:24.280
programmer. And, and you do,
you see these things where

57
00:03:24.280 --> 00:03:26.380
you grit your teeth and
you're like, ah, that's not

58
00:03:26.380 --> 00:03:31.480
quite accurate. And even I
understand for wide audience, that's

59
00:03:31.480 --> 00:03:33.400
what you gotta do. So
I tried to be accurate

60
00:03:33.400 --> 00:03:37.030
where possible, and that does
lead to some digressions and

61
00:03:37.030 --> 00:03:40.090
tangents just to really explain,
well, this is actually what

62
00:03:40.090 --> 00:03:43.170
the real story is. I'm
actually going to have Clive

63
00:03:43.170 --> 00:03:44.760
on the show in a
little while and I'm, I'm

64
00:03:44.760 --> 00:03:47.790
quoted multiple times in the
book. And even though he

65
00:03:47.790 --> 00:03:49.770
had a fact checker, when
I spoke to him at

66
00:03:49.770 --> 00:03:52.800
length, I spoke to his
fact-checker at length. There's still

67
00:03:52.800 --> 00:03:54.770
a number of times when
I was like, Ooh, well,

68
00:03:54.770 --> 00:03:57.720
that's not exactly how I
would have phrased that. I

69
00:03:57.720 --> 00:03:59.850
saw, you know, there's all
these pills talk about bugs

70
00:03:59.850 --> 00:04:03.660
and software and they they're
kind of merging together an

71
00:04:03.660 --> 00:04:06.660
actual bug. Like Heartbleed where
the program made a mistake.

72
00:04:06.660 --> 00:04:10.620
And then things like the
seven 37 max eight problem,

73
00:04:10.620 --> 00:04:15.690
which is really technically not
a programmer bug because the

74
00:04:15.690 --> 00:04:18.570
system is working as designed.
It was just assigned badly.

75
00:04:18.570 --> 00:04:21.870
And then you got problems
like that. The Ericsson certificate

76
00:04:21.870 --> 00:04:24.870
problem last fall that knocked
out some cell phones and

77
00:04:25.200 --> 00:04:27.150
people call all of those
things, bug and the bugs.

78
00:04:27.150 --> 00:04:29.100
And then he's trying to
give an example of a

79
00:04:29.100 --> 00:04:32.160
bug and he gives a
Python syntax. There that's like

80
00:04:32.160 --> 00:04:35.460
that. That's not any of
those that that's not at

81
00:04:35.460 --> 00:04:38.310
all what we're talking about.
It's not a logic bug

82
00:04:38.340 --> 00:04:41.220
or design bug or an
operational bug. It's some minor

83
00:04:41.220 --> 00:04:44.310
thing that gets, that gets
cleared up quickly and never

84
00:04:44.310 --> 00:04:47.760
affects any code that's checked
in. So I was trying

85
00:04:47.760 --> 00:04:51.030
to be, Hey, I'm actually
a programmer. I do understand

86
00:04:51.030 --> 00:04:52.950
this stuff. When I try
to explain it for a

87
00:04:52.950 --> 00:04:56.670
lay man, at least I'm
not making some basic mistake

88
00:04:56.670 --> 00:05:00.450
of, of a miscategorizing something
that would great on a

89
00:05:00.720 --> 00:05:05.430
programmer's eyes balls. I was
trying to explain meltdown inspector,

90
00:05:05.790 --> 00:05:09.150
you know, the Intel CPU
exploits, as you know, they're,

91
00:05:09.660 --> 00:05:11.250
they're not really a bug
as they were like you

92
00:05:11.250 --> 00:05:14.580
say, a design flaw was
trying to explain them for

93
00:05:14.580 --> 00:05:17.820
the lay person. And I
said, well, imagine that you

94
00:05:18.990 --> 00:05:22.440
are thinking about going and
spending some money. And by

95
00:05:22.440 --> 00:05:25.020
virtue of the fact that
you thought about looking in

96
00:05:25.020 --> 00:05:27.390
your wallet, I stole the
credit cards out of your

97
00:05:27.390 --> 00:05:31.890
wallet. You know, you're cause
you're doing a predictive, you

98
00:05:31.890 --> 00:05:34.620
know, you're, you're, there's, there's
two parallel universes, one where

99
00:05:34.620 --> 00:05:36.570
you left and opened your
wallet and went off and

100
00:05:36.570 --> 00:05:38.520
did it in one way.
You didn't. And by virtue

101
00:05:38.520 --> 00:05:40.410
of the fact that you
thought about it, I've stolen

102
00:05:40.410 --> 00:05:44.160
your money. And people like
either think that's a perfect

103
00:05:44.160 --> 00:05:46.710
analogy or they spend the
rest of the day ripping

104
00:05:46.710 --> 00:05:49.830
the analogy apart as a
totally and completely imperfect analogy.

105
00:05:50.250 --> 00:05:52.290
There's just no good way
to make analogies around code.

106
00:05:52.620 --> 00:05:55.290
Yeah, honestly, that analogy is
made has some flaws, which

107
00:05:55.290 --> 00:06:00.500
up nevermind. I saw it.
I heard about that and

108
00:06:00.500 --> 00:06:03.770
I thought, wow, that is
really clever. Occasionally you have

109
00:06:03.770 --> 00:06:05.960
to look at, sometimes you
look at an exploit and

110
00:06:05.960 --> 00:06:07.610
you're like, wow. I mean,
just to think of that

111
00:06:07.610 --> 00:06:13.070
and, and realize you could
use cash speed to predict

112
00:06:13.070 --> 00:06:15.440
stuff and, and realize what
the, what the processor had

113
00:06:15.440 --> 00:06:18.500
done is I got more
complicated. It was actually pretty

114
00:06:18.500 --> 00:06:23.170
darn close. Yeah. And you
refer to the software sausages

115
00:06:23.170 --> 00:06:25.900
and how it's made and
you know, what's, what's clean

116
00:06:25.900 --> 00:06:28.750
and what's not throughout the
book. And one of the

117
00:06:28.750 --> 00:06:30.670
things that you call out
kind of early on is

118
00:06:30.670 --> 00:06:34.360
this the education of a
programmer and whether or not

119
00:06:34.360 --> 00:06:36.490
we can catch these things
early, or maybe some of

120
00:06:36.490 --> 00:06:39.280
these bugs in software are
really bugs and how we

121
00:06:39.280 --> 00:06:43.960
teach software. Yeah. I think
the problem is you, you

122
00:06:43.960 --> 00:06:46.810
can learn to program on
your own. And a lot

123
00:06:46.810 --> 00:06:50.230
of people do this really
started once the personal computer

124
00:06:50.230 --> 00:06:53.800
became widespread and people could
teach themselves to program without

125
00:06:53.800 --> 00:06:56.080
going to work for a
company or go to college,

126
00:06:56.080 --> 00:06:58.870
which is where the computers
used to be. And people

127
00:06:58.870 --> 00:07:02.290
taught themselves. And then they
went to college and kind

128
00:07:02.290 --> 00:07:05.830
of use the same skills
they taught themselves. And universities

129
00:07:05.830 --> 00:07:09.430
weren't really teaching the actual
mechanics of writing code. They

130
00:07:09.430 --> 00:07:13.990
tended to teach algorithms. And
so people were basically all

131
00:07:13.990 --> 00:07:17.350
self-taught. Even if you had
a nominally had a software

132
00:07:17.350 --> 00:07:20.320
engineering or computer science degree,
you actually tie yourself to

133
00:07:20.320 --> 00:07:23.770
code and you would tie
yourself on very small programs,

134
00:07:24.190 --> 00:07:27.400
maybe with a couple other
people working for three months

135
00:07:27.400 --> 00:07:30.610
on some assignment in class.
And that is vastly different

136
00:07:31.150 --> 00:07:34.690
from what you do at
a large company where the

137
00:07:35.080 --> 00:07:38.170
software has to persist for
years. And it's multiple people

138
00:07:38.170 --> 00:07:40.780
working out of multiple groups,
it's stitched together with APIs.

139
00:07:41.440 --> 00:07:44.650
The frustrating part of all
this is IBM and other

140
00:07:44.650 --> 00:07:47.830
companies figured this out and
in the 1960s and wrote

141
00:07:47.830 --> 00:07:50.980
a bunch of books about
it. But that was essentially

142
00:07:50.980 --> 00:07:54.850
ignored by all these self-taught
people in the late eighties

143
00:07:54.850 --> 00:07:58.930
and early nineties, because they
could be successful with their

144
00:07:58.930 --> 00:08:02.320
self-taught methodology. So you really
wind up and it's still

145
00:08:02.320 --> 00:08:05.680
today that it takes a
while working in industry for

146
00:08:05.680 --> 00:08:09.910
people to hopefully figure out,
Oh, API design is very

147
00:08:09.910 --> 00:08:14.140
important. It's not some afterthought
stitching these things together is

148
00:08:14.140 --> 00:08:17.890
really what matters, not just
cranking out some code in

149
00:08:17.890 --> 00:08:23.680
my office and Microsoft, certainly
despite that being known and

150
00:08:23.680 --> 00:08:28.270
ignored, they spent a long
time figuring out things, for

151
00:08:28.270 --> 00:08:30.820
example, that you couldn't test
in quality, you had to

152
00:08:30.820 --> 00:08:34.720
design it in. I heard
Jerry Weinberg state that Charles

153
00:08:34.720 --> 00:08:39.460
Babbage working on the difference
engine 150 years ago, stated

154
00:08:39.460 --> 00:08:41.530
that you could not test
quality in. You had to

155
00:08:41.530 --> 00:08:43.720
design it in. So it's
not like it's a new

156
00:08:43.720 --> 00:08:47.200
idea, but people keep having
to rediscover it on their

157
00:08:47.200 --> 00:08:52.960
own at great cost of
time and frustration. So, okay.

158
00:08:52.960 --> 00:08:55.180
So let me ask you
this, this tough question, because

159
00:08:56.250 --> 00:08:58.200
as I'm going to refer
to you and I as

160
00:08:58.200 --> 00:09:01.950
senior developers, and that could
be a double entendre in

161
00:09:01.950 --> 00:09:04.020
the use of the word
senior, how do we make

162
00:09:04.020 --> 00:09:07.350
sure that we as senior
people are not gatekeeping and

163
00:09:07.350 --> 00:09:12.300
preventing younger people or self-taught
people from being successful? Like

164
00:09:12.300 --> 00:09:15.000
there is this knowledge out
there by virtue of the

165
00:09:15.000 --> 00:09:17.010
fact that they are either
self-taught or learned at a

166
00:09:17.010 --> 00:09:19.380
code camp, or maybe just
learn at a university that

167
00:09:19.380 --> 00:09:22.020
didn't teach them these things.
How do we set them

168
00:09:22.020 --> 00:09:24.240
up for success when we
bring them on our teams?

169
00:09:24.990 --> 00:09:27.390
Certainly we don't want them
to simply not get involved

170
00:09:27.390 --> 00:09:28.800
in tech in the first
place. We want them to

171
00:09:28.800 --> 00:09:32.900
be successful. It's tricky to
avoid being the grumpy old

172
00:09:33.320 --> 00:09:38.030
person, shaking your fist at
those kids today. I think

173
00:09:38.630 --> 00:09:42.230
the way I learned and
I started out by, I

174
00:09:42.230 --> 00:09:45.740
had a job before Microsoft,
but my first real serious

175
00:09:45.740 --> 00:09:47.840
software development was at Microsoft.
And I happened to be

176
00:09:47.840 --> 00:09:52.370
on the windows and T
team under Dave Cutler. And

177
00:09:53.180 --> 00:09:56.810
luckily that was just the
way things were done. You

178
00:09:56.810 --> 00:10:00.620
did do design work. You
really did worry about quality.

179
00:10:01.040 --> 00:10:05.270
You try to avoid being
careless. That was the, just

180
00:10:05.340 --> 00:10:09.320
the, in the air in
the group. And so I

181
00:10:09.320 --> 00:10:12.590
think what's important when people
come into existing team out

182
00:10:12.590 --> 00:10:14.600
of college is just to
say, look, this is what

183
00:10:14.600 --> 00:10:18.260
we do acknowledge that the
people are smart and they

184
00:10:18.260 --> 00:10:21.920
can write code. And they
could probably debug small bits

185
00:10:21.920 --> 00:10:25.760
of code, but in a
gentle way, explain that industry

186
00:10:25.760 --> 00:10:29.390
software is different because of
the scale and the time

187
00:10:30.260 --> 00:10:34.520
that it has to last.
And there's certain ways we

188
00:10:34.520 --> 00:10:38.720
have to operate. Despite that
your first code review will

189
00:10:38.720 --> 00:10:42.620
be hard to take for
anybody. It will feel like

190
00:10:42.650 --> 00:10:46.490
personal criticism, no matter how
much you're prepared for it.

191
00:10:46.970 --> 00:10:51.020
I wish universities did code
reviews. They had students doing

192
00:10:51.020 --> 00:10:54.590
code reviews of each other's
code, both for the educational

193
00:10:54.590 --> 00:10:57.380
aspect, and also just getting
used to it that that's

194
00:10:57.380 --> 00:11:01.610
part of working in softwares.
Other people have opinions about

195
00:11:01.610 --> 00:11:05.750
your code and you're not
the, the one software genius

196
00:11:05.750 --> 00:11:08.780
in the world That is
hard to take that feedback

197
00:11:08.780 --> 00:11:11.360
though. Like you have to
be able to take like

198
00:11:11.690 --> 00:11:14.270
your, like I used to
say, like, you know, my

199
00:11:14.270 --> 00:11:17.390
code doesn't suck to me.
My code sucks. Rather. I

200
00:11:17.390 --> 00:11:19.760
don't suck. Right? It's like
when you write your first

201
00:11:20.060 --> 00:11:22.550
essay or your first poem
or anything, you put a

202
00:11:22.550 --> 00:11:25.250
piece of creativity out in
the world and it's sub

203
00:11:25.280 --> 00:11:29.090
optimal. You know, it doesn't
work for whatever reason at

204
00:11:29.090 --> 00:11:32.090
not attaching your ego to
what you wrote is, is

205
00:11:32.090 --> 00:11:34.700
challenging for anyone, especially a
young person. Right? I think

206
00:11:34.700 --> 00:11:37.070
especially if you're in software
where you've sort of succeeded

207
00:11:37.070 --> 00:11:41.270
without really having to learn
a lot from other people

208
00:11:41.270 --> 00:11:44.480
and get feedback. I think
in other industries, certainly other

209
00:11:45.350 --> 00:11:50.090
engineering disciplines or areas like
medicine, you're learning from other

210
00:11:50.090 --> 00:11:55.150
people all the time. Nobody
goes through a medical program

211
00:11:55.150 --> 00:11:58.090
thinking, Oh, I know everything
about medicine. I'll just keep

212
00:11:58.090 --> 00:12:00.610
doing what I did in
high school. So they've already

213
00:12:00.610 --> 00:12:03.940
been taught that yes, you
have to learn. You have

214
00:12:03.940 --> 00:12:08.140
to stand on the shoulders
of giants. And I think

215
00:12:08.170 --> 00:12:10.510
I made an analogy in
software. It's more like we're

216
00:12:10.540 --> 00:12:12.850
maybe getting a little boost
onto their big toe or

217
00:12:12.850 --> 00:12:17.260
something. And most, most stuff
is just relearn by people

218
00:12:17.260 --> 00:12:20.530
rather than having this understanding.
It that's the way the

219
00:12:20.530 --> 00:12:24.420
world works. You learn something
from other people. Speaking of

220
00:12:24.420 --> 00:12:27.420
old people who shake their
fists, you mentioned Edgar Dykstra

221
00:12:27.420 --> 00:12:29.550
in the, in the book.
And you'd talk about in

222
00:12:29.550 --> 00:12:34.350
1975, he said, it's impossible
to teach good programming to

223
00:12:34.350 --> 00:12:38.310
students. Who've had an exposure
to basic. They're already mutilated

224
00:12:38.310 --> 00:12:42.600
beyond hope of general regeneration.
That's a little bit rough.

225
00:12:42.630 --> 00:12:45.930
I certainly hope we're not
doing that today with JavaScript

226
00:12:45.930 --> 00:12:48.990
or other languages that are
more accessible. Yeah. Well, every

227
00:12:48.990 --> 00:12:51.480
time I make a comment
about a specific language, somebody

228
00:12:51.480 --> 00:12:54.660
yells at me. So I'll
refrain from that. But a

229
00:12:54.660 --> 00:12:58.560
diaper was really saying the
quote is a good one

230
00:12:58.620 --> 00:13:01.620
about basic because well, bill
Gates, his first language was

231
00:13:01.620 --> 00:13:05.550
basics. I wasn't that funny,
but the timing's actually important.

232
00:13:05.550 --> 00:13:09.120
It was 1975. It was
the year that Microsoft was

233
00:13:09.120 --> 00:13:14.610
founded to market. A basic
interpreter. And Dykstra was really

234
00:13:14.610 --> 00:13:17.790
trying to tell people languages
like basic as they existed

235
00:13:17.790 --> 00:13:21.780
back then not, not visual
basic, which is somewhat modern.

236
00:13:22.290 --> 00:13:25.170
Those languages. They didn't have
block. If statements they were

237
00:13:25.230 --> 00:13:28.090
riddled with GoTo is out
of necessity. The several teens

238
00:13:28.090 --> 00:13:31.110
didn't have parameters. There were
terrible languages. And he was

239
00:13:31.110 --> 00:13:36.000
saying, there are actually better
languages. Our goal in particular

240
00:13:36.000 --> 00:13:38.820
was a pretty good language.
And it's really the, the

241
00:13:39.180 --> 00:13:41.940
ancestor of, of C and
C sharp and Java and

242
00:13:42.390 --> 00:13:46.560
most modern languages. He was
desperately trying to tell people,

243
00:13:46.590 --> 00:13:49.980
stop learning, basic stop learning
Fortran and COBOL is your

244
00:13:49.980 --> 00:13:53.970
first language use better languages.
Unfortunately, it was just the

245
00:13:53.970 --> 00:13:57.930
wrong timing. The PC industry
was happening. They all use

246
00:13:57.930 --> 00:14:00.390
basic as their built in
language because you could fit

247
00:14:00.390 --> 00:14:04.320
it into a one K
rom or something. And so

248
00:14:05.250 --> 00:14:09.330
they went with basic, all
these people bought their PCs,

249
00:14:09.330 --> 00:14:13.380
taught themselves basic, and maybe
they weren't mentally mutilated, but

250
00:14:13.380 --> 00:14:16.980
they certainly learned some very
bad habits. I always had

251
00:14:16.980 --> 00:14:21.120
an argument with somebody about,
well, it was my sister

252
00:14:21.120 --> 00:14:25.830
actually about how you didn't
really need parameters to methods.

253
00:14:25.970 --> 00:14:27.720
And you could use a
line number instead of a

254
00:14:27.720 --> 00:14:30.300
name. I mean, you understood
it, right? And that's just

255
00:14:30.300 --> 00:14:34.020
a classic kind of thing
you say when you've only

256
00:14:34.020 --> 00:14:37.770
worked on small pieces of
software for yourself, and you've

257
00:14:37.770 --> 00:14:41.430
never worked on something big
because if you're writing a

258
00:14:41.430 --> 00:14:44.490
small piece of software for
yourself, any language is fine,

259
00:14:44.670 --> 00:14:48.360
essentially because it doesn't matter
how readable it is. You

260
00:14:48.360 --> 00:14:51.620
understand it. It's when other
people have to understand your

261
00:14:51.620 --> 00:14:56.420
code, that something like old
school basic really becomes problematic.

262
00:14:57.130 --> 00:15:00.160
He's a programmer to your
family of programmers. Well, she's

263
00:15:00.160 --> 00:15:03.340
actually not a programmer, but
she was taking a program

264
00:15:03.340 --> 00:15:05.590
in class and in college
when I was a high

265
00:15:05.590 --> 00:15:10.900
school senior, you know, my
sisters, probably not the, you

266
00:15:10.900 --> 00:15:13.180
know, the place where I
applied the most logic to

267
00:15:13.180 --> 00:15:16.420
my arguments. So I was
probably mostly interested in improving

268
00:15:16.420 --> 00:15:19.870
her wrong. So I adopted
this sort of ridiculous attitude

269
00:15:19.870 --> 00:15:23.530
that IBM PC basic was
a, was a good language.

270
00:15:25.060 --> 00:15:27.850
Your code is powerful. And
so are you. And when

271
00:15:27.850 --> 00:15:30.250
you consider the reach of
your code, it's clear that

272
00:15:30.250 --> 00:15:33.880
to deliver quality code, you
must also deliver secure code.

273
00:15:34.120 --> 00:15:37.000
So where can you start?
A first step is educating

274
00:15:37.000 --> 00:15:40.240
yourself on basic secure coding
principles and beginning to put

275
00:15:40.240 --> 00:15:44.860
these principles into practice every
day. Vera code secure coding

276
00:15:44.860 --> 00:15:47.950
toolkit is your go to
resource for all your secure

277
00:15:47.950 --> 00:15:51.970
coding needs. The benefits of
the toolkit include learning best

278
00:15:51.970 --> 00:15:56.110
practices for secure coding, understanding
how to secure your dev

279
00:15:56.110 --> 00:16:00.070
ops environments and learning to
combat the most common software

280
00:16:00.070 --> 00:16:04.780
vulnerabilities, stay secure and download
this valuable asset today at

281
00:16:04.780 --> 00:16:15.010
vericode.com/toolkit. That's V R a
covid.com/toolkit. You, you also talk

282
00:16:15.010 --> 00:16:18.130
about the difference in programmers
of different areas and what

283
00:16:18.130 --> 00:16:20.680
they worry about. And you
point out that the programmers

284
00:16:20.680 --> 00:16:23.260
of your era, worried about
the efficiency at which their

285
00:16:23.260 --> 00:16:26.830
programs run. And I remember
myself reading the book programming

286
00:16:26.860 --> 00:16:30.250
pearls, which is a collection
of columns from Carnegie Mellon,

287
00:16:31.120 --> 00:16:35.080
computer science professor. And it
seems like I hear at

288
00:16:35.080 --> 00:16:38.110
least amongst applications that are
commercial applications, less and less

289
00:16:38.110 --> 00:16:41.050
about the concern around efficiency.
Are we getting away with

290
00:16:41.050 --> 00:16:44.800
a lot because processors are
so powerful and memory's so

291
00:16:44.830 --> 00:16:48.880
plentiful. Well, we probably are.
And I think that's fantastic

292
00:16:48.910 --> 00:16:53.980
because when you worry about
performance, you almost certainly make

293
00:16:53.980 --> 00:16:57.040
our code more complicated and
harder for other people that

294
00:16:57.040 --> 00:17:00.520
understand what I was teaching
my kids to drive. I

295
00:17:00.520 --> 00:17:03.760
said, the number one way
to drive safely is not

296
00:17:03.760 --> 00:17:05.830
to be in a hurry
because when you're in a

297
00:17:05.830 --> 00:17:09.220
hurry, you take shortcuts and
you're not your best driver.

298
00:17:09.220 --> 00:17:11.050
It's the same thing with
designing software. If you're worried

299
00:17:11.050 --> 00:17:15.550
about performance, it sounds like
a noble thing. And maybe

300
00:17:15.550 --> 00:17:18.670
you could even conceptually say,
and there's a couple examples

301
00:17:18.670 --> 00:17:21.370
probably where, Oh, I, I
removed the code and it

302
00:17:21.370 --> 00:17:24.460
was simpler and it ran
faster, but that almost never

303
00:17:24.460 --> 00:17:28.870
happens. Worrying about performance means
putting in some side channel

304
00:17:28.870 --> 00:17:32.590
or adding some weird API
for amateur that kicks in

305
00:17:32.590 --> 00:17:36.070
some behavior in certain situations.
And just generally writing more

306
00:17:36.070 --> 00:17:40.840
code to handle the, the
common path separately from the

307
00:17:41.050 --> 00:17:44.290
error path or whatever, just,
just it winds up with

308
00:17:44.290 --> 00:17:46.900
less understandable code. And so
the fact that people can

309
00:17:47.530 --> 00:17:50.970
not worry about it in
most and just write clear

310
00:17:50.970 --> 00:17:55.250
simple code is actually a
great thing. Again, when, when

311
00:17:55.260 --> 00:17:58.440
Bentley was writing programmer pearls,
that was a long time

312
00:17:58.440 --> 00:18:02.790
ago, and you did have
to worry about performance more,

313
00:18:02.790 --> 00:18:06.390
but even he said, although
programming pearls is mostly about

314
00:18:06.390 --> 00:18:10.320
performance. Even he said, don't
do this stuff all the

315
00:18:10.320 --> 00:18:12.660
time. This is for the
situations where you need to

316
00:18:12.660 --> 00:18:16.620
worry about performance. You can
use these techniques, but don't

317
00:18:16.620 --> 00:18:20.160
just go blindly trying to
make your software fast. Even

318
00:18:20.160 --> 00:18:23.520
though it feels good, it's
like scratching a niche and

319
00:18:23.520 --> 00:18:27.450
it's easy to measure. You
made something 5% faster, figuring

320
00:18:27.450 --> 00:18:29.670
out that you also made
it a hundred percent more

321
00:18:29.670 --> 00:18:33.630
complicated is takes longer and
involves other people and more

322
00:18:33.630 --> 00:18:37.110
time, which are not something
programmers generally want to deal

323
00:18:37.110 --> 00:18:39.750
with. So they can just
sit there over optimizing something

324
00:18:39.750 --> 00:18:43.050
all day and feeling virtuous.
When in fact they're probably

325
00:18:43.050 --> 00:18:45.980
not helping anything. Well, certainly
making it the what's that

326
00:18:46.010 --> 00:18:47.840
what's that old saying, right.
Make it right. And then

327
00:18:47.840 --> 00:18:52.340
make it fast. Yes. I
like canoes quote about premature

328
00:18:52.340 --> 00:18:56.120
optimization is the root of
all evil. And I've simplified

329
00:18:56.120 --> 00:18:59.390
that to say optimization is
the root of all evil,

330
00:18:59.420 --> 00:19:02.660
not, you should never optimize,
but a lot of bugs

331
00:19:02.660 --> 00:19:06.590
are there because someone was
optimizing something. And, and they,

332
00:19:06.740 --> 00:19:08.690
like I said, made the
code more complicated or just

333
00:19:08.690 --> 00:19:13.100
had a bug programmers like
to write caches again, Cassius

334
00:19:13.100 --> 00:19:15.740
seemed like a clever thing,
but there's a lot of

335
00:19:15.740 --> 00:19:19.940
bugs in the cache itself,
which only manifests because you

336
00:19:19.940 --> 00:19:24.170
try to make things faster
and often without really knowing

337
00:19:24.170 --> 00:19:27.320
if that was important until
you get something in front

338
00:19:27.320 --> 00:19:29.960
of a customer, you don't
really know if this thing

339
00:19:30.230 --> 00:19:33.770
needs to be optimized and
today with stuff in the

340
00:19:33.770 --> 00:19:36.770
cloud and the way you
can scale so easily and

341
00:19:36.770 --> 00:19:40.880
storage is basically free. And
CPU is so cheap. A

342
00:19:40.880 --> 00:19:42.470
lot of times you don't
have to worry about optimizing

343
00:19:42.470 --> 00:19:45.500
it. You just throw some
more hardware at it. You

344
00:19:45.500 --> 00:19:47.180
know, it's, it's interesting that
you pointed that out because

345
00:19:47.190 --> 00:19:49.910
I've got a blog system
that I worked on. That's

346
00:19:49.910 --> 00:19:53.630
called dos blog, D a
S like it's German for

347
00:19:53.660 --> 00:19:58.580
the blog. And it's been
running for 14 years, effectively

348
00:19:58.580 --> 00:20:01.760
unchanged, but I have a
couple of bugs that I

349
00:20:01.760 --> 00:20:06.170
hit probably once or twice
a month, as well as

350
00:20:06.170 --> 00:20:09.530
a lovely bug that I
hit every time we fall

351
00:20:09.530 --> 00:20:13.310
back because the software never
expected that that time could

352
00:20:13.310 --> 00:20:17.630
go backwards and they're all
caching related. And I, and

353
00:20:17.630 --> 00:20:19.970
I probably didn't, you know,
I did it because 15

354
00:20:19.970 --> 00:20:21.860
years ago we had less
processor power than we do

355
00:20:21.860 --> 00:20:23.960
today. And I could probably
turn the cash off and

356
00:20:23.960 --> 00:20:26.540
the thing would work a
lot more reliably, virtually every

357
00:20:26.840 --> 00:20:29.840
bug in dust blog is
cash and cash related book.

358
00:20:30.800 --> 00:20:34.040
Yeah. I'd say within, within,
within a routing error, if

359
00:20:34.040 --> 00:20:38.390
someone suggests a performance optimization,
you should say, no, you'll

360
00:20:38.390 --> 00:20:41.330
be right enough. That, well,
the couple of cases where

361
00:20:41.330 --> 00:20:43.550
it's probably a good idea,
you can, you can deal

362
00:20:43.550 --> 00:20:45.770
with. But I think as
I said, it's, it's a

363
00:20:45.770 --> 00:20:50.740
programmer instinct and you've got
these old timers grumping about

364
00:20:51.490 --> 00:20:55.450
kids today, but I think
there's far more important things

365
00:20:55.450 --> 00:20:58.960
to concentrate on it in
particular making code that's maintainable

366
00:20:58.960 --> 00:21:01.440
and readable. Well, I appreciate
that. Like, we, we can

367
00:21:01.440 --> 00:21:04.640
joke about old programmers saying
kids today, but they're what,

368
00:21:04.640 --> 00:21:06.480
what, what, what do you
think kids today will get

369
00:21:06.480 --> 00:21:09.330
from a book like this?
They'll there's historical context. I

370
00:21:09.330 --> 00:21:12.420
think you talk about the
importance of agile and when

371
00:21:12.420 --> 00:21:15.570
these things started and how
it, how it fits into

372
00:21:15.570 --> 00:21:18.270
how we make software today,
what do you think that

373
00:21:18.270 --> 00:21:19.950
a 20 year old would
take away from this book

374
00:21:19.980 --> 00:21:22.380
as they are learning about
things like agile and learning

375
00:21:22.380 --> 00:21:26.460
about things like design thinking,
right? Hopefully they'll, they'll get

376
00:21:26.820 --> 00:21:29.820
the understanding that something like
agile is useful in certain

377
00:21:29.820 --> 00:21:33.270
situations, but not all situations.
And the, that language they

378
00:21:33.270 --> 00:21:38.430
like is good in some
situations, but not other situations.

379
00:21:38.430 --> 00:21:41.550
So just be a somewhat
skeptical consumer of programming wisdom.

380
00:21:42.180 --> 00:21:46.320
They have likely very limited
experience. They don't know the

381
00:21:46.320 --> 00:21:49.290
broad exposure to a bunch
of different languages, a bunch

382
00:21:49.290 --> 00:21:53.250
of different code bases. And
so they may, based on

383
00:21:53.250 --> 00:21:55.770
their own experience, think that
something is the right way

384
00:21:55.770 --> 00:21:58.860
to do something, but that
may or may not be

385
00:21:58.860 --> 00:22:02.970
true. And I think it's
easy to kind of float

386
00:22:02.970 --> 00:22:08.520
through a CS undergrad program
on your own wits and

387
00:22:08.520 --> 00:22:11.190
never really come to terms
with the fact that I'm

388
00:22:11.230 --> 00:22:13.770
faced with the fact that
other people actually are smart

389
00:22:13.770 --> 00:22:17.400
too. And, and your favorite
language may not be the

390
00:22:17.400 --> 00:22:20.100
greatest language, that kind of
thing. So just an appreciation

391
00:22:20.100 --> 00:22:22.560
that they might be suffering
from a little bit of

392
00:22:22.560 --> 00:22:28.020
hubris as they approach work
in an industry. And those

393
00:22:28.020 --> 00:22:32.230
old grumpy programmers may have
something to teach them. Yeah,

394
00:22:32.250 --> 00:22:34.860
I've, I've I, as someone,
myself who used to teach

395
00:22:35.250 --> 00:22:37.800
computer science at a, at
a state university, at least

396
00:22:39.270 --> 00:22:41.940
I always felt like there
should have been a historical

397
00:22:41.940 --> 00:22:44.520
context of computer science or
a history of computer science.

398
00:22:44.520 --> 00:22:47.580
And like, let's learn about
programming. Cause I feel like

399
00:22:47.580 --> 00:22:52.260
I'm learning more now in
2019 about the history of

400
00:22:52.260 --> 00:22:56.190
programming from tweets, where I
learn about, you know, what,

401
00:22:56.700 --> 00:22:59.730
you know, ADA Lovelace did
or what you know, or

402
00:22:59.730 --> 00:23:01.320
seeing a movie like hidden
figures. And I go, Oh,

403
00:23:01.320 --> 00:23:03.390
wow. I didn't realize that
that's how that was done

404
00:23:03.390 --> 00:23:05.310
because no one ever taught
me this in school. I

405
00:23:05.310 --> 00:23:07.350
don't know. Did you have
a history of computer science

406
00:23:07.440 --> 00:23:11.190
courses? We had zero history
and I went to school

407
00:23:11.190 --> 00:23:14.160
in the eighties. So a
lot of this, there was

408
00:23:14.160 --> 00:23:16.890
a lot of empirical studies
done in the seventies. People

409
00:23:16.890 --> 00:23:21.750
actually studied commenting and variable
names and method length, all

410
00:23:21.750 --> 00:23:24.840
this stuff. That's just sort
of debated endlessly now with

411
00:23:24.840 --> 00:23:27.780
no resolution. They actually studied
in the seventies. And that,

412
00:23:27.780 --> 00:23:29.790
that wasn't that long ago.
And I went to school,

413
00:23:29.790 --> 00:23:32.850
but we heard nothing about
it. It was just, here's

414
00:23:32.850 --> 00:23:37.290
some algorithms now go write
a compiler and figure out

415
00:23:37.440 --> 00:23:40.620
here's the, here's the book
here's R go teach yourself

416
00:23:40.620 --> 00:23:43.710
C kind of thing. And
that was, that was what

417
00:23:43.710 --> 00:23:45.830
I heard from other people.
It wasn't where I went

418
00:23:45.830 --> 00:23:49.190
to school. And so yeah,
there, there was, there was,

419
00:23:49.370 --> 00:23:54.740
there was really nothing historical
sort of time began when,

420
00:23:55.040 --> 00:23:58.810
when Unix was created maybe.
And, And it literally began

421
00:23:58.810 --> 00:24:01.330
though. I mean, technically it
kind of begins at that

422
00:24:01.330 --> 00:24:03.790
moment. Right. We know when
zero was. Right, Right. Yeah.

423
00:24:03.790 --> 00:24:07.480
That was essentially the message
we got, you know, C

424
00:24:07.480 --> 00:24:11.200
was CEO, the first programming
language ever, you know, the

425
00:24:11.200 --> 00:24:14.230
first decent programming languages. It
did feel like that. Like

426
00:24:14.230 --> 00:24:16.780
for people of a certain
age, they did kind of

427
00:24:16.780 --> 00:24:20.440
imply that like C was
the first language ever of

428
00:24:20.440 --> 00:24:23.620
any, of any import. Here's
the key in our book.

429
00:24:23.650 --> 00:24:25.900
They hand it to you
and Oh, by the way,

430
00:24:25.900 --> 00:24:27.670
there's this assembly language, but
we only have to do

431
00:24:27.670 --> 00:24:31.060
that for one semester. Yeah.
It really was. I mean,

432
00:24:31.480 --> 00:24:34.990
I mean, literally somebody asked
in class as we were

433
00:24:34.990 --> 00:24:39.400
discussing our first programming assignment
because they were one of

434
00:24:39.400 --> 00:24:42.970
the rare people who hadn't
taught themselves to program in

435
00:24:42.970 --> 00:24:45.670
high school said, well, how
do I learn the language?

436
00:24:45.700 --> 00:24:49.120
And they said, Oh, well,
here's the book, knock yourself

437
00:24:49.150 --> 00:24:55.060
out. Those are the days.
So you, you were at

438
00:24:55.120 --> 00:25:00.070
Microsoft through windows NT through
2003. And a lot of

439
00:25:00.070 --> 00:25:06.040
bugs started showing up slammer
bugs, slammer blaster worms, like

440
00:25:06.040 --> 00:25:09.850
2003, four or five people
were slapping windows, NT and

441
00:25:09.850 --> 00:25:13.720
windows generally around pretty, pretty
hard. Were they not? Yeah.

442
00:25:13.720 --> 00:25:19.900
So we did a, an
attempt to eradicate the bugs

443
00:25:21.220 --> 00:25:24.340
in, it had to be
before mid 2000. Cause that's

444
00:25:24.340 --> 00:25:26.980
when I left the TT
and that's when I left

445
00:25:26.980 --> 00:25:29.470
Microsoft the first time. So
that was where they actually

446
00:25:29.470 --> 00:25:35.470
sat down and explained about
buffer overruns and exactly how

447
00:25:35.470 --> 00:25:39.040
you could construct the next
bullet using a buffer override,

448
00:25:39.040 --> 00:25:42.100
which again, to me seemed,
wow, that's really clever. But

449
00:25:42.100 --> 00:25:44.320
then of course it was
my software. They were attacking.

450
00:25:44.320 --> 00:25:46.660
So we had to fix
it. But we did it

451
00:25:46.660 --> 00:25:50.680
with just with code reviews
and we didn't have the

452
00:25:50.950 --> 00:25:54.910
sound adaptation language that would
attempt to track some of

453
00:25:54.910 --> 00:25:58.270
these C problems, the cost
across function calls. So you

454
00:25:58.270 --> 00:26:00.880
could actually get some sense
of what was safe and

455
00:26:00.880 --> 00:26:05.170
what wasn't. And I think
Jim, Altran made an unfortunate

456
00:26:05.170 --> 00:26:07.450
quote to the comment to
the press that, Oh, we

457
00:26:07.450 --> 00:26:10.840
found all the bugs and,
and, and fix them. And

458
00:26:10.840 --> 00:26:13.580
then of course you had
slammer and Zoetrope and blaster

459
00:26:13.960 --> 00:26:15.910
Cause he believed that there
was an automated tool that

460
00:26:15.910 --> 00:26:18.280
could find all buffer overflows.
I think he just thought

461
00:26:18.280 --> 00:26:21.790
you could find it by
code reviews. And I mean,

462
00:26:21.820 --> 00:26:26.260
finding stuff by code reviews
is really a classic testing

463
00:26:26.260 --> 00:26:30.400
and quality approach. I mean,
Eric, Raymond was running around

464
00:26:30.430 --> 00:26:34.060
claiming that open source software
is more secure because there

465
00:26:34.060 --> 00:26:37.360
were more eyeballs looking at
it, which is just completely

466
00:26:37.360 --> 00:26:41.980
not true. You make things
more secure SSL, right? You,

467
00:26:41.980 --> 00:26:46.530
you make things more secure
by, by engineering and certain

468
00:26:46.530 --> 00:26:48.810
techniques to avoid in this
case and see us such

469
00:26:48.810 --> 00:26:52.560
a terrible language for buffer
overruns by there's techniques to

470
00:26:52.560 --> 00:26:54.450
avoid it. Or you could
not write stuff in C

471
00:26:54.450 --> 00:26:57.150
that would also work, but
that might be a bridge

472
00:26:57.150 --> 00:27:00.570
too far for some people.
But yeah, we, I mean,

473
00:27:00.570 --> 00:27:02.910
it's, it was, I don't
think my, I don't think

474
00:27:02.910 --> 00:27:06.690
my code ever actually had
an exploit directly in my

475
00:27:06.690 --> 00:27:11.580
code, but I mean, I
was writing code that faced

476
00:27:11.580 --> 00:27:15.210
the network that manipulated Buffer's
received off the network. So

477
00:27:15.540 --> 00:27:18.540
I mean, I could easily
have had an exploit that

478
00:27:18.540 --> 00:27:23.240
was directly in my code.
Do Keep, did people keep

479
00:27:23.240 --> 00:27:24.500
track of stuff like that?
I mean, does it really

480
00:27:24.500 --> 00:27:26.030
matter whether it was in
your code or do they,

481
00:27:26.120 --> 00:27:29.150
their collective code ownership, does
it where people, you know,

482
00:27:29.150 --> 00:27:32.460
running blame and saying, look,
He was at, they, they,

483
00:27:32.460 --> 00:27:36.140
they wouldn't run blame. I
think it was. And maybe

484
00:27:36.140 --> 00:27:41.390
this is being too forgiving.
The attitude was well, see

485
00:27:41.390 --> 00:27:45.170
as hard. And I think
that was general town, even

486
00:27:45.170 --> 00:27:49.730
when He is hard. Yeah.
Worm came out in 1988,

487
00:27:50.240 --> 00:27:53.180
which was the first remote
CX ploy. The attitude was,

488
00:27:53.180 --> 00:27:56.450
wow, you can't protect against
everything sort of, you know,

489
00:27:57.050 --> 00:27:59.480
attitude. I mean, I, once
I was talking to, I

490
00:27:59.480 --> 00:28:05.240
actually worked in the trustworthy
computing team and he had,

491
00:28:06.590 --> 00:28:09.270
they add some analysis of
all the major exploits and

492
00:28:09.290 --> 00:28:11.300
who had done the actual
check-in again, I don't think

493
00:28:11.300 --> 00:28:13.490
they were going to blame
people. It was just, okay,

494
00:28:13.490 --> 00:28:16.190
maybe there's something on his
team. And he had the

495
00:28:16.190 --> 00:28:17.990
actual name of the person
who'd done the check in.

496
00:28:17.990 --> 00:28:20.360
And I sort of said,
well, as anybody on that

497
00:28:20.360 --> 00:28:23.750
list twice and he sort
of laughed. And then we,

498
00:28:23.880 --> 00:28:28.010
we ordered the Excel by,
by user ID. And there

499
00:28:28.010 --> 00:28:31.520
was somebody who had actually
managed to check in to

500
00:28:31.520 --> 00:28:36.470
exploits or the code behind
two exploits and was like,

501
00:28:36.530 --> 00:28:37.970
I wonder what happened to
that guy? We looked him

502
00:28:37.970 --> 00:28:40.340
up. And of course he
was now a director of

503
00:28:40.340 --> 00:28:43.610
development somewhere in Microsoft, but
that that's an amusing story,

504
00:28:43.610 --> 00:28:46.430
but that doesn't mean necessarily
he was a bad program.

505
00:28:46.790 --> 00:28:49.100
I mean, I think we
all could have made mistakes,

506
00:28:49.100 --> 00:28:53.240
but he just happened to
have to have made two

507
00:28:53.240 --> 00:28:55.940
of them. Well, certainly let
me let he, who is

508
00:28:56.000 --> 00:28:58.700
he or she, who has
filed the first book throw

509
00:28:58.700 --> 00:29:00.950
the first, you know, throw
the first stone. I mean,

510
00:29:01.460 --> 00:29:04.430
any, anyone can, can make
a bug like that, it's

511
00:29:04.480 --> 00:29:07.100
it? You can fat finger
something and you're off by

512
00:29:07.100 --> 00:29:09.650
one errors are, are the
bane of the entire internet,

513
00:29:09.650 --> 00:29:12.500
aren't they? Yeah. These tended
there's a lot of Unicode

514
00:29:13.700 --> 00:29:16.070
putting Unicode into the guts
of auntie was, was a

515
00:29:16.070 --> 00:29:18.410
great thing because it meant
you could handle all these

516
00:29:18.410 --> 00:29:20.840
languages, but there was a
lot of these exports that

517
00:29:20.840 --> 00:29:26.000
were just messing up the
w char the number of

518
00:29:26.630 --> 00:29:30.680
two byte characters versus the
number of bytes needed to

519
00:29:30.680 --> 00:29:32.360
store it. And so you
had a lot of these,

520
00:29:32.450 --> 00:29:34.850
it wasn't off by one.
It was off by a

521
00:29:34.850 --> 00:29:37.850
factor of two mistakes. And
you just tried to copy

522
00:29:37.850 --> 00:29:44.470
a 256 Unicode buffer, which
is 512 bytes into a

523
00:29:44.470 --> 00:29:52.470
256 byte stack buffer. And
the thing would overrun. I

524
00:29:52.470 --> 00:29:54.960
remember those days, it was
very difficult. I remember as

525
00:29:54.960 --> 00:29:58.350
everything was switching over, you
know, in w we were

526
00:29:58.380 --> 00:30:00.900
in school, it was baked
into our brains that one

527
00:30:00.900 --> 00:30:05.280
bite equals one character. And
then one day one bite

528
00:30:05.310 --> 00:30:09.180
equals one, you know, one
or less than one character

529
00:30:09.390 --> 00:30:11.370
or a fraction of a
character or the beginning of

530
00:30:11.370 --> 00:30:14.430
a statement that there might
be characters coming and utfh

531
00:30:15.030 --> 00:30:18.390
in hitters. And all these
things became complicated. Suddenly we

532
00:30:18.390 --> 00:30:20.700
were counting bytes in one
hand and counting characters in

533
00:30:20.700 --> 00:30:23.970
the other hand. And it
took quite a few years

534
00:30:23.970 --> 00:30:27.480
before everything shook itself out.
Right. Actually walk through this

535
00:30:27.480 --> 00:30:29.160
in some detail in the
book, because I think it's

536
00:30:29.160 --> 00:30:31.770
important. I'm trying to explain
why, why see as a

537
00:30:31.770 --> 00:30:35.730
bad language. And hopefully I'm
not losing all my non-program

538
00:30:35.730 --> 00:30:38.820
or readers, but it really
comes down to just make

539
00:30:38.820 --> 00:30:40.770
it a math mistake. And
I mean, you can, you

540
00:30:40.770 --> 00:30:43.560
can do it right. You
can write buffer manipulation code

541
00:30:43.560 --> 00:30:46.350
that is not exploitable. I
think the fact that people

542
00:30:46.350 --> 00:30:48.900
use the term virus makes
it sound like, Oh, you,

543
00:30:49.420 --> 00:30:52.440
you can't necessarily defend again
against it, but you can

544
00:30:52.440 --> 00:30:55.410
write clean code. It's just
a little tricky to do.

545
00:30:56.670 --> 00:30:58.770
Yeah. You called out a
couple of other things that

546
00:30:58.770 --> 00:31:01.140
reminded me of some bugs
that I had, like you

547
00:31:01.140 --> 00:31:04.050
call that the Turkish code
page and the concept of

548
00:31:04.050 --> 00:31:07.890
code pages, where we had
256 characters. And we were

549
00:31:07.890 --> 00:31:11.580
trying to map other characters
on top of those. I

550
00:31:11.580 --> 00:31:14.010
remember one of my big
bugs that actually, I still

551
00:31:14.010 --> 00:31:16.380
think still may exist in
my blogging software is the,

552
00:31:16.660 --> 00:31:20.820
the legendary Turkish eye where
they have an I letter,

553
00:31:20.820 --> 00:31:23.880
I with a dot above
it. And when you capitalize

554
00:31:23.880 --> 00:31:27.420
that eye turns into a
capital, I with a dot

555
00:31:27.420 --> 00:31:30.390
above it, which is not
a capital I it's a

556
00:31:30.630 --> 00:31:35.160
Turkish capitalized, you know, you
make comparisons and things go

557
00:31:35.250 --> 00:31:38.370
bad. Yeah. That's another example.
I actually dig into it

558
00:31:38.370 --> 00:31:40.560
in my book a bit,
because I'm trying to explain

559
00:31:40.560 --> 00:31:43.950
about it's, it's an API,
you call an upper casing

560
00:31:43.950 --> 00:31:46.560
API, or maybe you call
it comparison API and you

561
00:31:46.560 --> 00:31:48.990
have to make sure you're
doing properly. And it's, I'm

562
00:31:48.990 --> 00:31:52.020
just trying to explain that
again, API design is really

563
00:31:52.020 --> 00:31:55.830
important and understanding an API
is critical and that's really

564
00:31:55.830 --> 00:31:58.740
somebody not exactly understanding what
the API does. And in

565
00:31:58.740 --> 00:32:02.970
this particular case, I wind
up railing against a default

566
00:32:02.970 --> 00:32:06.270
parameters, which I think are
really a scourge on, on

567
00:32:06.390 --> 00:32:09.660
programming and should be removed
because it, you have to

568
00:32:09.660 --> 00:32:12.060
make an assumption about what
the color of the API

569
00:32:12.060 --> 00:32:15.780
wants. And I think that's
a bad idea and yes,

570
00:32:15.780 --> 00:32:19.200
you can save a little
typing with a default parameter,

571
00:32:19.200 --> 00:32:22.140
which saving typing is a
bit of an obsession among

572
00:32:22.140 --> 00:32:25.220
programmers. But if it leads
to a bad bug, it

573
00:32:25.260 --> 00:32:29.580
probably isn't worth it. So
I, I don't like default

574
00:32:29.580 --> 00:32:32.760
parameters on, on API APIs.
Well, there's a ton of

575
00:32:32.760 --> 00:32:35.190
great stories in the book.
And like you point out

576
00:32:35.190 --> 00:32:37.950
it is accessible. This is
not a book where one

577
00:32:37.950 --> 00:32:40.100
page is full of code.
And the other page is

578
00:32:40.100 --> 00:32:43.640
full of discussion of code.
It is definitely readable by

579
00:32:43.640 --> 00:32:46.670
the non programmer. It's not
an overwhelming bunch of curly

580
00:32:46.670 --> 00:32:50.180
braces. That's going to stress
you out. It's really a

581
00:32:50.180 --> 00:32:56.810
fun, smart tour of many
decades of experience from yourself

582
00:32:56.810 --> 00:32:59.210
and others. And I appreciate
you coming on the show

583
00:32:59.210 --> 00:33:01.760
to chat with me about
it. Thank you so much

584
00:33:01.760 --> 00:33:04.490
for having me. You can
check out the problem with

585
00:33:04.490 --> 00:33:08.210
software. Why smart engineers write
bad code it's available now

586
00:33:08.210 --> 00:33:10.400
from MIT press, and I'm
going to have links to

587
00:33:10.400 --> 00:33:13.580
it in the show notes.
This has been another episode

588
00:33:13.580 --> 00:33:15.650
of Hansel minutes, and we'll
see you again next week.

589
00:33:15.910 --> 00:33:36.190
<inaudible>.


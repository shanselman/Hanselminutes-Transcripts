WEBVTT FILE

1
00:00:00.180 --> 00:00:03.360
Hi, this is Scott. I
really appreciate our sponsors because

2
00:00:03.360 --> 00:00:06.300
they make the show possible.
Today's show is sponsored by

3
00:00:06.300 --> 00:00:10.500
developer express, become a UI
superhero with dev express controls

4
00:00:10.500 --> 00:00:15.030
and libraries. Deliver elegant.net solutions
that address customer needs today

5
00:00:15.420 --> 00:00:19.500
by leveraging your existing knowledge,
you can build next generation

6
00:00:19.500 --> 00:00:23.610
touch enabled solutions for tomorrow,
you can download your free

7
00:00:23.700 --> 00:00:48.410
30 day trial@dxdothanselminutes.com. That's dx.hanselminutes.com
From hanselminutes.com. It's Hansel minutes,

8
00:00:48.740 --> 00:00:52.580
a weekly discussion with web
developer on technologists. Scott Hanselman.

9
00:00:52.940 --> 00:00:57.080
This is Lawrence Ryan announcing show
number four 28. In this

10
00:00:57.080 --> 00:01:01.460
episode, Scott talks with Matt
Barrett from adaptive consulting about

11
00:01:01.460 --> 00:01:04.220
creating high quality reactive users.
Your face is for the

12
00:01:04.220 --> 00:01:08.840
industry. Hi, this is Scott
Hanselman, and this is another

13
00:01:08.840 --> 00:01:11.330
episode of Hansel minutes. And
I am talking with Matt

14
00:01:11.360 --> 00:01:14.510
Barrett from adaptive consulting about
an application that they have

15
00:01:14.510 --> 00:01:17.840
open source called reactive trader.
Thanks for chatting with me.

16
00:01:18.500 --> 00:01:20.600
Hi Scott, how are you?
Hi, I'm lovely. And this

17
00:01:20.600 --> 00:01:24.140
is really interesting. I, I
love it when people approach

18
00:01:24.140 --> 00:01:26.780
me and they say, Hey,
we put a whole pile

19
00:01:26.780 --> 00:01:30.170
of code on GitHub that
we learned, you know, we

20
00:01:30.170 --> 00:01:32.390
learned from, and now we
want you to learn from,

21
00:01:32.390 --> 00:01:34.850
and you know, people, people
email me a lot and

22
00:01:34.850 --> 00:01:36.200
they say, Hey, we've got
some code. I want you

23
00:01:36.200 --> 00:01:38.240
to take a look at,
but this is more than

24
00:01:38.240 --> 00:01:41.780
that. This is a, not
just a little library you

25
00:01:41.780 --> 00:01:45.770
put together, but you've got
a backend and a website

26
00:01:45.770 --> 00:01:48.260
and WPF, and you're working
on a windows phone version.

27
00:01:48.260 --> 00:01:50.270
This is quite the, a
lot of work that you're

28
00:01:50.270 --> 00:01:53.330
giving away here. Reactive trader.
Yeah, it's a bit of

29
00:01:53.330 --> 00:01:55.610
an investment, I guess, from,
from Adaptive's point of view,

30
00:01:55.610 --> 00:01:59.960
we really wanted to showcase
of interwoven user interfaces in

31
00:01:59.960 --> 00:02:02.750
particular, but more so the
stuff we've learned over the

32
00:02:02.750 --> 00:02:07.700
last five, 10, 15 years
building push-based user interfaces and

33
00:02:07.700 --> 00:02:11.960
what that means. So, so
push based, I guess I

34
00:02:11.960 --> 00:02:14.450
think about, you know, like
stock trading and the prices

35
00:02:14.450 --> 00:02:17.090
are being pushed out from
the server, but I've always

36
00:02:17.090 --> 00:02:20.540
assumed that using, you know,
commodity web technologies that's been

37
00:02:20.540 --> 00:02:24.860
faked, it's usually refreshes or
polling, and that all changed,

38
00:02:24.860 --> 00:02:28.430
you know, with the idea
of, of pushover HTTP. How

39
00:02:28.430 --> 00:02:30.620
did you do that before?
And how is that starting

40
00:02:30.620 --> 00:02:33.080
to change in the industry?
So there's been a lot

41
00:02:33.080 --> 00:02:35.630
of different techniques being cobbled
together. I guess you could

42
00:02:35.630 --> 00:02:39.650
say by various vendors who
have been doing this in

43
00:02:39.650 --> 00:02:42.200
the financial services industry since
the last or since the

44
00:02:42.200 --> 00:02:44.600
late nineties, I should say.
And they've got a bunch

45
00:02:44.600 --> 00:02:47.360
of different techniques that people
are familiar with eye frames,

46
00:02:47.360 --> 00:02:51.800
long polling, exactly the sort
of stuff you mentioned. And

47
00:02:51.800 --> 00:02:55.020
it's gotten now to the
level of maturity where you,

48
00:02:55.020 --> 00:02:58.980
you buy a product, you
use an API and you

49
00:02:58.990 --> 00:03:02.770
get basically What looks like
a socket to you that

50
00:03:02.770 --> 00:03:05.920
can push things at you
and underneath it, the technology

51
00:03:05.920 --> 00:03:09.070
will be trying all these
different sort of connectivity means

52
00:03:09.100 --> 00:03:11.260
and falling back to the
most available one on a

53
00:03:11.260 --> 00:03:15.490
per client basis. Because the
problem with corporate networks is

54
00:03:15.490 --> 00:03:17.890
that they will have very,
very old network infrastructure and

55
00:03:17.890 --> 00:03:21.730
lots of these routers haven't
been rebooted and years and

56
00:03:22.090 --> 00:03:26.380
WebSockets don't work and probably
will never work. So these

57
00:03:26.380 --> 00:03:28.870
guys have got this really
strong background and a fallback

58
00:03:28.870 --> 00:03:32.170
of technologies going all the
way back down to buy

59
00:03:32.260 --> 00:03:34.810
frames and all sorts of
horrible stuff. It's slower, but,

60
00:03:34.870 --> 00:03:37.120
but it works and it
lets you as the application

61
00:03:37.120 --> 00:03:40.060
builder kind of abstract out
the underlying technology. So you

62
00:03:40.060 --> 00:03:41.290
don't have to think about
it and you can just

63
00:03:41.290 --> 00:03:45.120
use it for its benefits
And as signal arts simplified,

64
00:03:45.120 --> 00:03:46.170
a lot of that, I
mean, you could go to

65
00:03:46.170 --> 00:03:49.320
a vendor and say, here's
their service and events implementation,

66
00:03:49.320 --> 00:03:51.270
but is signal or mature
enough? Do you think that

67
00:03:51.270 --> 00:03:53.280
it could be used for
an app like this? Yeah,

68
00:03:53.310 --> 00:03:55.110
thanks. I think so. We
had a lot of success

69
00:03:55.110 --> 00:03:57.180
with that. We didn't, it
didn't cause us any problems.

70
00:03:57.420 --> 00:03:59.730
We use it in a,
in a pretty naive way

71
00:03:59.730 --> 00:04:01.980
because we know that relying
too much on the features

72
00:04:01.980 --> 00:04:06.540
of one particular middleware, we
call these things middlewares, which

73
00:04:06.540 --> 00:04:08.820
means different things to different
people. But then in our

74
00:04:08.820 --> 00:04:12.030
lingo, it's the sort of
software that sits between your

75
00:04:12.030 --> 00:04:14.460
client and your server and
lets you get messages between

76
00:04:14.460 --> 00:04:16.860
the two. And we know
that relying too much on

77
00:04:16.860 --> 00:04:20.130
any one particular functionality of
a particular middleware is going

78
00:04:20.130 --> 00:04:22.440
to cause you pain when
you need to either move

79
00:04:22.440 --> 00:04:24.380
to a different middleware or
start doing things that are

80
00:04:24.960 --> 00:04:27.870
exotic. And then this stuff
exotic is bad and simple

81
00:04:27.870 --> 00:04:32.730
as good. So when I
hit this@reactivetrader.azure websites.net, this is

82
00:04:32.730 --> 00:04:34.830
kind of the online demo
site. You know, I'm seeing

83
00:04:34.830 --> 00:04:37.740
a board of buying and
selling and prices and everything

84
00:04:37.740 --> 00:04:39.810
is moving and you've got
kind of fake data going

85
00:04:39.810 --> 00:04:42.030
from place to place. You
refer to this as a

86
00:04:42.030 --> 00:04:44.670
soft real time system. What
does that mean? Soft real

87
00:04:44.670 --> 00:04:47.910
time. Soft real time is
kind of distinct from hard

88
00:04:47.910 --> 00:04:50.250
real time that there's no
guarantees built into the system

89
00:04:50.250 --> 00:04:54.140
about the timeliness of data
flowing through it. But it's,

90
00:04:54.140 --> 00:04:56.520
it's real time in the
sense that you and I

91
00:04:56.520 --> 00:04:59.220
are seeing the data, the
same information at the same

92
00:04:59.220 --> 00:05:01.860
time. In fact, if you
go ahead and place a

93
00:05:01.860 --> 00:05:03.930
trade just by clicking on
the cell, Well I want

94
00:05:03.930 --> 00:05:08.520
to sell a U S
Japan. Yeah, that just came

95
00:05:08.520 --> 00:05:10.440
up on my screen. So
we're living in the same.

96
00:05:10.650 --> 00:05:13.500
I'm in London and we're
looking at the same stuff,

97
00:05:13.530 --> 00:05:15.570
the same data flowing back
and forth, the same service

98
00:05:15.570 --> 00:05:18.510
distributing process and trades to
all of the people that

99
00:05:18.510 --> 00:05:21.300
are connected at the same
time. It's almost like it's

100
00:05:21.300 --> 00:05:25.020
real time unless it's not
It's realtime unless it's not.

101
00:05:25.160 --> 00:05:27.800
And unless it's not as
where it gets interesting and

102
00:05:27.810 --> 00:05:31.740
where the stuff we've learned
and tried to showcase and

103
00:05:31.740 --> 00:05:34.920
reactive trader is what's interesting
about it. Cause the happy

104
00:05:34.920 --> 00:05:38.500
paths are the happy paths,
right? Everyone sit down and

105
00:05:38.500 --> 00:05:41.130
you knock out some code
replication works when every system

106
00:05:41.130 --> 00:05:43.440
is up and every system
is connected and licensees are

107
00:05:43.440 --> 00:05:46.470
low and bandwidths are high.
That's fantastic. But these real,

108
00:05:46.500 --> 00:05:49.080
these real time systems that
are sitting on clients' desktops,

109
00:05:49.110 --> 00:05:52.710
where they are making very
large financial decisions about whether

110
00:05:52.710 --> 00:05:54.870
to sell or to buy,
you need to make sure

111
00:05:54.870 --> 00:05:57.590
that the user is seeing
the correct information. And also

112
00:05:57.590 --> 00:05:59.140
you need to tell the
user, if you know that

113
00:05:59.140 --> 00:06:02.360
you can't show them the
correct information. And that's a

114
00:06:02.360 --> 00:06:04.700
lot of what we, we
talked about. We wrote a

115
00:06:04.700 --> 00:06:08.450
reactive trader originally because we'd
been invited to speak at

116
00:06:08.810 --> 00:06:12.230
a conference earlier this year
called react comp, which has

117
00:06:12.410 --> 00:06:15.680
some really some pretty big,
heavy hitters and the of

118
00:06:15.680 --> 00:06:19.070
introversion, I guess you could
call it software development space

119
00:06:19.070 --> 00:06:21.410
over the last 20, 30
years, Joe Armstrong and people like

120
00:06:21.410 --> 00:06:24.890
that. And we wanted to
showcase and event driven user

121
00:06:24.890 --> 00:06:28.880
interface and we're adaptive as
a financial services consultancy. And

122
00:06:28.880 --> 00:06:30.830
we couldn't show any of
the applications we built for

123
00:06:30.830 --> 00:06:33.050
our clients. So we thought
it will be interesting to

124
00:06:33.560 --> 00:06:36.200
build an app that showcases
some of the more interesting

125
00:06:36.200 --> 00:06:38.900
parts of the sort of
challenges we face in building

126
00:06:38.900 --> 00:06:42.290
these, these real time, low
latency applications and where they

127
00:06:42.300 --> 00:06:44.690
pretty impressed with what you,
what you did. Yeah, I

128
00:06:44.690 --> 00:06:46.460
think so the talk went
down really well. We got,

129
00:06:46.460 --> 00:06:48.680
we've got a really warm
reaction from it. Everyone was

130
00:06:48.680 --> 00:06:50.420
very positive and it was
a huge amount of fun.

131
00:06:50.420 --> 00:06:53.720
We learned a lot preparing
the talk and, and giving

132
00:06:53.720 --> 00:06:55.340
the talk. And I did
it with a colleague of

133
00:06:55.340 --> 00:06:57.710
mine Lee and we had
a really good time. So

134
00:06:57.710 --> 00:06:59.750
from that respect, we got
a lot out of it

135
00:06:59.750 --> 00:07:02.860
and I think everyone else
did too. How, how is

136
00:07:02.890 --> 00:07:05.260
talk to me a little
bit about reactive. I've talked

137
00:07:05.260 --> 00:07:10.060
briefly with people like Paul
bets around what reactive programming

138
00:07:10.060 --> 00:07:13.570
is. And I feel like
there's, there's a lot happening.

139
00:07:13.600 --> 00:07:15.370
You know, this was something
that had existed existed for

140
00:07:15.370 --> 00:07:17.950
a long time, but there's
been a, a hockey stick

141
00:07:17.950 --> 00:07:20.320
almost in the last maybe
five or 10 years where

142
00:07:20.320 --> 00:07:22.840
people are starting to realize
that for a certain class

143
00:07:22.840 --> 00:07:24.820
of applications, this is really
the only way to go.

144
00:07:25.420 --> 00:07:28.720
Yeah. So I was thinking
about, because I knew that

145
00:07:28.780 --> 00:07:30.670
someone, what you would ask
me a question of what

146
00:07:30.670 --> 00:07:34.150
do you mean by reactive?
And for us reactive is

147
00:07:34.210 --> 00:07:36.220
kind of baked into the
language of what we do,

148
00:07:36.220 --> 00:07:39.100
right? A reactive user and
faces all user interfaces. If

149
00:07:39.100 --> 00:07:41.830
it didn't react as it
broken, he's probably just turn

150
00:07:41.830 --> 00:07:44.410
it off. But for us,
a reactive user interfaces, one

151
00:07:44.410 --> 00:07:46.870
that needs to deal with
very, very large amounts of

152
00:07:47.380 --> 00:07:49.990
events. And it needs to
be able to make sure

153
00:07:49.990 --> 00:07:53.980
that if those events go,
the rate of those incoming

154
00:07:53.980 --> 00:07:56.320
events goes crazy up to
the thousands or hundreds of

155
00:07:56.320 --> 00:08:00.010
thousands of events per second,
that the application doesn't fall

156
00:08:00.010 --> 00:08:02.860
over, lets you keep processing
and doesn't start showing you

157
00:08:02.930 --> 00:08:05.650
updates from a minute ago.
That's not interesting. What we

158
00:08:05.650 --> 00:08:07.390
should be doing is showing
you the state of the

159
00:08:07.390 --> 00:08:09.640
world right now, not what
was happening in minutes ago

160
00:08:09.640 --> 00:08:12.490
when the missus first got
put into a queue Speaking

161
00:08:12.490 --> 00:08:15.220
kind of, you know, ignorantly,
which is something I'm very

162
00:08:15.220 --> 00:08:18.790
good at doing. I can
see thinking about event driven.

163
00:08:18.850 --> 00:08:21.850
Like there's some data coming
from somewhere. I'll just hook

164
00:08:21.850 --> 00:08:25.630
up an event on God
data and then do some

165
00:08:25.630 --> 00:08:28.570
stuff when that happens. And
then I can imagine if

166
00:08:28.570 --> 00:08:31.570
I'm not able to keep
up, I've I've spent time

167
00:08:31.570 --> 00:08:34.330
in applications before where there's
suddenly this flood and the

168
00:08:34.330 --> 00:08:37.510
application starts going dah, dah,
dah, and updating itself. And

169
00:08:37.510 --> 00:08:39.910
it's like, well, wait a
second. What exactly is happening?

170
00:08:39.910 --> 00:08:42.610
Are we trying to catch
up right now? What is

171
00:08:42.610 --> 00:08:45.550
the difference between that kind
of classically event driven from

172
00:08:45.550 --> 00:08:48.700
the perspective of an old
time visual basic three programmer

173
00:08:49.840 --> 00:08:53.620
on event changed kind of
thing versus reactive? Sure. So

174
00:08:54.880 --> 00:08:57.210
for us, it's the thing
that's really enabled us to

175
00:08:57.210 --> 00:09:00.300
write reactive traders so quickly
and so easily was using

176
00:09:00.300 --> 00:09:04.740
reactive extensions. So in, in
the financial services industry in

177
00:09:04.740 --> 00:09:09.090
London with reactive extensions RX
from Microsoft has been picked

178
00:09:09.090 --> 00:09:10.980
up and has really loved.
And we started using it

179
00:09:10.980 --> 00:09:15.000
about 2010. So pretty early
on and in its lifecycle

180
00:09:15.000 --> 00:09:18.570
I guess, and learnt lessons
along the way. And what

181
00:09:18.660 --> 00:09:20.580
using that has allowed us
to do is think about

182
00:09:20.580 --> 00:09:24.960
streams of events, not as
an individual event that you're

183
00:09:24.960 --> 00:09:26.970
dealing with there. And then,
which is kind of like

184
00:09:27.150 --> 00:09:30.060
you implement the method, get
data. And we got a

185
00:09:30.060 --> 00:09:32.130
message and we do something
with it. But instead think

186
00:09:32.130 --> 00:09:34.500
about these things as streams
and time. So you can

187
00:09:34.500 --> 00:09:37.080
say, well, if we see
more than four events in

188
00:09:37.080 --> 00:09:39.420
a second, we need to
do something. Conversely, if we

189
00:09:39.420 --> 00:09:41.820
don't see an event for
four seconds, we also need

190
00:09:41.820 --> 00:09:45.130
to do something. And so
it's sitting inside a, a

191
00:09:45.270 --> 00:09:47.700
mr. Chandler is, it is
a difficult place to try

192
00:09:47.700 --> 00:09:50.730
and do that. You're starting
timers and incrementing counters and

193
00:09:50.730 --> 00:09:52.320
doing all this sort of
the sort of stuff you

194
00:09:52.320 --> 00:09:55.080
tie yourself up and, and
knots pretty quickly. And most

195
00:09:55.080 --> 00:09:57.600
of the time it's so
difficult. You don't do it

196
00:09:58.170 --> 00:10:01.050
because it works fine in
the happy path. And so

197
00:10:01.050 --> 00:10:03.210
you don't conceive of the
case when you suddenly get

198
00:10:03.210 --> 00:10:05.430
a burst of a hundred
messages per second, you don't

199
00:10:05.430 --> 00:10:07.440
think about where that data
is going to be cued.

200
00:10:07.740 --> 00:10:10.110
Is it going to sit
in the PCP Buffalo? Is

201
00:10:10.110 --> 00:10:13.740
that going to sit in
some background thread coming in

202
00:10:13.740 --> 00:10:16.170
for off into the ThreadPool
in your, in your dotnet

203
00:10:16.170 --> 00:10:18.360
processes are going to set,
backed up on a WPF,

204
00:10:18.360 --> 00:10:21.360
dispatcher, you just, you just
don't think about it. You

205
00:10:21.360 --> 00:10:23.280
test and you and you
releasing it. It's fine. But

206
00:10:23.400 --> 00:10:25.500
we really can't do that
with these sorts of applications.

207
00:10:25.830 --> 00:10:28.440
If you start showing people
prices that are five to

208
00:10:28.440 --> 00:10:30.330
10 seconds out of date
and they tied to trade

209
00:10:30.360 --> 00:10:32.070
that they're going to their
trade is going to fail.

210
00:10:32.310 --> 00:10:34.950
And they're going to go
to another client that, which

211
00:10:36.060 --> 00:10:37.500
not what we want. We
want, we want to keep

212
00:10:37.500 --> 00:10:40.020
people using the systems that
we built. And it's just,

213
00:10:40.020 --> 00:10:42.450
it just makes sense. Really.
Google does a lot, has

214
00:10:42.450 --> 00:10:45.930
done a lot of research
about how much lowering response

215
00:10:45.930 --> 00:10:49.290
time on their websites improves
usability and how long people

216
00:10:49.290 --> 00:10:51.540
stick with websites and things
like that. And it's exactly

217
00:10:51.540 --> 00:10:53.940
the same for rich applications.
It wouldn't be any different

218
00:10:53.940 --> 00:10:55.620
when you collect, you want
something to happen straight away.

219
00:10:56.480 --> 00:11:00.740
So just the idea of
reactive programming, formally introduced time,

220
00:11:00.740 --> 00:11:03.560
this, this temporal notion into
what was something that really

221
00:11:03.560 --> 00:11:05.780
had no sense of time.
I would, I would say

222
00:11:05.780 --> 00:11:09.140
it's a pretty key part
of it. Absolutely reactive extinctions

223
00:11:09.140 --> 00:11:12.200
pretty much makes time explicit
to you. You can introduce

224
00:11:12.620 --> 00:11:14.720
time by the use of
schedulers and things, which are,

225
00:11:14.780 --> 00:11:17.060
which are an IPI level
thing that the concept of

226
00:11:17.060 --> 00:11:19.580
it is is there first
and foremost, and that it's,

227
00:11:19.940 --> 00:11:22.580
the API is about pushing
you something and that you

228
00:11:22.580 --> 00:11:24.680
are not in control of
when you get pushed. That

229
00:11:24.680 --> 00:11:26.990
message and that message may
not come to you for

230
00:11:26.990 --> 00:11:29.450
another five or 10 seconds.
So time is very much

231
00:11:29.480 --> 00:11:30.950
first class concept. That's a
good way to think about

232
00:11:30.950 --> 00:11:34.910
it. And you're doing a
reactive work, both in the

233
00:11:34.910 --> 00:11:37.370
UI, on the, on the
client looking at, for example,

234
00:11:37.370 --> 00:11:41.120
the HTML client, but also
in the WPF side and

235
00:11:41.120 --> 00:11:44.660
then presumably on the servers.
Yeah, absolutely. So we, when

236
00:11:44.660 --> 00:11:46.400
we sat down to write
reactive trader, we did a

237
00:11:46.400 --> 00:11:50.060
WPF app and a dotnet
server implementation first and foremost,

238
00:11:50.360 --> 00:11:53.500
talking over signal hours, we've
already said, and we RX

239
00:11:53.500 --> 00:11:57.580
on both sides. So the
server creates these observable streams

240
00:11:57.670 --> 00:12:00.340
and increments and decrements prices.
Like you can see on

241
00:12:00.340 --> 00:12:03.430
your screen here kind of
doing a random walk around

242
00:12:04.330 --> 00:12:06.220
or away from some initial
values we set them up

243
00:12:06.220 --> 00:12:10.180
with and that those events
are put onto a signal,

244
00:12:10.180 --> 00:12:12.250
armed message bus. And at
the other end, we've got,

245
00:12:12.340 --> 00:12:16.030
we, we turn that signal
our API into an, into

246
00:12:16.030 --> 00:12:18.520
an observable stream pretty much
as soon as we can

247
00:12:18.820 --> 00:12:20.410
and then deal with that
all the way up through

248
00:12:20.410 --> 00:12:23.170
the UI, through the traditional
WPF things like a view

249
00:12:23.170 --> 00:12:27.100
model and up until the
binding engine and similarly in

250
00:12:27.110 --> 00:12:30.300
the RX JS implementation, we
do the same thing. We

251
00:12:30.310 --> 00:12:33.490
get called back from the
signal, our JavaScript API, and

252
00:12:33.490 --> 00:12:36.070
we immediately go into an
observable stream and do exactly

253
00:12:36.070 --> 00:12:40.270
the same implementation of business
logic. This thing that I

254
00:12:40.270 --> 00:12:42.310
was mentioning about telling the
user, if the stream has

255
00:12:42.310 --> 00:12:45.310
gone cold. So our observable
streams here have a have

256
00:12:45.310 --> 00:12:47.710
an SLA that says they
will yield a new price

257
00:12:47.710 --> 00:12:50.110
every four seconds. If we
don't see a price in

258
00:12:50.110 --> 00:12:52.000
four seconds, then one of
the little tile that has

259
00:12:52.000 --> 00:12:54.250
gone quiet, we'll go, we'll
go red. And every now

260
00:12:54.250 --> 00:12:56.500
and then you see one
of them flash red, which

261
00:12:56.500 --> 00:12:58.720
is indicating that that's exactly
what's happened. And it's the

262
00:12:58.720 --> 00:13:02.530
same code, the same pattern,
the same asynchronous pattern that

263
00:13:02.530 --> 00:13:06.370
we've implemented in WPF and
the JavaScript version. And also

264
00:13:06.370 --> 00:13:09.850
we're now moving into iOS,
I'm using Xamarin and we'll

265
00:13:09.850 --> 00:13:12.550
probably keep going into windows,
phone and Android and things

266
00:13:12.550 --> 00:13:14.910
like that. Let's look at
that, that, that point for

267
00:13:14.910 --> 00:13:17.160
a second. You said that
when something goes stale, it

268
00:13:17.160 --> 00:13:19.770
turns red. Is that a
view? There you go. Just,

269
00:13:19.770 --> 00:13:24.210
yeah, the Euro Australian dollar
just went red that said,

270
00:13:24.210 --> 00:13:26.130
that basically said, this is
too stale for me to

271
00:13:26.130 --> 00:13:28.800
feel comfortable about. Yeah. We
think that if you try

272
00:13:28.800 --> 00:13:30.780
and trade on this price,
it's not going to work.

273
00:13:31.410 --> 00:13:33.600
And this is kind of
a, yeah, just when they're

274
00:13:33.600 --> 00:13:37.650
at us, this is us
talking. So in the talk

275
00:13:37.650 --> 00:13:39.600
we gave at react, con
three really wanted to highlight

276
00:13:39.630 --> 00:13:42.000
a couple of things. And
one is that it's important

277
00:13:42.000 --> 00:13:46.410
to make technical failures business
events because it's building reliable,

278
00:13:46.710 --> 00:13:49.890
distributed systems is very hard
and the industry is struggling

279
00:13:49.890 --> 00:13:52.890
to do it, but we
don't have to admit failure.

280
00:13:52.890 --> 00:13:54.780
If something goes wrong, we
can always kind of step

281
00:13:54.810 --> 00:13:58.200
out of bounds. Sorry, out
of band with the technical

282
00:13:58.470 --> 00:14:00.600
problem we have, and maybe
flash up a phone number

283
00:14:00.600 --> 00:14:03.300
for someone to call. So
if the price goes stale,

284
00:14:03.870 --> 00:14:05.940
we flashed the screen red,
but in a real system,

285
00:14:05.940 --> 00:14:08.130
we'd probably give a set
of phone number up so

286
00:14:08.130 --> 00:14:09.450
that someone could ring up
and try and get a

287
00:14:09.450 --> 00:14:11.070
price over the phone and
do a trade if they

288
00:14:11.070 --> 00:14:13.560
really felt they needed to.
So this means that from

289
00:14:13.560 --> 00:14:16.830
the client's perspective, this system
didn't go down. The client

290
00:14:16.830 --> 00:14:19.740
was still able to trade,
which is, which is perfect,

291
00:14:19.740 --> 00:14:21.030
which is exactly what sort
of thing we're trying to

292
00:14:21.030 --> 00:14:24.780
do. And thinking about reactive
systems, they're ones that responds

293
00:14:24.780 --> 00:14:28.200
to events. And in this
case, there's a failure somewhere

294
00:14:28.470 --> 00:14:30.780
and we don't want the
system to turn off the

295
00:14:30.780 --> 00:14:32.580
system as a whole needs
to keep going. So it

296
00:14:32.580 --> 00:14:34.980
responds by prompting someone with
a phone number and they

297
00:14:34.980 --> 00:14:37.470
can go and make a
phone call. The I'm looking

298
00:14:37.470 --> 00:14:41.190
at the, the RX JS.
And I guess I'm a

299
00:14:41.190 --> 00:14:44.520
little bit spoiled that I
assume that a JavaScript library

300
00:14:44.520 --> 00:14:46.380
will just have kind of
one JavaScript library. And you

301
00:14:46.380 --> 00:14:50.190
say, here's the model include
this, but they've broken our

302
00:14:50.190 --> 00:14:52.700
XJS into quite a few
things. I would have to

303
00:14:52.700 --> 00:14:55.250
say for the, for the
uninitiated, it is a little

304
00:14:55.250 --> 00:15:00.620
overwhelming there's RX dot all
there's dot light. And then

305
00:15:00.620 --> 00:15:03.650
there's a whole series of
binding and join patterns and

306
00:15:03.650 --> 00:15:06.860
testing and virtual time. Why
is it broken up like

307
00:15:06.860 --> 00:15:09.470
that? And why, what did
you use and why would

308
00:15:09.470 --> 00:15:14.050
I care of you? That
really comes from the reactive

309
00:15:14.050 --> 00:15:16.870
extension style of, of giving
you only the smallest amount

310
00:15:16.870 --> 00:15:20.020
of, of API surface area
that you, that you need,

311
00:15:20.320 --> 00:15:22.150
which is good when you're
a power user, but you're

312
00:15:22.150 --> 00:15:24.580
right. It's a bit intimidating
to begin with. And I

313
00:15:24.580 --> 00:15:27.850
would suggest to people just,
just starting off, use everything

314
00:15:28.210 --> 00:15:30.040
and just play around with
it. Look at the online

315
00:15:30.040 --> 00:15:32.560
videos, figuring out, figuring out
how you build these apps.

316
00:15:32.650 --> 00:15:34.630
There's some great tutorials out
there. Have a look at

317
00:15:34.630 --> 00:15:37.150
reactive traders, see what, see
how we plug everything together

318
00:15:37.480 --> 00:15:39.850
and then realize that most
of the stuff you don't

319
00:15:39.850 --> 00:15:41.440
need and not all of
it sits at the same

320
00:15:41.440 --> 00:15:43.480
level of importance. So once
you've got a bit of

321
00:15:43.480 --> 00:15:45.190
a mental model about the
stuff it's quite easy to

322
00:15:45.190 --> 00:15:49.150
discount and not important things
you don't want. Okay. And

323
00:15:49.150 --> 00:15:51.760
I noticed that one of
the things that's important about

324
00:15:51.820 --> 00:15:55.990
our XJS is that they
unify all the different sources

325
00:15:56.020 --> 00:15:59.080
of information. It's not just
in this case, a data

326
00:15:59.080 --> 00:16:02.560
stream, we've been talking about
trading and this is finance

327
00:16:02.560 --> 00:16:04.870
data stream, but another data
stream might be evented data

328
00:16:04.870 --> 00:16:07.960
like the keyboard or something
that's happening in a web

329
00:16:07.960 --> 00:16:11.530
worker is, is in the
world of reactive. Is everything

330
00:16:11.530 --> 00:16:14.440
a data stream from my
mouse moving to something going

331
00:16:14.440 --> 00:16:18.190
on? Absolutely, absolutely. Everything is
Australian. And that's, that's one

332
00:16:18.190 --> 00:16:21.340
of the things we really
highlighted then in our talk

333
00:16:21.790 --> 00:16:24.490
is that when we picked
up react to extensions and

334
00:16:24.490 --> 00:16:26.710
started using it to deal
with streams of data, like

335
00:16:26.710 --> 00:16:28.840
prices and trades appearing on
the blotter and stuff like

336
00:16:28.840 --> 00:16:31.660
that, it's very natural that
it became so natural to

337
00:16:31.660 --> 00:16:34.570
us, that we also started
seeing streams where before we

338
00:16:34.570 --> 00:16:37.450
thought we were seeing just
request response. So for things

339
00:16:37.450 --> 00:16:41.740
like loading configuration data, when
your application starts up loading

340
00:16:41.740 --> 00:16:43.540
the set of users, you're
entitled to see you or

341
00:16:43.540 --> 00:16:47.080
something like that. We traditionally
think of those as request

342
00:16:47.080 --> 00:16:50.290
response. But actually if you
think about them as request,

343
00:16:50.620 --> 00:16:52.780
tell me what the set
of users I can see

344
00:16:52.780 --> 00:16:54.700
now are, and then keep
telling me about it all

345
00:16:54.700 --> 00:16:57.730
the way through while I'm
running. That's really powerful. Now

346
00:16:57.730 --> 00:17:01.150
you've got an application that
if configuration changes, it will

347
00:17:01.150 --> 00:17:03.940
reconfigure itself. Why do we
want to be telling people

348
00:17:03.940 --> 00:17:05.830
to turn things on, turn
things off again, just to

349
00:17:06.040 --> 00:17:08.440
refresh, to get the latest
set of accounts. So we

350
00:17:08.440 --> 00:17:11.920
really think about all network
calls that we make to

351
00:17:11.920 --> 00:17:14.320
backend services, to API APIs,
whether it's to a rest

352
00:17:14.320 --> 00:17:17.110
API, for example, we would
want in future for it

353
00:17:17.110 --> 00:17:19.330
to just give me back
the answer now, and then

354
00:17:19.480 --> 00:17:21.820
all the answers in the
future. Whenever something changes as

355
00:17:21.820 --> 00:17:24.640
long as we're still interested.
No, that's really interesting because

356
00:17:24.640 --> 00:17:26.980
that takes what I would
think is a traditionally very

357
00:17:26.980 --> 00:17:32.350
hard problem. Like the kind
of the classic configuration changed

358
00:17:32.560 --> 00:17:36.550
event then would involve a,
for most applications, the new

359
00:17:36.550 --> 00:17:40.600
King of all configuration and
then reload from settings. I

360
00:17:40.600 --> 00:17:43.880
mean, I know we've all
written that code before you,

361
00:17:43.880 --> 00:17:46.480
you're saying you would completely
change your, your way of

362
00:17:46.480 --> 00:17:49.710
thinking your perspective on that.
We would, we would, we,

363
00:17:49.930 --> 00:17:51.960
we Can't really do that
for, for these sorts of

364
00:17:51.960 --> 00:17:57.750
financial services applications, if a
regulation or some client exceeds

365
00:17:57.750 --> 00:17:59.850
their credit limit, or there's
some business event that happens

366
00:17:59.850 --> 00:18:01.800
during the course of the
week, we're not in a

367
00:18:01.800 --> 00:18:04.470
position to say we're going
to call up all our

368
00:18:04.470 --> 00:18:06.170
clients and tell them to
turn their app off and

369
00:18:06.180 --> 00:18:08.010
then turn it back on
again. What they will do

370
00:18:08.010 --> 00:18:11.070
is go and use some
other banks trading application. Cause

371
00:18:11.070 --> 00:18:13.710
these guys have no interest
in the, an our problems

372
00:18:13.740 --> 00:18:15.570
they're trying to solve their
problems. We shouldn't be forcing

373
00:18:15.570 --> 00:18:18.390
our problems onto them. So
we very quickly learned that

374
00:18:18.390 --> 00:18:21.360
we have to be able
to push configuration changes, permission

375
00:18:21.360 --> 00:18:25.440
changes. So maybe one of
these currency pairs, you're only

376
00:18:25.440 --> 00:18:27.600
able to trade from Monday
through Wednesday and on Thursday

377
00:18:27.600 --> 00:18:30.030
and Friday, someone else's able
to do it. Well, we

378
00:18:30.030 --> 00:18:31.710
don't want you turning your
app on and off to

379
00:18:31.770 --> 00:18:33.590
get the latest set of
things you can tray. We

380
00:18:33.600 --> 00:18:36.780
will push you a bit
of data that says you

381
00:18:36.780 --> 00:18:39.900
can no longer trade Australia,
U S dollar, and that

382
00:18:39.900 --> 00:18:43.490
will disappear from your screen.
So that configuration is, is

383
00:18:43.500 --> 00:18:46.070
a stream. You think about
it that like, it seems

384
00:18:46.070 --> 00:18:49.580
like layering while important in
programming is super important than

385
00:18:49.580 --> 00:18:51.980
this. Like I assume that
your user interface has no

386
00:18:51.980 --> 00:18:55.550
concept of where this data
comes from. It's all the

387
00:18:55.550 --> 00:18:59.120
idea of model view, model,
and MVVM yeah. Extra important.

388
00:18:59.630 --> 00:19:02.570
The model is a well
architecture view and view model

389
00:19:02.570 --> 00:19:04.640
is, is extra important because
you need to be able

390
00:19:04.640 --> 00:19:07.550
to reason about the different
parts of your application that

391
00:19:07.550 --> 00:19:11.150
are susceptible to these, these
events that will occur sometime

392
00:19:11.150 --> 00:19:13.820
in the future and require
you to make something disappear

393
00:19:13.820 --> 00:19:17.570
or reappear. So it's very
important to understand the life

394
00:19:17.570 --> 00:19:20.090
cycle of your application and
how you will be turning

395
00:19:20.090 --> 00:19:22.430
various features on and off
in response to these events.

396
00:19:22.880 --> 00:19:24.830
So the idea of a
view model, and then some

397
00:19:24.830 --> 00:19:28.910
client data binding that's automatic
is, is a, is important.

398
00:19:28.910 --> 00:19:31.190
What are you using in
both these applications? You've got

399
00:19:31.190 --> 00:19:34.370
a WPF app and you've
got to HTML app. I

400
00:19:34.370 --> 00:19:36.860
assume that the data is
streaming in. And then the

401
00:19:36.860 --> 00:19:39.440
reactive code that you've written
is acting upon that. And

402
00:19:39.440 --> 00:19:42.740
then magically the UI gets
updated. What does that? So

403
00:19:42.740 --> 00:19:45.140
in the WPF app, we
don't have a lot, we're

404
00:19:45.140 --> 00:19:48.590
pretty confident with WPF with
a fairly large bit of

405
00:19:48.590 --> 00:19:51.620
the software landscape in the
industry we work in. So

406
00:19:51.620 --> 00:19:54.260
it's pretty straightforward. We just
have the reactive extensions, API

407
00:19:54.260 --> 00:19:56.600
and observable stream that comes
all the way up. The

408
00:19:56.600 --> 00:19:59.960
view models that we write
subscribed to them and assign

409
00:19:59.960 --> 00:20:01.880
it to the properties. And
the binding engine takes care

410
00:20:01.880 --> 00:20:05.670
of the rest on the
standard WPF binding engine standard

411
00:20:05.750 --> 00:20:08.300
up here, binding engine works
great, nice and lightweight. Everyone

412
00:20:08.300 --> 00:20:11.030
understands it. It's easy to,
it's easy to reason about,

413
00:20:11.600 --> 00:20:14.240
and we don't like the
idea of putting a lot

414
00:20:14.240 --> 00:20:16.910
of complexity into some special
source of the application. The

415
00:20:16.910 --> 00:20:19.400
stuff is complex enough as
it is. And we like

416
00:20:19.400 --> 00:20:22.970
to see everything be done
explicitly to talk about the

417
00:20:22.970 --> 00:20:26.120
JavaScript app. Let me just
Olivier, what did we use

418
00:20:26.120 --> 00:20:28.010
for JavaScript? And we can
edit this but out and

419
00:20:28.010 --> 00:20:32.660
I'll knock out. So for
the JavaScript version, do you

420
00:20:32.660 --> 00:20:36.300
wanna re ask the question
cause I keep rolling. So

421
00:20:37.130 --> 00:20:38.750
What Matt has done is
he just kind of turned

422
00:20:38.750 --> 00:20:40.970
his head to one of
the other developers, Olivia and

423
00:20:41.300 --> 00:20:44.630
asked the question she using
knockout, knockout, Knock out. Yeah,

424
00:20:44.660 --> 00:20:47.860
exactly the same, the same
style from underneath. So an

425
00:20:47.860 --> 00:20:50.470
observable stream comes off the
signal, our API up into

426
00:20:50.470 --> 00:20:53.610
the UI and we just
bind to the knockout. It's

427
00:20:53.610 --> 00:20:55.920
interesting that you're using that
because for people who are

428
00:20:55.920 --> 00:21:00.300
WPF programmers or formerly Silverlight
programmers and are really deep

429
00:21:00.300 --> 00:21:04.200
into MVVM knockout is an
extremely comfortable place to just

430
00:21:04.200 --> 00:21:06.660
kind of drop in. So
you really kind of poured

431
00:21:06.660 --> 00:21:10.800
it, didn't you? Oh yeah.
We, we use TypeScript and

432
00:21:10.830 --> 00:21:13.830
port it from the WPF
implementation that we did directly

433
00:21:13.830 --> 00:21:17.520
into enter TypeScript. Olivia did
that over the course of,

434
00:21:17.760 --> 00:21:20.730
I guess a week or
so. And he's amazed at

435
00:21:20.730 --> 00:21:24.720
it's basically a line-by-line port
and the binding engine that

436
00:21:24.720 --> 00:21:27.570
knockout provides is very similar
to WVF. Maybe it's a

437
00:21:27.570 --> 00:21:29.130
little bit better, cause it's
a bit more modern, a

438
00:21:29.130 --> 00:21:32.460
bit more lightweight, HTML and
CSS is a very good

439
00:21:32.550 --> 00:21:36.360
rendering toolkit. And it's very
fast. That's interesting that you

440
00:21:36.360 --> 00:21:39.750
use TypeScript. I joke in
a talk, but as with

441
00:21:39.750 --> 00:21:42.990
all jokes, there is truth
that a TypeScript is what

442
00:21:42.990 --> 00:21:48.600
a C sharp programmer wishes
JavaScript was. Yeah, absolutely. We

443
00:21:48.960 --> 00:21:51.660
a lot. So we've done
work in HTML apps and

444
00:21:51.690 --> 00:21:55.140
w fats and all sorts
of different things over Adaptive's

445
00:21:55.140 --> 00:21:58.350
history, but that our own
individual careers as programmers. And

446
00:21:58.350 --> 00:22:00.330
one of the things we've
been struggling with a little

447
00:22:00.330 --> 00:22:05.010
bit is how to build
large applications and HTML and

448
00:22:05.010 --> 00:22:08.580
JavaScript when you don't have
inherent structure in your development.

449
00:22:08.970 --> 00:22:12.090
So if you've got 10,
15, 20 developers building an

450
00:22:12.090 --> 00:22:15.660
application that has five, six,
seven different functional components, and

451
00:22:15.660 --> 00:22:17.820
you know that the investment
is going to last for

452
00:22:18.180 --> 00:22:21.210
five to 10 years, you
have a very large concern

453
00:22:21.210 --> 00:22:23.550
about code policy from day
one because you know, this

454
00:22:23.750 --> 00:22:25.890
stuff is going to be
around forever. So you want,

455
00:22:26.460 --> 00:22:30.810
you want strong typing. You
want structure and TypeScript enables

456
00:22:30.810 --> 00:22:32.700
us to get all those
things and kind of opt

457
00:22:32.700 --> 00:22:34.680
in and opt out of
JavaScript when we want to.

458
00:22:34.920 --> 00:22:36.960
But overall have a really
nice structure for how we

459
00:22:36.960 --> 00:22:39.660
build our applications. So that
the idea of strong typing

460
00:22:39.660 --> 00:22:42.930
that safety net was important
because you're in finance. No,

461
00:22:42.930 --> 00:22:45.510
not because of them finances
because the scale of the

462
00:22:45.510 --> 00:22:48.600
applications we know are large
and aren't going to go

463
00:22:48.600 --> 00:22:53.190
away. And that the developers
are many and varied who

464
00:22:53.190 --> 00:22:56.100
will be working on the
project. So compilation I'd like

465
00:22:56.100 --> 00:22:58.650
to say, compilation is the
first unit test. It was

466
00:22:58.650 --> 00:23:02.100
this, this safety net that
was type safety offered. Yeah,

467
00:23:02.640 --> 00:23:04.770
Absolutely. And the ability to
refactor and be confident that

468
00:23:04.770 --> 00:23:06.450
you've caught all the places
where you might've broken a

469
00:23:06.450 --> 00:23:10.680
contract. And at the, at
the protocol layer, coming back

470
00:23:10.680 --> 00:23:13.350
down the protocol area, your
WPF app and your JavaScript

471
00:23:13.350 --> 00:23:16.710
app, both talk signal are
to a back end reactive

472
00:23:17.310 --> 00:23:20.490
server basically. And these, they
speak the exact same thing

473
00:23:20.850 --> 00:23:24.480
and you move right off
the wire into the internal

474
00:23:24.480 --> 00:23:28.410
message bus quickly as possible.
So the signal R is

475
00:23:28.410 --> 00:23:31.140
really at the lowest level
and it's Yup. So we're

476
00:23:31.140 --> 00:23:34.500
pushing Jason back and forth
across signal R and the

477
00:23:34.590 --> 00:23:37.650
common path. So these prices
that are taking, which happened

478
00:23:37.650 --> 00:23:40.980
many, many times a second,
we've optimized that Jason down

479
00:23:40.980 --> 00:23:43.530
to use sort of optimization
you can do with Jason,

480
00:23:43.530 --> 00:23:46.730
which is just use shorter
strings. Then the next step

481
00:23:46.730 --> 00:23:48.830
would be to, to rip
that out and have a

482
00:23:48.830 --> 00:23:52.910
binary representation. And then the
next level of sophistication after

483
00:23:52.910 --> 00:23:55.240
that, which we haven't got
to in reactive trader. And

484
00:23:55.250 --> 00:23:58.070
I don't know if we
will, as to send just

485
00:23:58.070 --> 00:24:00.950
deltas. So just the parts
of the message that changed

486
00:24:00.950 --> 00:24:04.330
that fully described a price,
Assuming that the network latency

487
00:24:04.330 --> 00:24:05.800
and the nut size of
the message in the network

488
00:24:05.800 --> 00:24:09.160
is in fact. Sure. So
we find that even though

489
00:24:09.190 --> 00:24:12.370
a lot of the clients
are, a lot of people

490
00:24:12.380 --> 00:24:15.730
are sitting in and very,
very nice high bandwidth environments.

491
00:24:15.730 --> 00:24:18.790
There's still clients in Vietnam
who are important, people who

492
00:24:18.790 --> 00:24:20.590
were sitting on on the
end of a very long

493
00:24:20.590 --> 00:24:22.930
line of copper, or maybe
not even on copper, maybe

494
00:24:22.930 --> 00:24:25.810
sitting on a three G
or four G connection that

495
00:24:25.810 --> 00:24:27.610
their whole office is using.
And so we need to

496
00:24:27.610 --> 00:24:29.200
be very conscious of the
amount of data we're sending

497
00:24:29.200 --> 00:24:32.060
over the wire. So then
something like be sawn or

498
00:24:32.060 --> 00:24:35.260
binary. Jason might be a
future optimization and then a

499
00:24:35.260 --> 00:24:38.920
Delta over binary. Jason. Absolutely.
That's exactly the sort of

500
00:24:39.130 --> 00:24:41.230
investigation we would do. And
we need to be very

501
00:24:41.230 --> 00:24:43.510
sympathetic to what the middleware
is doing. So we'd need

502
00:24:43.510 --> 00:24:46.840
to look into signal RNC,
how much hitters it seems

503
00:24:46.840 --> 00:24:48.970
with each message. Maybe there's
something that we could, we

504
00:24:48.970 --> 00:24:51.580
could use more closely to
get it, to work nicely

505
00:24:51.580 --> 00:24:53.560
all up and down the
stack. Yeah. And definitely it's

506
00:24:53.560 --> 00:24:55.930
interesting when you're optimizing things
that things are getting so

507
00:24:55.930 --> 00:24:59.020
tight right now that the
size of the HTP headers

508
00:24:59.020 --> 00:25:01.930
may in fact be larger
than the body you really

509
00:25:01.930 --> 00:25:04.420
want to optimize was web
sockets. Of course, once you

510
00:25:04.420 --> 00:25:07.000
start that connection and you
can be just a few

511
00:25:07.000 --> 00:25:10.060
bites. Absolutely. So we would
move to WebSockets as quickly

512
00:25:10.060 --> 00:25:13.510
as possible. And in fact,
reactive trader starts up downloads,

513
00:25:14.170 --> 00:25:17.800
JavaScript, HTML, and CSS from
the website, and then switches

514
00:25:17.800 --> 00:25:19.900
immediately over to a web
socket connection. So there's no

515
00:25:19.900 --> 00:25:22.510
rest API behind any of
us. It's all web sockets.

516
00:25:22.950 --> 00:25:25.690
All of them are WebSocket
service calls. And that's the

517
00:25:25.690 --> 00:25:28.570
way we think everyone will
be writing these applications in

518
00:25:28.570 --> 00:25:31.330
the future. Because once you
have a connection running, you

519
00:25:31.330 --> 00:25:35.020
don't need to go about
establishing that TCP handshake all

520
00:25:35.020 --> 00:25:36.820
over again. If you've already
got, you've got an active

521
00:25:36.820 --> 00:25:38.860
connection and a duplex pipe
that lets you send things

522
00:25:38.860 --> 00:25:41.620
back and forth really easily.
And you did your, your

523
00:25:41.620 --> 00:25:44.860
windows app in WPF. And
I think WPF sometimes gets

524
00:25:44.860 --> 00:25:47.830
a bad name just because
there haven't been a whole

525
00:25:47.830 --> 00:25:50.500
series of updates to WPF.
I'm curious why you didn't

526
00:25:50.500 --> 00:25:53.140
do a windows eight Fullscreen
app and what your opinion

527
00:25:53.140 --> 00:25:55.900
is about WPF in for
this kind of app. Sure.

528
00:25:55.900 --> 00:25:58.450
So we actually do have
a windows Fullscreen app where

529
00:25:58.480 --> 00:26:01.090
once we've written the WPF
app, which was kind of

530
00:26:01.090 --> 00:26:02.620
our bread and butter bread
and butter and where we

531
00:26:02.620 --> 00:26:05.860
went first, we started porting
it to other platforms. So

532
00:26:05.860 --> 00:26:08.500
we've got a windows, a
Fullscreen windows store app, and

533
00:26:08.500 --> 00:26:11.050
we're just waiting to do
the last bit of the

534
00:26:11.050 --> 00:26:14.230
last 20%, which will probably
take quite a while to,

535
00:26:14.450 --> 00:26:16.780
to get it up onto
the, onto the windows store.

536
00:26:17.410 --> 00:26:21.130
And we've also started porting
to iOS using Xamarin. So

537
00:26:21.610 --> 00:26:25.720
we're C sharp.net devs first
and foremost, although adaptive as

538
00:26:25.720 --> 00:26:28.870
a consultancy has sort of
the full gamut of technologists

539
00:26:28.870 --> 00:26:32.020
working for it. But we
wanted to learn more about

540
00:26:32.020 --> 00:26:36.490
Xamarin. Cause we see it's
expensive. If you're someone trying

541
00:26:36.490 --> 00:26:40.750
to get an app onto
Android and iOS and windows

542
00:26:40.750 --> 00:26:44.970
phone to rewrite all those
parts of the application over

543
00:26:44.970 --> 00:26:47.010
and over again. And it
seems like Xamarin offers a

544
00:26:47.010 --> 00:26:50.420
really good solution for us.
Yeah, absolutely. And it's very

545
00:26:50.420 --> 00:26:53.210
familiar and the idea that
signal is available on Xamarin

546
00:26:53.210 --> 00:26:55.700
and why you don't have
web sockets directly on iOS,

547
00:26:56.260 --> 00:26:58.760
you can get really, really
close to the same programming

548
00:26:58.760 --> 00:27:02.330
model. Absolutely. And you throw
it up on Azure, it's

549
00:27:02.330 --> 00:27:08.660
up on adaptive, adaptive, reactive
trader.azure websites.net. Yeah. Hopefully people

550
00:27:08.660 --> 00:27:11.120
will be able to play
with it up there. What

551
00:27:11.120 --> 00:27:13.040
are your, what are your
plans for the future? You're

552
00:27:13.040 --> 00:27:14.900
going to put a store
apps in. So you're gonna

553
00:27:14.900 --> 00:27:20.390
have basically four different Store
apps yet iOS, Android, when

554
00:27:20.390 --> 00:27:23.480
those phones to begin with
them, we'll keep going. And

555
00:27:23.480 --> 00:27:25.460
then we're going to try
and pull all the content

556
00:27:25.460 --> 00:27:27.410
together into one place and
kind of try and improve,

557
00:27:27.440 --> 00:27:30.080
improve the story about event
driven, user interfaces and event

558
00:27:30.080 --> 00:27:35.480
driven programming and document more
our mistakes. I guess we've

559
00:27:35.510 --> 00:27:37.610
been doing this stuff for
10 years. We've made a

560
00:27:37.610 --> 00:27:40.130
lot of mistakes and it's
fun to talk about them

561
00:27:40.130 --> 00:27:42.680
and share what we think
is best practice. And also

562
00:27:42.680 --> 00:27:47.000
have the conversation that financial
financial services isn't a secret

563
00:27:47.000 --> 00:27:50.360
place, but because of the
concerns about IP and how

564
00:27:50.360 --> 00:27:54.590
people don't like to talk
about what they're doing, people

565
00:27:54.710 --> 00:27:56.990
don't get to see these
sorts of applications and why

566
00:27:56.990 --> 00:27:59.510
not. They're fun. It's a
cool technical challenge to, to

567
00:27:59.510 --> 00:28:02.090
think about these sorts of
the sort of data and

568
00:28:02.480 --> 00:28:05.690
this much reactivity. And I
think we'll see more and

569
00:28:05.690 --> 00:28:10.130
more users wanting this sort
of responsiveness and they're in

570
00:28:10.130 --> 00:28:12.440
their shopping carts, right? Why
shouldn't, if we're both logged

571
00:28:12.440 --> 00:28:14.150
into a website, why couldn't
I put something in your

572
00:28:14.150 --> 00:28:15.740
cart and you put something
in mind and have it

573
00:28:15.740 --> 00:28:18.220
appear straight away. That seems
like a fun thing for

574
00:28:18.230 --> 00:28:19.490
software to be able to
do in this day and

575
00:28:19.490 --> 00:28:21.350
age. I think the other
thing that's so nice about

576
00:28:21.350 --> 00:28:23.420
this, and it's so generous
for you to release such

577
00:28:23.420 --> 00:28:26.180
a large amount of code
is that it's, it's real.

578
00:28:26.300 --> 00:28:31.940
It is nontrivial. And it's
really a very tidy, you

579
00:28:31.940 --> 00:28:34.940
know, as, as code looks,
it's like, there's a little

580
00:28:34.940 --> 00:28:37.340
imposing and you go, Oh
my goodness. There's like nine

581
00:28:37.340 --> 00:28:40.160
projects here, but it's very
clean. It's very well factored.

582
00:28:40.160 --> 00:28:42.680
It's very, very organized and
it was very easy to

583
00:28:42.680 --> 00:28:44.390
follow. And I noticed also
one of the things that

584
00:28:44.390 --> 00:28:46.820
was kind of interesting is
that you drop some link

585
00:28:46.820 --> 00:28:50.870
pad example queries into the
source code as well. Yeah.

586
00:28:51.380 --> 00:28:54.710
So this is us taking
reactive and event driven programming

587
00:28:54.710 --> 00:28:57.410
to kind of the next
next level, I guess. So

588
00:28:57.410 --> 00:29:02.000
reactive domain models are something
we we've started building and

589
00:29:02.000 --> 00:29:03.680
it's something that we're getting
a lot of traction with.

590
00:29:03.680 --> 00:29:07.040
So this is the idea
that we're all kind of

591
00:29:07.040 --> 00:29:10.160
used to, or we're starting
to become used to asynchronous

592
00:29:10.190 --> 00:29:12.740
service calls. So you make
a call, you get back

593
00:29:12.740 --> 00:29:15.350
and observable or, or a
task. And you know that

594
00:29:15.360 --> 00:29:17.360
the result is going to
come sometime in the future.

595
00:29:17.840 --> 00:29:20.480
But we still have, I
guess you could say synchronous

596
00:29:20.480 --> 00:29:24.860
domain models. So customer dot,
name dot last name, you

597
00:29:24.860 --> 00:29:27.770
know, all this sort of
stuff, but actually what's underlying

598
00:29:27.770 --> 00:29:30.290
that, and this is an
observable or reactive domain model.

599
00:29:30.650 --> 00:29:32.330
So what, that's, what you
can see in that little

600
00:29:32.360 --> 00:29:34.070
link pad strip, where we
go off to the backend

601
00:29:34.070 --> 00:29:36.020
and say, give me all
the currency pairs that I

602
00:29:36.020 --> 00:29:39.500
can, I can look at,
find me the Euro USD

603
00:29:39.500 --> 00:29:43.420
currency pair, give me the
price stream on that currency

604
00:29:43.450 --> 00:29:46.090
here. Tell me when the
price is above or below

605
00:29:46.090 --> 00:29:48.520
a certain rate and then
execute an order. And that

606
00:29:48.520 --> 00:29:52.600
is five lines of query
comprehension, syntax, and a link

607
00:29:52.600 --> 00:29:55.090
pad script. And it reads
and does exactly what it

608
00:29:55.090 --> 00:29:57.130
says. Business users can read
it, but all of it

609
00:29:57.130 --> 00:30:00.550
say synchronous, which is pretty
cool. And that's that level

610
00:30:00.550 --> 00:30:03.250
of asynchrony and being able
to embrace it and use

611
00:30:03.250 --> 00:30:06.880
it for even the most
trivial of truly trivial parts

612
00:30:06.880 --> 00:30:10.120
of your application. Whereas before
the complexity of the asynchrony

613
00:30:10.120 --> 00:30:11.980
would be something you'd say,
Oh, I'm just going to

614
00:30:11.980 --> 00:30:13.630
block here and not worry
about it. I don't have

615
00:30:13.960 --> 00:30:16.180
10 days to do this
properly. I need to get

616
00:30:16.180 --> 00:30:18.400
the job done. Now you
can just put it everywhere

617
00:30:18.430 --> 00:30:21.400
and use it elegantly. And
it leads to really nice

618
00:30:21.400 --> 00:30:24.250
API APIs. So if you
are, I would really encourage

619
00:30:24.250 --> 00:30:28.930
your listeners to download reactive
trader open up link pad

620
00:30:28.960 --> 00:30:31.030
and just start playing around
with the API that we've

621
00:30:31.030 --> 00:30:33.100
got, that we've built the
application on and they can

622
00:30:33.100 --> 00:30:35.560
go and write a command
line, react of trader and

623
00:30:36.070 --> 00:30:38.440
probably an hour. I guess
they could list out the

624
00:30:38.440 --> 00:30:40.960
currency pairs, pick one that
they want to trade against.

625
00:30:40.990 --> 00:30:43.510
Just update the prices into
the console into when they

626
00:30:43.510 --> 00:30:46.630
want to buy or sell.
That's pretty cool. The API

627
00:30:46.630 --> 00:30:49.450
is going to lead them
down the road of success,

628
00:30:49.450 --> 00:30:51.040
get them to fall into
the pit of success, I

629
00:30:51.040 --> 00:30:54.460
guess, because the API will
only expose the different operations

630
00:30:54.460 --> 00:30:56.950
they can perform when they've
got the right data. And

631
00:30:56.950 --> 00:31:01.350
when everything's in the appropriate
state, It was a challenge

632
00:31:01.350 --> 00:31:03.360
to the reader right there
to the listeners. I want

633
00:31:03.360 --> 00:31:07.200
to see an ASCII art
version of traitor. We need

634
00:31:07.200 --> 00:31:10.440
to get that done ASAP.
And I have to say

635
00:31:10.440 --> 00:31:12.390
it is it's very well
factored. And I think your

636
00:31:12.390 --> 00:31:14.490
point of being able to
go in and write queries

637
00:31:14.490 --> 00:31:17.340
over the top of this
API with, with respect to

638
00:31:17.340 --> 00:31:20.520
Arthur, C Clark, I like
to say that any sufficiently

639
00:31:20.520 --> 00:31:24.180
well factored layer of abstraction
is indistinguishable from magic. And

640
00:31:24.540 --> 00:31:26.550
we've definitely pulled that off.
Thank you so much, Matt

641
00:31:26.550 --> 00:31:29.940
Barrett for chatting with me
today, from the folks who

642
00:31:29.940 --> 00:31:33.450
made a reactive trader adaptive
consulting, I'm going to put

643
00:31:33.480 --> 00:31:36.420
links to everything in the
show notes. You can go

644
00:31:36.420 --> 00:31:39.210
and get this at get
hub slash adaptive consulting. There's

645
00:31:39.210 --> 00:31:43.680
a video, there's a complete
walkthrough, it's fantastic stuff, and

646
00:31:43.680 --> 00:31:46.050
a really, really great way
to learn reactive. So thank

647
00:31:46.050 --> 00:31:49.980
you so much for your
time. This has been another

648
00:31:49.980 --> 00:31:53.070
episode of Hanselminutes and we'll
see you again next week.


WEBVTT FILE

1
00:00:12.180 --> 00:00:17.520
From hanselminutes.com. It's Hansel minutes.
Oh, weekly discussion with web

2
00:00:17.520 --> 00:00:22.080
developer and technologists. Scott Hanselman.
This is Lawrence Ryan announcing show

3
00:00:22.080 --> 00:00:28.470
number three 94. Recorded live
Thursday, October 17th, 2013. This episode of

4
00:00:28.470 --> 00:00:31.260
Hansel minutes is brought to
you by cellaring offering the

5
00:00:31.260 --> 00:00:40.350
best in developer tools and
support online@telerikdotcomandbyfranklins.net makers of gesture

6
00:00:40.350 --> 00:00:44.340
pack a powerful gesture, recording
and recognition system for Microsoft

7
00:00:44.340 --> 00:00:50.460
connect for windows developers details.
Add gesture, pa.com. In this

8
00:00:50.460 --> 00:00:54.330
episode, Scott talks with Diane Marsh
about the rise of Scala.

9
00:00:57.180 --> 00:00:59.190
Hi, this is Scott Hanselman.
This is another episode of

10
00:00:59.190 --> 00:01:02.940
Hansel minutes, and I'm talking
to Diane Marsh from Netflix director

11
00:01:02.940 --> 00:01:05.940
of engineering for cloud tools.
Thanks for chatting with me

12
00:01:05.940 --> 00:01:09.390
today. Thanks Scott. Glad to
be here. I was really

13
00:01:09.390 --> 00:01:12.600
happy to have another Netflix
person on I talking about

14
00:01:12.600 --> 00:01:15.720
groovy on grails a couple
of weeks ago, clay McCoy,

15
00:01:16.620 --> 00:01:18.840
but you are a Scala
fan. Talk to me about

16
00:01:18.840 --> 00:01:21.330
Scala. That sounds really like
I need a PhD to

17
00:01:21.330 --> 00:01:26.870
use. Well, funny you say
that because that has sort

18
00:01:26.870 --> 00:01:30.350
of been the myth perpetuated
in the community over the

19
00:01:30.350 --> 00:01:32.930
last couple of years. I
think it's starting to change

20
00:01:33.950 --> 00:01:37.640
is, you know, I, I
approached Bruce Eckel about writing

21
00:01:37.640 --> 00:01:41.090
a book about Scala a
few years ago for the

22
00:01:41.090 --> 00:01:45.710
sole purpose of helping to
debunk that myth we had,

23
00:01:45.740 --> 00:01:48.080
we had been hearing over
and over and over again,

24
00:01:48.080 --> 00:01:52.280
scholars hard it's it's too
terse. It's too Pearl. Like,

25
00:01:52.580 --> 00:01:56.510
and that hadn't been my
experience at all. So I'm

26
00:01:56.510 --> 00:01:58.430
friends with Bruce Eckel and
I, I was at a

27
00:01:58.430 --> 00:02:00.530
conference with him and I
S I just approached him

28
00:02:00.530 --> 00:02:02.540
and said, what do you
think about me writing a,

29
00:02:03.260 --> 00:02:07.190
a book on introduction to
Scala, sort of letting people

30
00:02:07.190 --> 00:02:09.470
know the scholar is not
hard and showing them my

31
00:02:09.470 --> 00:02:12.200
experience. And he paused for
a moment. And he said,

32
00:02:12.620 --> 00:02:14.960
I'd like to help you
write that book, which was,

33
00:02:15.050 --> 00:02:17.930
I know incredibly generous, you
know, I wasn't really where

34
00:02:17.930 --> 00:02:21.740
I was going, but wow.
Blown over by the suggestion

35
00:02:21.740 --> 00:02:24.410
and by the generosity, right.
And people who don't know

36
00:02:24.410 --> 00:02:27.620
who Bruce Bruce echo is. He
is the author of thinking

37
00:02:27.620 --> 00:02:31.310
in Java and thinking in
C plus plus. And I

38
00:02:31.310 --> 00:02:33.500
might go so far as
to say thinking in curly

39
00:02:33.500 --> 00:02:37.010
braces. So I'm surprised he
was so enthusiastic about a

40
00:02:37.610 --> 00:02:41.180
scholar. I mean, I know
he's a programming language enthusiastic

41
00:02:41.210 --> 00:02:44.810
and has done lots of
lectures and is arguably agnostic

42
00:02:44.840 --> 00:02:49.700
in his understanding of, and
belief in the programming languages.

43
00:02:49.730 --> 00:02:53.360
But wouldn't you say that
that Java, Java and C

44
00:02:53.360 --> 00:02:56.000
plus plus, and those kinds
of languages are different than

45
00:02:56.000 --> 00:02:59.530
scholar, scholar feels different? It's
it is more perlite and

46
00:02:59.530 --> 00:03:05.020
it has, it, it, it's
not either of those languages.

47
00:03:05.550 --> 00:03:08.130
I think it's on the
evolutionary scale. I think what

48
00:03:08.130 --> 00:03:12.510
we're seeing is that programmers
like me started with C

49
00:03:12.510 --> 00:03:14.490
and moved to C plus
plus, and then moved to

50
00:03:14.490 --> 00:03:18.570
Java and, you know, played
and toyed with, with C-sharp

51
00:03:18.570 --> 00:03:20.790
for awhile, because I thought
that was fun and interesting,

52
00:03:21.060 --> 00:03:24.180
but I really found my
home in Scala, where I

53
00:03:24.180 --> 00:03:29.160
found that the, the expressiveness
of the language, the fact

54
00:03:29.190 --> 00:03:31.500
that I don't have to
write all the boiler plate

55
00:03:31.500 --> 00:03:36.540
code relieved me of a
lot of the annoyances of

56
00:03:36.540 --> 00:03:38.910
writing in a language that
was developed a very long

57
00:03:38.910 --> 00:03:41.670
time ago. So you think
that it's some of the

58
00:03:41.670 --> 00:03:45.570
historical baggage that, that causes
us problems as we try

59
00:03:45.570 --> 00:03:48.690
to solve new problems in
languages that were, that have

60
00:03:48.840 --> 00:03:52.740
like 40 years of curly
brace baggage. I think what,

61
00:03:53.280 --> 00:03:55.590
well, so I have some
strong opinions about this. I

62
00:03:55.590 --> 00:04:00.210
think that some of the
newer developers come to us

63
00:04:00.240 --> 00:04:04.530
having learned Java in college
and having used Java in

64
00:04:04.530 --> 00:04:07.260
their jobs for years and
years and years, and never

65
00:04:07.260 --> 00:04:11.850
having experienced the migration to
a new programming language. I

66
00:04:11.850 --> 00:04:16.770
think that they've forgotten that
Java the language today is

67
00:04:16.770 --> 00:04:19.290
not the same language that
they learned in college. It's

68
00:04:19.290 --> 00:04:22.470
evolved with them. They've grown
with it. They've learned how

69
00:04:22.470 --> 00:04:25.890
to bring in libraries that
did amazingly great things and

70
00:04:25.890 --> 00:04:29.670
made their lives simpler. So
they've sort of eased into

71
00:04:29.670 --> 00:04:33.060
the language, but it was
still called Java. So you

72
00:04:33.060 --> 00:04:35.760
put a new language in
front of them, Scala, and

73
00:04:35.760 --> 00:04:39.600
you add a functional programming
paradigm on top of that.

74
00:04:39.780 --> 00:04:43.170
And now it seems really
scary and different. And I

75
00:04:43.170 --> 00:04:46.140
think that part of the
problem is that we've sort

76
00:04:46.140 --> 00:04:49.890
of, as an industry, lost
our muscle in learning new

77
00:04:49.890 --> 00:04:52.140
languages. And I feel like
that's part of the problem

78
00:04:52.140 --> 00:04:56.220
here. It's different, it's new
and it's scary. And then

79
00:04:56.220 --> 00:04:58.200
when we add the functional
aspects on top of that,

80
00:04:58.350 --> 00:05:01.500
it gets even more scary,
right? When someone looks at

81
00:05:01.500 --> 00:05:04.740
scholar, remembering, of course that
we're on a podcast, you

82
00:05:04.740 --> 00:05:06.360
know, what, what are they
going to see if they

83
00:05:06.360 --> 00:05:08.520
don't know that scholar exists?
Are they going to say,

84
00:05:08.550 --> 00:05:10.320
Oh, it looks like Python
or, Oh, but that doesn't

85
00:05:10.320 --> 00:05:12.450
look right. That's not Python.
I mean, what does it

86
00:05:12.810 --> 00:05:16.530
feel and look like visually.
Yeah, I guess it probably

87
00:05:16.530 --> 00:05:21.030
looks a little bit like
Python. It looks a little

88
00:05:21.030 --> 00:05:25.920
bit like Java. Some things
are a little bit disconcerting

89
00:05:25.980 --> 00:05:32.070
about it because the, the
variable declarations, so the, the

90
00:05:32.070 --> 00:05:34.380
type of the variable follows
the name of the variable.

91
00:05:34.380 --> 00:05:40.290
So it's, it's variable name,
colon type, and which really

92
00:05:40.290 --> 00:05:44.610
helps with type inference. Right?
So what you're buying is

93
00:05:44.640 --> 00:05:47.640
type inference and what your,
the, the cost of that

94
00:05:47.640 --> 00:05:50.550
is, you're seeing it slightly
different syntax. Is that required

95
00:05:50.670 --> 00:05:52.950
if I sort of VAR
foo, do I have to

96
00:05:52.950 --> 00:05:57.060
say colon title? No, you
don't. In fact, most of,

97
00:05:57.830 --> 00:05:59.750
most of the time when
you're writing Scala code, you

98
00:05:59.750 --> 00:06:04.130
won't necessarily define the type
you'll normally use type inference

99
00:06:04.310 --> 00:06:07.460
where you'll see the types
is mainly when you're defining

100
00:06:08.450 --> 00:06:12.140
either classes or in your,
and you're talking about the

101
00:06:12.170 --> 00:06:16.370
arguments or the parameters for
that class, or when you're

102
00:06:16.370 --> 00:06:20.270
defining methods on that class,
you'll see the types for

103
00:06:20.270 --> 00:06:23.630
methods. And you'll see the
types for class definitions. You'll

104
00:06:23.630 --> 00:06:27.710
also not see a constructor
because the, well, it won't

105
00:06:27.710 --> 00:06:29.900
look like you're seeing a
constructor because when you say

106
00:06:29.900 --> 00:06:35.840
class Fu and then parentheses,
and you, you list out

107
00:06:35.840 --> 00:06:41.720
your parameters that becomes your
class definition, and it buys

108
00:06:41.720 --> 00:06:44.150
you a lot of things.
It means that if you

109
00:06:44.150 --> 00:06:49.130
have variables, defined parameters defined
to that class, those become

110
00:06:49.850 --> 00:06:55.550
either private or public fields
in that class, depending on

111
00:06:55.550 --> 00:06:58.640
how you've defined them. So
you get your getters and

112
00:06:58.640 --> 00:07:02.240
setters for free, for example.
And so this is something

113
00:07:02.240 --> 00:07:04.310
that just needs to be
pointed out to you once

114
00:07:04.310 --> 00:07:08.210
you see it. It's really
cool. You may look past

115
00:07:08.210 --> 00:07:11.320
it though and not see
it initially. I see. So

116
00:07:11.320 --> 00:07:14.050
in something like Java or
C sharp, I'll say public

117
00:07:14.050 --> 00:07:17.860
class point and then have
private X and Y, and

118
00:07:17.860 --> 00:07:19.240
then have to go and
hook up the getters and

119
00:07:19.240 --> 00:07:22.690
setters for the public properties
of X and Y. But

120
00:07:22.690 --> 00:07:25.810
in Scala, I just say
class point and then Val

121
00:07:25.810 --> 00:07:30.280
X, Val Y, and I
just had 10 less lines

122
00:07:30.280 --> 00:07:33.310
of code. Really? Yeah. And
so it may seem subtle,

123
00:07:33.310 --> 00:07:36.280
but when you said Val
X fail, why now you

124
00:07:36.280 --> 00:07:39.940
get just the setters and
those, those are immutable variables.

125
00:07:40.260 --> 00:07:43.540
You say VAR, X and
VAR. Why now you've got

126
00:07:44.410 --> 00:07:49.630
variables and those become those,
those defined both getters and

127
00:07:49.630 --> 00:07:54.220
setters. Wow. That is a
subtle one letter change. Their

128
00:07:54.220 --> 00:07:59.140
valve versus VAR has completely
huge semantics that kind of

129
00:07:59.170 --> 00:08:02.380
ripple through the system. If
you leave it off entirely,

130
00:08:02.560 --> 00:08:06.520
then what you're getting is
private fields. Really. So if

131
00:08:06.520 --> 00:08:10.120
I just say foo equals
one, that's just a private

132
00:08:10.120 --> 00:08:12.720
and it's, it's kind of
inside of the class and

133
00:08:12.740 --> 00:08:15.400
scope to the class. Yeah.
So if you say class

134
00:08:15.610 --> 00:08:21.670
bar X, colon it, for
example, then that access private

135
00:08:21.670 --> 00:08:24.700
to that class. So it
doesn't seem like it's as

136
00:08:24.700 --> 00:08:27.190
verbose as, as, and again,
I kind of think about

137
00:08:27.190 --> 00:08:29.860
the sea heritage of languages.
You know, if you look

138
00:08:29.860 --> 00:08:33.610
at an example, a program
in Java, the scholar, one

139
00:08:33.610 --> 00:08:38.020
is about two thirds of
the size Or less, maybe

140
00:08:38.020 --> 00:08:42.250
one 30, even it's significantly
less than size. You just,

141
00:08:42.840 --> 00:08:45.190
even to the point where,
you know, in Java, if

142
00:08:45.190 --> 00:08:48.640
you're declaring a variable, you
have to declare the type

143
00:08:48.640 --> 00:08:50.530
on both the left hand
side and the right hand

144
00:08:50.530 --> 00:08:52.630
side. Right. You're doing it
on the right hand side.

145
00:08:52.630 --> 00:08:54.820
You're declaring the type on
the left hand side in,

146
00:08:55.320 --> 00:09:00.240
you're just saying VAR, blah
equals list one, two, three.

147
00:09:01.020 --> 00:09:04.260
Right? So you're, you're not,
you're only saying list once

148
00:09:04.500 --> 00:09:07.800
on the right hand side,
for example, they're even simpler

149
00:09:07.800 --> 00:09:12.570
ways to do things like
that. So lots of verbosity

150
00:09:12.570 --> 00:09:15.630
is removed from the language
and you do get to

151
00:09:15.630 --> 00:09:20.150
leave off your semi-colons. So,
Oh, don't, don't tell Douglas

152
00:09:20.150 --> 00:09:24.560
Crockford. So this, the, the
semantics are there though you've

153
00:09:24.560 --> 00:09:28.790
removed the, the, the, the
sugar, but the meaning is

154
00:09:28.790 --> 00:09:33.440
still there. Right? And it
does compile down to Java

155
00:09:33.440 --> 00:09:35.750
byte code. So what you're
getting at the end of

156
00:09:35.750 --> 00:09:39.980
the day is an application
that runs on the JVM,

157
00:09:40.760 --> 00:09:45.230
and you're getting a lot
of compatibility with other languages

158
00:09:45.230 --> 00:09:48.170
that are on the JVM,
calling into other languages from

159
00:09:48.170 --> 00:09:52.730
Scala, calling Java, from Scala,
Scala, from Java. There's some

160
00:09:52.730 --> 00:09:55.160
tricky things that you need
to be aware of when

161
00:09:55.160 --> 00:09:58.340
you do that. But, you
know, for the most part,

162
00:09:58.340 --> 00:10:00.380
that's something that you can
do, and you can kind

163
00:10:00.380 --> 00:10:05.030
of sort of evolve your
code in your libraries to

164
00:10:05.030 --> 00:10:07.730
reflect the fact that you're
using a new language, but

165
00:10:07.730 --> 00:10:10.760
you don't have to go
wholesale and rewrite everything. Interesting.

166
00:10:10.760 --> 00:10:13.010
So if I'm doing a
lot of type inference, and

167
00:10:13.010 --> 00:10:15.560
then suddenly I reach a
border, a boundary where I

168
00:10:15.560 --> 00:10:18.350
have to move into some
Java or some existing Java

169
00:10:18.350 --> 00:10:20.750
classes that I've already written,
you know, what do I

170
00:10:20.750 --> 00:10:23.030
have to do? Do I
have to say as instance

171
00:10:23.030 --> 00:10:25.970
of, and then kind of
cast my dynamics down into

172
00:10:25.970 --> 00:10:30.170
something that Java's going to
understand? No, because you're using

173
00:10:30.170 --> 00:10:33.800
the Scala compiler, you're able
to bring in those classes

174
00:10:33.830 --> 00:10:39.710
without, in, in sort of
a native Scala syntax. The

175
00:10:39.770 --> 00:10:42.680
only difference is that, you
know, you're, you're bringing in

176
00:10:42.680 --> 00:10:47.240
Java classes, so you may
run into some boundaries around

177
00:10:47.270 --> 00:10:50.180
no pointer exceptions, which we
wouldn't normally see in Scala.

178
00:10:50.480 --> 00:10:51.950
So, you know, you just
have to be a little

179
00:10:51.950 --> 00:10:55.190
bit careful about that, but
as far as your you're

180
00:10:55.190 --> 00:10:57.830
importing a Java class in
the same way that you

181
00:10:57.830 --> 00:11:00.980
would import a scholar. Okay.
So that's on the consumption

182
00:11:00.980 --> 00:11:04.310
side where a Scala class
wants to consume Java. What

183
00:11:04.310 --> 00:11:06.950
about if Java wants to
consume Scala? Do I have

184
00:11:06.950 --> 00:11:10.130
to then add the annotations
and type annotations at that

185
00:11:10.130 --> 00:11:13.010
layer? Yeah. Then you're in
Java codes, then you're going

186
00:11:13.010 --> 00:11:16.190
to have to follow all
of the Java, the Java

187
00:11:16.190 --> 00:11:19.640
restrictions about what your, you
know, how you bring in

188
00:11:19.640 --> 00:11:24.350
the scholar classes. But Java
arguably doesn't know, it doesn't

189
00:11:24.350 --> 00:11:27.470
really care. It doesn't no,
it's the same as bringing

190
00:11:27.470 --> 00:11:31.210
in any other JVM language.
Okay. So you can, and

191
00:11:31.210 --> 00:11:33.140
I understand that you could
even, I mean, this is

192
00:11:33.470 --> 00:11:37.100
operationally, it behaves like Java
cause ultimately is Java it's

193
00:11:37.100 --> 00:11:39.050
in the JVM. And as
far as the JVM is

194
00:11:39.050 --> 00:11:44.660
concerned, Scala code Java code
is not distinguishable. That's right.

195
00:11:44.660 --> 00:11:49.520
And then, yeah. So one
of the, the things that

196
00:11:49.520 --> 00:11:53.060
you get now is the
ability to be able to

197
00:11:54.070 --> 00:11:56.440
migrate your code, you know,
sort of on a piecemeal

198
00:11:56.440 --> 00:12:00.610
basis, migrate your, write new
code in Scala and, and

199
00:12:00.610 --> 00:12:04.120
leave your old code in
Java. And that's a nice

200
00:12:04.120 --> 00:12:07.480
approach. Some people take sort
of, I think it would

201
00:12:07.480 --> 00:12:12.310
be unrealistic to expect that
people would Greenfield everything right.

202
00:12:12.430 --> 00:12:16.660
And so this is a
really nice step into, into

203
00:12:16.660 --> 00:12:20.650
Scala land. Another really nice
step into Scala land, you

204
00:12:20.650 --> 00:12:23.170
know, to sort of build
confidence in your team around

205
00:12:23.170 --> 00:12:28.030
learning Scala is to use
Scala test and Scala test

206
00:12:28.030 --> 00:12:32.950
is a testing framework that
bill vendors' wrote, and it

207
00:12:32.950 --> 00:12:36.100
allows you to actually test
your Java code using Scala

208
00:12:36.100 --> 00:12:40.720
test. And it's a nice
BDD approach. And it can,

209
00:12:40.750 --> 00:12:43.420
it's a really great framework
in its own, right. But

210
00:12:43.420 --> 00:12:47.770
it also gives your team
sort of some experience with

211
00:12:47.770 --> 00:12:51.640
writing Scala tests where it's
not in production code. You

212
00:12:51.640 --> 00:12:54.160
know, they don't have to
feel concerned about, you know,

213
00:12:54.160 --> 00:12:57.280
jumping wholesale into the language,
but yet they can get

214
00:12:57.280 --> 00:13:00.850
that experience with, with Scala
in, in that sort of

215
00:13:00.850 --> 00:13:06.550
a comfort, comfort level. And
some teams have found that

216
00:13:06.550 --> 00:13:09.310
they liked Scala tests so
much that they've decided to

217
00:13:09.310 --> 00:13:12.100
go into Scala for production
code as well. You know,

218
00:13:12.100 --> 00:13:14.020
sort of, they got that
confidence. They're like, Hey, this

219
00:13:14.020 --> 00:13:17.230
isn't so bad. And, and
you know, that's really what

220
00:13:17.230 --> 00:13:21.130
I've been trying to promote
is the idea that it's,

221
00:13:21.190 --> 00:13:24.880
it's not that scary. And
even if you use Scala

222
00:13:24.910 --> 00:13:28.390
as a better Java, it's
better than Java. You know

223
00:13:28.480 --> 00:13:31.630
what I mean? You know,
I think you probably remember

224
00:13:31.630 --> 00:13:34.270
as I do the biggest
insult you could love yet

225
00:13:34.270 --> 00:13:36.280
someone when they were going
from C to C plus

226
00:13:36.280 --> 00:13:40.180
plus is, Oh, you're still
writing C and you're using

227
00:13:40.180 --> 00:13:42.910
a C plus plus compiler,
you know? And, and so

228
00:13:42.910 --> 00:13:45.100
I think we all feel
a little bruised by that.

229
00:13:45.100 --> 00:13:47.200
Right. And like, we're ready
for the shoe to fall

230
00:13:47.200 --> 00:13:50.080
where people are saying you're
writing Java and using a

231
00:13:50.080 --> 00:13:54.160
scholar compiler. It's okay. Yeah.
Know, I think that people

232
00:13:54.160 --> 00:13:57.250
will, their code will become
more idiomatic as they get

233
00:13:57.250 --> 00:14:00.640
experienced with the language. Yeah.
Even if you don't use

234
00:14:00.640 --> 00:14:04.330
any functional aspects to start,
I have to say that

235
00:14:04.460 --> 00:14:07.270
it's in chanting, you know,
you get more experience with

236
00:14:07.270 --> 00:14:09.310
the language and you, you
learn more about it and

237
00:14:09.310 --> 00:14:12.070
you start saying, gosh, you
know, I could just use

238
00:14:12.100 --> 00:14:15.400
immutable variables here because it's,
it's, it's, the variables are

239
00:14:15.400 --> 00:14:18.730
immutable by default. Right. So
if I start using immutable

240
00:14:18.730 --> 00:14:21.910
variables, then I, I learned
how to restructure my loops

241
00:14:21.910 --> 00:14:24.280
in a different way. And
I learned a, maybe I

242
00:14:24.280 --> 00:14:28.750
start heading down the path
of doing more recursion, you

243
00:14:28.750 --> 00:14:31.000
know, and it sort of
spirits you in and you

244
00:14:31.000 --> 00:14:33.040
learn it at your own
pace. You don't have to

245
00:14:33.040 --> 00:14:35.020
jump in and be like,
all right, I'm all functional

246
00:14:35.020 --> 00:14:38.290
today. You know, you can
really sort of ease yourself

247
00:14:38.290 --> 00:14:42.000
into the whole experience. Yeah.
I think that turning to

248
00:14:42.210 --> 00:14:45.270
learn to learn in another
language is one thing, learning

249
00:14:45.270 --> 00:14:48.300
to write poetry in that
language is another thing. Like

250
00:14:48.660 --> 00:14:52.130
someone asked me how well
I speak Spanish. And I

251
00:14:52.130 --> 00:14:56.510
said, <inaudible> because that's about
how well I speak Spanish.

252
00:14:56.510 --> 00:14:58.310
You know what I mean?
I can order food, but

253
00:14:58.310 --> 00:15:00.530
I am not writing poetry.
And I feel the same

254
00:15:00.530 --> 00:15:02.870
way when I started learning
a new language. Like, you

255
00:15:02.870 --> 00:15:05.870
know, can I order food
and F sharp? Sure. Can

256
00:15:05.870 --> 00:15:09.380
I write poetry in F
sharp? Probably not. But if

257
00:15:09.530 --> 00:15:11.600
the language is structured in
such a way that I

258
00:15:11.600 --> 00:15:13.520
could say, all right, I'm
going to go ahead and

259
00:15:13.640 --> 00:15:17.180
switch from Java for each
loops to the Scala for

260
00:15:17.180 --> 00:15:19.550
expression. And I'm going to
do that in a nonthreatening

261
00:15:19.550 --> 00:15:23.180
way in C sharp. Another
example would be like, you

262
00:15:23.180 --> 00:15:25.550
know, really starting to embrace
link. You can either, you

263
00:15:25.550 --> 00:15:30.470
can write idiomatic tight, clean,
poetic looking link expressions, or

264
00:15:30.470 --> 00:15:32.600
just don't do it at
all. You know, you get

265
00:15:32.600 --> 00:15:34.850
to pick and choose. So
it's good to know that

266
00:15:34.850 --> 00:15:37.820
you don't have to go
whole hog into Scala world.

267
00:15:38.680 --> 00:15:42.550
I think that's a really
great example because I learned

268
00:15:42.550 --> 00:15:46.510
link in C-sharp at sort
of around the same time

269
00:15:46.510 --> 00:15:49.150
that I was learning Scala.
I was sort of playing

270
00:15:49.150 --> 00:15:50.770
with link at the same
time. And I saw a

271
00:15:50.770 --> 00:15:54.610
lot of similarities between the
two. And I found that,

272
00:15:55.150 --> 00:15:58.270
you know, as you learn
those concepts and those, those

273
00:15:58.270 --> 00:16:01.630
idioms about how to use
something like link or, or,

274
00:16:01.640 --> 00:16:05.110
or functional programming in general,
you start applying that to

275
00:16:05.140 --> 00:16:07.090
all of the code that
you write, and you sort

276
00:16:07.090 --> 00:16:10.030
of bring that into your
toolbox. And I think it

277
00:16:10.030 --> 00:16:12.130
makes all of us better
programmers when we can just

278
00:16:12.130 --> 00:16:15.160
have better, better, you know,
different tools that we can

279
00:16:15.160 --> 00:16:18.610
apply in, in situations that
we find them necessary. I

280
00:16:18.610 --> 00:16:21.670
think this is important for
younger programmers and I don't

281
00:16:21.670 --> 00:16:25.330
mean by age, but inexperienced,
younger programmers too. To remember

282
00:16:25.330 --> 00:16:28.180
that there are a class
of programmer out there that

283
00:16:28.180 --> 00:16:31.450
have been writing for loops
and switch statements and wild

284
00:16:31.450 --> 00:16:34.960
loops for 20 years. And,
you know, got a problem.

285
00:16:35.110 --> 00:16:38.770
Let's write three, listed four
loops, and then you show

286
00:16:38.770 --> 00:16:42.170
them something like in using
a four expression example in

287
00:16:42.190 --> 00:16:45.670
scholars, say for something one
to something, if there's a,

288
00:16:45.730 --> 00:16:49.780
you know, a case yield
and then wait a second,

289
00:16:49.780 --> 00:16:52.210
you just took my nested
for loop and turned it

290
00:16:52.210 --> 00:16:55.360
into one line. That's that's
too much. If you can

291
00:16:55.360 --> 00:16:59.080
make that, that semantic jump
out of just kind of

292
00:16:59.080 --> 00:17:03.280
classic procedural, cause you're effectively
writing basic, you know what

293
00:17:03.280 --> 00:17:05.140
I mean? You're writing the
basic that you learned when

294
00:17:05.140 --> 00:17:08.020
you were 13, except now
you're a, you've been an

295
00:17:08.020 --> 00:17:10.930
engineer for 15 years and
you keep writing these same

296
00:17:11.260 --> 00:17:14.350
four loops over and over
and over again, try to

297
00:17:14.350 --> 00:17:17.470
pick one problem and solve
it in an idiomatic way.

298
00:17:17.470 --> 00:17:20.080
And then that's now in
your toolbox and you'll recognize

299
00:17:20.080 --> 00:17:23.260
it in other, in other
languages. Yeah. And then I

300
00:17:23.260 --> 00:17:26.050
think the four expressions are
a great example and you

301
00:17:26.050 --> 00:17:28.570
know, people that are familiar
with link, I think we'll

302
00:17:28.570 --> 00:17:32.410
find four expressions and scholar
quite comfortable because there there's

303
00:17:32.410 --> 00:17:38.020
a nice sort of comparison
there. Another really great thing

304
00:17:38.020 --> 00:17:42.790
in Scala is magic expressions,
magic expressions, take pattern matching,

305
00:17:42.790 --> 00:17:45.820
you know, all the way
to 11 with, with pattern

306
00:17:45.820 --> 00:17:50.820
matching and Scala. It's interesting.
You mentioned that the naive

307
00:17:50.820 --> 00:17:54.900
programmer. I remember when I
first started using case statements,

308
00:17:55.830 --> 00:17:57.780
I guess it must've been,
I don't know whether it

309
00:17:57.780 --> 00:18:00.330
was called case statements and
C or Pascal or whatever,

310
00:18:00.330 --> 00:18:02.130
but you know, sort of
the equivalent of doing pattern

311
00:18:02.130 --> 00:18:05.910
matching back then, I had
this sense that we should

312
00:18:05.910 --> 00:18:08.520
be able to match on
things that weren't ordinal values.

313
00:18:08.520 --> 00:18:10.470
You know, I wanted to
match on all kinds of

314
00:18:10.470 --> 00:18:13.440
things and I was too
naive to realize that I

315
00:18:13.440 --> 00:18:15.830
couldn't do that. So I
tried to do that. And

316
00:18:15.840 --> 00:18:19.230
of course the compiler, you
know, whacked me and said,

317
00:18:19.230 --> 00:18:20.700
you can't do that. You
can, you know, you have

318
00:18:20.700 --> 00:18:23.880
to use ordinal values for
match expression or for in

319
00:18:23.880 --> 00:18:27.360
that case pattern matching scholar
relieves you of that. So

320
00:18:27.360 --> 00:18:29.820
in a sense, it takes
me back to my youth

321
00:18:29.820 --> 00:18:31.950
where, you know, I was
naive enough to think I

322
00:18:31.950 --> 00:18:34.320
should be able to do
this, and now I can,

323
00:18:34.560 --> 00:18:36.840
you know, and so it's,
it's really great to have

324
00:18:36.840 --> 00:18:40.890
features like that emerge in
the language. And, and the

325
00:18:40.890 --> 00:18:42.960
fact, I guess, that's where
I see Scala as part

326
00:18:42.960 --> 00:18:46.620
of the evolutionary scale. There've
been a lot of advances

327
00:18:46.620 --> 00:18:50.850
in language features and a
lot of advances in, in

328
00:18:50.850 --> 00:18:54.000
how we build languages and
how we pull concepts together.

329
00:18:54.660 --> 00:18:57.330
I want the benefit of
that work that's happened over

330
00:18:57.330 --> 00:18:59.760
the last 20 years. I
don't want to stay with

331
00:18:59.760 --> 00:19:02.940
languages that were, you know,
prior to that and the

332
00:19:02.940 --> 00:19:07.160
evolution. Yeah, yeah, yeah. Then
the case classes and pattern

333
00:19:07.160 --> 00:19:10.610
matching and Scala is, does
so much in so few

334
00:19:10.610 --> 00:19:14.120
lines that it, it's one
of those things where I

335
00:19:14.120 --> 00:19:15.770
feel like when you feel
like learning Pearl, where you

336
00:19:15.770 --> 00:19:17.120
just have to stare at
it for a minute and

337
00:19:17.120 --> 00:19:19.580
just wait for the wait
for the knowledge to come,

338
00:19:20.540 --> 00:19:24.170
I saw a quick sort
algorithm done using matches in

339
00:19:24.170 --> 00:19:26.240
cases in Scala. And it
was like six lines of

340
00:19:26.240 --> 00:19:29.750
code. And it's just like,
what is happening here? I

341
00:19:29.750 --> 00:19:32.000
don't, you know what I
mean? There's just so there's

342
00:19:32.000 --> 00:19:35.210
so much in such a
short amount of space. Yeah.

343
00:19:35.210 --> 00:19:38.600
I think what I've been
asking people to think about

344
00:19:38.600 --> 00:19:43.250
is that terseness like, where
is it too much? And

345
00:19:43.250 --> 00:19:45.740
I think it's really important
that your team be able

346
00:19:45.740 --> 00:19:49.300
to read your code. It's
really important that other people

347
00:19:49.330 --> 00:19:51.410
be able to read your
code. And it's really important

348
00:19:51.410 --> 00:19:53.210
that you're able to read
your code when you come

349
00:19:53.210 --> 00:19:57.170
back to it after vacation.
Right? So writing something in

350
00:19:57.170 --> 00:20:00.920
the most terse format ever
is not the goal here,

351
00:20:01.310 --> 00:20:03.800
you know, write it, write
your code to be readable

352
00:20:04.310 --> 00:20:07.220
and you can write readable
code in Scala. I think

353
00:20:07.550 --> 00:20:09.200
a lot of what we
saw and a lot of

354
00:20:09.200 --> 00:20:12.680
damage that was done or
that can be done in

355
00:20:12.680 --> 00:20:16.280
any language with early adopters
is that the early adopters

356
00:20:16.280 --> 00:20:20.330
get very excited by how
terse they can make their

357
00:20:20.330 --> 00:20:23.090
code, look at the cool
thing I can do. Right.

358
00:20:23.480 --> 00:20:26.630
And so then that becomes
what's on stack overflow. That

359
00:20:26.630 --> 00:20:29.060
becomes what people find when
they're searching on the internet.

360
00:20:29.270 --> 00:20:31.520
And that those are the
examples that they see. And

361
00:20:31.520 --> 00:20:34.280
they're like, Oh no, it
looks like Pearl, but it

362
00:20:34.280 --> 00:20:37.070
doesn't have to, those are
just what the early adopters

363
00:20:37.070 --> 00:20:41.000
were doing. Right. And so
it was a bad representation.

364
00:20:41.390 --> 00:20:43.370
Yeah, it was cool. But
it's not the code that

365
00:20:43.370 --> 00:20:45.680
you want to write for
production. Right. When those, th

366
00:20:45.710 --> 00:20:49.570
those are unfortunate that when
the, the early adopter enthusiast

367
00:20:49.600 --> 00:20:52.060
sees it and then starts
to push on it, to

368
00:20:52.060 --> 00:20:54.430
see how far it can
take it, the same thing

369
00:20:54.430 --> 00:20:58.870
happened with link where it's
like, you know, here's a

370
00:20:58.870 --> 00:21:01.330
Ray tracer in one line
of code, and it's like,

371
00:21:01.360 --> 00:21:03.550
Oh, no, this is impossible.
What am I going to

372
00:21:03.550 --> 00:21:06.850
do? You know, it's, it's
great that they did that,

373
00:21:06.850 --> 00:21:08.590
but it, for the, for
the newbie to go and

374
00:21:08.590 --> 00:21:10.060
look at that it's difficult.
And I think this is

375
00:21:10.060 --> 00:21:13.840
a larger problem than with
functional languages, because people who

376
00:21:13.840 --> 00:21:18.070
like math and the expressiveness
of math and understand math

377
00:21:18.280 --> 00:21:22.510
at a cellular level, love
writing terse equations and small

378
00:21:22.510 --> 00:21:25.870
proofs and things like that,
whether it be Scala or

379
00:21:25.870 --> 00:21:29.470
Haskell or F sharp, it's
like how small and efficient

380
00:21:29.470 --> 00:21:32.050
can I get this to
look like a mathematical function?

381
00:21:32.740 --> 00:21:35.830
How does someone make that
jump from procedural to functional

382
00:21:35.920 --> 00:21:38.290
when there are these barriers
that stand in the way?

383
00:21:39.390 --> 00:21:41.640
Yeah. I think those barriers
are in our own heads,

384
00:21:41.670 --> 00:21:43.710
right? And I think that,
you know, it's just, it's

385
00:21:43.710 --> 00:21:47.610
that muscle we're not exercising.
And it was funny because

386
00:21:47.610 --> 00:21:50.430
when we first started writing
atomic Scala, we thought maybe

387
00:21:50.430 --> 00:21:53.490
we'll have two volumes, maybe
volume one will be object

388
00:21:53.490 --> 00:21:57.060
oriented scholar, and maybe volume
two will be functional scholar.

389
00:21:57.540 --> 00:22:00.300
And as we started writing
the book, we thought we

390
00:22:00.300 --> 00:22:04.890
realized that we were bringing
our own bias as developers

391
00:22:04.890 --> 00:22:10.020
with lots of object oriented
experience into the book. So

392
00:22:10.020 --> 00:22:13.440
we were writing a book
for beginning programmers and thinking,

393
00:22:13.860 --> 00:22:17.400
Hey, they may not have
experience with object during your

394
00:22:17.400 --> 00:22:21.660
programming. So why are we
perpetuating this idea? That object

395
00:22:21.660 --> 00:22:26.130
oriented programming is, is easier
than functional programming. When all

396
00:22:26.130 --> 00:22:28.080
of us know how to
do math and how to

397
00:22:28.080 --> 00:22:32.550
represent mathematical equations, it may
actually be the case that

398
00:22:32.550 --> 00:22:39.030
people are just as able
to adopt functional programming as

399
00:22:39.030 --> 00:22:42.660
a concept as they are,
or maybe even easier than

400
00:22:42.660 --> 00:22:45.960
they are to adapt object
oriented programming. And for example,

401
00:22:45.960 --> 00:22:48.150
I suspect that my husband,
who's an engineer and a

402
00:22:48.150 --> 00:22:51.060
laser scientist who writes programs
and MATLAB lab all day

403
00:22:51.060 --> 00:22:55.110
long, would find Scala much
easier than what he would

404
00:22:55.140 --> 00:22:58.980
then, then, then Java or
C sharp or C plus

405
00:22:58.980 --> 00:23:02.070
plus Isn't that because when
you're writing something in a

406
00:23:02.130 --> 00:23:05.880
C family or procedural language,
that you're your writing, a

407
00:23:05.880 --> 00:23:09.390
series of steps, now do
this, and now do that.

408
00:23:09.420 --> 00:23:11.610
Now do this in a
loop. Wow. When you're doing

409
00:23:11.610 --> 00:23:15.540
something functionally, you really have
to, and I don't want

410
00:23:15.540 --> 00:23:17.730
to insult anybody, but you
have to really understand the

411
00:23:17.730 --> 00:23:20.730
problem. Like when you doing
something procedurally, you can just

412
00:23:20.730 --> 00:23:23.310
kind of step one, step
two, step three, didn't work

413
00:23:23.310 --> 00:23:24.570
out. I'm going to just
back up and try a

414
00:23:24.570 --> 00:23:27.240
different step three. Well, when
you do something functionally, you

415
00:23:27.240 --> 00:23:29.010
have to really get what
you're trying to do. You

416
00:23:29.010 --> 00:23:31.290
have to really understand the
problem from end to end

417
00:23:31.290 --> 00:23:34.110
and then express it in
a function. Like if you

418
00:23:34.110 --> 00:23:35.940
think about recursion, you know,
like that was one of

419
00:23:35.940 --> 00:23:39.120
the big things in computer
science class, that early programmers,

420
00:23:39.120 --> 00:23:40.980
like you either get it,
or you don't, and then

421
00:23:40.980 --> 00:23:43.980
one day it clicks, but
you have to really visualize

422
00:23:43.980 --> 00:23:48.380
and internalize and grok what's
happening. And I think that

423
00:23:48.770 --> 00:23:50.150
a lot of people don't
really know what they're trying

424
00:23:50.150 --> 00:23:52.040
to accomplish when they sit
down and they start typing.

425
00:23:52.070 --> 00:23:54.370
You know what I mean?
Yeah. Maybe we should step

426
00:23:54.370 --> 00:23:57.790
back from the keyboard a
little bit That right there.

427
00:23:57.790 --> 00:24:01.030
I mean, I think that
languages that are expressive and

428
00:24:01.030 --> 00:24:04.600
tourists, like this require an
understanding of the problem space

429
00:24:05.020 --> 00:24:08.860
that requires sitting quietly with
your hands at your lap,

430
00:24:09.250 --> 00:24:12.430
not on your keyboard, thinking
about what the problem I'm

431
00:24:12.430 --> 00:24:14.080
trying to solve is, especially
when you're going to issues

432
00:24:14.080 --> 00:24:17.650
like concurrency. Yeah. And I
think one night. So I

433
00:24:17.650 --> 00:24:22.070
think that there are some
functional programming languages that are,

434
00:24:22.070 --> 00:24:26.380
are unapproachable because you have
to really grok that functional

435
00:24:27.250 --> 00:24:30.070
aspect before you can be
productive in a language. And

436
00:24:30.070 --> 00:24:32.380
what I liked about Scala
was I could ease into

437
00:24:32.380 --> 00:24:35.230
that water. I could, you
know, I could still write

438
00:24:35.230 --> 00:24:40.900
my very procedural code in
Scala, the, the experience scholar

439
00:24:40.900 --> 00:24:43.510
program, or would come back
and say, Oh, you know,

440
00:24:43.510 --> 00:24:47.680
it's not very idiomatic, but
I can get better. You

441
00:24:47.680 --> 00:24:49.570
know, I can, I can
learn and I can, I

442
00:24:49.570 --> 00:24:53.260
can watch what other people
are doing and I can

443
00:24:53.260 --> 00:24:58.720
grow my functional sort of
muscle back. You know, I

444
00:24:58.720 --> 00:25:01.510
used to think recursively, right
back when I was in

445
00:25:01.510 --> 00:25:06.940
college, I stopped thinking recursively
as, as I got older

446
00:25:06.940 --> 00:25:10.090
and, you know, potentially more
lazy, you know, in my,

447
00:25:10.180 --> 00:25:12.010
in my, like you said,
you know, I continued to

448
00:25:12.010 --> 00:25:14.230
write the same code year
after year, after year after

449
00:25:14.230 --> 00:25:17.590
year, you know, and I
stopped exercising that muscle. You

450
00:25:17.590 --> 00:25:19.450
know, it just, I think
it just takes a little

451
00:25:19.450 --> 00:25:21.460
bit more time to get
that back and to start

452
00:25:21.460 --> 00:25:24.010
thinking, you know, once you
kind of understand the way

453
00:25:24.010 --> 00:25:27.760
recursion works, it's pretty obvious,
you know? And so it's

454
00:25:27.760 --> 00:25:30.520
easier to decompose the problem,
but you have to really

455
00:25:30.520 --> 00:25:33.790
remember the secret of how
you're actually looping through things

456
00:25:33.790 --> 00:25:37.240
and, you know, calling with
previous state, you know, as,

457
00:25:37.240 --> 00:25:40.150
as part of the method
itself. And I think that

458
00:25:40.390 --> 00:25:43.420
it's, it's a way of
thinking that we're, we've become

459
00:25:44.890 --> 00:25:50.110
inexperienced at using. There's a,
a kind of developer that

460
00:25:50.110 --> 00:25:52.810
I gave an ARCA title
name to. We call them

461
00:25:52.810 --> 00:25:55.990
the dark matter developers. They
take up most of the

462
00:25:55.990 --> 00:25:58.180
space of the universe, but
we can't prove that they

463
00:25:58.180 --> 00:26:02.440
exist just like dark matter.
And well, there's so much

464
00:26:02.440 --> 00:26:06.340
enthusiasm around the JVM kind
of derivative languages like Scala

465
00:26:06.340 --> 00:26:09.970
and closure and groovy. And
it seems like everyone who

466
00:26:09.970 --> 00:26:13.120
is smart and loud on
the internet is doing those

467
00:26:13.120 --> 00:26:15.670
things. If you look at
the math behind it and

468
00:26:15.670 --> 00:26:18.610
the actual like popularity, you
know, Scala doesn't even break

469
00:26:18.610 --> 00:26:22.690
the top 30 languages. It's
down there with Earl Lang

470
00:26:22.720 --> 00:26:26.590
and prologue and Haskell, which
are great languages, but the

471
00:26:26.590 --> 00:26:30.640
dark matter developer doesn't use
them. Java is got popularity

472
00:26:30.640 --> 00:26:34.780
right now. Why, why is
it that loud, enthusiastic, smart

473
00:26:34.780 --> 00:26:38.470
people talk about languages like
Scala and groovy enclosure while

474
00:26:38.470 --> 00:26:43.950
the enterprise person just keeps
banging out JSP pages. Gosh,

475
00:26:44.040 --> 00:26:48.180
That's a hard question to
solve because when you have

476
00:26:48.180 --> 00:26:52.590
the mentality that you joined
this industry, because it was

477
00:26:52.590 --> 00:26:55.410
evolving and ever changing, and
it was a, it was

478
00:26:55.410 --> 00:26:59.580
basically a dedication to a
career of learning. It's hard

479
00:26:59.580 --> 00:27:03.510
to identify with people who
are perfectly happy doing what

480
00:27:03.510 --> 00:27:07.410
they were doing 10, 15
years ago. Right. It's, it's

481
00:27:07.410 --> 00:27:12.300
absolutely impossible for me to
put myself in their shoes.

482
00:27:12.540 --> 00:27:15.600
All I know is that
I, I, I am fairly

483
00:27:15.600 --> 00:27:19.260
lazy in programming in terms
of I'd rather write less

484
00:27:19.260 --> 00:27:22.320
code and spend more time
thinking about the problem domain.

485
00:27:22.770 --> 00:27:26.550
And, and so I think
that the newer languages offer

486
00:27:26.550 --> 00:27:32.220
me that ability. They also
let the, let the problem

487
00:27:32.220 --> 00:27:34.770
that I am trying to
solve emerge from the code

488
00:27:34.770 --> 00:27:38.160
more readily and make that
more apparent when I'm looking

489
00:27:38.160 --> 00:27:40.320
at the code, because it's,
there's, it's not hidden by

490
00:27:40.320 --> 00:27:44.160
all the boiler plate. And
so for me, it's easier

491
00:27:44.160 --> 00:27:48.450
to solve these problems using
newer languages, because I get

492
00:27:48.450 --> 00:27:51.090
to hide away all that
cruft that was taking up

493
00:27:51.090 --> 00:27:54.750
space in my brain. But
I think that there are

494
00:27:54.810 --> 00:27:57.570
a large number of people
that will never touch who

495
00:27:57.570 --> 00:28:00.510
are perfectly happy, who don't
listen to this podcast, who

496
00:28:00.510 --> 00:28:04.320
don't listen to any podcasts
who don't go to conferences

497
00:28:04.440 --> 00:28:08.280
who are perfectly happy doing
programming nine to five and

498
00:28:08.280 --> 00:28:11.970
not thinking about it on
the weekends and, and, and

499
00:28:11.970 --> 00:28:14.820
never really thinking about where
their career is going. Cause

500
00:28:14.820 --> 00:28:17.160
they have a job and
their job is to write

501
00:28:17.160 --> 00:28:20.430
Java code. And when Java
becomes the language that nobody

502
00:28:20.430 --> 00:28:24.330
uses anymore, then there'll be
unemployed. And then they'll, they'll

503
00:28:24.330 --> 00:28:28.380
learn by the very necessity
of learning a new language

504
00:28:28.410 --> 00:28:30.030
so that they can get
a job. Again, the learn,

505
00:28:30.030 --> 00:28:32.880
whatever new language it is,
then look at another job

506
00:28:33.060 --> 00:28:35.250
and they'll repeat the same
mistakes over and over again.

507
00:28:36.620 --> 00:28:40.220
Is there, is there a
kind of an implicit value

508
00:28:40.220 --> 00:28:43.580
judgment in that? I mean,
there's, I mean, you do

509
00:28:43.580 --> 00:28:45.890
the kind of is, I
mean, we're not saying that

510
00:28:45.890 --> 00:28:48.710
there, we're not saying that
it's not about punching out

511
00:28:48.710 --> 00:28:50.240
at five o'clock or not.
I mean, you can have

512
00:28:50.240 --> 00:28:52.580
a very good career and
a successful career, not thinking

513
00:28:52.580 --> 00:28:54.440
about these things on the
weekends, but I think your,

514
00:28:54.440 --> 00:28:56.150
when you said thinking about
it on the weekends, you're

515
00:28:56.150 --> 00:29:00.050
really talking about, it's like,
if you're a craftsman who

516
00:29:00.050 --> 00:29:02.390
makes things with wood and
you watch like the Yankee

517
00:29:02.390 --> 00:29:04.940
workshop, you know, it's like,
it's something that you're so

518
00:29:04.940 --> 00:29:07.280
excited about. And you're always
thinking about new and effective

519
00:29:07.280 --> 00:29:09.170
ways to make wood and
make the wood bend to

520
00:29:09.170 --> 00:29:12.410
your will because you just
love it. Is this the

521
00:29:12.410 --> 00:29:16.040
difference between just loving computer
science and software engineering and

522
00:29:16.040 --> 00:29:18.530
just kind of like, Oh,
it's a job. Yeah. I

523
00:29:18.530 --> 00:29:21.140
think it is. I think
it's that the person who

524
00:29:21.140 --> 00:29:25.730
loves computer science and software
is the, is the person

525
00:29:25.730 --> 00:29:28.610
who can't turn their brain
off. Right. And so I'm

526
00:29:28.610 --> 00:29:31.430
not asking, I'm not saying
that I go home and

527
00:29:31.430 --> 00:29:33.140
work all night long and
that I don't have a

528
00:29:33.140 --> 00:29:36.080
life. Right. I think especially
one thing I noticed here

529
00:29:36.080 --> 00:29:39.350
at Netflix, because we tend
to hire developers who have

530
00:29:39.380 --> 00:29:44.920
experienced, we don't have a
culture that really has people

531
00:29:44.920 --> 00:29:47.800
coming in and staying through
all hours of the night.

532
00:29:48.010 --> 00:29:50.590
What I've seen here is
that people tend to arrive

533
00:29:50.590 --> 00:29:52.960
around nine o'clock after they
drop their kids off at

534
00:29:52.960 --> 00:29:55.810
school, they tend to stay
until five or six when

535
00:29:55.810 --> 00:29:57.400
they're going to go pick
their kids up from school.

536
00:29:57.640 --> 00:30:00.010
And then they go home
and they, you know, they,

537
00:30:00.010 --> 00:30:03.280
they, they do some more
work, but if that's what

538
00:30:03.280 --> 00:30:05.500
they need to do for
their job, they work really

539
00:30:05.500 --> 00:30:08.080
super hard when they're here,
you know, and then they

540
00:30:08.080 --> 00:30:10.750
go home and they're, they
don't shut their brains off.

541
00:30:10.780 --> 00:30:13.750
They may not actually be
fingers on keyboard, but they're

542
00:30:13.750 --> 00:30:18.360
thinking about interesting problems and
they can't help themselves. That's

543
00:30:18.360 --> 00:30:20.160
cool. I guess if you're
going to have a dysfunction,

544
00:30:20.160 --> 00:30:23.910
that's the right kind of
have. Yeah. Yeah. Well, it

545
00:30:23.910 --> 00:30:25.650
sounds like it's really exciting
and stuff that's happening at

546
00:30:25.650 --> 00:30:27.660
Netflix. And thanks so much
for talking to me about

547
00:30:27.660 --> 00:30:30.090
Scala and for having clay
on to talk about groovy

548
00:30:30.120 --> 00:30:33.120
and people of course can
follow you on Twitter and

549
00:30:33.120 --> 00:30:35.100
learn more about your stuff
as all, as well as

550
00:30:35.100 --> 00:30:37.050
go up to get hub
and see all the great

551
00:30:37.050 --> 00:30:39.030
things that Netflix is putting
out into the open source

552
00:30:39.030 --> 00:30:42.240
world. Yeah. It's really exciting
and really fun. And you

553
00:30:42.240 --> 00:30:44.160
know, it's part of us
giving back to the community

554
00:30:44.160 --> 00:30:47.040
for having used a lot
of open source in our

555
00:30:47.040 --> 00:30:51.180
software and, and really helping
to help other people adopt

556
00:30:51.180 --> 00:30:54.510
the cloud. So it's, it's
a pretty fun 35, I

557
00:30:54.510 --> 00:30:57.630
think, projects now on get
hub, including one of clay,

558
00:30:58.290 --> 00:31:00.420
clay, McCoy's who you talked
to a couple weeks ago,

559
00:31:00.420 --> 00:31:03.270
one of his projects is
out there called glisten. So

560
00:31:03.480 --> 00:31:06.540
pretty exciting stuff. That's fantastic.
Thanks so much. Diane Marsh from

561
00:31:06.540 --> 00:31:09.750
Netflix for talking to me
today. Thanks, Scott. This has

562
00:31:09.750 --> 00:31:12.810
been another episode of Hanselminutes
and we'll see you again

563
00:31:12.810 --> 00:31:13.290
next week.


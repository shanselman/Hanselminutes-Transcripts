WEBVTT FILE

1
00:00:04.380 --> 00:00:16.250
<inaudible> From Hanselman it's dot
com. It's Hansel minutes, a

2
00:00:16.250 --> 00:00:20.450
weekly discussion with web developer
and technologist Scott Hanselman hosted

3
00:00:20.450 --> 00:00:25.850
by Carl Franklin. This is Lawrence Ryan
announcing show number 96. Recorded

4
00:00:25.850 --> 00:00:31.820
live Friday, January 11th, 2008. Support for
Hansel minutes is provided by

5
00:00:31.910 --> 00:00:35.930
Tellerik already controls the most
comprehensive suite of components for

6
00:00:35.930 --> 00:00:45.590
windows forms, asp.net web applications.
online@wwwdottelerik.com. In this episode, Scott

7
00:00:45.590 --> 00:00:53.840
talks F sharp with dev
express developer, Dustin Campbell. Hi,

8
00:00:53.840 --> 00:00:55.820
this is Scott Hanselman. This
is another episode of Hansel

9
00:00:55.820 --> 00:00:58.310
minutes, and I'm sitting here
in the hallowed halls of

10
00:00:58.310 --> 00:01:02.570
a Kalahari resort in Sandusky,
Ohio, halfway between Toledo and

11
00:01:02.570 --> 00:01:04.790
Cleveland. I'm sitting here in
the middle of the code

12
00:01:04.790 --> 00:01:08.870
mash conference with Destin Campbell
fame, developer of dev express

13
00:01:08.900 --> 00:01:12.140
and arch nemesis of Mark Miller.
How are you, Dustin? I'm

14
00:01:12.140 --> 00:01:15.020
doing great, man. Hey, yesterday
you gave a fantastic talk

15
00:01:15.020 --> 00:01:17.840
on F sharp. That was
really interesting. Thanks, man. I

16
00:01:17.840 --> 00:01:19.790
really appreciate that. One of
the things that really struck

17
00:01:19.790 --> 00:01:22.010
me about your talk was
that you said this is

18
00:01:22.010 --> 00:01:24.470
an immense language, and you
said that at least three

19
00:01:24.470 --> 00:01:27.710
times, and you had this
diagram up on the screen.

20
00:01:28.070 --> 00:01:29.570
I know that we're on
a podcast, so I can't

21
00:01:29.570 --> 00:01:31.490
show people a diagram and
be to blog about it.

22
00:01:31.490 --> 00:01:36.860
But explain to me these
different, these different modalities that

23
00:01:36.890 --> 00:01:40.850
F sharp kind of encompasses
will as sharp, where some

24
00:01:40.850 --> 00:01:44.270
programming paradigms can be. You
can work with different programs,

25
00:01:44.300 --> 00:01:47.840
programming paradigms in different languages,
F sharp. We're actually fully

26
00:01:47.840 --> 00:01:52.250
embraces three. So functional programming
object during programming and imperative.

27
00:01:52.700 --> 00:01:58.820
Alright, now what goes along
with that is, is a

28
00:01:58.820 --> 00:02:01.490
massive number of features. So
you've got your functional programming

29
00:02:01.490 --> 00:02:04.970
features, which are, are fully
in there, like automatic generalization

30
00:02:04.970 --> 00:02:08.060
and extreme type inference, but
then you've got object oriented

31
00:02:08.990 --> 00:02:12.440
features that are almost some
of these are unique to

32
00:02:12.440 --> 00:02:15.860
F sharp. And on top
of that things like, you

33
00:02:15.860 --> 00:02:19.700
know, compiling to mano and
standalone executable and all the

34
00:02:19.710 --> 00:02:21.770
sorts of things that are
just like it's, it's, there's

35
00:02:21.770 --> 00:02:23.720
a lot of features in
this language is a huge,

36
00:02:23.720 --> 00:02:27.170
huge thing. You keep using
really enthusiastic adjectives. You keep

37
00:02:27.170 --> 00:02:30.650
using things like immense and
extreme. You said extreme type

38
00:02:30.650 --> 00:02:33.740
inference. That seems like the
X games. What is an

39
00:02:33.740 --> 00:02:37.370
example of an extreme type
inference? I mean, you're, you're

40
00:02:37.490 --> 00:02:41.840
pulling information from as much
context as you can from

41
00:02:41.840 --> 00:02:44.330
other places. I mean, where
can you pull this context

42
00:02:44.330 --> 00:02:49.550
from? Well, for example, the
operators that are being used

43
00:02:50.450 --> 00:02:53.450
functions that are being used,
that within your code, within

44
00:02:53.450 --> 00:02:55.790
the body of another function,
those might have some type

45
00:02:55.800 --> 00:02:59.950
annotations, but the F sharp
compiler can say, you know

46
00:02:59.950 --> 00:03:02.080
what? I'm not sure what
these types are, but I

47
00:03:02.080 --> 00:03:03.700
can make them generic. I
know that I can make

48
00:03:03.700 --> 00:03:07.270
these generic types for you.
So you might declare a

49
00:03:07.270 --> 00:03:10.870
function and it might not
actually say, Hey, this, this,

50
00:03:11.050 --> 00:03:12.730
this parameter is going to
be an ENT. It's going

51
00:03:12.730 --> 00:03:13.820
to say, you know what?
This is going to be

52
00:03:13.820 --> 00:03:16.500
the generic type parameter, a
that sort of thing. Now,

53
00:03:16.510 --> 00:03:18.420
when you say generic, I
mean, I think generic, I

54
00:03:18.420 --> 00:03:22.980
think, you know, angle bracket,
generics, like list of end,

55
00:03:22.980 --> 00:03:24.450
is that the kind of
generic that we're talking exactly.

56
00:03:24.480 --> 00:03:26.760
Yeah. Kind of generic, but
at a function level where

57
00:03:26.910 --> 00:03:29.730
your function is actually declaring
generics into itself, that's some

58
00:03:29.730 --> 00:03:33.240
of its parameters, we'll a
have generic type parameters Saying

59
00:03:33.240 --> 00:03:34.950
that I don't know enough
that this is an end

60
00:03:34.950 --> 00:03:36.690
or long, but I know
that it's going to be

61
00:03:36.940 --> 00:03:39.930
some kind of a type.
So I'll just loosen up

62
00:03:39.930 --> 00:03:41.820
a little bit and allow
those types to go through

63
00:03:41.910 --> 00:03:45.450
exactly. Now, can you provide
it with hints? Yes. You

64
00:03:45.450 --> 00:03:47.940
can apply. You can add
your own type annotations if

65
00:03:47.940 --> 00:03:50.550
you need to. And sometimes
when you're writing library code,

66
00:03:50.550 --> 00:03:52.590
if you're writing a public
API, that might be nice.

67
00:03:53.580 --> 00:03:56.430
Maybe if you're giving out
the source code and you

68
00:03:56.430 --> 00:03:58.530
know, people want to look
at this, they can, they

69
00:03:58.530 --> 00:04:01.860
can see what the types
are, but generally it's, I'm

70
00:04:01.860 --> 00:04:04.320
writing code. I can write
it very succinctly, not use

71
00:04:04.320 --> 00:04:08.070
types and maybe like 97%
of the time. It's just,

72
00:04:08.220 --> 00:04:10.170
it just gets what I
want. So what I want

73
00:04:10.170 --> 00:04:12.150
is this a dynamic language?
I mean, people think of

74
00:04:12.150 --> 00:04:15.390
dynamic languages as moving types
in a very liquid form.

75
00:04:15.390 --> 00:04:17.340
Just kind of from here
to there. No, it's not

76
00:04:17.340 --> 00:04:21.570
a dynamic language. That's very
strongly, very statically typed, but

77
00:04:21.570 --> 00:04:24.210
the type inference allows you
to write in a way

78
00:04:24.210 --> 00:04:26.910
that feels like that kind
of fluid dynamic language. If

79
00:04:26.910 --> 00:04:29.850
I declare a variable and
the compiler, and first the

80
00:04:29.850 --> 00:04:33.690
type for that variable, I
can't now go and set

81
00:04:33.690 --> 00:04:36.240
that variable to another, another
value of a different type.

82
00:04:36.660 --> 00:04:38.100
You can't change it to
a value of another type

83
00:04:38.100 --> 00:04:41.010
of, I go and say,
let, let I equals zero.

84
00:04:41.040 --> 00:04:44.910
I can't go let I
equals string. Well, it change

85
00:04:44.910 --> 00:04:48.960
at all. You can't change,
but there are scoping rules

86
00:04:48.960 --> 00:04:50.970
within a sharp. So you
can't actually read declare I

87
00:04:51.390 --> 00:04:54.450
okay. But that's actually a
new eye. It's not the

88
00:04:54.450 --> 00:04:56.940
same. I'm not actually declaring.
I'm not actually changing the

89
00:04:56.940 --> 00:04:59.490
same value. So the original
variable, I write to a

90
00:04:59.490 --> 00:05:02.910
new type I'm declaring a
new variable. I and any,

91
00:05:02.910 --> 00:05:05.760
any, if you had a
function say that that worked

92
00:05:05.760 --> 00:05:08.390
with I, if you had
a function that, that consumed

93
00:05:08.730 --> 00:05:11.430
the original eye, that function
would still continue to use

94
00:05:11.430 --> 00:05:13.890
the original eye with the
original type, but you'd now

95
00:05:13.950 --> 00:05:16.380
if you, and then if
you read, declare I to

96
00:05:16.380 --> 00:05:19.950
a new type that I
know exists for the rest

97
00:05:19.950 --> 00:05:22.890
of this. Cool. Okay. So
at this point we've lost

98
00:05:22.890 --> 00:05:25.620
90% of our listeners. Let
me, let me start, let

99
00:05:25.620 --> 00:05:27.180
me start, let me see
if I can understand. Cause

100
00:05:27.180 --> 00:05:28.830
I'm struggling to understand this
as much as I'm sure

101
00:05:28.830 --> 00:05:30.570
some of the listeners are.
So if I go and

102
00:05:30.570 --> 00:05:32.610
I say, let, this is
like a, like, what I

103
00:05:32.610 --> 00:05:34.470
would think of is dim.
I mean, I'm, I'm basically

104
00:05:34.470 --> 00:05:38.130
just making a declaration. Sure.
Let I equals zero. And

105
00:05:38.130 --> 00:05:40.620
I'm saying that there is
a name now that is

106
00:05:40.620 --> 00:05:43.020
bound to the value zero,
such that when I refer

107
00:05:43.020 --> 00:05:45.990
to, I later, I'm really
referring to zero, but I'm

108
00:05:45.990 --> 00:05:48.420
referring to it with a
friendly name. Yes. Okay. I

109
00:05:48.420 --> 00:05:53.580
get that right now. I
can't say I equals two

110
00:05:54.000 --> 00:05:57.840
later. No, that seems like
a very big mental change.

111
00:05:57.860 --> 00:05:59.750
I mean, you're saying that
there's really no variables. It

112
00:05:59.750 --> 00:06:02.770
feels like there's only Constance.
There's not that they're constant.

113
00:06:02.770 --> 00:06:05.800
In fact, it's just that
they're they're variables, but they're

114
00:06:05.800 --> 00:06:10.120
immutable. Okay. So they can't
be changed unless you declare

115
00:06:10.120 --> 00:06:12.910
that variable differently. For example,
you could say, let mutable,

116
00:06:12.910 --> 00:06:16.240
I equals zero and now
you can then use an

117
00:06:16.240 --> 00:06:18.670
assignment operator to change that.
I, so it is a

118
00:06:18.670 --> 00:06:21.910
variable it's just by default
in F sharp, all variables

119
00:06:21.910 --> 00:06:25.000
are immutable and it cannot
change. Okay. And that sounds

120
00:06:25.000 --> 00:06:28.870
like, that sounds like a
hassle. It is kind of

121
00:06:28.870 --> 00:06:31.480
a hassle. If you, if
you, if you're wanting to

122
00:06:31.690 --> 00:06:33.730
program in that, if you're
used to that old imperative

123
00:06:33.730 --> 00:06:36.760
style of programming that we've
been indoctrinated with since, since

124
00:06:36.760 --> 00:06:41.080
Fortran, right? So if you're,
if that's what makes you

125
00:06:41.080 --> 00:06:44.470
comfortable, then we will feel
a bit of a hassle

126
00:06:44.470 --> 00:06:47.830
at first. But once, once
you get used to it,

127
00:06:47.830 --> 00:06:49.570
once you get used to
the idioms of, of a

128
00:06:49.570 --> 00:06:53.950
more functional style of programming,
it, it, it becomes very

129
00:06:53.950 --> 00:06:56.260
nice. So there's an interesting
contrast here. You're pointing out

130
00:06:56.620 --> 00:07:00.100
very explicitly that there's the
imperative style of programming, what

131
00:07:00.100 --> 00:07:03.040
you referred to as the
Fortran style. And then there's

132
00:07:03.040 --> 00:07:05.650
the functional style, which is,
I assume from the list

133
00:07:05.890 --> 00:07:09.460
world. And these are, I
think there are a lot

134
00:07:09.460 --> 00:07:10.900
of people out there. A
lot of people would it

135
00:07:10.900 --> 00:07:13.540
be of my generation or
younger who just never learned

136
00:07:13.540 --> 00:07:16.720
lisp in college. They just,
they skipped that part because

137
00:07:16.720 --> 00:07:20.140
imperative programming has been so
fundamental to everything that we've

138
00:07:20.140 --> 00:07:22.150
done. Can you, can you
talk a little bit about

139
00:07:22.180 --> 00:07:24.220
those differences? I mean, what
is, what really is a

140
00:07:24.220 --> 00:07:27.730
difference in functional programming and
imperative programming? You made a

141
00:07:27.730 --> 00:07:30.970
good point that really it
comes from lisp, right? Really

142
00:07:30.970 --> 00:07:33.730
it's if you think about
it, the two oldest programming

143
00:07:33.730 --> 00:07:37.120
languages in widespread use, which
would be Fortran and lists

144
00:07:37.570 --> 00:07:40.210
are really kind of the
mother languages, right. List being

145
00:07:40.210 --> 00:07:44.350
the mother language of functional
programming, Fortran being the mother

146
00:07:44.350 --> 00:07:47.440
language of, of what became
C and then C based

147
00:07:47.440 --> 00:07:49.150
languages like Java and C
sharp and all of our

148
00:07:49.150 --> 00:07:52.540
imperative languages, but what makes
these languages different is that

149
00:07:52.540 --> 00:07:55.810
list while it was trying
to solve math problems, it

150
00:07:55.810 --> 00:07:59.080
would start from the mathematical
symbols. That's where it started.

151
00:07:59.080 --> 00:08:02.170
And then it moved downwards
and added abstractions below it.

152
00:08:02.710 --> 00:08:05.680
Whereas Fortran started kind of
with the numbers and it

153
00:08:05.680 --> 00:08:09.130
grew up where it's edit
obstructions on top. And that's

154
00:08:09.160 --> 00:08:12.940
what we live with today.
What really makes these, I

155
00:08:12.940 --> 00:08:15.160
think the words that, that
the kind of buzzword. So

156
00:08:15.160 --> 00:08:17.320
I hate using them in
one sense, but the words

157
00:08:17.320 --> 00:08:19.270
that really just kind of
describe what these are doing

158
00:08:19.480 --> 00:08:22.060
is that lisp was more
of a declarative style where

159
00:08:22.060 --> 00:08:25.330
you're saying, or, or a
functional programming language to get

160
00:08:25.350 --> 00:08:27.610
away from lists. So just
the functional programming languages in

161
00:08:27.610 --> 00:08:29.710
general law, you to write
things in a more declarative

162
00:08:29.710 --> 00:08:32.620
way, saying this is what
I want done as opposed

163
00:08:32.620 --> 00:08:34.930
to an imperative style, which
is more like a recipe.

164
00:08:34.990 --> 00:08:37.030
Like you're a chef and
you're, you've got a list

165
00:08:37.030 --> 00:08:38.980
of instructions that you want
to follow step by step

166
00:08:39.940 --> 00:08:42.190
and say, this is how
I want this done. This

167
00:08:42.190 --> 00:08:44.560
is exactly what I want
the process to do the

168
00:08:44.560 --> 00:08:45.760
steps that I want you
to go through to do

169
00:08:45.760 --> 00:08:47.740
it. And in a functional
programming language, you do the

170
00:08:47.740 --> 00:08:48.850
opposite. You say, this is
what I want you to

171
00:08:48.850 --> 00:08:52.420
do. And I really don't
care how it happens. Okay.

172
00:08:52.420 --> 00:08:54.970
So that's really, that's a
really good description. I'm going

173
00:08:55.110 --> 00:08:57.270
paraphrase that cause you kind
of blown my mind there.

174
00:08:57.630 --> 00:09:01.170
So a functional programming environment
is where you're basically saying

175
00:09:01.170 --> 00:09:04.200
that, you know, here are
some, here's the state of

176
00:09:04.200 --> 00:09:08.070
affairs as I know them
initially. And here's a description

177
00:09:08.070 --> 00:09:12.300
of what my ultimate goal
is. Go ahead and get

178
00:09:12.300 --> 00:09:15.900
on that, work that out
start and not concerned if

179
00:09:15.900 --> 00:09:18.000
it's, if it's recursion or
if it's a big old

180
00:09:18.000 --> 00:09:20.370
loop or whatever, you just
make it happen and call

181
00:09:20.370 --> 00:09:22.860
me when it's done. Yes.
And then in the imperative

182
00:09:22.920 --> 00:09:26.520
format, we start out with
some beginning state as again,

183
00:09:26.520 --> 00:09:28.950
as we did before. But
then we say very, very

184
00:09:28.950 --> 00:09:31.500
explicitly all of the state
changes that we're going to

185
00:09:31.500 --> 00:09:34.050
go through in order to
get something done. And it's

186
00:09:34.050 --> 00:09:37.680
completely up to us to
decide how that gets done.

187
00:09:38.040 --> 00:09:43.080
And sometimes that how is
outside of the scope of

188
00:09:43.290 --> 00:09:47.070
the problem itself? And we
may not know the best

189
00:09:47.070 --> 00:09:50.610
way yes. To do that.
You had a recursive function

190
00:09:50.970 --> 00:09:53.250
add that took X and
Y and then just added

191
00:09:53.250 --> 00:09:57.810
one and returned. And you
wrote it in C sharp.

192
00:09:58.620 --> 00:10:02.280
And then you tried to
add like 38,000. Yeah. One

193
00:10:02.280 --> 00:10:04.390
plus one plus one, and
you were cursed and you

194
00:10:04.390 --> 00:10:08.310
move the stack, very nasty
exception to have happen. And

195
00:10:08.340 --> 00:10:09.750
not only did you blow
the stack, but you took

196
00:10:09.750 --> 00:10:12.240
a long time to do
it because the stack got

197
00:10:12.240 --> 00:10:15.720
really big. I mean, there
was a huge 37,000 deep

198
00:10:15.720 --> 00:10:18.210
stack, but when you did
it in F sharp, you

199
00:10:18.210 --> 00:10:20.730
wrote the, basically what I
perceived to be the same

200
00:10:21.150 --> 00:10:25.380
recursion, but it happened instantly.
It didn't blow the stack.

201
00:10:25.740 --> 00:10:27.720
Was there no stack? Is
there no, is there no

202
00:10:27.720 --> 00:10:30.560
spoon? Is there no spoon
there wasn't, there was no,

203
00:10:30.780 --> 00:10:32.930
the way F sharp compiler
took, took a look at

204
00:10:32.930 --> 00:10:35.360
that, a bit of recursive
code. It could see that

205
00:10:35.360 --> 00:10:38.810
the very last thing that
was done by the function

206
00:10:38.810 --> 00:10:41.990
was to call itself and
it's called tail recursion. That's

207
00:10:42.230 --> 00:10:43.790
what the tail means. It
means it's the very last

208
00:10:43.790 --> 00:10:47.240
thing that happens. And it
took that and it was

209
00:10:47.240 --> 00:10:49.250
able to say, well, if
all I'm going to do

210
00:10:49.250 --> 00:10:50.840
is go back to the
front of this ma this

211
00:10:50.840 --> 00:10:53.840
function again, then all that
I need to do is

212
00:10:53.840 --> 00:10:57.380
turn this into a wild
loop. And that's what happens

213
00:10:57.380 --> 00:10:59.300
in an, in a talk,
in a session we, we

214
00:10:59.300 --> 00:11:00.650
brought up reflect when we
took a look at the

215
00:11:00.650 --> 00:11:03.770
C sharp code compiled exactly.
As I'd written it, you

216
00:11:03.770 --> 00:11:05.180
know, when we looked at
it with, with reflector, and

217
00:11:05.180 --> 00:11:07.040
then we looked at, looked
at the F sharp code

218
00:11:07.100 --> 00:11:10.490
in using the C-sharp decompiler
and we saw that while

219
00:11:10.490 --> 00:11:14.300
loop. And so it really
happened almost instantaneously. Cause it

220
00:11:14.300 --> 00:11:16.760
was just, it was just
increments and detriments within a

221
00:11:16.760 --> 00:11:20.450
while loop. Is that a
feature of the language or

222
00:11:20.900 --> 00:11:23.090
a feature of the compiler?
I mean the C sharp

223
00:11:23.090 --> 00:11:25.130
compiler is getting very, very
smart. There's a lot more

224
00:11:25.340 --> 00:11:27.770
method in lining. And some
tail, there is some tail

225
00:11:27.770 --> 00:11:31.280
call optimization in the jitter
of the CLR, but apparently

226
00:11:31.280 --> 00:11:33.620
not enough to have spotted
that issue and fixed it.

227
00:11:33.860 --> 00:11:36.080
Sure. So is this a
feature of the language and

228
00:11:36.080 --> 00:11:38.780
the sense that, that, that
kind of optimization has been

229
00:11:38.780 --> 00:11:41.570
brought up into the language
back and said that this

230
00:11:41.570 --> 00:11:43.280
is something that we'll handle
this as an optimization that's

231
00:11:43.280 --> 00:11:45.950
appropriate or is this just
at the F sharp compiler

232
00:11:45.950 --> 00:11:49.220
is just so smart. Well,
it's, it's, it is more

233
00:11:49.220 --> 00:11:51.500
of a language thing because
functional programming in the abstract

234
00:11:51.500 --> 00:11:55.200
language is so built upon
is becomes, it's such a

235
00:11:55.210 --> 00:11:58.840
natural fixture, an idiom that's
used that it really is

236
00:11:58.840 --> 00:12:01.150
part of the language. So
even if you do things

237
00:12:01.150 --> 00:12:03.790
that you would think, well,
this isn't a tale recurs

238
00:12:03.790 --> 00:12:06.580
of situation, where you do
co recursion, what's called COVID

239
00:12:06.580 --> 00:12:09.790
version where you have one
function that calls another function.

240
00:12:09.790 --> 00:12:11.620
And that function calls the
first function and back and

241
00:12:11.620 --> 00:12:15.310
forth to solve a problem.
F sharp will still handle

242
00:12:15.310 --> 00:12:20.710
that using IRL instructions appropriate.
It'll, it'll manage to get

243
00:12:20.710 --> 00:12:23.440
that so that it won't
stack overflow. So it's really

244
00:12:23.440 --> 00:12:25.960
part of the language. It's
trying very hard. You know,

245
00:12:25.960 --> 00:12:27.940
you can, you can get
there, you can get there

246
00:12:27.940 --> 00:12:29.830
and get a stack overflow.
But if you, if you

247
00:12:29.830 --> 00:12:32.710
follow kind of these functional
programming, idioms of tail recursion,

248
00:12:32.980 --> 00:12:35.290
that sort of thing, F
sharp, we'll pick that up

249
00:12:35.290 --> 00:12:38.080
for you and allow you
to do these kinds of

250
00:12:38.080 --> 00:12:41.700
things without overflows. No Often
when I'm writing a C-sharp

251
00:12:41.700 --> 00:12:45.300
code or what I would
think of as classic imperative.net

252
00:12:45.300 --> 00:12:49.710
languages. I find myself thinking
about how things are going

253
00:12:49.710 --> 00:12:51.900
to look at runtime. I
find myself thinking, well, here's

254
00:12:51.900 --> 00:12:54.420
what I'll be in the
stack at this point. And,

255
00:12:54.420 --> 00:12:56.730
you know, maybe recursion is
appropriate here, but I don't

256
00:12:56.730 --> 00:13:00.330
think recursion is something that
a, you know, unless you're

257
00:13:00.330 --> 00:13:04.200
calling fine control. I don't
think that Joe, a.net developer

258
00:13:04.200 --> 00:13:06.720
necessarily pulls recursion out of
his pocket every five minutes.

259
00:13:07.080 --> 00:13:10.950
But it seems like with,
with a functional programming language,

260
00:13:10.950 --> 00:13:16.410
like of sharp, where you
can't change a variable, then

261
00:13:16.410 --> 00:13:17.970
you would need to use
recursion. Cause you had to

262
00:13:17.970 --> 00:13:21.240
put stuff somewhere. Yes. So
you need to modify that

263
00:13:21.240 --> 00:13:23.610
variable. If you're, for example,
with ad the way it

264
00:13:23.610 --> 00:13:26.730
works, we have two parameters,
X and Y. And when

265
00:13:26.730 --> 00:13:32.460
we Recurse, we call, we
call add again, decrementing X

266
00:13:32.550 --> 00:13:35.580
and incrementing Y so we
call it with one less

267
00:13:35.580 --> 00:13:37.920
and one more on each
parameter. And by the time

268
00:13:37.920 --> 00:13:39.930
we get, when X equals
zero, then we know that

269
00:13:39.930 --> 00:13:42.000
Y is the final result
and that's kind of how

270
00:13:42.000 --> 00:13:44.250
recursion works. You're going to
take an accumulative value at

271
00:13:44.250 --> 00:13:47.610
the end. And when things
are immutable like that, you're

272
00:13:47.610 --> 00:13:51.600
exactly right. So in functional
programming, an F sharp, one

273
00:13:51.600 --> 00:13:54.690
of the structures that's used
most Austin often is a

274
00:13:54.690 --> 00:13:59.070
list singly linked list. And
that's a recursive data structure

275
00:13:59.490 --> 00:14:03.000
and it has to be
dealt with using recursion. It

276
00:14:03.000 --> 00:14:04.410
has to be when you
operate on it, you have

277
00:14:04.410 --> 00:14:06.690
to use recursion to build
up new lists, to operate

278
00:14:06.690 --> 00:14:10.950
on a list. You manipulate
your manipulations on the original

279
00:14:10.950 --> 00:14:12.720
list, produce a new list.
And you build that up

280
00:14:12.750 --> 00:14:16.440
through recursion using the same
kind of technique where you

281
00:14:16.440 --> 00:14:19.950
have a parameter that's going
to accumulate the result. That's

282
00:14:19.950 --> 00:14:23.130
interesting. So a list is
not a system, not collection

283
00:14:23.130 --> 00:14:26.220
site list. This is a,
an F sharp, specific thing.

284
00:14:27.060 --> 00:14:30.150
It's not a list that
I iterate over. I'm recursing

285
00:14:30.150 --> 00:14:32.260
over it. You get what
I'm saying? Am I, can

286
00:14:32.260 --> 00:14:35.100
I for loop over this
over these lists? I'm sure

287
00:14:35.160 --> 00:14:38.250
Provide some structures that look
like that, But that's not

288
00:14:38.250 --> 00:14:42.090
what's happening. Okay. Yeah, Because
a, an F sharp list

289
00:14:42.090 --> 00:14:44.790
is, is it's, it's a,
it's a beautiful structure really.

290
00:14:44.790 --> 00:14:48.720
Cause it's, it's, it's a
recursive structure where a list

291
00:14:48.720 --> 00:14:50.880
is really simply just a
head and a tail it's

292
00:14:50.880 --> 00:14:53.810
like value and then the
rest of the list. But

293
00:14:53.810 --> 00:14:56.780
that rest of the list
is another list with a

294
00:14:56.780 --> 00:14:59.000
value and the rest of
the list. And so on

295
00:14:59.000 --> 00:15:00.980
all the way down to
the very end and where

296
00:15:00.980 --> 00:15:02.720
there's a little marker called
the empty list. That ends

297
00:15:02.720 --> 00:15:05.620
it. See, this is interesting.
I keep thinking about computer

298
00:15:05.620 --> 00:15:08.260
science class, because you're talking
about things that, I mean,

299
00:15:08.410 --> 00:15:11.080
really honestly, when was the
last time a C sharp

300
00:15:11.080 --> 00:15:13.060
programmer who wasn't in academia
had to whip out a

301
00:15:13.060 --> 00:15:16.660
singly link list. Yeah. It
just doesn't. I mean, it

302
00:15:16.660 --> 00:15:18.100
happens and I'm sure that
there'll be, I'll get, I'll

303
00:15:18.100 --> 00:15:20.110
get an email from listeners.
It'll say, okay, man, I

304
00:15:20.110 --> 00:15:22.870
do this all the time.
But when you look in

305
00:15:22.870 --> 00:15:26.590
system dot collection, that wasn't
the first thing that doubly

306
00:15:26.590 --> 00:15:28.870
linked lists and singly. This
were not the first things

307
00:15:28.870 --> 00:15:32.020
that leap out of the
collections. It's mostly just, here's

308
00:15:32.020 --> 00:15:34.450
a chunk of memory. And
here's how we're going to

309
00:15:34.450 --> 00:15:38.080
think about it. Sure. But
today in programming and C-sharp

310
00:15:38.110 --> 00:15:41.860
three, we don't have it.
We don't use a singly

311
00:15:41.860 --> 00:15:44.680
linked list per se. We
use something we use IEnumerable

312
00:15:44.680 --> 00:15:48.370
of T, which is essentially
the same things and iteration

313
00:15:48.370 --> 00:15:50.890
structure that is used in
link in a very similar

314
00:15:50.890 --> 00:15:53.080
way to way to the
way that an F sharp

315
00:15:53.080 --> 00:15:55.960
list would be used. It's
interesting. I didn't think about

316
00:15:55.960 --> 00:15:59.410
that because my next question
was going to be, has

317
00:15:59.410 --> 00:16:02.260
F sharp kind of come
out of nowhere and because

318
00:16:02.260 --> 00:16:06.550
it includes cause it included
non-functional paradigms. Cause we, at

319
00:16:06.550 --> 00:16:08.470
the beginning of the talk
here, I was asking you

320
00:16:08.470 --> 00:16:11.890
about how you threw up
this diagram that said functional

321
00:16:11.890 --> 00:16:15.190
and an object oriented and
imperative. And then you drew

322
00:16:15.190 --> 00:16:16.930
this kind of circle around
them all and said, well,

323
00:16:16.930 --> 00:16:20.770
F sharp really encompasses all
of these things. And one

324
00:16:20.770 --> 00:16:23.530
of the things that I
personally feel has made functional

325
00:16:23.530 --> 00:16:27.490
programming languages, less applicable to
me in my life was

326
00:16:27.490 --> 00:16:32.230
that the problems I solved
didn't feel like classical functional

327
00:16:32.230 --> 00:16:36.820
problems, but as this may
be one of the most

328
00:16:36.940 --> 00:16:40.720
accessible languages for the.net developer,
because I can do things

329
00:16:40.720 --> 00:16:45.490
in the old way, but
put my toe, I put

330
00:16:45.490 --> 00:16:47.230
my toe in the pool,
I guess if I'm not

331
00:16:47.230 --> 00:16:49.840
quite ready to jump in,
you know, Cannonball style, I

332
00:16:49.840 --> 00:16:52.660
want to just feel around
and I could move from

333
00:16:52.660 --> 00:16:55.990
paradigm to paradigm. And I
wonder if this is, are

334
00:16:55.990 --> 00:17:00.220
there other languages that are
that inclusive, that broad reaching

335
00:17:00.250 --> 00:17:03.010
in their style that they
would let you move kind

336
00:17:03.010 --> 00:17:08.380
of comfortably from, from, Oh,
to functional to imperative, There

337
00:17:08.380 --> 00:17:12.100
are others, but I I'm
I'm I'm not finding them.

338
00:17:12.700 --> 00:17:14.860
Yeah. I'm, I'm really not.
The F sharp for me

339
00:17:14.860 --> 00:17:16.630
is the one that that's
really spoken to me. It

340
00:17:16.630 --> 00:17:20.590
really makes this the most
clear, especially with functional programming.

341
00:17:20.590 --> 00:17:23.980
If you go to, you
know, for example, if you

342
00:17:23.980 --> 00:17:25.450
want to try and learn
functional programming and go to

343
00:17:25.450 --> 00:17:28.610
a language like Haskell, that's
what I learned thing. Right?

344
00:17:28.630 --> 00:17:31.570
So, you know, it's a
very language and there, there

345
00:17:31.570 --> 00:17:34.090
are certain things that are
forced upon you, whereas an

346
00:17:34.090 --> 00:17:36.460
F sharp, like we said
earlier, yes, you can, your,

347
00:17:36.490 --> 00:17:39.580
your variables are immutable by
default, but it's fine to

348
00:17:39.580 --> 00:17:41.380
go ahead and declare a
mutable value as well because

349
00:17:41.380 --> 00:17:44.410
F sharp does embrace imperative.
Programming allows you approach to

350
00:17:44.410 --> 00:17:47.200
programming an imperative style as
well. If you, if that's,

351
00:17:47.200 --> 00:17:50.730
what's, what's comfortable to you,
hopefully as you get, get

352
00:17:50.730 --> 00:17:54.240
more comfortable with a language,
you'll do that less, but

353
00:17:54.460 --> 00:17:57.540
we won't fall back so
much on, on, on that

354
00:17:57.540 --> 00:18:00.090
kind of old, older, older
style, thinking that that's more

355
00:18:00.090 --> 00:18:02.840
comfortable to you. This is
a very inclusive language. You

356
00:18:02.840 --> 00:18:05.240
know, we had Robert Pickering
on the show who wrote

357
00:18:05.600 --> 00:18:08.050
an F sharp book a
couple of months ago. And

358
00:18:08.150 --> 00:18:09.470
he pointed out that one
of the things that was

359
00:18:09.470 --> 00:18:12.800
attracted to him, that it
allows you to have significant

360
00:18:12.800 --> 00:18:16.640
white space Yes. Or not.
Yes. And that, Or not

361
00:18:16.640 --> 00:18:20.030
part was really interesting because
it's, it's unusual for me.

362
00:18:20.090 --> 00:18:23.990
I would think that a
language could provide a, a

363
00:18:23.990 --> 00:18:26.360
choice like that languages are
always so dogmatic, you know,

364
00:18:26.660 --> 00:18:30.050
here's how we do things
in Scott Sharp. And, you know,

365
00:18:30.050 --> 00:18:32.420
if you don't like that,
well, phooey on you, but

366
00:18:32.420 --> 00:18:35.180
here's a language that said
that here's a religious issue

367
00:18:35.660 --> 00:18:38.720
that, you know, it's almost
like don't eat pork, but

368
00:18:38.720 --> 00:18:42.170
if you do, here's some
wonderful recipes And it's that

369
00:18:42.170 --> 00:18:44.180
way. An audit, joining a
programming too, with F sharp,

370
00:18:44.240 --> 00:18:47.660
I'm finding as I, as
I, as I do Oop

371
00:18:47.670 --> 00:18:50.930
style code in F sharp
I'm writing design patterns, I'm

372
00:18:50.930 --> 00:18:53.150
coding them in very different
ways than I would have

373
00:18:53.420 --> 00:18:57.020
in a language like Java
or C sharp. For example,

374
00:18:57.510 --> 00:18:59.090
you just made it a,
I mean, a really good

375
00:18:59.090 --> 00:19:02.180
example of giving you the
options there, but not saying

376
00:19:02.180 --> 00:19:05.690
here's what you have to
do F sharp supports implementation,

377
00:19:05.690 --> 00:19:10.760
inheritance, right. But implementation, inheritance
has some baggage and overhead

378
00:19:10.760 --> 00:19:13.160
associated with it. When you,
when you descend from a

379
00:19:13.160 --> 00:19:16.110
class you're, you're essentially making
a more complex object a

380
00:19:16.110 --> 00:19:18.800
lot of the times. And
so, so implementation appearance can

381
00:19:18.800 --> 00:19:21.130
be the cause of some
problems in object models that

382
00:19:21.140 --> 00:19:24.950
become riddle objects, models become
brittleness sort of thing. So

383
00:19:24.950 --> 00:19:27.680
F sharp allows you to
do implementation inheritance, but it

384
00:19:27.680 --> 00:19:30.650
downplays it. And it gives
you another language feature called

385
00:19:30.650 --> 00:19:34.340
object expressions, which allow you
to take, say an abstract

386
00:19:34.340 --> 00:19:37.580
class or an interface, and
just instantiate it, giving it

387
00:19:37.580 --> 00:19:40.010
its members, giving it the
implementations that you want at

388
00:19:40.010 --> 00:19:41.870
the time that you instantiate
it. So instead of actually

389
00:19:41.870 --> 00:19:43.760
having to go out and
declare something and declare some

390
00:19:43.760 --> 00:19:46.580
descendant or implementer of something,
you can just, you can

391
00:19:46.580 --> 00:19:50.880
just, just construct it right.
There Is interesting because it's,

392
00:19:50.880 --> 00:19:54.530
it's not a language that
is looking down on you.

393
00:19:54.530 --> 00:19:56.540
If you try to do
something, it's saying that this

394
00:19:56.540 --> 00:19:59.120
is you can do this.
And rather than making you

395
00:19:59.120 --> 00:20:02.450
feel guilty about it, they
simply provide an alternative method

396
00:20:02.450 --> 00:20:04.640
that if you find more
attractive, we would encourage you

397
00:20:04.640 --> 00:20:07.250
to use. So it's a
very friendly language. It's a

398
00:20:07.250 --> 00:20:09.500
very friendly language, But it's
also, it's a research language.

399
00:20:09.500 --> 00:20:12.470
So when I said it
was immense, part of that

400
00:20:12.470 --> 00:20:16.790
is that it just keeps
getting more features that some

401
00:20:16.790 --> 00:20:21.230
of which are very experimental.
So it it's, it's, it's,

402
00:20:21.260 --> 00:20:24.380
it's a, it's a very
friendly language in the one

403
00:20:24.380 --> 00:20:27.470
sense. And the other sense
it's, it's very large. It

404
00:20:27.470 --> 00:20:28.880
seems like if you, if
you looked at all the

405
00:20:28.880 --> 00:20:30.980
features in a big list,
it would be very daunting.

406
00:20:31.250 --> 00:20:35.210
So my talk earlier was
about trying to start a

407
00:20:35.210 --> 00:20:38.480
little bit, trying to start
smaller with it and, and

408
00:20:38.480 --> 00:20:40.850
build from there. It's a
good topic, starting small with

409
00:20:40.850 --> 00:20:44.150
F sharp. Yeah. That's our
topic today. Now, This is

410
00:20:44.150 --> 00:20:46.220
interesting. When you say it's
immense, are you saying it

411
00:20:46.220 --> 00:20:48.430
is immense in its feature
set or is it immense

412
00:20:48.430 --> 00:20:49.900
in the sense that it's
going to use a lot

413
00:20:49.900 --> 00:20:53.170
of those, if I hold
down shift and start pushing

414
00:20:53.200 --> 00:20:55.540
funky swear word, looking characters
at the top of the,

415
00:20:55.960 --> 00:20:57.910
the numbers row of my
keyboard, that it's going to

416
00:20:57.910 --> 00:20:59.860
use more of those in
a very tourist and unconscious.

417
00:21:00.630 --> 00:21:04.380
No, it doesn't. It's, it's,
it's, it's actually very succinct.

418
00:21:04.530 --> 00:21:06.120
I mean, a part of
that is the type inference

419
00:21:06.660 --> 00:21:11.250
part of that's just flexible
syntax, but it it's immense

420
00:21:11.250 --> 00:21:13.290
and its feature set. There
are, there are things that,

421
00:21:13.530 --> 00:21:15.900
that I haven't touched yet.
I just haven't had the

422
00:21:15.900 --> 00:21:18.990
time I'm spending time learning
how to do certain things

423
00:21:18.990 --> 00:21:22.320
with a language, you know,
what solve my problem domains

424
00:21:22.320 --> 00:21:24.360
at the time. And I
don't have time to look

425
00:21:24.360 --> 00:21:27.990
at this other giant piece
of the language over here.

426
00:21:28.890 --> 00:21:31.290
For example, like computation expressions
is something that I've not

427
00:21:31.290 --> 00:21:33.300
had time to look at.
And for if there's a

428
00:21:33.300 --> 00:21:36.780
Haskell listener, it's that means
that we're talking about monads

429
00:21:36.780 --> 00:21:38.490
here in a sharp. I
haven't had an opportunity to

430
00:21:38.490 --> 00:21:41.820
look at that. And, and
it's just, it's just immense.

431
00:21:42.690 --> 00:21:44.040
One of the things that
I, I have trouble with

432
00:21:44.040 --> 00:21:47.370
when I'm learning a new,
a new language, whether it

433
00:21:47.370 --> 00:21:51.990
be a linguistic language, a
human language, or a programming

434
00:21:51.990 --> 00:21:54.570
languages as I, I can
get the job done at

435
00:21:54.570 --> 00:21:56.430
some point, but I don't
know if I said it

436
00:21:56.430 --> 00:21:59.630
correctly. Someone said to me
once that if you, if

437
00:21:59.640 --> 00:22:01.830
you have a friend who
says, you know, I speak,

438
00:22:01.890 --> 00:22:04.680
I speak 12 languages. I
speak really well. Oh yeah.

439
00:22:04.710 --> 00:22:07.170
You know, a French totally
speak French. And they say,

440
00:22:07.170 --> 00:22:10.080
really, you speak French. You
should ask them how to

441
00:22:10.080 --> 00:22:15.120
say, flush the toilet. And
if, if they may be

442
00:22:15.120 --> 00:22:17.100
hung out in France for
six weeks on a backpacking

443
00:22:17.100 --> 00:22:22.020
trip, they might say something
in French, like the bowl

444
00:22:22.020 --> 00:22:24.420
of toilet, you know, the
toilet bowl with the water

445
00:22:24.420 --> 00:22:26.820
pull the, you know, or
whatever. They might say, something

446
00:22:27.210 --> 00:22:29.760
that kind of sounds like
and explains the process of

447
00:22:29.760 --> 00:22:33.150
toilet flushing, but they don't
know the ed amatic specific

448
00:22:33.150 --> 00:22:36.120
speech. And apparently in France,
it's like a pull. The

449
00:22:36.120 --> 00:22:39.090
chain is the, is the
idiomatic speech that means flush

450
00:22:39.090 --> 00:22:41.640
the toilet. And if you
ask in any language, they

451
00:22:41.640 --> 00:22:44.490
all have a different way
of expressing that, but you

452
00:22:44.490 --> 00:22:47.600
couldn't know that unless you
lived there and we knew

453
00:22:47.690 --> 00:22:50.640
and worked, so people will
dance around the right way

454
00:22:50.640 --> 00:22:52.620
to do that. So when
I try to learn a

455
00:22:52.620 --> 00:22:54.720
new language, like I have
sharp, I can, I can

456
00:22:54.720 --> 00:22:58.260
get myself, I can express
that bowl with the water,

457
00:22:58.260 --> 00:23:00.840
and then it goes away
and, you know, I get

458
00:23:00.840 --> 00:23:02.760
my point across, but I
don't know if I did

459
00:23:02.760 --> 00:23:06.270
it. Right. Right. How do
I know in F sharp

460
00:23:06.450 --> 00:23:09.690
that it, I mean, the
fact that it worked isn't

461
00:23:09.930 --> 00:23:12.510
that it Was the correct
the most elegant way to

462
00:23:12.510 --> 00:23:14.370
do it. Was it the
most idiomatic way to do

463
00:23:14.370 --> 00:23:16.320
it? Is that what, Yeah,
I think so. And then

464
00:23:16.320 --> 00:23:19.710
with, with the, with the
rise of Ruby and this

465
00:23:19.740 --> 00:23:22.680
notion of the programmer aesthetic
and the language is genetic,

466
00:23:23.070 --> 00:23:28.950
I feel more insecure about
my code than ever before.

467
00:23:28.950 --> 00:23:30.660
I mean, that's a really
uncomfortable thing. I'll say it

468
00:23:30.660 --> 00:23:34.080
again. I feel insecure about
my code more now than

469
00:23:34.080 --> 00:23:38.790
before, because there seems to
be an unwieldy amount of

470
00:23:38.790 --> 00:23:41.940
peer pressure on behalf of
the community, no matter what

471
00:23:41.940 --> 00:23:44.550
language they have about, well,
you know, here's a better

472
00:23:44.550 --> 00:23:47.480
way that you have done
that, you know, someone will

473
00:23:47.480 --> 00:23:49.250
write something and then another
guy comes out with its

474
00:23:49.250 --> 00:23:51.470
T sharp LINQ expression that,
you know, is like eight

475
00:23:51.470 --> 00:23:55.010
characters and it's unbelievably elegant.
It doesn't feel like a

476
00:23:55.010 --> 00:23:57.860
really great way to learn
a language. And certainly not

477
00:23:57.860 --> 00:23:59.660
a very good way to
feel good about oneself. Sure.

478
00:23:59.870 --> 00:24:02.390
How do you know when
you're learning F sharp? Because

479
00:24:02.390 --> 00:24:04.670
you're, I mean, I would
say you're relatively new to

480
00:24:04.670 --> 00:24:06.800
this language, right? Yeah. How
do you know that you've

481
00:24:06.830 --> 00:24:08.860
got it right? That this
was the right way, that

482
00:24:08.860 --> 00:24:11.000
the beautiful way do you
ask around, do you look

483
00:24:11.000 --> 00:24:14.480
at examples? How can a
listener jump into this language?

484
00:24:14.480 --> 00:24:16.730
Because so often you hear
people say, Oh, you haven't

485
00:24:16.730 --> 00:24:18.950
Pocono with F sharp. We're
poking around with this language.

486
00:24:19.280 --> 00:24:20.840
They make it a chapter
or two into a book,

487
00:24:20.840 --> 00:24:23.210
but they don't really drink
deeply of the language and

488
00:24:23.210 --> 00:24:25.190
learn how to say, flush
the toilet. There's a budding

489
00:24:25.190 --> 00:24:27.920
community around F sharp that
will help that you can

490
00:24:27.920 --> 00:24:30.890
go and you can ask
questions and you can see

491
00:24:31.850 --> 00:24:35.060
examples of, of ways to
do things. I'll go to

492
00:24:35.060 --> 00:24:37.550
the, the Fs hub, which
is a community server that

493
00:24:37.550 --> 00:24:39.230
was set up with forums
on it, that people ask

494
00:24:39.230 --> 00:24:41.660
questions, and someone will post
a bit of code and

495
00:24:41.660 --> 00:24:44.210
say, Hey, what's the best
way to do this. And

496
00:24:44.210 --> 00:24:48.620
then you'll get four different
responses with different styles and

497
00:24:48.620 --> 00:24:51.140
different ways to do things.
And it's, it's, it's, it's

498
00:24:51.140 --> 00:24:53.590
a friendly community, which is
fun. And you can, you

499
00:24:53.590 --> 00:24:55.880
can, and then eventually you'll
see, one of the, even

500
00:24:55.880 --> 00:24:57.410
one of the implementers of
the language will come on

501
00:24:57.410 --> 00:24:59.660
and say, Oh no, here's
how I can do this

502
00:24:59.660 --> 00:25:01.730
really succinctly. And that's kind
of a lot of fun.

503
00:25:01.730 --> 00:25:04.880
There's, there's a, it's almost
like there's, it's, there's an

504
00:25:04.880 --> 00:25:08.200
engagement of people to write
elegant, beautiful code with F

505
00:25:08.200 --> 00:25:09.860
sharp and they're willing to
help each other do it.

506
00:25:10.430 --> 00:25:15.710
And another resource is that
the, the F sharp source

507
00:25:15.770 --> 00:25:18.640
actually ships with the language.
So you can go down

508
00:25:18.660 --> 00:25:22.160
the libraries. You can look
at elegant ways to do

509
00:25:22.160 --> 00:25:24.440
things the way to see
how the language is built

510
00:25:24.440 --> 00:25:25.910
up. You can look at
how that F sharp list

511
00:25:25.910 --> 00:25:29.780
is implemented and see that
that is, it's an essence

512
00:25:29.930 --> 00:25:32.570
written in three lines of
code, for example. And it's

513
00:25:32.570 --> 00:25:35.300
just, there's, there's a lot
of beauty within the libraries

514
00:25:35.300 --> 00:25:39.020
themselves. Yeah. That's a very
interesting, interesting perspective. I didn't

515
00:25:39.020 --> 00:25:42.260
realize that since those libraries
ship, they would be the

516
00:25:42.260 --> 00:25:44.870
canonical example of a good
way to do something. Sure.

517
00:25:45.410 --> 00:25:47.720
Fantastic. Well, I really appreciate
you taking the time to

518
00:25:47.720 --> 00:25:49.070
sit down with me. I
know that you're missing a

519
00:25:49.070 --> 00:25:51.920
session right now, and this
was really interesting stuff. Thanks.

520
00:25:51.950 --> 00:25:54.260
I, I think that F
sharp is going to be

521
00:25:55.580 --> 00:25:57.800
kind of the new dotnet
language. I understand it's going

522
00:25:57.800 --> 00:26:00.380
to be in visual studio.
It's supported in a more

523
00:26:00.380 --> 00:26:03.470
fundamental way. Are we going
to see we factoring tools

524
00:26:03.470 --> 00:26:06.890
for F sharp? Perhaps I'm
a, a, that's kind of

525
00:26:06.890 --> 00:26:08.570
a personal goal of mine
this year. I don't think

526
00:26:08.570 --> 00:26:11.210
I can make any announcements
about things, but know that

527
00:26:11.210 --> 00:26:14.330
we are looking very closely
at F sharp for code

528
00:26:14.330 --> 00:26:17.510
rush and refactor support for
code, rush, and refactor. So

529
00:26:17.930 --> 00:26:20.960
from dev express, so, you
know, maybe on the horizon,

530
00:26:20.960 --> 00:26:24.110
you might see something there.
Fantastic new language on the

531
00:26:24.110 --> 00:26:26.540
horizon. F sharp. Thank you
very much, Dustin, for sitting

532
00:26:26.540 --> 00:26:28.640
down with me here at
code, man, this has been

533
00:26:28.640 --> 00:26:30.560
another episode of Hansel minutes,
and I'll see you again

534
00:26:30.560 --> 00:26:37.690
next week. <inaudible>.


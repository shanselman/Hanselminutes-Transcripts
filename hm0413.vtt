WEBVTT FILE

1
00:00:12.090 --> 00:00:17.220
From Hansel minutes.com. It's Hansel
minutes, all weekly discussion with

2
00:00:17.220 --> 00:00:21.270
web developer and technologist and
Scott Hanselman. This is Lawrence Ryan

3
00:00:21.270 --> 00:00:27.540
announcing show number four 16
recorded live Thursday, March 20th, 2014. This

4
00:00:27.540 --> 00:00:30.150
episode of Hansel minutes is
brought to you by Tellerik

5
00:00:30.300 --> 00:00:34.560
empowering over 1 million developers to
create compelling app experiences across

6
00:00:34.560 --> 00:00:42.270
any screen. Learn more@terik.com and
by Franklin stock makers of

7
00:00:42.270 --> 00:00:46.290
gesture pack a powerful gesture,
recording and recognition system for

8
00:00:46.290 --> 00:00:53.460
Microsoft connect for windows developers
details@gesturepak.com. In this episode, Scott

9
00:00:53.460 --> 00:01:00.290
talks with Andrew Duran about the
go programming language. Hi, this

10
00:01:00.290 --> 00:01:02.660
is Scott Hanselman. This is
another episode of Hansel minutes,

11
00:01:02.690 --> 00:01:05.780
and I'm chatting with Andrew Duran,
who is a developer on

12
00:01:05.780 --> 00:01:09.410
the go team at Google.
How are you, sir? Good.

13
00:01:09.410 --> 00:01:11.990
How are you? Lovely. Thanks
so much for taking the

14
00:01:11.990 --> 00:01:13.820
time to chat with me
today, all the way from

15
00:01:13.820 --> 00:01:18.620
Sydney. So I want to
understand where go as a

16
00:01:18.620 --> 00:01:21.800
language fits in. Like there
seems to be a Renaissance

17
00:01:21.800 --> 00:01:24.140
at languages right now. Everyone's
making a new language. Every

18
00:01:24.140 --> 00:01:26.270
time I go to hacker
news, there's a new language

19
00:01:26.270 --> 00:01:29.600
coming out and Google's got
dart and they've got go.

20
00:01:30.050 --> 00:01:31.940
I understand that there was
a time at Google where

21
00:01:31.940 --> 00:01:34.430
there are only a few
languages allowed, right? You had

22
00:01:34.430 --> 00:01:36.410
a very limited number of
languages to choose from. Wasn't

23
00:01:36.410 --> 00:01:39.740
it basically Java and C
plus plus, I mean, I,

24
00:01:40.250 --> 00:01:42.890
I think maybe that's slight
exaggeration. Like there people have

25
00:01:42.890 --> 00:01:48.320
been creating languages pretty consistently
for pretty much since computers

26
00:01:48.320 --> 00:01:54.080
have been around, but so
on the Google angle, we

27
00:01:54.080 --> 00:01:56.660
actually still only have a
very small number of languages

28
00:01:56.660 --> 00:02:00.710
that usable by the general
engineering population. And they are

29
00:02:01.160 --> 00:02:04.760
C plus plus Java Python
and go, and of course

30
00:02:04.760 --> 00:02:07.400
we use Java script for
front end stuff, of course,

31
00:02:07.400 --> 00:02:10.850
but those four are considered
the canonical languages. And then

32
00:02:10.850 --> 00:02:14.330
we also have a couple
of sort of domain specific

33
00:02:14.330 --> 00:02:17.480
languages that we've developed inside
of Google. There were sores

34
00:02:17.480 --> 00:02:19.880
all for logs processing, which
is also being used by

35
00:02:19.880 --> 00:02:25.640
some people outside and we
have a language specifying monitoring,

36
00:02:25.640 --> 00:02:30.620
configurations and machine configurations and
so on. So Google's always

37
00:02:30.620 --> 00:02:34.430
been a place where we've
been on afraid of creating

38
00:02:34.430 --> 00:02:38.390
new languages. So it's kind
of natural the way we

39
00:02:38.390 --> 00:02:44.600
should see a couple coming
out. What's interesting about open

40
00:02:44.600 --> 00:02:47.990
source projects that Google is
effectively sponsoring and putting a

41
00:02:47.990 --> 00:02:51.770
lot of engineering effort behind.
And so they're not just

42
00:02:51.770 --> 00:02:53.870
for Google to use, but
they're really for everyone to

43
00:02:53.870 --> 00:02:57.470
use. And we sort of
hope that particularly in the

44
00:02:57.470 --> 00:03:01.930
case of Gara, that we
can kind, I guess, philosophically

45
00:03:01.930 --> 00:03:06.160
Rupert some people's assumptions about
what's necessary and expected from

46
00:03:06.160 --> 00:03:10.270
a programming language. And so
what do I mean by

47
00:03:10.270 --> 00:03:14.680
that? Well, one thing that
people, when they look at

48
00:03:14.680 --> 00:03:18.480
Gore, Should I, should I
talk about what go is

49
00:03:18.570 --> 00:03:22.420
in general? Well, let's, let's
talk about that. Like go

50
00:03:22.470 --> 00:03:26.610
as a language that solves
what problem, like, why, why

51
00:03:26.610 --> 00:03:29.640
go and why now? So
you're to give her A

52
00:03:29.640 --> 00:03:33.030
bit of background on where
go came from. It was

53
00:03:33.600 --> 00:03:37.020
developed by a small team
of people, Rob pike, Ken

54
00:03:37.020 --> 00:03:41.040
Thompson, and Robert Greasimer, who
were engineers at Google and

55
00:03:41.040 --> 00:03:44.130
had been there for, I
guess, five or six years

56
00:03:44.130 --> 00:03:46.380
at the time. And this
is when Google was about

57
00:03:46.920 --> 00:03:51.720
six or seven years old.
And so they were accustomed

58
00:03:51.720 --> 00:03:55.410
to building services at Google,
mostly in C plus plus,

59
00:03:55.710 --> 00:04:02.610
and some Java, I guess,
and Google is basically a

60
00:04:02.610 --> 00:04:05.430
large C plus plus code
base and a pretty substantial

61
00:04:05.430 --> 00:04:08.880
Java code base with Python
and the other languages, a

62
00:04:08.880 --> 00:04:14.460
distant kind of third and
so on, but only a

63
00:04:14.460 --> 00:04:18.720
really small fraction of the,
the services built at Google

64
00:04:18.750 --> 00:04:23.190
require the kind of control
that you get with C

65
00:04:23.190 --> 00:04:27.060
plus plus like Sables pluses,
a fantastically powerful language, but

66
00:04:27.060 --> 00:04:29.160
it also requires you to
think about a lot of

67
00:04:29.160 --> 00:04:32.700
stuff. It's also a very
complicated language. And so even

68
00:04:32.700 --> 00:04:36.660
if you're writing something really
simple, like a, like a

69
00:04:36.660 --> 00:04:39.480
web app, for instance, or
a command line utility or

70
00:04:39.480 --> 00:04:42.780
something like that, you still
need to think about memory

71
00:04:42.780 --> 00:04:47.370
management and you still have
to deal with many, many

72
00:04:47.370 --> 00:04:49.980
aspects of the building build
system and language. And so

73
00:04:49.980 --> 00:04:55.860
on that, you know, if
you're using Python or Ruby

74
00:04:55.860 --> 00:05:00.180
or something like that, you
it's a lot easier, you

75
00:05:00.180 --> 00:05:04.710
know, it's, you can just,
those dynamic languages mean you

76
00:05:04.710 --> 00:05:08.370
don't have to think about
the type system and you

77
00:05:08.370 --> 00:05:10.350
can just kind of write
what you mean, and then

78
00:05:10.350 --> 00:05:14.250
it comes out and it
works, but sort of in

79
00:05:14.250 --> 00:05:17.040
the culture of Google, where
we used C plus plus

80
00:05:17.040 --> 00:05:20.460
for everything and to talk
to various services, you know,

81
00:05:20.460 --> 00:05:24.060
you really needed to be
using C plus plus libraries.

82
00:05:24.690 --> 00:05:27.840
You were kind of locked
into that approach. And it

83
00:05:27.840 --> 00:05:30.780
was very hard to argue
that you could use Python

84
00:05:30.780 --> 00:05:34.590
instead because Python doesn't really
give you control of a

85
00:05:34.590 --> 00:05:40.440
memory it's generally very inefficient.
So it really limits what

86
00:05:40.440 --> 00:05:42.510
it's useful for even, even
though it is more fun

87
00:05:42.510 --> 00:05:45.000
to use. And so the
question was really, you know,

88
00:05:45.060 --> 00:05:48.420
can we have a language
which is as easy and

89
00:05:48.420 --> 00:05:51.300
it's fun to use as
these newest scripting languages, but

90
00:05:51.300 --> 00:05:55.230
that still gives you enough
control to do things, you

91
00:05:55.230 --> 00:06:00.800
know, the sensible way, the
efficient and so go is,

92
00:06:00.850 --> 00:06:04.970
is that language go is
basically, you could look at,

93
00:06:04.970 --> 00:06:08.240
go as starting off with
C and taking away a

94
00:06:08.240 --> 00:06:12.350
lot of the dangerous man
manual memory management stuff, and

95
00:06:12.350 --> 00:06:18.860
then re reexamining the top
system and just putting in

96
00:06:18.860 --> 00:06:24.170
there what is necessary and
then adding some concurrency and

97
00:06:24.170 --> 00:06:28.160
adding a few other nice
things. And so what you

98
00:06:28.160 --> 00:06:31.160
get is a language, which
is as fun to use

99
00:06:31.160 --> 00:06:34.370
as a scripting language, but
it gives you type safety.

100
00:06:34.880 --> 00:06:40.790
It gives you, you know,
efficient runtime performance. And so

101
00:06:42.080 --> 00:06:45.200
it kind of sits in
this middle ground between what

102
00:06:45.200 --> 00:06:50.500
we consider lower level system
languages and scripting languages. What

103
00:06:50.500 --> 00:06:53.230
do you think it is
that makes a language fun?

104
00:06:53.620 --> 00:06:56.320
I, and I'm sure everyone
has their opinion, and that's

105
00:06:56.320 --> 00:06:59.530
a very objective and I
don't particularly find CNC plus

106
00:06:59.530 --> 00:07:01.690
plus fun. I certainly don't
find C plus plus fun

107
00:07:01.690 --> 00:07:05.770
anymore. C plus plus represents
frustration to me. Yeah. I

108
00:07:05.770 --> 00:07:09.850
mean, I think a language
is fun when you can

109
00:07:09.880 --> 00:07:12.400
think about something and then
you can just ride it

110
00:07:12.400 --> 00:07:14.230
out the way you think
it should work. And that,

111
00:07:14.290 --> 00:07:18.880
that works and fun is
also being able to experiment

112
00:07:18.880 --> 00:07:22.120
quickly so that you can
take something and, you know,

113
00:07:22.210 --> 00:07:25.330
quickly change the way that
works quickly, you know, try

114
00:07:25.330 --> 00:07:28.060
out a new idea, a
new interface that you think

115
00:07:28.060 --> 00:07:31.360
might be better without having
to go back and, you

116
00:07:31.360 --> 00:07:35.260
know, reef go on some
big yak, shave refactoring mission

117
00:07:35.260 --> 00:07:40.930
to do that. And I
guess, you know, part of

118
00:07:40.930 --> 00:07:43.600
the reason why go is
fun is that it was

119
00:07:43.600 --> 00:07:47.830
designed for, for scale. It
was designed for this to

120
00:07:47.830 --> 00:07:50.440
be working on really, really
large code bases with really

121
00:07:50.440 --> 00:07:55.660
large numbers of programmers. And
that design philosophy kind of

122
00:07:55.660 --> 00:08:00.190
caused us to put less
complexity into the language itself.

123
00:08:01.210 --> 00:08:04.180
So it has this much
smaller set of features compared

124
00:08:04.180 --> 00:08:08.830
to most, most mainstream languages.
And as a result, you

125
00:08:08.830 --> 00:08:12.640
can really look at any
code and really understand what

126
00:08:12.640 --> 00:08:16.960
that code does even on
a superficial reading. So you

127
00:08:16.960 --> 00:08:19.030
don't need to have a
lot of context to really

128
00:08:19.030 --> 00:08:23.650
understand part of a system.
And that property for working

129
00:08:23.650 --> 00:08:27.820
in the lodge translates really
well into fun at the,

130
00:08:27.880 --> 00:08:30.250
in the small. So if
you're working on your own

131
00:08:30.250 --> 00:08:35.290
personal project, you know, if
you decide that, you know,

132
00:08:35.290 --> 00:08:39.220
you want to fundamentally change
the, the core interface of

133
00:08:39.220 --> 00:08:41.980
your program, it's just a
bit of search and replace

134
00:08:41.980 --> 00:08:46.750
that's required. It's not, it's
not a full on sort

135
00:08:46.750 --> 00:08:48.670
of, you don't have to
go around and fix all

136
00:08:48.670 --> 00:08:57.270
your inheritance hierarchies or whatever.
And yeah, so that's kind

137
00:08:57.270 --> 00:08:59.430
of on the type system
side. The thing that makes

138
00:08:59.430 --> 00:09:04.800
it fun in another way
is that it's concurrency system

139
00:09:04.800 --> 00:09:09.960
lets you model concurrent problems,
which are generally the type

140
00:09:09.960 --> 00:09:12.450
of problems we deal with
in network environments. Like we're

141
00:09:12.450 --> 00:09:15.750
writing web applications and so
on. And it lets you

142
00:09:15.780 --> 00:09:17.910
deal with them in a,
in a pretty natural way,

143
00:09:18.480 --> 00:09:22.830
in a way that's generally
safer than the approaches that

144
00:09:22.830 --> 00:09:27.450
you might take in sort
of more traditional thread based

145
00:09:27.450 --> 00:09:31.140
environments. Is it, is it
from a concurrency perspective, it

146
00:09:31.490 --> 00:09:35.300
introduces a number of concurrency
related syntax and types to

147
00:09:35.300 --> 00:09:38.420
support that. Is it, is
it upleveling things or is

148
00:09:38.420 --> 00:09:40.910
it just taking the knowledge
of the last, you know,

149
00:09:40.910 --> 00:09:44.570
many years of people trying
to solve these concurrency problems?

150
00:09:44.570 --> 00:09:46.460
And like you said, pairing
it down to just what

151
00:09:46.460 --> 00:09:51.380
is needed Concurrency approach is
inherited from a series of

152
00:09:51.380 --> 00:09:58.700
languages that Rob pike worked
on at bell labs among

153
00:09:58.700 --> 00:10:00.970
them, a new squeak and
LF. And they had a,

154
00:10:01.410 --> 00:10:07.550
a CSP based concurrency model,
which is a, a message

155
00:10:07.550 --> 00:10:10.610
processing concurrency model, which I
guess people would be kind

156
00:10:10.610 --> 00:10:12.770
of familiar with from Earl
Lang, but goes take on

157
00:10:12.770 --> 00:10:16.130
that as a bit different
And CSP is communicating sequential

158
00:10:16.130 --> 00:10:18.680
processes just for folks that
may not know that. Yeah,

159
00:10:18.680 --> 00:10:23.480
that's right. That's, that's also
channel programming, right? Yeah. Yes,

160
00:10:23.840 --> 00:10:29.570
exactly. So go's approach to
concurrency is, is at a

161
00:10:29.570 --> 00:10:32.370
language level. It's not a
library support level. It's, it's

162
00:10:32.450 --> 00:10:37.250
basically, you know, you can
write a function or a

163
00:10:37.250 --> 00:10:41.150
closure, a function closure and
put the key word, go

164
00:10:41.150 --> 00:10:43.340
in front of that and
then have that run in

165
00:10:43.340 --> 00:10:47.000
another thread. Well, I say
thread, I actually mean I

166
00:10:47.010 --> 00:10:49.760
go retain, which is a
kind of light white thread,

167
00:10:49.760 --> 00:10:53.180
like a green thread managed
by the go runtime. So

168
00:10:53.180 --> 00:10:55.160
it's not a, it's not,
it's not a threat. Like

169
00:10:55.160 --> 00:10:56.900
you use the term green
thread, which I think of

170
00:10:56.900 --> 00:10:58.820
in terms of Java, you
know, there's like a real

171
00:10:58.820 --> 00:11:02.030
thread and then a pretend
thread. Yeah. It's definitely a

172
00:11:02.030 --> 00:11:07.670
pretend thread in the sense
that I go program will

173
00:11:07.670 --> 00:11:11.600
typically spin up, you know,
only as many threads as

174
00:11:11.600 --> 00:11:15.200
a required to keep all
the cause humming along. But

175
00:11:15.200 --> 00:11:19.220
otherwise the go program and
the go runtime has a

176
00:11:19.220 --> 00:11:23.060
better understanding of the scheduling
needs of the program than

177
00:11:23.060 --> 00:11:25.670
the operating system. So rather
than pushing all that work

178
00:11:25.670 --> 00:11:29.090
onto the operating system, by
using operating system threads, it

179
00:11:29.090 --> 00:11:32.090
just schedules the execution of
these go routines across a

180
00:11:32.090 --> 00:11:37.100
smaller pool of iOS threats.
And the end result is

181
00:11:37.100 --> 00:11:39.050
that you get the kind
of performance that you get

182
00:11:39.050 --> 00:11:41.420
from say node JS. When
you have to ride in

183
00:11:41.420 --> 00:11:46.160
a, in a blocking, sorry,
in a nonblocking callback oriented

184
00:11:46.160 --> 00:11:49.400
style, but you get that
kind of performance in guard,

185
00:11:49.430 --> 00:11:51.410
but you get to write
blocking code. So you just

186
00:11:51.410 --> 00:11:54.670
write the code that blocks
and the go run time

187
00:11:54.670 --> 00:11:57.160
knows that those are blocking
events. And so it just

188
00:11:57.460 --> 00:12:02.080
reached, it just puts that
go routine into the background

189
00:12:02.170 --> 00:12:05.650
while it's waiting on some
disc IO or network IO

190
00:12:05.710 --> 00:12:09.070
or whatever. And then it
executes whatever the next waiting

191
00:12:09.070 --> 00:12:14.280
go routine. So is this
specific to IO or because

192
00:12:14.280 --> 00:12:16.680
there's the idea of running
something on a background threads

193
00:12:16.680 --> 00:12:18.390
who has not to block
things. And then there's the

194
00:12:18.390 --> 00:12:22.470
idea of doing something asynchronously
and letting some IO completion

195
00:12:22.470 --> 00:12:24.780
port handle it in, let
me know when it's done.

196
00:12:24.870 --> 00:12:27.570
Is this something you can
do with CPU intensive things

197
00:12:27.570 --> 00:12:29.130
or is it only things
where you're writing to disk

198
00:12:29.130 --> 00:12:31.800
or talking on a wire?
No, it is, it is

199
00:12:31.800 --> 00:12:34.830
possible to do it with
CPU intensive things as well.

200
00:12:35.220 --> 00:12:39.720
You can, I mean, obviously
if you have more concurrent

201
00:12:39.720 --> 00:12:43.050
CPU, intensive things going on,
then you have cause to

202
00:12:43.050 --> 00:12:45.510
spare, then some of those
processes are going to be

203
00:12:45.510 --> 00:12:52.530
stabbed, but in general, the
Goretti schedule is a bit

204
00:12:52.530 --> 00:12:55.230
preemptive. Now it used to
be totally co-operative but now

205
00:12:55.230 --> 00:12:59.160
it's, it, it will preempt
the threads. So you can

206
00:12:59.160 --> 00:13:04.590
just run, you know, many
parallel computations in the runtime.

207
00:13:04.590 --> 00:13:08.940
We'll just sorted out. Generally.
I think the scheduler is,

208
00:13:08.970 --> 00:13:15.000
is the scheduler is aware
of the network. So it's,

209
00:13:15.030 --> 00:13:21.450
it's fairly tuned towards network
servers so that it can,

210
00:13:21.510 --> 00:13:24.720
it can know, Oh, this
go routines waiting on this

211
00:13:24.720 --> 00:13:28.050
socket. And so I know
when this socket come, when

212
00:13:28.110 --> 00:13:30.990
the message on this right
on this socket is ready

213
00:13:31.020 --> 00:13:33.750
that I will wake that
go retain, like that's kind

214
00:13:33.750 --> 00:13:35.820
of built into the core
of the schedule. So it's

215
00:13:35.820 --> 00:13:40.470
definitely more oriented to doing
IO stuff, but you know,

216
00:13:40.470 --> 00:13:43.920
there's no, there's no reason
why it's unsuitable for, for

217
00:13:43.920 --> 00:13:48.030
doing computations. So how does
that differ with Earline? Cause

218
00:13:48.030 --> 00:13:50.880
Erling also prides itself in,
in the way that it

219
00:13:50.880 --> 00:13:53.520
handles concurrency, but it's a
little bit different than the,

220
00:13:53.840 --> 00:13:57.300
the, the goal model. Yeah.
So there's a kind of,

221
00:13:57.360 --> 00:14:01.320
it's a fundamental difference between
enrolling in, go in a

222
00:14:01.320 --> 00:14:06.420
program design kind of sense.
So in go, you write

223
00:14:06.840 --> 00:14:10.380
a program that is compiled
to an executable and then

224
00:14:10.380 --> 00:14:13.530
it runs as a process
and all of the concurrency

225
00:14:13.530 --> 00:14:17.250
stuff exists within that process.
So you create go routines,

226
00:14:17.250 --> 00:14:20.910
you communicate between them with
channels, but it's all going

227
00:14:20.910 --> 00:14:24.150
on inside that, that one
process, if you want to

228
00:14:24.180 --> 00:14:28.020
communicate between processes, then the
expectation is you have some

229
00:14:28.020 --> 00:14:31.530
kind of infrastructure to do
that. Like an obviously system,

230
00:14:31.560 --> 00:14:34.410
some kind of naming name,
resolution system, and so on.

231
00:14:35.490 --> 00:14:37.290
And you know, we have
those things inside Google, there

232
00:14:37.290 --> 00:14:41.190
exists other solutions for that
outside of Google. But in

233
00:14:41.190 --> 00:14:47.610
Erlangen, they have this really
powerful VM system where Earline

234
00:14:47.610 --> 00:14:50.970
processes a much smaller and
a typical airline program are

235
00:14:50.990 --> 00:14:54.800
consist of many of these
processes that communicate through message

236
00:14:54.800 --> 00:15:02.150
processing and in an Erling
program, the expectation is that

237
00:15:02.300 --> 00:15:05.090
any of those processes can
fail at any time. And

238
00:15:05.090 --> 00:15:09.710
you design your program such
that, you know, you expect

239
00:15:09.710 --> 00:15:12.230
these things to fail and
you gracefully recover when messages

240
00:15:12.230 --> 00:15:17.480
aren't delivered and so on,
but in a go program,

241
00:15:18.710 --> 00:15:21.320
you know, the other go
routines must be running because

242
00:15:21.320 --> 00:15:24.290
you're running because you're all
running within the same process.

243
00:15:24.350 --> 00:15:26.150
And so if you send
a message to another girl

244
00:15:26.150 --> 00:15:30.710
routine, you know, that message
has been received because you

245
00:15:30.710 --> 00:15:35.930
are still alive speaking from
the garbage perspective. And so

246
00:15:36.920 --> 00:15:39.980
those two kind of represent
fundamentally different ways of thinking

247
00:15:39.980 --> 00:15:45.260
about concurrent programming. I guess
one of them is, you

248
00:15:45.260 --> 00:15:47.180
know, you expect things to
fail and you just plan

249
00:15:47.180 --> 00:15:50.090
for failure all the time.
Whereas the other is you

250
00:15:50.090 --> 00:15:54.170
kind of program with the
expectation of success at the,

251
00:15:54.410 --> 00:16:00.950
at, within a single process.
And so they're really, even

252
00:16:00.950 --> 00:16:04.760
though the message crossing property
is, is common to align

253
00:16:04.760 --> 00:16:07.370
and go the way you
use each language is really

254
00:16:07.370 --> 00:16:11.240
very different. And the runtime
performance of both is quite

255
00:16:11.240 --> 00:16:16.400
different. And you know, the
deployment story is obviously very

256
00:16:16.400 --> 00:16:19.070
different with go, you just
ship a single statically, compiled

257
00:16:19.070 --> 00:16:22.370
binary and run it with
Erlang. You have to set

258
00:16:22.370 --> 00:16:26.840
up your, your VM and
so on and administer that.

259
00:16:27.710 --> 00:16:29.810
And there are positives and
negatives, I think, to both

260
00:16:29.810 --> 00:16:32.990
approaches, but go is a
much more traditional approach in

261
00:16:32.990 --> 00:16:35.900
the sense that, you know,
you write a program that

262
00:16:35.900 --> 00:16:38.420
runs as a process on
a machine somewhere. And then

263
00:16:38.420 --> 00:16:42.050
if you need a cluster,
then you run many processes,

264
00:16:42.080 --> 00:16:44.390
but you know, you need
to build out the infrastructure

265
00:16:44.390 --> 00:16:47.180
between those things kind of
gives you that stuff free,

266
00:16:47.180 --> 00:16:49.130
but then it also locks
you into that model as

267
00:16:49.130 --> 00:16:54.100
well. So we may not
have explained kind of fully

268
00:16:54.100 --> 00:16:56.500
what the kind of runtime
environment is. I mean, we,

269
00:16:56.700 --> 00:17:00.640
we think of runtime today
in 2014, I think people

270
00:17:00.640 --> 00:17:04.360
think about virtual machines and,
you know, via, you know,

271
00:17:04.450 --> 00:17:07.780
Java, VMs and CLRs and
things like that. They're not

272
00:17:07.780 --> 00:17:10.180
used to thinking about runtimes
in the context of like

273
00:17:10.210 --> 00:17:14.620
the sea runtime is go
running in a virtual machine,

274
00:17:14.620 --> 00:17:16.300
or is it more like,
see where it is? Its

275
00:17:16.300 --> 00:17:20.560
own universe? No. So go
is go. Programs are just

276
00:17:20.560 --> 00:17:25.390
compile to statically linked binary
is that our machine code.

277
00:17:26.500 --> 00:17:29.560
And so there's no VM,
it's not interpreted in any

278
00:17:29.560 --> 00:17:32.500
way. When I speak of
the runtime, the runtime is

279
00:17:32.500 --> 00:17:37.390
essentially a object that's linked
in to that binary that

280
00:17:37.390 --> 00:17:40.060
does things like memory management
and the scheduling of go

281
00:17:40.060 --> 00:17:46.780
routines. And while it's a
part of every go program,

282
00:17:46.780 --> 00:17:48.970
it's not something that runs
the go program. It's more

283
00:17:49.170 --> 00:17:53.640
something that facilitates the go
program. If that makes sense,

284
00:17:54.720 --> 00:17:57.150
it just kind of does
the things the go program

285
00:17:57.150 --> 00:17:59.670
needs it to do. It's
like a base foundation library

286
00:17:59.790 --> 00:18:04.980
in a way in, in
that regard, the fact that

287
00:18:04.980 --> 00:18:08.640
go is compiled to machine
language. You really, there's a

288
00:18:08.640 --> 00:18:11.430
really nice property that when
you write some go code,

289
00:18:12.660 --> 00:18:15.720
and then if you look
at that assembled machine code,

290
00:18:16.440 --> 00:18:18.900
the assembly code, there is
actually really similar to the

291
00:18:18.900 --> 00:18:22.110
GOCO that you wrote. There's
not these kinds of levels

292
00:18:22.110 --> 00:18:24.870
of indirection between the card
that you write and the

293
00:18:24.870 --> 00:18:28.410
code that's executed on the
CPU. And so as a

294
00:18:28.410 --> 00:18:31.080
result, you, you actually do,
it feels like you have

295
00:18:31.080 --> 00:18:33.060
a lot more control over
what the machine is actually

296
00:18:33.060 --> 00:18:37.020
doing when compared to using
interpreted languages or machine languages

297
00:18:37.020 --> 00:18:40.880
that run on a VM.
Can you drop down any

298
00:18:40.880 --> 00:18:43.100
lower? Is there like the
metal or is go on

299
00:18:43.100 --> 00:18:46.400
the metal? Like, can I
call see libraries easily? Yeah.

300
00:18:46.400 --> 00:18:49.580
So it's, well, for one
thing, you can write a

301
00:18:49.590 --> 00:18:53.390
assembly as part of your
go packages and it will

302
00:18:53.390 --> 00:18:58.580
just get LinkedIn. So you
just write your function, a

303
00:18:59.330 --> 00:19:02.090
function specification, and then you
have an assembly file that

304
00:19:02.090 --> 00:19:05.300
implements that function. And that's,
that's quite easy to do.

305
00:19:05.690 --> 00:19:07.730
If assembly is a bit
too low level, you can

306
00:19:07.790 --> 00:19:11.300
just link against C code
and there's a tool called

307
00:19:11.300 --> 00:19:17.630
CGO or Sego. And it's
quite nice because you, the

308
00:19:17.660 --> 00:19:20.540
mechanics of it are pretty
clever. You, you just ride

309
00:19:20.540 --> 00:19:24.230
a normal go file and
you import a magical C

310
00:19:24.230 --> 00:19:28.100
package like with a capital
C and you put a

311
00:19:28.100 --> 00:19:34.700
comment above the import declaration,
which is, which actually contains

312
00:19:34.700 --> 00:19:36.470
the C code. You want
to link into your go

313
00:19:36.470 --> 00:19:42.230
code. So you have UFC
include lines, any C type

314
00:19:42.230 --> 00:19:46.070
declarations or, or function declarations
that you might need. And

315
00:19:46.070 --> 00:19:49.460
then in the go package,
you can refer to any

316
00:19:49.460 --> 00:19:52.910
of the names in the
C namespace, just by saying

317
00:19:52.910 --> 00:19:56.360
C dot for where Fu
is some name that exists

318
00:19:56.360 --> 00:19:59.510
in, in your C libraries.
And there are a bunch

319
00:19:59.510 --> 00:20:02.180
of helper functions for converting
between go types and C

320
00:20:02.180 --> 00:20:07.130
types. And so writing a
rapid go rapper libraries for

321
00:20:07.130 --> 00:20:10.910
C libraries is really straightforward.
You don't even really need

322
00:20:10.910 --> 00:20:14.180
to be a safe programmer
to do it well. And

323
00:20:14.180 --> 00:20:16.820
w are so go apps,
make no promise to be

324
00:20:16.820 --> 00:20:18.770
portable, right? If I'm going
to be doing things like

325
00:20:18.800 --> 00:20:22.280
C library linking in and
in line assembler type things,

326
00:20:22.580 --> 00:20:25.850
I would, I compile to
a particular distribution of Linux

327
00:20:25.850 --> 00:20:28.610
or compile to windows. And
then that go program only

328
00:20:28.610 --> 00:20:33.710
works on that operating system
Actually go is quite portable.

329
00:20:34.040 --> 00:20:38.030
If you only use go
the language, I mean, sorry,

330
00:20:38.030 --> 00:20:39.890
if you want to use
the bicycle or distribution. So

331
00:20:39.890 --> 00:20:42.860
the basic standard library and
so on, we've gone to

332
00:20:42.860 --> 00:20:45.920
great lengths to make sure
that you can use the

333
00:20:45.920 --> 00:20:49.930
same standard library on windows,
on Linux, on iOS 10

334
00:20:50.490 --> 00:20:55.000
and our other supportive platforms.
So while it's not compile

335
00:20:55.000 --> 00:20:58.110
once run anywhere, it is
right once and then compiled

336
00:20:58.110 --> 00:21:01.390
to any of those targets.
When you, when you introduce

337
00:21:01.400 --> 00:21:05.260
assembly, obviously, you know, if
you only provide assembly for

338
00:21:05.260 --> 00:21:10.210
64 bit Intel processes, then
it's only going to run

339
00:21:10.210 --> 00:21:15.280
on those processes. But it's,
it's very easy. We have

340
00:21:15.400 --> 00:21:19.720
a nice convention for providing
alternate implementations for different architectures.

341
00:21:19.720 --> 00:21:22.540
So if you know the
assembly for arm or, or

342
00:21:22.540 --> 00:21:25.660
three 86, you could write
that. But when it comes

343
00:21:25.660 --> 00:21:30.490
to C libraries, it's a
little bit more complex. Basically

344
00:21:30.490 --> 00:21:32.800
the short story is that
if you're using a C

345
00:21:32.800 --> 00:21:36.820
library and you go program,
your go program is only

346
00:21:36.820 --> 00:21:41.380
as portable as that C
library is. And so recently

347
00:21:41.380 --> 00:21:44.770
I've been working on an
audio synthesizer project and I'm

348
00:21:44.770 --> 00:21:48.850
using a library called port
audio, which is, Oh, it's

349
00:21:48.850 --> 00:21:51.760
go port audio, which is
a go wrapper around the

350
00:21:51.760 --> 00:21:55.300
sea port audio library. And
port audio is as the

351
00:21:55.310 --> 00:21:59.230
name suggests a portable in
a library for talking to

352
00:22:00.550 --> 00:22:04.720
audio interfaces, like your sound
cut and your computer. And

353
00:22:04.720 --> 00:22:08.800
that, that actually runs on
iOS 10 Linux and windows

354
00:22:09.010 --> 00:22:13.390
because that's where port audio
runs. And yeah, it just

355
00:22:13.390 --> 00:22:17.680
works. So that's, so it
can actually still be very

356
00:22:17.680 --> 00:22:22.540
portable, even though, you know,
you are dealing at a,

357
00:22:22.630 --> 00:22:25.750
at a lower level than
some other high level environments.

358
00:22:27.150 --> 00:22:29.520
Nice. It is as portable
as what you're using is

359
00:22:29.520 --> 00:22:32.940
portable. That's cool. Yeah, it
definitely doesn't get in your

360
00:22:32.940 --> 00:22:35.910
way. One of the things
I thought was a significant

361
00:22:36.420 --> 00:22:40.830
about go from a getting
Mindshare perspective is that the

362
00:22:40.950 --> 00:22:45.600
famous author, Bruce echo, who
was on the ANSI standard

363
00:22:45.600 --> 00:22:48.720
committee for C plus plus,
and he wrote thinking in

364
00:22:48.720 --> 00:22:53.610
C plus plus has said
that the complexity of C

365
00:22:53.610 --> 00:22:58.920
plus plus is no longer
justified vis-a-vis productivity. He says,

366
00:22:58.920 --> 00:23:00.330
all the hoops that you
have to jump through and

367
00:23:00.330 --> 00:23:02.610
all the hassle is just
is a waste. So here's

368
00:23:02.610 --> 00:23:05.340
someone who's, you know, career
is on all about C

369
00:23:05.340 --> 00:23:07.620
plus. Plus who's saying that,
you know, go makes more

370
00:23:07.620 --> 00:23:10.080
sense for the class of
problems that C plus plus

371
00:23:10.080 --> 00:23:13.530
was intended to solve. That's.
Yeah, I mean, I wouldn't

372
00:23:13.530 --> 00:23:15.630
disagree. I think there are
a lot of people, obviously

373
00:23:15.630 --> 00:23:18.660
I'm biased, but I think
there are a lot of

374
00:23:18.660 --> 00:23:23.460
people who, you know, really
good at and proficient at

375
00:23:23.460 --> 00:23:25.890
C plus plus, and it,
and it works for them.

376
00:23:27.780 --> 00:23:32.760
But I think on balance,
there are fewer and fewer

377
00:23:33.540 --> 00:23:36.780
problems that C plus plus
is really well suited to

378
00:23:36.780 --> 00:23:39.180
today, given the alternatives that
exist. And I think go

379
00:23:39.180 --> 00:23:42.420
is one of those alternatives,
for sure. What is a

380
00:23:42.450 --> 00:23:46.100
class of problem at Google
or that you've worked on

381
00:23:46.490 --> 00:23:50.570
where go just really slid
in and was just the

382
00:23:50.570 --> 00:23:54.440
perfect solution and doing it
and go was so much

383
00:23:54.440 --> 00:23:56.120
more of a joy than
it would have been. Had

384
00:23:56.120 --> 00:23:59.740
you done it in another
language? One example that jumps

385
00:23:59.740 --> 00:24:03.670
out at me is there's
a download server that serves

386
00:24:04.240 --> 00:24:10.030
dl.google.com. So it's a solo
foul, Android and Chrome and

387
00:24:10.090 --> 00:24:14.350
Google earth and other big
kind of binary downloads. And

388
00:24:14.350 --> 00:24:16.360
so basically it's a static
file server, but it's a

389
00:24:16.360 --> 00:24:19.360
little bit more complicated than
that because there's a whole

390
00:24:19.360 --> 00:24:22.120
lot of business logic that
dictates, you know, which files

391
00:24:22.120 --> 00:24:26.230
should be served, where, and
when, and also it needs

392
00:24:26.230 --> 00:24:30.070
to talk to our backend
storage system. So it's, obviously

393
00:24:30.070 --> 00:24:34.000
you can imagine we don't
just have the files sitting

394
00:24:34.000 --> 00:24:38.170
on a, on a, a
62 partitions, somewhere on some

395
00:24:38.380 --> 00:24:44.350
Linux box. We have our
distributed storage system. And so

396
00:24:45.270 --> 00:24:48.310
we have this, the, the
download, the, the architecture of

397
00:24:48.310 --> 00:24:53.350
the downloads of is basically
there are many of these

398
00:24:53.350 --> 00:24:56.530
processes running across several data
centers. And when a request

399
00:24:56.530 --> 00:25:01.750
comes in for a particular
file, it will fetch that

400
00:25:01.750 --> 00:25:04.810
file from the, the backend
storage system and serve it

401
00:25:04.810 --> 00:25:08.440
out to the client. But
it also does a level

402
00:25:08.440 --> 00:25:15.520
of caching where within a
given cluster one, these processes

403
00:25:15.520 --> 00:25:19.990
kind of form a distributed
cache together, caching chunks of

404
00:25:19.990 --> 00:25:25.000
each of those files. And
then each of the processes

405
00:25:25.000 --> 00:25:28.840
also has in it, a
hot cash. So that any

406
00:25:28.840 --> 00:25:32.470
particularly in really high demand
file will be cashed in

407
00:25:32.470 --> 00:25:37.810
each process as opposed to
across all of them. And

408
00:25:37.810 --> 00:25:45.670
so like this to, to
make this work well, Brad

409
00:25:45.670 --> 00:25:50.920
Fitzpatrick wrote a library called
group cache, which is now

410
00:25:50.920 --> 00:25:53.560
an open source project. You
can get it from github.com/

411
00:25:53.590 --> 00:25:57.820
<inaudible> slash group cash. And
it does all of that

412
00:25:57.880 --> 00:26:02.320
caching layer for you in
go. And the actual library

413
00:26:02.320 --> 00:26:05.560
itself is really nicely designed.
It's a really nice example

414
00:26:05.560 --> 00:26:11.110
of using goes interfaces to,
to design a really nice

415
00:26:11.110 --> 00:26:17.290
API, but basically that project
was a rewrite of a

416
00:26:17.290 --> 00:26:23.230
C plus plus program. And
the rewrite really played to

417
00:26:23.230 --> 00:26:26.590
all of those strengths. It's
uses concurrency heavily. It uses

418
00:26:26.620 --> 00:26:32.740
interfaces heavily, and the end
result was significantly shorter. I

419
00:26:32.740 --> 00:26:34.870
think it was like a
quarter of the number of

420
00:26:34.870 --> 00:26:38.350
lines. It was much more
well tested. Cause the first

421
00:26:38.350 --> 00:26:39.850
thing I did was write
a whole lot of nice

422
00:26:39.850 --> 00:26:45.690
tests and it ended up
being really high performance, actually

423
00:26:45.690 --> 00:26:50.130
deploying that, which happened quite
a while ago, helped us

424
00:26:50.130 --> 00:26:53.670
find some hotspots in the,
in the runtime performance and

425
00:26:53.670 --> 00:26:56.940
the, and the compiler as
well, so that we could

426
00:26:57.000 --> 00:27:00.210
tune go as a result
of that experience. But that

427
00:27:00.210 --> 00:27:07.200
really, that really came together
really, really nicely. And there

428
00:27:07.200 --> 00:27:11.850
are other projects that Google
in a similar vein where

429
00:27:11.850 --> 00:27:14.490
go has just slid in
and really been a perfect

430
00:27:14.490 --> 00:27:18.240
fit like that. I can
talk, I can talk about

431
00:27:18.240 --> 00:27:25.080
another example, which is also
opensource is my sequel load

432
00:27:25.080 --> 00:27:31.230
balancing and sharding system called
Vitesse, which YouTube use very

433
00:27:31.230 --> 00:27:33.360
heavily. So if you load
any YouTube page, it goes

434
00:27:33.360 --> 00:27:37.110
through this go program and
that's a project that's been

435
00:27:37.110 --> 00:27:39.630
ongoing for a couple of
years. And they're very, very

436
00:27:39.630 --> 00:27:42.900
happy with how it goes,
work for that. Yeah. This,

437
00:27:43.350 --> 00:27:47.610
the one that Brad Fitzpatrick
worked on that it replaced

438
00:27:47.640 --> 00:27:51.420
not only Python and C
plus plus, but you said

439
00:27:51.420 --> 00:27:54.510
it got much smaller. It
starts up faster. It was

440
00:27:54.510 --> 00:27:57.000
just a perfectly suited thing.
There's a great talk that

441
00:27:57.000 --> 00:28:00.000
he gave at Oz con
in 2013. And I'll put

442
00:28:00.040 --> 00:28:04.140
in the show notes. People
can get that powered by

443
00:28:04.140 --> 00:28:09.000
go download.google.com slide deck, where
he goes through it and

444
00:28:09.000 --> 00:28:11.640
shows you examples of C
plus plus here's what it

445
00:28:11.640 --> 00:28:13.800
wasn't C plus plus. And
here's the equivalent code and

446
00:28:13.800 --> 00:28:16.600
go look how much easier
it is to read and

447
00:28:16.690 --> 00:28:20.240
a lot less moving parts.
It's pretty slick. Yeah. And

448
00:28:20.250 --> 00:28:23.520
the, you know, the group,
there are other people outside

449
00:28:23.520 --> 00:28:26.490
Google now using that group
cache library that we opensourced.

450
00:28:27.630 --> 00:28:31.230
And yeah, it's a really,
it's a really nice general

451
00:28:31.320 --> 00:28:33.690
general solution to a problem
that a lot of people

452
00:28:33.690 --> 00:28:38.970
have. So where do people
go? No pun intended to

453
00:28:39.300 --> 00:28:42.960
do check out, go Lang
and, and, you know, work

454
00:28:42.960 --> 00:28:47.880
with it immediately get started
with it. Visit girling.org. There's

455
00:28:48.600 --> 00:28:50.700
a download link on the
front page. You can also

456
00:28:50.700 --> 00:28:54.030
take a tour of go
from there or just go

457
00:28:54.030 --> 00:28:57.810
to tour.org. And then you
can learn, go from your

458
00:28:57.810 --> 00:29:01.650
web browser and you can
play with go code snippets

459
00:29:01.650 --> 00:29:04.980
and run them from the
browser and learn all of

460
00:29:04.980 --> 00:29:08.550
the aspects of the language
effectively. Nice. No download necessary

461
00:29:08.550 --> 00:29:11.730
to play with. Go. Yeah,
that's right. Very cool. Well,

462
00:29:11.730 --> 00:29:15.150
thank you Andrew, for chatting
with me today. My pleasure.

463
00:29:16.170 --> 00:29:18.570
This has been another episode
of Hansel minutes and we'll

464
00:29:18.570 --> 00:29:19.590
see you again next week.


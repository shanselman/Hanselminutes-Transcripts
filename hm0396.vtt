WEBVTT FILE

1
00:00:04.890 --> 00:00:17.120
<inaudible> From hanselminutes.com. It's Hansel
minutes, all weekly discussion with

2
00:00:17.120 --> 00:00:21.560
web developer and technologist Scott
Hanselman. This is Lawrence Ryan announcing

3
00:00:21.560 --> 00:00:28.400
show number three 96. Recorded
live Thursday, October 31st, 2013. This episode

4
00:00:28.400 --> 00:00:31.190
of Hansel minutes is brought
to you by Tellerik offering

5
00:00:31.190 --> 00:00:40.160
the best in developer tools
and support online@telerikdotcomandbyfranklins.net makers of

6
00:00:40.160 --> 00:00:43.670
gesture pack a powerful gesture,
recording and recognition system for

7
00:00:43.670 --> 00:00:50.960
Microsoft connect for windows developers
details@gesturepak.com. In this episode, Scott

8
00:00:50.960 --> 00:00:55.550
talks with Douglas Crockford author
and discover of Jason about

9
00:00:55.550 --> 00:01:01.370
bugs discipline, and how to
ride better software. Hi, this

10
00:01:01.370 --> 00:01:03.440
is Scott Hanselman. This is
another episode of Hansel minutes.

11
00:01:03.440 --> 00:01:05.900
I'm here at the angle
brackets conference and the MGM

12
00:01:05.900 --> 00:01:09.980
granted Las Vegas. And I'm
sitting down with Douglas Crockford,

13
00:01:10.130 --> 00:01:14.030
a distinguished architect at PayPal
and the discoverer of Jason.

14
00:01:14.660 --> 00:01:17.510
How are you, sir? I'm
great. Thank you. We were

15
00:01:17.510 --> 00:01:21.650
chatting a little bit earlier
and I was, I think

16
00:01:21.650 --> 00:01:23.510
I was ranting a little
bit, but you made a

17
00:01:23.510 --> 00:01:28.910
really fascinating comment about the
lack of intellectual curiosity in

18
00:01:28.910 --> 00:01:31.100
our industry. Can you talk
a little bit about that?

19
00:01:31.460 --> 00:01:34.490
Yeah. Most of the people
who do what we do

20
00:01:34.490 --> 00:01:37.880
are not aware of where
this stuff came from, not

21
00:01:37.880 --> 00:01:42.380
aware of their own craft.
We have no sense of

22
00:01:42.380 --> 00:01:44.780
history really in software and
part of that's because it

23
00:01:44.780 --> 00:01:47.090
turns over so quickly. But
part of it is that

24
00:01:47.480 --> 00:01:52.490
we've forgotten all this important
knowledge. There's this, I like

25
00:01:52.490 --> 00:01:55.160
the way we teach physics,
whereas the first course of

26
00:01:55.160 --> 00:01:58.040
physics as a history course,
where we look at our

27
00:01:58.040 --> 00:02:02.750
communities and Galileo and Newton
and everybody, and how each

28
00:02:02.750 --> 00:02:05.720
of them enhanced our understanding
of how the universe works.

29
00:02:06.530 --> 00:02:09.500
And it's told in terms
of their stories and their

30
00:02:09.500 --> 00:02:12.890
personalities, because of what they
did was important. We don't

31
00:02:12.890 --> 00:02:15.770
do anything like that for
our own field. It says,

32
00:02:15.770 --> 00:02:19.850
if the stuff all happened
spontaneously or what, there was

33
00:02:19.850 --> 00:02:22.700
this inevitability that it couldn't
have been any other way,

34
00:02:24.080 --> 00:02:27.440
but that's not how it
was that the story of

35
00:02:27.440 --> 00:02:29.630
how we got to where
we are is a really

36
00:02:29.630 --> 00:02:33.320
interesting one. And it's worth
studying. If only to recognize

37
00:02:34.220 --> 00:02:38.300
the consequences of the choices
that we made, which in

38
00:02:38.300 --> 00:02:41.840
some cases caused us to
forgo things which may have

39
00:02:41.840 --> 00:02:44.900
been better in which we
may still end up having

40
00:02:44.900 --> 00:02:49.700
to backtrack to get to,
Is that because of there's

41
00:02:49.700 --> 00:02:52.580
a large number of developers
that did not have a

42
00:02:52.580 --> 00:02:56.480
formal computer science upbringing, for
lack of a better That

43
00:02:56.480 --> 00:02:58.970
wouldn't help because the computer
scientists don't get this stuff

44
00:02:58.990 --> 00:03:04.120
either just generally, there's too
little history in our stuff.

45
00:03:04.690 --> 00:03:07.030
We're not completely without history.
There are places like the

46
00:03:07.030 --> 00:03:11.470
computer history museum in mountain
view, California, which was brilliant.

47
00:03:12.370 --> 00:03:16.090
Everybody should go there. And
there are some collections of

48
00:03:16.090 --> 00:03:19.750
material. Like one of my
favorite websites is a bit

49
00:03:19.750 --> 00:03:24.250
savers.org, where you can find
manuals for all of these

50
00:03:24.250 --> 00:03:27.220
old machines that are completely
forgotten. It turns out there

51
00:03:27.220 --> 00:03:30.070
is brilliance in that stuff.
And even though we don't

52
00:03:30.070 --> 00:03:31.930
pay any attention to it,
we don't celebrate it the

53
00:03:31.930 --> 00:03:34.900
way we should. There's still
brilliant ideas and they're to

54
00:03:34.900 --> 00:03:38.050
be mine. So I sometimes
think of myself as a

55
00:03:38.050 --> 00:03:42.220
software archeologist and I'm trying
to uncover the wisdom of

56
00:03:42.220 --> 00:03:44.560
the ages and age has
only happened a few decades

57
00:03:44.560 --> 00:03:48.810
ago, but it's still important
stuff. What should we do

58
00:03:48.810 --> 00:03:50.520
though in teaching the next
generation? I mean, if I

59
00:03:50.520 --> 00:03:52.800
have young children and they're
playing on a raspberry PI,

60
00:03:52.830 --> 00:03:56.340
should I get them a
Commodore 64 or teach them

61
00:03:56.340 --> 00:04:00.600
about punch cards? I think
it is important to teach

62
00:04:00.600 --> 00:04:04.890
them about punch cards because
there are consequences in that

63
00:04:05.070 --> 00:04:07.860
system that came over. I
would teach him how typewriters

64
00:04:07.860 --> 00:04:11.580
used to work. Cause there's
enormous amount of typewriters, which

65
00:04:11.580 --> 00:04:16.590
survive in our modern machines.
And it's all things which

66
00:04:16.590 --> 00:04:18.780
were a good idea at
one time, a long time

67
00:04:18.780 --> 00:04:25.290
ago, back when typewriters were
driven entirely by the energy

68
00:04:25.290 --> 00:04:29.430
that you could transmit through
your fingertips. And there were

69
00:04:29.430 --> 00:04:34.470
designed decisions that were made
then, which are completely unnecessary

70
00:04:34.470 --> 00:04:38.940
now, but we still keep
it in our systems. And

71
00:04:38.940 --> 00:04:44.600
we still see it in
asking Unicode. Yeah. Why, why

72
00:04:44.880 --> 00:04:48.240
Code for a certain letter
is a code. There were

73
00:04:48.240 --> 00:04:53.190
physical reasons for that and
that, that remains today. Yeah.

74
00:04:54.570 --> 00:04:59.100
Parts of ASCII were optimized
for teletype machines in order

75
00:04:59.100 --> 00:05:02.880
to make the decoding of
the signals that would drive

76
00:05:02.880 --> 00:05:06.530
the little dude that had
the letters on it. Whose

77
00:05:06.530 --> 00:05:09.480
little, the little striking ball.
Yeah, it wasn't, it was

78
00:05:09.480 --> 00:05:12.870
a cylinder. It's a cylinder.
And depending on what the

79
00:05:12.870 --> 00:05:16.500
Selectric, I guess Selectric, well,
there's a, a parallel story.

80
00:05:16.500 --> 00:05:19.530
So IBM was using MC
deck and that was a

81
00:05:20.250 --> 00:05:25.380
completely different code set. But
yeah, the stuff's important. I

82
00:05:25.560 --> 00:05:27.840
always find it funny. The
whole carriage return line feed

83
00:05:27.840 --> 00:05:31.080
arguments, as I guess windows
has picked one and Linux

84
00:05:31.080 --> 00:05:33.510
has picked another and Mack
has picked another. And all

85
00:05:33.510 --> 00:05:35.280
of this was whether or
not we could feed the

86
00:05:35.280 --> 00:05:38.850
paper and then return the
Right that comes directly out

87
00:05:38.850 --> 00:05:43.710
of the teletype that yeah,
one code would return the

88
00:05:43.710 --> 00:05:46.320
carriage and the other would
roll the paper. And the

89
00:05:46.320 --> 00:05:48.630
old teletypes were so slow
that they really needed two

90
00:05:48.630 --> 00:05:51.330
codes. Cause it took a
while for the carriage to

91
00:05:51.330 --> 00:05:53.760
get returned. And while that
was happening, you could then

92
00:05:53.760 --> 00:05:58.310
roll the paper. And so
having it as two allowed

93
00:05:58.310 --> 00:06:00.980
you to put in that
delay without actually having to

94
00:06:01.100 --> 00:06:03.940
put any logic in, See,
I find that stuff fascinating,

95
00:06:03.940 --> 00:06:06.490
but it, our computer scientists
who are being taught by

96
00:06:06.490 --> 00:06:09.580
professors in school or whether
they are on the job

97
00:06:09.610 --> 00:06:12.790
trained, not being taught this
because there's no perceived value

98
00:06:13.930 --> 00:06:17.740
Perhaps, but, but then we
see it go wrong. And

99
00:06:17.740 --> 00:06:21.910
other places like what should
be the code and align.

100
00:06:23.290 --> 00:06:25.930
There was an argument about
that many years ago. And

101
00:06:25.930 --> 00:06:29.110
some people said it should
be carriage return. And other

102
00:06:29.110 --> 00:06:31.060
people said, no, it should
be line feed. And some

103
00:06:31.060 --> 00:06:34.390
people probably not. The smartest
guys in the room said

104
00:06:34.390 --> 00:06:36.700
it should be both because
that's how it's always worked.

105
00:06:37.300 --> 00:06:40.810
You know, the traditionalist, the
care's return guys were looking

106
00:06:40.810 --> 00:06:42.160
at it from the human
point of view. When I

107
00:06:42.160 --> 00:06:45.370
want to end it, I
hit three turnkey. The other,

108
00:06:45.460 --> 00:06:47.530
the line feed guys were
thinking of it from it,

109
00:06:47.530 --> 00:06:50.650
from the printer's point of
view, when the printer wants

110
00:06:50.650 --> 00:06:52.240
to go to the next
line, it does align feed

111
00:06:53.350 --> 00:06:56.620
and the committee couldn't agree.
You know? So the way

112
00:06:56.620 --> 00:06:59.710
the internet works today is
you have to have both

113
00:07:00.160 --> 00:07:04.900
that's the mutually disagreeable compromise
that the guys who want

114
00:07:04.900 --> 00:07:07.420
to carriage return didn't want
the line feed guys to

115
00:07:07.420 --> 00:07:10.750
get it because that meant
they were wrong and vice-a-versa,

116
00:07:10.750 --> 00:07:14.440
and this way everybody, And
this to this day, this

117
00:07:14.440 --> 00:07:17.320
remains the number one issue
that hits me on a

118
00:07:17.320 --> 00:07:19.930
day to day basis when
checking in and out from

119
00:07:19.930 --> 00:07:23.200
get of repositories that are
on a different system than

120
00:07:23.200 --> 00:07:25.630
mine. And I'm thinking about
this several times a week.

121
00:07:26.530 --> 00:07:32.290
Yeah. And it's completely unnecessary,
but it's because we didn't

122
00:07:32.290 --> 00:07:37.540
understand this thing. And so
going forward, understanding mistakes that

123
00:07:37.540 --> 00:07:40.570
we made historically gives us
a way to think about

124
00:07:40.570 --> 00:07:43.720
how to make things correct
going forward, except we tend

125
00:07:43.750 --> 00:07:45.820
not to learn the history.
And so we tend to

126
00:07:45.880 --> 00:07:50.800
repeat the mistakes. Sometimes we
learn early programming languages in

127
00:07:50.800 --> 00:07:52.750
school from a and that,
and they think that that's

128
00:07:52.750 --> 00:07:55.000
historical context, they'll say, well,
here, we're going to learn

129
00:07:55.740 --> 00:07:58.180
assembler or we're going to
learn, Oh, Kamler, Haskell. And

130
00:07:58.180 --> 00:08:00.910
then that's going to be
our entree into some, some

131
00:08:00.910 --> 00:08:03.790
newer or whatever, the new
shiny programming languages do you

132
00:08:03.790 --> 00:08:06.640
think we need to connect
software to hardware more? Should

133
00:08:06.640 --> 00:08:10.720
we be talking about soldering
and physics and electrons at

134
00:08:10.720 --> 00:08:12.610
that level? And then work
our way up to software.

135
00:08:12.970 --> 00:08:15.190
I don't know that we
need to go that far

136
00:08:15.190 --> 00:08:18.700
down, but I think it
is important to understand how

137
00:08:18.700 --> 00:08:22.540
instruction sets work because ultimately
that's where software is grounded

138
00:08:23.320 --> 00:08:28.120
and everything else is transformations
or abstractions. On top of

139
00:08:28.120 --> 00:08:34.330
that, and many of our
languages were very strongly influenced

140
00:08:34.330 --> 00:08:35.860
by the kinds of machines
they were going to be

141
00:08:35.860 --> 00:08:39.880
resting upon. But modern machines
are architecturally quite different from

142
00:08:39.880 --> 00:08:44.380
those, but our languages are
still in the old paradigm.

143
00:08:46.180 --> 00:08:47.980
There are a lot of
things which we do in

144
00:08:47.980 --> 00:08:51.400
our languages, which I think
work against what should be

145
00:08:51.400 --> 00:08:54.160
our primary goal of writing
software that works well, that

146
00:08:54.160 --> 00:08:59.460
has no bugs in. And
very often I see programmers

147
00:08:59.670 --> 00:09:03.540
pursuing other goals, which are
incompatible with that one. And

148
00:09:03.540 --> 00:09:10.010
so that becomes a subordinate
rather than primary. So you're

149
00:09:10.010 --> 00:09:13.040
saying that we're where our
head is not right. Our

150
00:09:13.040 --> 00:09:15.980
priorities are wrong. Our goal
is to write software that

151
00:09:15.980 --> 00:09:20.750
has fewer mistakes, But it
should be, but our, all

152
00:09:20.750 --> 00:09:23.660
of our tools tend to
be working against us. So

153
00:09:23.720 --> 00:09:28.010
let me tell you about
a bug I made. I

154
00:09:28.010 --> 00:09:32.000
wrote a Chasen library in
Java many years ago as

155
00:09:32.000 --> 00:09:36.140
a reference implementation. And in
that library, I had a

156
00:09:36.140 --> 00:09:39.410
variable called index, which was
counting the number of characters

157
00:09:39.410 --> 00:09:42.410
into the text that was
being parsed. And it was

158
00:09:42.410 --> 00:09:45.200
used primarily for error messages.
So if there was a

159
00:09:45.200 --> 00:09:48.020
syntax error, I would say
at this location, we found

160
00:09:48.190 --> 00:09:51.320
a problem and I made
it in the end because

161
00:09:51.590 --> 00:09:56.210
that seemed to be the
right thing. And then allows

162
00:09:56.210 --> 00:09:59.000
you to have a text
that's up to two gigabytes

163
00:09:59.000 --> 00:10:01.970
in size, which at that
time was still a pretty

164
00:10:01.970 --> 00:10:07.160
big disc drive today. It's
not today, it's Ram, right.

165
00:10:07.160 --> 00:10:09.410
Which is wonderful. You know,
Moore's law has been working

166
00:10:09.410 --> 00:10:12.440
for us, but at the
time I couldn't imagine anyone

167
00:10:12.440 --> 00:10:16.310
would ever have a text
bigger than two gigabytes. Last

168
00:10:16.310 --> 00:10:19.580
year, someone wrote to me
and said that they had

169
00:10:19.580 --> 00:10:22.490
a text, which was considerably
bigger than that. And that

170
00:10:22.490 --> 00:10:26.990
they had a syntax error
past two megabytes. And so

171
00:10:28.310 --> 00:10:31.730
my package misreported where the
thing was, So they had

172
00:10:31.730 --> 00:10:35.570
a JavaScript file that was
larger than two adjacent file

173
00:10:35.570 --> 00:10:39.590
of more than two gigs.
Yeah. Which amazed me because

174
00:10:39.590 --> 00:10:41.930
when I designed Jason, I
didn't expect there to ever

175
00:10:41.930 --> 00:10:44.090
be an adjacent text bigger
than a couple of K.

176
00:10:44.660 --> 00:10:47.540
And I intended it as
a message passing thing to

177
00:10:47.540 --> 00:10:52.250
go over the network, something
highly interactive. So I, you

178
00:10:52.250 --> 00:10:54.590
can't anticipate all the future
uses of the things that

179
00:10:54.590 --> 00:10:55.970
you do. Right. But if
you had said it to

180
00:10:55.970 --> 00:10:58.730
two terabytes five years from
now, someone would send you

181
00:10:58.730 --> 00:11:01.880
about their multi terabyte. Jason.
Yeah. I'm not thinking that

182
00:11:01.880 --> 00:11:08.090
it's going to be such
a problem. I asked the

183
00:11:08.090 --> 00:11:10.190
guy, how long did it
take to actually parse that?

184
00:11:10.190 --> 00:11:14.000
And it took awhile. So
Moore's law is not working

185
00:11:14.000 --> 00:11:16.970
that well. So I don't
think I have to worry

186
00:11:16.970 --> 00:11:21.200
about that. If I'd made
it a long, it wouldn't

187
00:11:21.200 --> 00:11:23.540
have been a problem. So
it's nice that it took

188
00:11:23.540 --> 00:11:25.700
over a decade for this
bog in my program to

189
00:11:25.700 --> 00:11:29.510
be revealed, but looking at
why it was a bug,

190
00:11:29.780 --> 00:11:34.220
it was because Java gave
me a choice of six

191
00:11:34.850 --> 00:11:40.220
types that I could choose.
And by giving me that

192
00:11:40.220 --> 00:11:43.880
choice, I could choose the
wrong one. And in this

193
00:11:43.880 --> 00:11:47.570
case I did. And so
this is a trap that

194
00:11:47.570 --> 00:11:51.380
the language is setting for
you. The bargain it's suggesting

195
00:11:51.380 --> 00:11:58.210
is you can save memory
by picking the smallest possible

196
00:11:58.210 --> 00:12:03.550
type that'll contain your value.
And the flip side of

197
00:12:03.550 --> 00:12:07.000
that bargain is that, and
if you get it wrong,

198
00:12:07.060 --> 00:12:09.460
if you pick one that's
too small, then disaster happens.

199
00:12:10.330 --> 00:12:14.530
And there's no reason to
be making that trade off

200
00:12:15.340 --> 00:12:19.600
many years ago. It did.
So if you were programming

201
00:12:19.630 --> 00:12:25.690
the Atari 2,600, the VCs
that machine had 128 bytes

202
00:12:25.960 --> 00:12:28.870
of Ram in it, and
that included the stack and

203
00:12:28.870 --> 00:12:34.480
included all the buffers, Vos,
everything fit in 128 bytes.

204
00:12:34.480 --> 00:12:36.610
So in that machine, you
really paid attention to how

205
00:12:36.610 --> 00:12:40.990
big a variable was, but
we've had a lot, many,

206
00:12:41.080 --> 00:12:45.070
many doublings of memory capacity
since then we now have

207
00:12:45.070 --> 00:12:49.570
gigabyte memories. It is not
worth our time to try

208
00:12:49.570 --> 00:12:51.610
to figure out what the
right type for variable is.

209
00:12:52.410 --> 00:12:54.240
But every time we sit
down to write even the

210
00:12:54.240 --> 00:12:56.610
most trivial of programs, we
type into an account, do

211
00:12:56.610 --> 00:12:59.760
I need an end? And
then the processor power that

212
00:12:59.760 --> 00:13:02.790
requires my brain. Yeah. Yeah.
It shouldn't be a bite.

213
00:13:02.790 --> 00:13:06.000
Yeah. Or maybe a U
N D. Yeah. I can.

214
00:13:06.220 --> 00:13:09.930
One more extra bit. If,
if it's unsigned, which is

215
00:13:09.930 --> 00:13:12.240
a total waste of time,
you know, in terms of

216
00:13:12.330 --> 00:13:15.030
just measuring our own productivity,
there's no reason to be

217
00:13:15.030 --> 00:13:18.240
doing that. And then it
gets worse because there's this

218
00:13:18.240 --> 00:13:24.960
opportunity to have overflow and
the way numbers overflow is,

219
00:13:25.950 --> 00:13:30.090
has a lot of history
to it. So when they're

220
00:13:30.090 --> 00:13:33.240
there a number of models
for what should happen, if

221
00:13:33.240 --> 00:13:35.580
you try to put too
big, a number into a

222
00:13:35.580 --> 00:13:39.180
variable, one says, you should
get an interrupt. You should

223
00:13:39.180 --> 00:13:42.780
throw an exception, which would
be reasonable. Another says you

224
00:13:42.780 --> 00:13:46.110
should get Nan or some
other signal that says that's

225
00:13:46.110 --> 00:13:50.040
not an adequate value. And
that's okay. Too. Some systems,

226
00:13:50.070 --> 00:13:53.520
it saturates, it gets clipped
to a maximum possible value.

227
00:13:53.520 --> 00:13:56.880
That's really good for, for
signal processing and other applications.

228
00:13:57.750 --> 00:14:01.020
Instead, we do the worst
possible thing, which is we

229
00:14:01.020 --> 00:14:05.730
flip around to a maximally
negative number, but because it

230
00:14:05.730 --> 00:14:09.510
depends on other aspects of
the computation, we can't even

231
00:14:09.510 --> 00:14:11.520
predict what that number is
going to be. So you

232
00:14:11.520 --> 00:14:16.020
can't test specifically for that
value. It's the worst possible

233
00:14:16.020 --> 00:14:18.720
thing. And the reason we
do it that way is

234
00:14:18.720 --> 00:14:22.980
because in the fifties, when
they were starting to figure

235
00:14:22.980 --> 00:14:27.090
out how to build CPS,
someone figured out that if

236
00:14:27.090 --> 00:14:32.070
we put in a compliment
and use a complimentary notation,

237
00:14:32.670 --> 00:14:35.700
then we don't have to
implement, subtract. When we want

238
00:14:35.700 --> 00:14:39.450
to subtract with simply compliment
an ad and ignore the

239
00:14:39.450 --> 00:14:44.550
overflow. And that works Someone
micro optimized. Well at the

240
00:14:44.550 --> 00:14:47.550
time it was a reasonable
optimization cause Gates were really

241
00:14:47.550 --> 00:14:53.240
expensive. So in order to,
and every gate increased the

242
00:14:53.270 --> 00:14:56.630
unreliability of the machine because
they were built out tubes.

243
00:14:56.630 --> 00:14:59.690
And, you know, as much
as you can simplify the

244
00:14:59.690 --> 00:15:04.820
architecture that made it more
viable, have more uptime. So

245
00:15:04.820 --> 00:15:08.660
it was a good idea
at the time, but then

246
00:15:08.660 --> 00:15:12.950
it got baked into Fortran
and there was an expectation

247
00:15:12.950 --> 00:15:15.170
that in order to be
portable, we want to keep

248
00:15:15.170 --> 00:15:18.530
this crazy thing going on.
And then then got into,

249
00:15:18.530 --> 00:15:22.010
see where it's even worse,
where people expect to get

250
00:15:22.010 --> 00:15:26.090
a free modular operation if
they intentionally overflow a variable.

251
00:15:26.420 --> 00:15:32.210
So we're stuck. So it's
an architecture. So we've got

252
00:15:32.570 --> 00:15:35.450
the effect, compounds the trap
of having too many institutes

253
00:15:35.450 --> 00:15:38.420
from. So in JavaScript, we
only have one number type,

254
00:15:39.320 --> 00:15:43.400
which is great. I think
JavaScript is actually smarter than

255
00:15:43.400 --> 00:15:45.830
most of the other languages
in doing that because there's

256
00:15:45.830 --> 00:15:49.070
only one number type. You
waste no time thinking about

257
00:15:49.400 --> 00:15:52.490
what type to use and
you can't ever pick the

258
00:15:52.490 --> 00:15:57.260
wrong one. And yet JavaScript
is under tremendous pressure from

259
00:15:57.260 --> 00:16:01.700
the community to add into
it because people want this

260
00:16:01.700 --> 00:16:06.320
behavior because they have prior
to their experience with JavaScript,

261
00:16:06.590 --> 00:16:09.140
maybe never known another language
in which you didn't have

262
00:16:09.140 --> 00:16:14.810
the option of, of having
ants. And so they want

263
00:16:14.810 --> 00:16:18.200
to dumb it down. It's
difficult for us to see

264
00:16:18.200 --> 00:16:21.890
that JavaScript is actually the
future. It's where we want

265
00:16:21.890 --> 00:16:24.530
to be going. The thing
that JavaScript got wrong was

266
00:16:24.530 --> 00:16:28.070
it chose the wrong one
number type, it chose binary

267
00:16:28.070 --> 00:16:32.030
floating point. It should pick
the decimal floating point, but

268
00:16:32.030 --> 00:16:34.010
the idea that it was
just one that was big

269
00:16:34.010 --> 00:16:36.170
enough to hold all the
numbers that you could ever

270
00:16:36.170 --> 00:16:40.480
do was correct. Yeah. It's
fairly, forward-thinking given the context

271
00:16:40.690 --> 00:16:44.890
It was. And it was
done in that language because

272
00:16:44.890 --> 00:16:48.820
the language was originally intended
for beginners. And in order

273
00:16:48.820 --> 00:16:50.860
to make it easy for
them, let's just give them

274
00:16:50.890 --> 00:16:52.660
one kind of number. And
that's all they do the

275
00:16:52.660 --> 00:16:54.850
original basic to the same
thing. So it's not a

276
00:16:54.850 --> 00:16:58.480
new idea. Microsoft kind of
screwed basic up by adding

277
00:16:58.480 --> 00:17:04.270
in its various forms eventually.
And so it made it

278
00:17:04.270 --> 00:17:09.310
possible to waste time micro
optimizing, and it also made

279
00:17:09.310 --> 00:17:12.220
it possible to introduce more
errors and all of our

280
00:17:12.220 --> 00:17:15.430
other languages do that too.
It's interesting though. But whenever

281
00:17:15.430 --> 00:17:18.130
I think of things that
I don't like about JavaScript

282
00:17:18.340 --> 00:17:21.160
numbers are not, my problem
dates are where my pain

283
00:17:21.160 --> 00:17:26.980
lives in JavaScript. JavaScript's dates
were based on Chavez dates

284
00:17:28.480 --> 00:17:30.990
and yeah, I'm not aware
of anybody who's ever gotten

285
00:17:31.010 --> 00:17:34.030
dates, right? It's yeah. It's
all the, it's the serializing,

286
00:17:34.390 --> 00:17:37.990
it's the string formats for
dates that get so frustrating

287
00:17:37.990 --> 00:17:40.930
with time zones and the
Z in the middle and

288
00:17:40.930 --> 00:17:43.540
the T and getting all
of that. Just, just so

289
00:17:44.080 --> 00:17:48.460
Right. Well, that's not JavaScript's
fault. That's ISOs fault. No,

290
00:17:48.460 --> 00:17:51.750
that's a valid JavaScript Is
just implementing what I saw

291
00:17:51.780 --> 00:17:55.320
dead. And I think for
its problems, the ISO format

292
00:17:55.320 --> 00:17:58.140
is a big step forward
because it's at least a

293
00:17:58.140 --> 00:18:00.530
single format that we can
all argue about. That's a

294
00:18:00.530 --> 00:18:03.830
good point. So you're saying
that the tools are, are

295
00:18:03.830 --> 00:18:07.220
kind of working against us,
is it, is it we,

296
00:18:07.220 --> 00:18:11.630
that need to have more
discipline? We do. So one

297
00:18:11.630 --> 00:18:17.480
thing we can do is
demand programming, language languages, which

298
00:18:17.480 --> 00:18:21.110
have fewer affordances for going
off the rails. We tend

299
00:18:21.110 --> 00:18:23.090
to, as a community to
do the opposite, we want

300
00:18:23.450 --> 00:18:26.240
more ways of, You're saying
you want the programming language

301
00:18:26.240 --> 00:18:28.760
to give us less rope.
Yeah. I want it to

302
00:18:28.760 --> 00:18:32.900
be simpler. I want it
to be more constrained. I

303
00:18:32.900 --> 00:18:35.510
want it to be harder
to get things wrong. I

304
00:18:35.510 --> 00:18:38.750
want it to be simple
because the, the biggest problem

305
00:18:38.750 --> 00:18:43.190
we're we're dealing with is
managing complexity. That's most of

306
00:18:43.190 --> 00:18:50.450
what we do, complexity is
complicated. And so having complexity

307
00:18:50.450 --> 00:18:54.050
in our languages actually doesn't
help us. There's no conservation

308
00:18:54.050 --> 00:18:57.410
of complexity in that. If
we put more complexity in

309
00:18:57.410 --> 00:19:01.040
the language that our programs
get simpler, that doesn't happen,

310
00:19:01.130 --> 00:19:02.750
Just put a compliment and
it'll flip the whole thing

311
00:19:02.750 --> 00:19:06.950
over, and then it just
got, become simple. Yeah. Unfortunately

312
00:19:07.790 --> 00:19:14.990
doesn't simple. Isn't the compliment
of, of complicated. So, you

313
00:19:14.990 --> 00:19:18.200
know, I'm, I'm a minimalist
in that respect. So I

314
00:19:18.230 --> 00:19:21.800
want our languages to be
as small as possible. Having

315
00:19:22.130 --> 00:19:25.430
a lot of features in
the language is really attractive

316
00:19:25.430 --> 00:19:31.730
to us emotionally, but doesn't
actually help us. One of

317
00:19:31.730 --> 00:19:34.220
the things that a lot
of programmers get wrong is

318
00:19:34.580 --> 00:19:38.390
they think their job is
to identify every feature of

319
00:19:38.390 --> 00:19:41.360
the language, master it, and
then demonstrate that mastery in

320
00:19:41.360 --> 00:19:45.020
everything they write. And that
turns out to be an

321
00:19:45.020 --> 00:19:49.610
extremely bad practice. And what
I recommend instead is figure

322
00:19:49.610 --> 00:19:53.330
out what parts of the
language are most reliable or

323
00:19:53.330 --> 00:19:57.710
most consistent with being able
to write correctly and use

324
00:19:57.710 --> 00:20:02.090
only that That is really
interesting because I'm thinking to

325
00:20:02.090 --> 00:20:06.680
myself about the thing that
feeds programmers that makes us

326
00:20:06.680 --> 00:20:10.850
move forward. New features bolted
onto the side of the

327
00:20:10.850 --> 00:20:14.540
language. You know, whether it
be Lincoln C-sharp or new

328
00:20:14.540 --> 00:20:17.450
ways that, you know, there's
even new features that are

329
00:20:17.450 --> 00:20:19.720
being added to JavaScript. And
then they say, Oh, and

330
00:20:19.720 --> 00:20:21.830
I have another tool in
my tool belt. We like

331
00:20:21.830 --> 00:20:24.770
to say, but we never
seem to celebrate the removal

332
00:20:25.160 --> 00:20:27.860
of tools from our tool
belt. Well, and removal is

333
00:20:27.860 --> 00:20:32.390
really hard because the problem
with the things that you

334
00:20:32.390 --> 00:20:35.180
want to remove, isn't that
they're useless. That's that they're

335
00:20:35.180 --> 00:20:39.110
dangerous in that and not
dangerous in that they're going

336
00:20:39.110 --> 00:20:42.290
to blow your hands off,
but just Fe increase maybe

337
00:20:42.290 --> 00:20:47.830
slightly the likelihood that you're
going to make mistakes. And,

338
00:20:48.640 --> 00:20:51.070
you know, it's easy to
get into arguments about that

339
00:20:51.070 --> 00:20:53.380
stuff, you know, or, you
know, I, I use one

340
00:20:53.380 --> 00:20:56.530
of those dangerous features, but
in this particular instance, I

341
00:20:56.530 --> 00:20:58.570
think I'm using it correctly
and it is not an

342
00:20:58.570 --> 00:21:03.430
error and that's likely true,
but I think it is

343
00:21:03.430 --> 00:21:06.100
still better that you had
not done that and had

344
00:21:06.100 --> 00:21:09.750
written it the simpler more
reliable way instead Are these

345
00:21:10.530 --> 00:21:14.220
are these like known factual
things where one could say,

346
00:21:14.490 --> 00:21:16.230
I have removed a feature
from a language, or I

347
00:21:16.230 --> 00:21:19.860
have made this language minimal,
and this is mathematically true

348
00:21:19.860 --> 00:21:22.620
that it is better. Or
these are you describing a

349
00:21:22.620 --> 00:21:25.620
language that is a very
opinionated language where lots of

350
00:21:26.250 --> 00:21:28.470
people with opinions, the internet
are going to say, no,

351
00:21:28.470 --> 00:21:31.650
that's that's nonsense that guy's
wrong. Well, these arguments are

352
00:21:31.650 --> 00:21:36.570
almost always exclusively emotional. And
I used to make those

353
00:21:36.570 --> 00:21:40.770
same arguments. The thing that
changed me was developing JS

354
00:21:40.770 --> 00:21:45.420
lint, which has a lending
program for JavaScript. And that

355
00:21:45.450 --> 00:21:47.430
program turns out to be
a lot smarter than I

356
00:21:47.430 --> 00:21:52.050
am about programming languages. And
cause my intuitions were all

357
00:21:52.050 --> 00:21:57.060
wrong. I didn't develop that
program intending to enforce my

358
00:21:57.060 --> 00:22:00.720
opinions on other people. It
told me what my opinions

359
00:22:00.750 --> 00:22:03.180
should be. That if I
want to be able to

360
00:22:03.180 --> 00:22:07.920
statically analyze a program and
help determine the presence of

361
00:22:07.920 --> 00:22:12.090
bugs in it, I have
to avoid certain features because

362
00:22:12.090 --> 00:22:16.650
those features will tend to
mask bugs or are undecidable

363
00:22:17.220 --> 00:22:19.920
and in a static analysis
as to whether they're being

364
00:22:19.920 --> 00:22:24.240
used correctly or not. So
whenever I found there was

365
00:22:24.240 --> 00:22:29.550
a feature which has one
of these confusing aspects to

366
00:22:29.550 --> 00:22:33.000
it, where it's easily misused.
And if there is a

367
00:22:33.000 --> 00:22:36.510
different feature, which does the
same thing, but it doesn't

368
00:22:36.510 --> 00:22:39.750
have that ambiguity then use
a good one and never

369
00:22:39.750 --> 00:22:41.490
use the bad one. And
then you don't have to

370
00:22:41.490 --> 00:22:46.920
decide it At the beginning
before we talked, you said

371
00:22:46.920 --> 00:22:49.380
that you were not the
inventor of Jason, but rather

372
00:22:49.380 --> 00:22:52.380
the discover. And then you
described yourself as a software

373
00:22:52.380 --> 00:22:56.250
archaeologist. When, you know, when
someone is talking about like

374
00:22:56.250 --> 00:22:59.010
Michael Angelo pulled David out
of the stone, like he

375
00:22:59.010 --> 00:23:00.900
was inside of this rock
and I had to just

376
00:23:00.930 --> 00:23:03.810
let him out. It uses
a different part of the

377
00:23:03.810 --> 00:23:06.360
brain to discover that the
program wants to be a

378
00:23:06.360 --> 00:23:09.840
certain way, then creating the
program from your, Your own

379
00:23:09.840 --> 00:23:13.650
hands. I've used the, the,
the Michael Angelo metaphor in

380
00:23:13.650 --> 00:23:16.230
describing what Jaslyn does and
how it came about it.

381
00:23:17.100 --> 00:23:21.060
There is an ideal language
trapped inside of JavaScript. And

382
00:23:21.060 --> 00:23:24.930
I just had to chip
away the bad parts. Is

383
00:23:24.930 --> 00:23:26.940
that a using a different
part of the brain? Is

384
00:23:26.940 --> 00:23:29.370
there a whole class of
developer, whole generation as it

385
00:23:29.370 --> 00:23:33.270
were that's maybe not thinking
about it, right? Yeah. We,

386
00:23:33.300 --> 00:23:37.440
we tend to be very
emotional about syntax in the

387
00:23:37.440 --> 00:23:40.920
same way that the fashion
industry is emotional about fashion.

388
00:23:42.390 --> 00:23:45.470
You know, they'll argue about,
should there be pleats or

389
00:23:45.470 --> 00:23:47.840
not, should it be cuffs
or not things which make

390
00:23:48.230 --> 00:23:50.600
no sense to us, right.
You know, how high should

391
00:23:50.600 --> 00:23:53.050
heels be soft, Queer pleats.
I'm trying to think of

392
00:23:53.050 --> 00:23:55.510
different language features that I
would describe as software pleats.

393
00:23:55.640 --> 00:23:59.080
We are so into that.
So that part of the

394
00:23:59.080 --> 00:24:01.810
brain, we don't use it
for fashion. So we use

395
00:24:01.810 --> 00:24:04.210
it for language features. Yes.
Cause we have no fashion

396
00:24:04.210 --> 00:24:06.220
sense as we sit here
in our sneakers, in our

397
00:24:06.220 --> 00:24:10.900
tee shirts. Exactly. And so
we think we, because we

398
00:24:10.900 --> 00:24:14.890
are the ambassadors to the
computer, which is this ultra

399
00:24:15.100 --> 00:24:19.210
rational machinery. We imagine ourselves
also to be ultra rational.

400
00:24:19.210 --> 00:24:22.390
And we're not, we're deeply
emotional about things like syntax.

401
00:24:23.350 --> 00:24:26.350
And that's one of the
reasons why lint makes people

402
00:24:26.350 --> 00:24:31.360
cry because it's telling you
that you can improve your

403
00:24:31.360 --> 00:24:36.520
program by doing these things.
And our number one objective,

404
00:24:36.520 --> 00:24:38.380
because we want to be
writing good programs that are

405
00:24:38.380 --> 00:24:41.020
free of error. We should
go great. I need that

406
00:24:41.020 --> 00:24:45.490
advice. But instead, no, we
become really defensive and emotional

407
00:24:45.490 --> 00:24:47.470
as in, no, you can't
tell me to do that.

408
00:24:47.470 --> 00:24:49.750
You have no, right. I
have a right to use

409
00:24:49.750 --> 00:24:54.610
this feature. Someone once complained
to me that he should

410
00:24:54.610 --> 00:24:57.490
be able to write his
programs in excrement if he

411
00:24:57.490 --> 00:25:04.060
wanted to, in order to
have him express himself as

412
00:25:04.060 --> 00:25:07.720
an artist. You know, so
he was telling me that

413
00:25:07.720 --> 00:25:10.480
he has a right to
write programs, which are literally

414
00:25:10.660 --> 00:25:15.640
crap. I think we should
be, we should have a

415
00:25:15.640 --> 00:25:20.110
higher purpose than that. I've
said before that I felt

416
00:25:20.110 --> 00:25:23.680
that sometimes programmers and I
have a tendency and it's

417
00:25:23.680 --> 00:25:26.110
probably not a good habit
to refer to younger programmers

418
00:25:26.110 --> 00:25:28.660
because now that I'm becoming
middle-aged, I am thinking of

419
00:25:28.660 --> 00:25:31.630
myself, having moved from one
generation to another, have forgotten

420
00:25:31.750 --> 00:25:34.360
why it is exactly that
we are writing software. It's

421
00:25:34.360 --> 00:25:38.170
not necessarily an intellectual pursuit.
It's not necessarily the pursuit

422
00:25:38.170 --> 00:25:41.080
of poetry or haiku. You
know, I know like some

423
00:25:41.080 --> 00:25:43.240
Ruby assists consider themselves to
be trying to write a

424
00:25:43.240 --> 00:25:47.020
perfect program that is haiku.
Ultimately we're trying to solve

425
00:25:47.020 --> 00:25:50.200
a business problem presumably, or
for academic try to solve

426
00:25:50.200 --> 00:25:54.490
an academic problem. So correctness
seems to be the thing

427
00:25:54.490 --> 00:25:59.650
we should be striving for
Correctness and maintainability and anything

428
00:25:59.650 --> 00:26:02.830
that we do that works
against those is counterproductive. At

429
00:26:02.830 --> 00:26:05.740
least. Why do we spend
so much time on opinions

430
00:26:05.740 --> 00:26:09.220
and white space and where
the curly braces go? And

431
00:26:09.220 --> 00:26:13.150
the semi-colons Because we literally
don't know what we're doing

432
00:26:13.540 --> 00:26:15.520
as a, as a, as
an industry, as a community.

433
00:26:15.520 --> 00:26:19.570
Yeah. That we are very
smart people. You know, you

434
00:26:19.570 --> 00:26:21.430
have to be smart in
order to do this work.

435
00:26:22.300 --> 00:26:26.680
And so we'll give ourselves
points for smartness and give

436
00:26:26.680 --> 00:26:32.470
ourselves passes on everything else.
So what's our takeaway. How

437
00:26:32.470 --> 00:26:35.320
do I program better? Do
I need to change the

438
00:26:35.320 --> 00:26:38.590
way? I think, Yeah. You
need to, to keep in

439
00:26:38.590 --> 00:26:44.250
mind that approaching perfection is
most important thing you can

440
00:26:44.250 --> 00:26:48.210
do. And that perfection is
hard, particularly for deeply flawed

441
00:26:48.210 --> 00:26:51.060
human beings. Like us. I'm
a deeply flawed human being,

442
00:26:51.750 --> 00:26:54.540
but I'm a programmer and
I'm pretty good at it,

443
00:26:55.260 --> 00:26:59.250
but it's not a natural
thing. And I do it

444
00:26:59.250 --> 00:27:05.190
because I enjoy it. I
find it pleasurable, but it

445
00:27:05.400 --> 00:27:09.600
requires a lot of discipline.
And one of the things

446
00:27:09.600 --> 00:27:13.530
that we tend to do
is ignore our mistakes. What

447
00:27:14.280 --> 00:27:17.310
we'll go down into the
debugger and we go down

448
00:27:17.310 --> 00:27:20.550
into this cold, hurtful place
where we do that work.

449
00:27:20.550 --> 00:27:23.880
I call it the abyss.
Normal people cannot do that.

450
00:27:24.090 --> 00:27:26.460
They cannot go down the
air with the confidence that

451
00:27:26.460 --> 00:27:28.530
they're going to come back
alive. We do it all

452
00:27:28.530 --> 00:27:33.180
the time. And when we
come up, there's this exhilaration.

453
00:27:33.210 --> 00:27:35.400
I did it. I went
down there, I found the

454
00:27:35.400 --> 00:27:37.980
bug, I killed it and
I survived and I'm back.

455
00:27:38.970 --> 00:27:46.020
And in this euphoria, we
have an amnesia. We forget

456
00:27:46.050 --> 00:27:49.050
that we did that. And
so as a result, we

457
00:27:49.050 --> 00:27:52.150
tend not to learn from
our mistakes. No, you know,

458
00:27:52.230 --> 00:27:54.570
Oh, I did that again.
Get on the head. I

459
00:27:54.570 --> 00:27:58.890
forgot. It's going to happen
again. We do this all

460
00:27:58.890 --> 00:28:01.940
the time. Yeah. Yeah. I've,
I've talked about developers having

461
00:28:01.940 --> 00:28:04.940
20 years of experience, but
it's unfortunate if it's the

462
00:28:04.940 --> 00:28:07.640
same year, 20 times, We
do that a lot. Yeah.

463
00:28:07.640 --> 00:28:09.590
There's a lot of Groundhog's
day in, in the way

464
00:28:09.590 --> 00:28:13.520
that we work. So one
thing you can do is

465
00:28:13.910 --> 00:28:16.730
every time you make a
mistake, write it down, keep

466
00:28:16.730 --> 00:28:21.230
it journal. Yeah. You need
to develop self awareness of

467
00:28:21.260 --> 00:28:23.570
how you make mistakes. You
set that up as a

468
00:28:23.570 --> 00:28:26.660
bug journal. Yeah. I like
that. So what would I

469
00:28:26.660 --> 00:28:29.630
write about the bug? Like
what, what, how would I

470
00:28:29.630 --> 00:28:32.510
describe it? Like the, the
algorithmic issue that came up

471
00:28:32.510 --> 00:28:35.690
or Yeah. So Donald Knute
wrote a brilliant article about

472
00:28:35.690 --> 00:28:40.010
the bugs in tech. So
he kept a bug journalist.

473
00:28:40.010 --> 00:28:42.470
He was developing that program.
One of the biggest programs

474
00:28:42.470 --> 00:28:45.950
he wrote in his career,
one of our best programmers

475
00:28:46.340 --> 00:28:48.500
and he made lots of
mistakes and he categorized them.

476
00:28:48.650 --> 00:28:52.820
So he developed letter codes
indicating the different kinds of

477
00:28:52.820 --> 00:28:56.930
things, you know? So the
typos were distinguished from the

478
00:28:56.930 --> 00:29:00.470
algorithm errors and so on
and they sorted it and

479
00:29:00.620 --> 00:29:05.180
produces the results. That's a
really good article. And the

480
00:29:05.180 --> 00:29:07.760
important thing, isn't his findings
about what kind of bugs

481
00:29:07.760 --> 00:29:11.720
are more common? It's that,
that as an exercise is

482
00:29:11.720 --> 00:29:15.110
so useful because we tend
to not learn from our

483
00:29:15.110 --> 00:29:17.240
mistakes and the way you
learn from them is by

484
00:29:17.240 --> 00:29:20.510
paying attention to them. Yeah.
You can't cut something unless

485
00:29:20.510 --> 00:29:23.510
you've been measuring the whole
Well, that's the other thing

486
00:29:23.510 --> 00:29:25.310
we do is we do
a lot of cutting without

487
00:29:25.310 --> 00:29:29.750
measuring. One of the things
that drives us instead of

488
00:29:29.750 --> 00:29:36.170
correctness is performance. Micro benchmarks
for all performances is important,

489
00:29:36.200 --> 00:29:39.950
but it's less important. It's
more important that it be

490
00:29:39.950 --> 00:29:44.470
correct. And so there's this
thing that we tend to

491
00:29:44.470 --> 00:29:48.580
do, which is, you know,
micro optimizing, trying to cut

492
00:29:49.330 --> 00:29:53.380
time out of code, even
in code where it absolutely

493
00:29:53.380 --> 00:29:55.930
doesn't make any difference, right.
That our machines are so

494
00:29:55.930 --> 00:29:57.880
fast that unless you're in
the middle of loop of

495
00:29:57.880 --> 00:30:01.810
something, that's going to take
a long time. Optimizing is

496
00:30:01.810 --> 00:30:05.050
simply a waste of time.
And generally in any project,

497
00:30:05.050 --> 00:30:06.790
we have a limited amount
of time in which we

498
00:30:06.790 --> 00:30:10.690
should do optimization. We need
to be really careful where

499
00:30:10.690 --> 00:30:13.930
we do that optimization. You
need to optimize your optimizing.

500
00:30:14.410 --> 00:30:17.880
Yeah. It's amazing. How many
times perfectly rational people will

501
00:30:17.880 --> 00:30:20.700
put a four loop from
one to 10,000 around a

502
00:30:20.700 --> 00:30:23.790
piece of code that just
doesn't matter when the network

503
00:30:23.790 --> 00:30:27.210
latency is an order of
magnitude, more than anything you

504
00:30:27.210 --> 00:30:29.910
could ever do to that
four loop. Yeah. The, the

505
00:30:29.910 --> 00:30:34.860
first law of, of optimization
is look at where the

506
00:30:34.860 --> 00:30:38.820
cost is. And for us,
that usually means where's the

507
00:30:38.820 --> 00:30:44.310
time being spent, optimizing anything,
which isn't the principal place,

508
00:30:44.310 --> 00:30:45.960
where the time is being
spent is a waste of

509
00:30:45.960 --> 00:30:48.960
time. But we do that
all the time and it

510
00:30:48.960 --> 00:30:52.860
works against us in that
we are in doing those

511
00:30:52.860 --> 00:30:57.180
kinds of optimizations. You remove
generality from the code and

512
00:30:57.180 --> 00:30:59.880
by removing that generality, you
make it harder to test.

513
00:31:00.030 --> 00:31:02.760
You, make it harder to
maintain you, make it harder

514
00:31:02.760 --> 00:31:06.180
to be confident that it's
correct. So we're actually working

515
00:31:06.180 --> 00:31:10.620
against our, what should be
our principal goal. Sometimes you

516
00:31:10.620 --> 00:31:13.260
have to optimize and sometimes
you have to do terrible

517
00:31:13.260 --> 00:31:17.820
things, but you should measure
carefully before you do that,

518
00:31:17.820 --> 00:31:19.710
to be sure that in
fact, you even have to,

519
00:31:21.150 --> 00:31:24.060
When we were speaking earlier,
you told me a story

520
00:31:24.060 --> 00:31:28.200
about the GoTo statement and
how developers argue and make

521
00:31:28.200 --> 00:31:31.800
their arguments understood and how
ineffective arguments can potentially have

522
00:31:32.160 --> 00:31:35.040
decade long ramifications. Could you
talk about the GoTo statement?

523
00:31:35.460 --> 00:31:39.480
Yeah. So in 68, Dykstra
wrote a letter to the

524
00:31:39.720 --> 00:31:43.740
communications of the ACM, which
was titled GoTo statement considered

525
00:31:43.740 --> 00:31:49.050
harmful. And in it, he
describes GoTo statements as being

526
00:31:49.710 --> 00:31:54.090
disastrous. And then that we
should get rid of them.

527
00:31:54.750 --> 00:31:56.220
It turned out getting rid
of them was a good

528
00:31:56.220 --> 00:32:01.650
idea, but they weren't disastrous
that there were good programs

529
00:32:01.650 --> 00:32:06.930
that had go tos and
that worked fine. So his

530
00:32:07.260 --> 00:32:12.840
charge that simply by having
go tos that was causing

531
00:32:12.840 --> 00:32:16.500
destruction was, was not true.
And so there were a

532
00:32:16.500 --> 00:32:19.680
lot of people who were
emotionally invested in the GoTo

533
00:32:19.680 --> 00:32:22.980
statement, who thought they were
being completely logical about their

534
00:32:22.980 --> 00:32:26.880
defense of the statement. And
they looked at Dykstras claim

535
00:32:26.880 --> 00:32:30.600
of destruction and, and said,
well, that's obviously not true.

536
00:32:31.140 --> 00:32:34.640
Therefore his conclusion was obviously
not true. Dykstra was trying,

537
00:32:34.680 --> 00:32:39.590
trying to change a paradigm.
And it, in retrospect doesn't

538
00:32:39.590 --> 00:32:41.750
look like a paradigm shift.
Cause we're just getting rid

539
00:32:41.750 --> 00:32:44.510
of a statement, which at
that point in time, we

540
00:32:44.510 --> 00:32:47.900
didn't need anymore. That there
was a theory that if

541
00:32:47.900 --> 00:32:50.450
you have, if you add
ELLs and while to a

542
00:32:50.450 --> 00:32:54.050
programming language, most of the
needs for GoTo go away,

543
00:32:55.700 --> 00:32:59.660
but not all of them
said the defenders of the

544
00:32:59.660 --> 00:33:03.770
GoTo. And they came up
with lots of other arguments.

545
00:33:03.770 --> 00:33:07.340
Like you're saying that we
cannot tell when GoTo is

546
00:33:07.340 --> 00:33:09.260
appropriate or not. And so
you're gonna take it away

547
00:33:09.260 --> 00:33:12.830
from us. That is an
insult to us that you're

548
00:33:12.920 --> 00:33:17.990
challenging our competence and our
intelligence. And you're wrong about

549
00:33:17.990 --> 00:33:21.500
that. Cause we are competent
and intelligent people. They made

550
00:33:21.500 --> 00:33:24.260
arguments about tradition. You know,
we have always had GoTo

551
00:33:24.260 --> 00:33:27.290
in our language or comfortable
with it. It works for

552
00:33:27.290 --> 00:33:31.370
us. We're making weddings writing
with go-tos. You cannot take

553
00:33:31.370 --> 00:33:33.200
it away from us needing
you. You know, you can't

554
00:33:33.200 --> 00:33:38.480
destroy our livelihoods. They made
arguments about personal expression. We

555
00:33:38.480 --> 00:33:41.780
are artists and we express
ourselves with our go tos

556
00:33:42.080 --> 00:33:45.740
and you can't take that
away from us. They made

557
00:33:45.740 --> 00:33:50.870
the argument that nobody wants
the GoTo statement away taken

558
00:33:50.870 --> 00:33:53.480
away, which was ridiculous because
the reason they said that

559
00:33:53.480 --> 00:33:56.870
was because someone had suggested
that very thing. So saying

560
00:33:56.870 --> 00:34:02.510
nobody wants that is obviously
wrong. There are some other

561
00:34:02.510 --> 00:34:05.840
guys who weren't quite as
mathematically challenged, who said, instead,

562
00:34:06.290 --> 00:34:09.290
the majority of us want
to keep the GoTo and

563
00:34:09.290 --> 00:34:11.780
they, which is less obviously
wrong, but they said that

564
00:34:11.780 --> 00:34:15.410
without any data to support
it. And they continued saying

565
00:34:15.410 --> 00:34:18.500
that even when they were
no longer the majority, which,

566
00:34:18.560 --> 00:34:20.600
and all of that completely
missed the point that it

567
00:34:20.600 --> 00:34:23.960
doesn't matter what the majority
wants. The argument should have

568
00:34:23.960 --> 00:34:27.860
been. We're trying to write
programs that have fewer errors

569
00:34:27.860 --> 00:34:30.740
in them. And it suggested
that by getting rid of

570
00:34:30.740 --> 00:34:33.710
this statement, we'll accomplish that,
is that something we want

571
00:34:33.710 --> 00:34:37.430
to do? Is that a
true claim or not? That's

572
00:34:37.430 --> 00:34:39.590
what the argument should have
been instead. It was about

573
00:34:39.590 --> 00:34:42.830
all those other things, which
are ultimately all emotional. Right?

574
00:34:43.540 --> 00:34:45.190
I think that that's an
important lesson for everyone to

575
00:34:45.190 --> 00:34:48.460
remember that you are not
your code. And if you

576
00:34:48.700 --> 00:34:51.160
take an argument about someone's
code, even a friend or

577
00:34:51.160 --> 00:34:53.230
someone you work with, and
it starts with something like

578
00:34:53.260 --> 00:34:57.580
disastrous, a big specious declarative
statement about how, you know,

579
00:34:57.580 --> 00:35:01.240
your code sucks, then it's
going to go completely off

580
00:35:01.240 --> 00:35:05.020
the rails. Yeah. Dykstra started
the argument in a really

581
00:35:05.020 --> 00:35:08.770
bad way. Another thing he
said was we observed that

582
00:35:10.000 --> 00:35:14.260
programmers who use lots of
go tos are inferior to

583
00:35:14.320 --> 00:35:18.130
programmers who don't, what he
could have said was programs

584
00:35:18.130 --> 00:35:20.890
that have lots of go-tos
are inferior, but he didn't.

585
00:35:20.950 --> 00:35:24.430
He made it personal in
the first sentence of his

586
00:35:24.430 --> 00:35:29.200
letter. Wow. You know, it's,
you know, it's just really

587
00:35:31.780 --> 00:35:37.180
arrogant. Right. Alan Kay said
that arrogance is measured in

588
00:35:37.650 --> 00:35:45.300
nano Dykstras no, we should
love the coder, but hate

589
00:35:45.300 --> 00:35:47.910
the code. Right. And that
should have been his argument,

590
00:35:47.940 --> 00:35:50.220
but he didn't, he made
it personal too. So it's

591
00:35:50.340 --> 00:35:54.170
maybe not surprising that they
countered with personal arguments. Yeah.

592
00:35:54.230 --> 00:35:56.210
I tried it. I am
not my code. I try

593
00:35:56.220 --> 00:35:57.980
very hard to make sure
that other people do not

594
00:35:57.980 --> 00:35:59.690
feel that they are they're
Cody there, but it's hard

595
00:36:00.050 --> 00:36:02.840
in the world of pull
requests and Twitter. It's very

596
00:36:02.840 --> 00:36:05.930
easy to take these things
personally. Well, thanks so much

597
00:36:05.930 --> 00:36:08.030
for chatting with me today
and I'll put in the

598
00:36:08.030 --> 00:36:11.330
show notes, links to your
Google plus and your website

599
00:36:11.330 --> 00:36:13.370
and you know, things that
you've worked on as well

600
00:36:13.370 --> 00:36:17.360
as Jason link. Jason lint.
Thank you so much. Thank

601
00:36:17.360 --> 00:36:20.420
you. This has been another
episode of Hanselminutes and we'll

602
00:36:20.420 --> 00:36:21.560
see you again next week.


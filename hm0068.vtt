WEBVTT FILE

1
00:00:12.090 --> 00:00:17.730
From Hanselman it's dot com.
It's Hansel minutes, a weekly

2
00:00:17.730 --> 00:00:22.020
discussion with web developer and
technologists. Scott Hanselman hosted by

3
00:00:22.020 --> 00:00:27.990
Carl Franklin. This is Lawrence Ryan announcing
show number 68. Accorded Thursday,

4
00:00:27.990 --> 00:00:35.010
June 14th, 2007. Support for Hanselman minutes
is provided by Tellerik rad

5
00:00:35.010 --> 00:00:39.210
controls, the most comprehensive suite
of components for windows forms

6
00:00:39.210 --> 00:00:50.730
and asp.net web applications. online@wwwdottelerik.com.
Support is also provided by

7
00:00:50.730 --> 00:00:55.230
slash end software red carpet
subscriptions. The most comprehensive solution

8
00:00:55.230 --> 00:00:59.160
for adding connectivity to your
dot Benton asp.net applications. With

9
00:00:59.160 --> 00:01:09.510
components of every major internet
protocol online@wwwdotandsoftwaredotcomandby.net developers journal the

10
00:01:09.510 --> 00:01:15.750
world's leading dotnet developer magazine
online at www dot <inaudible>

11
00:01:16.080 --> 00:01:20.040
dot com. In this episode,
Scott and Carl discuss orcas

12
00:01:20.070 --> 00:01:27.060
dynamic languages and other topics
with Patrick Caldwell. Hi, this is

13
00:01:27.060 --> 00:01:30.150
Carl Franklin. You're listening to Hansel
minutes from Hanselman it's dot

14
00:01:30.150 --> 00:01:33.240
com. Scott is joining me
this week with a special

15
00:01:33.240 --> 00:01:36.750
guest. Hi Scott. Hey Carl,
how's it going? I'm doing

16
00:01:36.750 --> 00:01:38.390
fine. You were shocked there
because I asked you how

17
00:01:38.390 --> 00:01:41.270
you're doing because that wastes
the viewer's time. See, at

18
00:01:41.270 --> 00:01:43.190
this point I an ordinary
podcast, I would ask you

19
00:01:43.190 --> 00:01:45.050
how your weekend was, but
we're not going to do

20
00:01:45.050 --> 00:01:50.270
that here on Hanselman. It's
I don't care. I'm here

21
00:01:50.270 --> 00:01:55.390
with Patrick Caldwell. Patrick Caldwell is my
right hand, man. My tattoos

22
00:01:55.390 --> 00:02:00.260
to my mr. Rourke. He
is, he is, he's a,

23
00:02:00.590 --> 00:02:03.890
he's the architect here on
our next generation banking system.

24
00:02:04.490 --> 00:02:07.010
Okay. And we're going to
be talking about orcas. So

25
00:02:07.010 --> 00:02:10.340
we'll call this the orcas
overview show. Excellent. Welcome Patrick.

26
00:02:11.000 --> 00:02:13.310
Thanks Carl. We talked a
little bit about our original

27
00:02:13.790 --> 00:02:15.980
banking system here and how
it's kind of a hybrid

28
00:02:15.980 --> 00:02:18.050
and it's based on.net one,
one, but there's some C

29
00:02:18.050 --> 00:02:21.710
plus plus in there. And
Patrick is designing along with

30
00:02:21.710 --> 00:02:24.470
a number of folks over
here at Karelian now division

31
00:02:24.470 --> 00:02:28.220
of CheckFree the next generation
system. And it's going to

32
00:02:28.220 --> 00:02:30.320
be based on, I guess
they're calling it now.net three,

33
00:02:30.320 --> 00:02:34.520
five. That's the official title,
right? Right. And we're using

34
00:02:34.520 --> 00:02:38.600
a whole host of technologies
within that. It's probably worth

35
00:02:38.600 --> 00:02:42.200
for a second demystifying, the
kind of mess that is

36
00:02:42.200 --> 00:02:44.810
the.net framework numbering system. I'm
sure that you've had a

37
00:02:44.810 --> 00:02:47.210
little trouble with this yourself.
Right? Carl. I mean the

38
00:02:47.210 --> 00:02:50.300
whole thing about.net three O
not really being a new

39
00:02:50.300 --> 00:02:54.020
framework, but just being additional
features, you know, sort of

40
00:02:54.320 --> 00:02:56.510
has thrown the whole well,
you know, it's what happens

41
00:02:56.510 --> 00:03:00.520
when marketing people get involved
in, in naming decisions For

42
00:03:00.520 --> 00:03:03.370
versions of that, that should
normally be left up to

43
00:03:03.370 --> 00:03:07.170
the scientists. Right. And then
what is.net three, five, right,

44
00:03:07.180 --> 00:03:09.600
right. Remembering, remembering that all
of this is based on

45
00:03:09.600 --> 00:03:12.960
the two Oh CLR. Yup.
And then orcas is the

46
00:03:12.960 --> 00:03:18.720
code name for visual studio
2008. Right. So I feel

47
00:03:18.720 --> 00:03:21.240
that there's a lot of
good stuff. That's not being,

48
00:03:22.920 --> 00:03:26.400
not being expressed because people
are confused. People are not

49
00:03:26.700 --> 00:03:29.310
clear on exactly what is
orcas, what is three, five?

50
00:03:29.640 --> 00:03:31.410
And they were kind of
saying, well, what's the point?

51
00:03:31.530 --> 00:03:34.110
What is this next new
thing? So at lunch today,

52
00:03:34.110 --> 00:03:36.660
I mentioned this to Patrick
and I said, you know

53
00:03:36.990 --> 00:03:40.020
what? What's the big deal.
Orcas is what, and, and

54
00:03:40.020 --> 00:03:43.860
you said I've sort of
been downplaying while link. Okay,

55
00:03:43.860 --> 00:03:48.120
great. It's data. I think
that, that there's a lot

56
00:03:48.120 --> 00:03:50.910
more to link than just
the database part and that

57
00:03:51.120 --> 00:03:53.070
some of the changes that
they've had to make to

58
00:03:53.070 --> 00:03:57.060
the framework and to the
compiler to support link, I

59
00:03:57.060 --> 00:04:00.030
think will be a lot
of huge value to us

60
00:04:00.030 --> 00:04:05.850
going forward without necessarily having
direct bearing on data access.

61
00:04:06.570 --> 00:04:09.540
So you see how Patrick
went directly to link on

62
00:04:09.540 --> 00:04:11.700
an orifice question? Well, let
me know. That's, that's the

63
00:04:11.700 --> 00:04:14.430
big news, right? I mean,
link is the major feature

64
00:04:14.880 --> 00:04:18.990
that we have in this
new version of.net, right? It

65
00:04:18.990 --> 00:04:20.910
is a, I mean, it's,
it's the one that stands

66
00:04:20.910 --> 00:04:22.680
out, but I think there's
a lot of the underpinnings

67
00:04:22.680 --> 00:04:25.800
in C-sharp three Oh. That
they had to change to

68
00:04:25.800 --> 00:04:28.680
make link work that will
end up being at least

69
00:04:28.680 --> 00:04:31.560
as important, if not more
interesting than the actual link

70
00:04:31.590 --> 00:04:35.700
part. Okay. So how many
different things are required to

71
00:04:35.700 --> 00:04:38.280
make this work? I mean,
we all understand dotnet to,

72
00:04:38.280 --> 00:04:40.890
Oh, we're going to send
the.net CLR that done a

73
00:04:40.900 --> 00:04:44.760
two O type system. We
know that visual studio, 2005

74
00:04:44.880 --> 00:04:48.240
targets two Oh that you
can't target one, one without

75
00:04:48.270 --> 00:04:53.640
adding stuff to visual studio,
2000 and five.net three O

76
00:04:53.910 --> 00:04:58.110
was really a series of
libraries that augmented.net to, Oh,

77
00:04:58.770 --> 00:05:02.910
those libraries being the w
question Mark F stack to

78
00:05:02.910 --> 00:05:09.330
be PF WCF. Right. And
then.net three, five is still

79
00:05:09.360 --> 00:05:14.220
the.net two O CLR. It's
a new visual studio and

80
00:05:14.220 --> 00:05:16.440
it is a new C-sharp
compiler and a new visual

81
00:05:16.440 --> 00:05:19.500
basic compiler. Is that right,
Patrick? Yeah, That is correct.

82
00:05:19.530 --> 00:05:22.350
And there, and there's also
been some additional library changes

83
00:05:22.350 --> 00:05:25.500
around that. The w question
Mark F stack. So there's

84
00:05:25.500 --> 00:05:29.760
some new silver, which is
the integration between a WCF

85
00:05:29.760 --> 00:05:32.790
and windows workflow, which also
we're looking to take advantage

86
00:05:32.790 --> 00:05:36.180
of. So has the base
class library changed has my

87
00:05:36.180 --> 00:05:39.030
system dot collections and those
kinds of things changed. I

88
00:05:39.030 --> 00:05:41.640
mean, there are some additions,
but the fundamentals haven't changed

89
00:05:41.640 --> 00:05:44.820
at all. So there's been
a versioning stuff, versioning changes,

90
00:05:45.030 --> 00:05:46.830
but there's nothing like I'm
going to find more things

91
00:05:46.830 --> 00:05:50.310
marked obsolete. I don't think
so. The, you know, there

92
00:05:50.310 --> 00:05:53.620
may be some minor changes.
I think there certainly are

93
00:05:53.670 --> 00:05:55.950
mostly going to be additions
rather than any breaking changes,

94
00:05:56.700 --> 00:05:58.850
but that does bring up
though. I mean, it is

95
00:05:58.850 --> 00:06:00.770
additionally confusing. The picture that
when you look at the

96
00:06:00.770 --> 00:06:04.310
assembly versions on an Orca
system, some of the base

97
00:06:04.310 --> 00:06:07.010
class framework assemblies are still
version two. Oh. And some

98
00:06:07.010 --> 00:06:08.390
of them are three O
and now some of them

99
00:06:08.390 --> 00:06:12.050
will be three, five. So
it's really all, you're running

100
00:06:12.050 --> 00:06:14.330
this whole stack of things
that at different version level,

101
00:06:15.070 --> 00:06:18.580
But right now it seems
like that's just an issue

102
00:06:18.580 --> 00:06:20.770
of the beta. I mean,
ultimately the version numbers will

103
00:06:20.770 --> 00:06:24.210
all sync up. When I
put this on a system

104
00:06:24.220 --> 00:06:26.980
and I deploy to a
system, what do they require?

105
00:06:27.460 --> 00:06:28.920
Like, I understand if I
want to put Dutton at

106
00:06:28.920 --> 00:06:30.310
two on a system, I
need to put the done

107
00:06:30.310 --> 00:06:34.420
at two O runtime. If
I use WCF WPF type

108
00:06:34.450 --> 00:06:36.310
libraries, I need to put
the done at three O

109
00:06:37.750 --> 00:06:40.100
quote unquote runtime, not a
very good word for it.

110
00:06:40.480 --> 00:06:43.450
They're not that.net three O
libraries. What do I need

111
00:06:43.450 --> 00:06:46.360
to do to, to take
an orcas application to a

112
00:06:46.360 --> 00:06:49.790
non orcas prepared system, Then
you'd have to install the

113
00:06:49.810 --> 00:06:53.440
three, five, I guess, you
know, runtime, or Is there

114
00:06:53.440 --> 00:06:57.340
one yet? I don't know
if there's a separate installer

115
00:06:57.340 --> 00:06:59.920
outside of visual studio, 2008
right now, but I haven't

116
00:06:59.920 --> 00:07:03.580
looked So presumably there'll be
a similar three, five. And

117
00:07:03.580 --> 00:07:04.720
so now it's going to
be, do you know if

118
00:07:04.720 --> 00:07:06.520
it will be a stack?
I haven't figured this out.

119
00:07:06.880 --> 00:07:09.790
Like, can I get three,
five by just running one

120
00:07:09.790 --> 00:07:11.200
installer? Or do I have
to go and do the

121
00:07:11.620 --> 00:07:15.460
dance of stacking installers? I
think if, if three O

122
00:07:15.460 --> 00:07:18.040
is a precedent, then three,
five should be the same.

123
00:07:18.040 --> 00:07:19.660
And that you'll just run
the one installer and it'll

124
00:07:19.660 --> 00:07:22.390
install the two old runtime
and the three old libraries

125
00:07:22.390 --> 00:07:26.500
and then presumably any additional
three-five stuff. Okay. So back

126
00:07:26.500 --> 00:07:28.270
to the compiler thing, which
I think is the most

127
00:07:28.270 --> 00:07:31.720
significant kind of part that
people have trouble with, at

128
00:07:31.720 --> 00:07:34.120
least the people that I'm
talking to is the idea

129
00:07:34.120 --> 00:07:37.810
that there are two different
C-sharp compilers on an Orca

130
00:07:37.810 --> 00:07:42.550
system. When you say file
new within visual studio, 2008

131
00:07:44.380 --> 00:07:47.440
in that dialog box for
a new project, there's an

132
00:07:47.440 --> 00:07:50.110
option in the upper right
corner that says which framework

133
00:07:50.140 --> 00:07:52.510
version do you want to
target? And that sets the

134
00:07:52.510 --> 00:07:54.550
whole system up, that sets
up your whole project for

135
00:07:54.550 --> 00:08:00.340
specific compilers specific libraries with
which you'll get different syntax,

136
00:08:00.340 --> 00:08:05.590
checking, different IntelliSense, completely different
environment. So it's the first

137
00:08:05.590 --> 00:08:08.740
visual studio that lets you
target more than one version

138
00:08:08.740 --> 00:08:11.350
of the framework in a
supported way. When I say

139
00:08:11.350 --> 00:08:13.180
in a supported way, I
mean that, there's a thing

140
00:08:13.180 --> 00:08:18.400
called MSB, the Microsoft, the
build Everett environment, which let

141
00:08:18.400 --> 00:08:21.340
you target one, one under
visual studio, 2005, but it

142
00:08:21.340 --> 00:08:24.250
wasn't exactly a supported thing.
It was more of kind

143
00:08:24.250 --> 00:08:27.790
of a fun thing that
would give you a hybrid,

144
00:08:27.790 --> 00:08:30.430
but this is the a
formal change. It seems on

145
00:08:30.430 --> 00:08:32.770
the part of the visual
studio team to say we

146
00:08:32.770 --> 00:08:36.220
will support all three of
these targeted environments. Yeah. I

147
00:08:36.220 --> 00:08:38.590
think it becomes a little
easier though, because they're, since

148
00:08:38.590 --> 00:08:40.960
they're all targeting the same
runtime, you know, unlike with

149
00:08:40.960 --> 00:08:43.560
MSP stuff, you're really targeting
a two or a one,

150
00:08:43.560 --> 00:08:47.290
one runtime with this year,
you're targeting one CLR, right.

151
00:08:47.290 --> 00:08:50.110
There's only one, two Oh
runtime. And so that the

152
00:08:50.110 --> 00:08:52.330
switch is really just setting
up, which C-sharp compiler am

153
00:08:52.330 --> 00:08:54.880
I going to use and
which set of libraries in

154
00:08:54.880 --> 00:08:57.990
my right. My referencing the
two old version of system,

155
00:08:57.990 --> 00:09:00.300
not a, you know, collections,
or is it the three

156
00:09:00.300 --> 00:09:03.030
or the three, five version.
So really when, and then

157
00:09:03.030 --> 00:09:05.910
this really kind of underscores
the, the version number and

158
00:09:05.910 --> 00:09:10.050
confusion. I mean, there's, it's
all.net with some different libraries

159
00:09:10.440 --> 00:09:13.530
and as just one more
number and confusion, the new

160
00:09:13.530 --> 00:09:16.350
compiler is called C-sharp three
Oh, which is coming out

161
00:09:16.350 --> 00:09:20.340
with the three, five runtime
and which didn't ship with

162
00:09:20.340 --> 00:09:24.270
the, you know, three O
runtime that included, you know,

163
00:09:24.270 --> 00:09:27.960
WCF and WPF at, which
makes sense. If you view

164
00:09:27.960 --> 00:09:30.750
that independently, since it's a
new ECMO spec, they went

165
00:09:30.750 --> 00:09:32.790
from a C sharp, you
know, two Oh to C-sharp

166
00:09:32.820 --> 00:09:34.680
three hours, the name of
the spec, but it didn't

167
00:09:34.680 --> 00:09:36.780
ship with three. Oh. So,
and that just adds one

168
00:09:36.780 --> 00:09:40.110
more point of confusion. I
just like to think that

169
00:09:40.110 --> 00:09:43.320
with orcas, it's next gen
C sharp, and that's kind

170
00:09:43.320 --> 00:09:45.540
of simple, that's a simple
sentence kind of way of

171
00:09:45.540 --> 00:09:46.890
doing it, but it's how
I deal with all the

172
00:09:46.890 --> 00:09:51.030
different version numbering. So what
kind of improvements in C-sharp

173
00:09:51.030 --> 00:09:53.640
have we been using so
far? We see that, is

174
00:09:53.640 --> 00:09:58.380
it linked primarily Lincoln? The
stuff that surrounds it? So,

175
00:09:58.380 --> 00:10:01.170
I mean, that there's stuff
that they enabled in the

176
00:10:01.170 --> 00:10:05.520
compiler to make link work
like Lambda expressions and like

177
00:10:07.470 --> 00:10:10.680
anonymous types. And some of
the new stuff that really

178
00:10:10.680 --> 00:10:13.290
went into the language to
make link work are interesting

179
00:10:13.290 --> 00:10:16.500
languages features, you know, in
and of themselves. So a

180
00:10:16.680 --> 00:10:18.900
couple of weeks ago, you,
you add a blog post

181
00:10:18.900 --> 00:10:22.470
about the, the Ruby syntax
being more natural, where you

182
00:10:22.470 --> 00:10:26.040
could say, you know, 20
minutes ago, well, you can

183
00:10:26.040 --> 00:10:28.890
do that same, essentially the,
exactly the same syntax using

184
00:10:28.920 --> 00:10:34.950
the new C-sharp compiler because
of extension methods and that

185
00:10:34.950 --> 00:10:38.100
same sort of anonymous types
and facilitate a lot of

186
00:10:38.100 --> 00:10:41.210
that. Patrick, the DLR, the
dynamic language run time. This

187
00:10:41.210 --> 00:10:44.300
is not coming in the
orcas timeframe. Right. I believe

188
00:10:44.300 --> 00:10:47.180
that that's true. Yeah. And
the thing that's interesting about

189
00:10:47.180 --> 00:10:50.360
the DLR is it is
a library, a series of

190
00:10:50.360 --> 00:10:53.330
libraries. So it's something that
you could choose to redistribute

191
00:10:53.750 --> 00:10:56.930
and have them be private
libraries, private assemblies to your

192
00:10:56.930 --> 00:10:59.900
application. So it's not necessarily
something that you need to

193
00:10:59.900 --> 00:11:05.270
get, you don't necessarily make
it a shared assembly. Patrick,

194
00:11:05.270 --> 00:11:07.460
what about visual basic? You've
been talking about C sharp

195
00:11:07.460 --> 00:11:10.580
three. Oh, quite a bit.
There are a few features

196
00:11:10.580 --> 00:11:14.540
in a C-sharp tooo that
we would like to have

197
00:11:14.540 --> 00:11:16.940
had in VB. And the,
the one that I keep

198
00:11:16.940 --> 00:11:19.340
coming back to is yield.
Do you know anything about

199
00:11:19.340 --> 00:11:23.270
that? Are we finally getting
yield in VB? I, you

200
00:11:23.270 --> 00:11:25.220
know, I think I saw
something related to that, but

201
00:11:25.220 --> 00:11:29.000
honestly, I, I don't track
the, the VB spec very

202
00:11:29.000 --> 00:11:31.520
well, so, well, maybe you
can explain what yield means

203
00:11:31.520 --> 00:11:37.160
to the C-sharp program. So
a yield was a new.net

204
00:11:37.220 --> 00:11:41.510
through to, Oh, I guess,
keyword that allows you to

205
00:11:41.510 --> 00:11:47.120
do very simple returning enumerators,
right? So you can in

206
00:11:47.120 --> 00:11:50.030
a loop, just say for
each time through the loop

207
00:11:50.330 --> 00:11:52.730
yield, a return value of
this, and the compiler will

208
00:11:52.730 --> 00:11:55.900
take of turning that into
something that is IEnumerable and

209
00:11:55.900 --> 00:11:59.850
return Collection. And basically yield
goes back to the caller

210
00:12:00.120 --> 00:12:03.060
and, and sends that item
back to the caller as

211
00:12:03.060 --> 00:12:06.630
if it were part of
a collection. Right. Very, very

212
00:12:06.630 --> 00:12:09.930
cool stuff. Now, I wonder
about this and I'm just

213
00:12:09.930 --> 00:12:12.300
kind of like musing here.
I don't necessarily have a

214
00:12:12.300 --> 00:12:15.810
conclusion, but I wonder to
ask both you guys for

215
00:12:15.810 --> 00:12:21.180
the average, Joe, the average
programmer, these new features, how

216
00:12:21.180 --> 00:12:23.490
much of a mind shift
does it take for these

217
00:12:23.490 --> 00:12:25.980
new features for them to
start using it? Are these

218
00:12:25.980 --> 00:12:28.500
the kind of language features
where it's like, Oh, there

219
00:12:28.500 --> 00:12:32.850
was a vacuum. I needed
this and now it's there

220
00:12:32.850 --> 00:12:36.090
when I need it. Or
we've been using the existing

221
00:12:36.090 --> 00:12:40.470
language so long that we'll
continue to forget that yield

222
00:12:40.470 --> 00:12:43.560
is there, forget that anonymous
classes are there, you know,

223
00:12:43.560 --> 00:12:46.140
there's kind of, there's a
couple different kinds of programmers.

224
00:12:46.140 --> 00:12:48.360
I think that there's those
that are clamoring for the

225
00:12:48.360 --> 00:12:51.270
new language features and are
going to go, ah, it

226
00:12:51.270 --> 00:12:53.310
could become so much more
elegant now that I have

227
00:12:53.370 --> 00:12:56.010
this. And then there are
those who will continue to

228
00:12:56.010 --> 00:12:57.810
forget that they're available and
not use them at all.

229
00:12:58.710 --> 00:13:01.050
What do you think, Scott?
I think what you're going

230
00:13:01.050 --> 00:13:03.330
to see is just like
we had with generics in

231
00:13:03.330 --> 00:13:07.140
2.0, people really didn't know
that they could do it

232
00:13:07.140 --> 00:13:10.860
any other way. And so
we're perfectly happy coming down

233
00:13:10.860 --> 00:13:14.190
to the computers level and
programming without generics all these

234
00:13:14.190 --> 00:13:17.550
years and generic show up
and we start using them

235
00:13:17.550 --> 00:13:20.760
all over the place. And
wow. Finally, you know, there's

236
00:13:20.760 --> 00:13:22.170
a whole lot of work
that we don't have to

237
00:13:22.170 --> 00:13:25.740
do. That's good. And I
think the same thing will

238
00:13:25.740 --> 00:13:30.900
happen with link, especially that
it'll open up new possibilities

239
00:13:30.900 --> 00:13:34.440
of the way that we
can write code that, you

240
00:13:34.440 --> 00:13:36.210
know, once we get over
the learning curve and we

241
00:13:36.210 --> 00:13:38.190
start utilizing it a little
bit more, we won't want

242
00:13:38.190 --> 00:13:40.950
to go back to doing
things the old way. Yeah.

243
00:13:40.950 --> 00:13:43.080
And there, there are some
other new features in the,

244
00:13:43.080 --> 00:13:46.260
in the C-sharp compiler that
I haven't been getting a

245
00:13:46.260 --> 00:13:49.080
lot of press because there
aren't directly related to link,

246
00:13:49.440 --> 00:13:52.290
but there's got some new
stuff around object and collection

247
00:13:52.290 --> 00:13:56.190
initializers that are, it's a
much, much more compact syntax.

248
00:13:56.260 --> 00:13:59.460
So for example, when you
do a new on a

249
00:13:59.490 --> 00:14:03.930
customer object, just like we've
always had with attribute declarations.

250
00:14:04.500 --> 00:14:09.450
Now I can say, you
know, new customer open-close Perin

251
00:14:09.630 --> 00:14:11.880
and then give a named
list of parameters that I

252
00:14:11.880 --> 00:14:14.340
want to initialize. So you
can just like with the

253
00:14:14.940 --> 00:14:18.510
attributes syntax, I can say,
you know, new customer open-close

254
00:14:18.510 --> 00:14:23.850
per in first name equals
Joe last name equals Smith,

255
00:14:24.270 --> 00:14:26.790
and have that in a
very concise syntax as part

256
00:14:26.790 --> 00:14:30.540
of the object initializer, which
is a new feature that

257
00:14:30.540 --> 00:14:34.590
it has gone, you know,
rather overlooked, but it just

258
00:14:34.590 --> 00:14:37.200
makes the code that much
cleaner. And similarly there's a

259
00:14:37.200 --> 00:14:41.640
new collection initializer so you
can initialize anything. That's IEnumerable

260
00:14:41.640 --> 00:14:44.220
the same way that you
did with the previous C-sharp

261
00:14:44.340 --> 00:14:48.270
array syntax. So the new
constructor syntax kind of obviates

262
00:14:48.270 --> 00:14:52.610
the need for 20 different
overloaded kind of basic Instructors

263
00:14:52.610 --> 00:14:55.220
whose only job it is,
is to take a parameter

264
00:14:55.220 --> 00:14:57.910
and stick it into a
member variable. Right? Let's face

265
00:14:57.910 --> 00:15:00.640
it. That's, you know, that's
just busy work for most,

266
00:15:00.670 --> 00:15:04.360
most people, unless you actually
need to hook those things

267
00:15:04.360 --> 00:15:06.670
in a different way in
the constructor, which you in

268
00:15:06.670 --> 00:15:09.040
what you do in the,
in the setters. But typically

269
00:15:09.040 --> 00:15:12.280
that's not a good idea
anyway. Right? So it's, you

270
00:15:12.280 --> 00:15:14.680
know, it's an example of,
you know, it's not a

271
00:15:14.680 --> 00:15:17.560
beautiful new language feature maybe,
but it's, it goes, it's

272
00:15:17.560 --> 00:15:20.710
that much closer to reducing
the amount of code that

273
00:15:20.710 --> 00:15:22.390
monkeys could write that we
have to take care of

274
00:15:22.390 --> 00:15:25.420
ourselves After all that's the
goal is to find, to

275
00:15:25.450 --> 00:15:28.660
find ways to get monkeys,
to write code that's the

276
00:15:28.660 --> 00:15:31.870
goal. Ultimately, I think that
we all wish that monkeys

277
00:15:31.870 --> 00:15:36.160
would write code. Now, the,
the link stuff, I know

278
00:15:36.160 --> 00:15:38.170
that it's kind of, it
feels kind of strange when

279
00:15:38.170 --> 00:15:40.900
you start writing link D
link X-linked type code, because

280
00:15:41.260 --> 00:15:44.170
it's not in a string
we've spent so many years

281
00:15:44.620 --> 00:15:48.130
writing one language, be that
VB or Xi sharp, and

282
00:15:48.130 --> 00:15:52.540
then tunneling other languages inside
of strings. You know what

283
00:15:52.540 --> 00:15:55.480
I'm saying? You, you tunnel
in regular expressions, you tunnel

284
00:15:55.480 --> 00:15:58.960
in X path, you tunnel
in CQL. These are all

285
00:15:59.110 --> 00:16:02.590
chunks of other languages that
we kind of met up

286
00:16:02.590 --> 00:16:05.530
program and express in strings.
And the compiler has no

287
00:16:05.530 --> 00:16:08.770
idea that those things exist.
And every once in a

288
00:16:08.770 --> 00:16:11.050
while, someone will write a
cool add in. That'll let

289
00:16:11.050 --> 00:16:14.800
you peek inside those strings
and do some rudimentary syntax

290
00:16:14.800 --> 00:16:18.730
checking when those, those quotes,
those double quotes are removed

291
00:16:18.730 --> 00:16:21.190
and suddenly those big green
strings that used to be

292
00:16:21.190 --> 00:16:24.520
syntax highlighted as a string,
become a part of the

293
00:16:24.520 --> 00:16:27.040
language. It seems of kind
of creepy. At least to

294
00:16:27.040 --> 00:16:29.350
me, it seems kind of
hard to get used to

295
00:16:29.770 --> 00:16:33.160
how is the system aware
of all that information? That

296
00:16:33.160 --> 00:16:35.350
seems like all this new
knowledge that it knows about.

297
00:16:35.680 --> 00:16:38.950
It knows about the database
you're getting IntelliSense, right? Patrick

298
00:16:38.950 --> 00:16:41.980
on tables. Where did it
find out what table you

299
00:16:41.980 --> 00:16:43.690
were talking about? How did
it know about this stuff?

300
00:16:43.990 --> 00:16:46.570
So that with, with objects.
So the stuff that I've

301
00:16:46.570 --> 00:16:48.940
played around with Moses, the
link to object stuff, and

302
00:16:48.940 --> 00:16:51.880
there, obviously the compiler is
taking care of it with

303
00:16:51.880 --> 00:16:54.010
the link to SQL stuff.
You do have to take

304
00:16:54.010 --> 00:16:58.600
the step of building some,
you know, entities that the

305
00:16:58.600 --> 00:17:01.840
compiler will know about that
look like your database. So,

306
00:17:02.290 --> 00:17:04.270
you know, it is a
little strange and the syntax

307
00:17:05.240 --> 00:17:07.540
is, has ended up being
a little different than SQL.

308
00:17:08.380 --> 00:17:10.210
When you look at it,
for example, you start with

309
00:17:10.240 --> 00:17:13.720
a foresee in customers. And
then the end of this

310
00:17:13.720 --> 00:17:16.240
statement says what you're actually
selecting. So you do foresee

311
00:17:16.240 --> 00:17:21.730
and customers where C is,
you know, named dot Fred

312
00:17:22.150 --> 00:17:24.760
select C. So the syntax
is a little different from

313
00:17:24.760 --> 00:17:27.250
SQL, which, you know, may,
I don't think is a

314
00:17:27.430 --> 00:17:31.060
huge problem, what that facilitates
so is in TeleSign. So

315
00:17:31.060 --> 00:17:33.730
I think the first time
somebody gets real IntelliSense over

316
00:17:33.730 --> 00:17:38.500
their set based queries. They'll
they'll over look the weirdness

317
00:17:38.600 --> 00:17:41.530
and embrace the new features
and you don't have to

318
00:17:41.650 --> 00:17:44.920
regenerate these things. I mean,
this is part of the

319
00:17:44.920 --> 00:17:46.780
system now, right? You don't
have to go and say

320
00:17:47.050 --> 00:17:49.560
the database has changed. How
does it do, do you

321
00:17:49.560 --> 00:17:51.390
have to do that? I
think that you would, I

322
00:17:51.390 --> 00:17:53.550
haven't, I haven't tried it
myself, but I think that

323
00:17:53.550 --> 00:17:56.190
you would have to go
and regenerate those things. If

324
00:17:56.190 --> 00:17:58.880
the database has changed Here
at Kirlian, we have a

325
00:17:58.880 --> 00:18:02.480
little bit different situation because
our web servers don't talk

326
00:18:02.480 --> 00:18:05.840
directly to the database. We've
got a true three tier

327
00:18:05.840 --> 00:18:09.200
and multilayered system such that
the web server talks to

328
00:18:09.200 --> 00:18:12.980
an application server, passing objects,
data, transfer objects, back and

329
00:18:12.980 --> 00:18:16.010
forth. And then that application
server talks directly to the

330
00:18:16.010 --> 00:18:20.120
database. So a lot of
the work that we do

331
00:18:20.120 --> 00:18:24.050
is running around with objects
and we don't really know

332
00:18:24.050 --> 00:18:26.630
where they came from. We
don't see that the database

333
00:18:26.840 --> 00:18:29.720
got involved, but I do
know that in large systems

334
00:18:29.720 --> 00:18:32.990
like this, we spend a
lot of time marshaling between

335
00:18:32.990 --> 00:18:35.930
type systems. We dance a
lot between the, you know,

336
00:18:35.960 --> 00:18:40.340
SQL date, time, XML, date,
time, and the base class

337
00:18:40.340 --> 00:18:43.640
library, date time, how does
link or dealing deal with

338
00:18:43.640 --> 00:18:48.410
this, this constant marshaling of
data between three different type

339
00:18:48.410 --> 00:18:51.620
systems? Right. Well, my impression
is, and again, I haven't

340
00:18:51.620 --> 00:18:52.970
spent a lot of time
with the link to SQL

341
00:18:52.970 --> 00:18:56.870
stuff, but that essentially all
that's going to get normalized

342
00:18:56.870 --> 00:19:01.400
into two CLRN time types
so that the underlying link

343
00:19:01.400 --> 00:19:03.410
infrastructure is taken care of
that stuff for you. So

344
00:19:03.410 --> 00:19:06.680
you can just worry about
the C-sharp constructs and not

345
00:19:07.190 --> 00:19:10.700
worry about the underlying data
types. So that makes the

346
00:19:10.700 --> 00:19:13.910
base class library kind of
system dot ant system dot

347
00:19:13.910 --> 00:19:18.110
daytime makes those the first
among equals in this instance,

348
00:19:18.170 --> 00:19:20.900
because they're kind of the
controller in this, in this

349
00:19:20.900 --> 00:19:23.810
kind of triumvirate of data
types, there was relationship between

350
00:19:23.810 --> 00:19:26.540
the XML data types, SQL
data types, the base class

351
00:19:26.540 --> 00:19:29.360
library then becomes the first.
Yeah. And I think that's

352
00:19:29.360 --> 00:19:31.850
the way it should be.
Right. I mean, the average

353
00:19:31.850 --> 00:19:34.610
C-sharp programmer doesn't need to
know that there's any difference

354
00:19:34.610 --> 00:19:38.450
between a, you know, DB
no, and a no value

355
00:19:38.480 --> 00:19:40.940
for an object, right. I
mean, that's just trivia. And

356
00:19:40.940 --> 00:19:43.010
again, you know, that's, we're
back to the code that

357
00:19:43.010 --> 00:19:45.230
monkeys can ride, right? Nobody
wants to, to have to

358
00:19:45.230 --> 00:19:47.300
check every single value to
see if it should be

359
00:19:47.300 --> 00:19:49.490
cast as a DB Knoll
instead of a null object.

360
00:19:50.390 --> 00:19:53.540
That's, you know, it's just
busy work In your, in

361
00:19:53.540 --> 00:19:55.820
your work so far. Have
you felt that the code

362
00:19:55.820 --> 00:19:58.580
you're writing is less tedious?
You know, that kind of

363
00:19:58.580 --> 00:20:00.890
like repetitive stuff? I think
so. And I think that

364
00:20:00.890 --> 00:20:03.410
that will, because some of
the new language features that

365
00:20:03.410 --> 00:20:06.410
that'll continue to be the
case. And, you know, we

366
00:20:06.410 --> 00:20:10.310
want to in the same
way that we're starting to

367
00:20:10.310 --> 00:20:14.240
take it more advantage of
the underlying platform features rather

368
00:20:14.240 --> 00:20:17.690
than writing some code ourselves,
you know, we want to

369
00:20:17.870 --> 00:20:21.440
spend less time doing busy
work and more time writing

370
00:20:21.440 --> 00:20:24.350
banking software. And that, you
know, if we, every line

371
00:20:24.350 --> 00:20:25.940
of code that I don't
have to type, you know,

372
00:20:25.970 --> 00:20:30.530
tap out to, to cast
something to DB Noel is

373
00:20:30.530 --> 00:20:34.670
time spent solving banking problems.
Yeah. That's definitely one of

374
00:20:34.670 --> 00:20:37.400
the things that we focus
on here is just trying

375
00:20:37.400 --> 00:20:40.010
to do things that are
in our industry. In our

376
00:20:40.010 --> 00:20:42.320
case, we're in banking. In
your case, whoever you are

377
00:20:42.860 --> 00:20:46.160
a dear listener, you might
be an insurance or whatever,

378
00:20:46.160 --> 00:20:47.800
but you know, like a
lot, one of the first

379
00:20:47.800 --> 00:20:49.480
things that I ever did
here at Kirlian, like six

380
00:20:49.480 --> 00:20:51.790
years ago. So when we
started doing.net, as someone came

381
00:20:51.790 --> 00:20:55.390
up and asked me how
to parse a date time,

382
00:20:55.600 --> 00:20:57.790
they were running around doing
like an install or something

383
00:20:57.790 --> 00:21:00.430
on a string to parse
out the date time. I

384
00:21:00.430 --> 00:21:02.050
was just really shocked because
it was like, don't you

385
00:21:02.050 --> 00:21:05.620
think someone has cracked the
date time parsing problem. Could

386
00:21:05.620 --> 00:21:07.990
we move up, move up
a layer of abstraction. And

387
00:21:07.990 --> 00:21:11.200
we're constantly trying to build
those layers of abstraction, such

388
00:21:11.200 --> 00:21:14.200
that the system we are
building on top of looks

389
00:21:14.200 --> 00:21:17.470
more like the business problem,
right. And less like the

390
00:21:17.860 --> 00:21:21.430
tedium. You know, I'd like
to think about accounts and

391
00:21:21.490 --> 00:21:24.670
pays and payments rather than
even thinking about date times

392
00:21:24.670 --> 00:21:28.090
and things like that. So
hopefully that's the direction that

393
00:21:28.090 --> 00:21:32.200
things are heading. Is there
a sense that C sharp

394
00:21:32.200 --> 00:21:34.720
three O is, is more
dynamic because there's a sense

395
00:21:34.720 --> 00:21:39.400
that visual basic 10 DBX,
maybe 10 it's like OSX

396
00:21:39.520 --> 00:21:43.090
VBX, BB vigil, basic 10
is kind of reinventing itself

397
00:21:43.120 --> 00:21:46.090
or not reinventing itself, but
let's say reasserting its heritage

398
00:21:46.090 --> 00:21:48.550
as a dynamic language. I
know that you can do

399
00:21:48.550 --> 00:21:53.320
type inference in C sharp
three, but type inference does

400
00:21:53.320 --> 00:21:57.360
not dynamic language make. I
think when you put together

401
00:21:57.690 --> 00:22:03.290
things like extension methods, anonymous
types and the type inference

402
00:22:03.300 --> 00:22:05.250
of the new bar data
type, you get a lot

403
00:22:05.250 --> 00:22:09.770
closer to being a dynamic
language without it's obviously not

404
00:22:09.780 --> 00:22:11.910
as clean as syntax, right?
So you're not going to

405
00:22:12.060 --> 00:22:17.850
have the necessarily the syntactic
goodness of something like Ruby,

406
00:22:18.120 --> 00:22:19.950
but you'll have a lot
of those same features. So

407
00:22:19.950 --> 00:22:22.530
it may not look quite
the same, but you know,

408
00:22:22.620 --> 00:22:26.640
the language does facilitate more
of that dynamic behavior, Looking

409
00:22:26.640 --> 00:22:29.130
at things from a larger,
a larger scope, more historical

410
00:22:29.130 --> 00:22:33.120
scope looking back is if
you think about last 30,

411
00:22:33.540 --> 00:22:36.420
30, 40 years of programming
and how that dynamic language

412
00:22:36.780 --> 00:22:39.480
walks kind of say that
it's a resurgence of dynamic

413
00:22:39.480 --> 00:22:41.940
languages, is there a sense
that maybe we never left

414
00:22:41.940 --> 00:22:43.890
and this whole kind of
C thing was just a

415
00:22:43.890 --> 00:22:46.230
quick jaunt and I'll often
to a dead end or

416
00:22:46.230 --> 00:22:48.720
a call to sack. And
oops, didn't really mean to

417
00:22:48.720 --> 00:22:51.540
be that static. Let's head
back to, to list let's,

418
00:22:51.780 --> 00:22:56.040
let's all be lispy again.
I mean, it's kind of

419
00:22:56.040 --> 00:23:00.090
a religious issue, but the,
you know, I'm a statically

420
00:23:00.090 --> 00:23:03.450
typed language fan myself. I'm
still not totally bought off

421
00:23:03.450 --> 00:23:05.910
on the whole dynamic types
thing. So I mean, the

422
00:23:05.910 --> 00:23:09.270
fact that we can facilitate
the programming model we want

423
00:23:09.270 --> 00:23:13.530
and come closer to expressing
coder intent in our C-sharp

424
00:23:13.550 --> 00:23:16.560
three O code and still
get the benefits of compile

425
00:23:16.560 --> 00:23:19.530
time type checking. You know,
that that's where I'd like

426
00:23:19.530 --> 00:23:21.900
to see it go. I'm
still a little nervous about,

427
00:23:22.560 --> 00:23:26.730
you know, dynamic types and,
and some of the less

428
00:23:26.730 --> 00:23:30.120
strongly type stuff. So it's
nice to, I think a

429
00:23:30.120 --> 00:23:32.070
lot of the proponents of
dynamic languages, what they really

430
00:23:32.070 --> 00:23:34.350
want is I want my
code to express my intent

431
00:23:34.350 --> 00:23:37.080
without having to write a
bunch of other junk in

432
00:23:37.080 --> 00:23:39.150
the middle. Exactly. If we
can get closer to that

433
00:23:39.150 --> 00:23:41.460
and still have compiled time
type checking, that makes me

434
00:23:41.460 --> 00:23:44.220
happy. Now, when you say
compile time type checking, we

435
00:23:44.220 --> 00:23:46.670
did a little bit of
talk on dynamic languages. A

436
00:23:46.670 --> 00:23:50.090
couple of shows ago, someone
wrote in and mentioned that

437
00:23:50.720 --> 00:23:52.520
there was a thing I
thought it was called auto

438
00:23:52.520 --> 00:23:55.280
test. I might be getting
this wrong. Someone can correct

439
00:23:55.280 --> 00:23:58.790
me, but basically it was
a Ruby, a test engine

440
00:23:58.790 --> 00:24:03.710
that would constantly run your
application. So basically if you

441
00:24:03.710 --> 00:24:06.260
think about what compile time
type checking is doing, right,

442
00:24:06.390 --> 00:24:10.310
it's doing an almost run
to make sure that things

443
00:24:10.310 --> 00:24:12.710
are cool because ultimately you
don't know how this thing

444
00:24:12.710 --> 00:24:17.060
runs until it runs. So
a dynamic environment could make

445
00:24:17.060 --> 00:24:19.850
up for not having compile
time type checking by using

446
00:24:19.850 --> 00:24:23.180
those background cycles to simply
have the thing run constantly.

447
00:24:23.380 --> 00:24:25.210
Well, we have that in
visual basic, it's called the

448
00:24:25.210 --> 00:24:29.770
background compiler, Right? And, and,
and it, it breaks down

449
00:24:30.270 --> 00:24:32.860
at some point, whether it
be a thousand project, you

450
00:24:32.860 --> 00:24:35.170
know, somebody always comes up
with an email and they'll

451
00:24:35.170 --> 00:24:37.990
say, Hey, I have a
thousand projects into one solution.

452
00:24:37.990 --> 00:24:40.570
And background compilation is slow
on my system. Why do

453
00:24:40.570 --> 00:24:42.250
you think that is, That's
going to be the case,

454
00:24:42.250 --> 00:24:44.650
no matter what kind of
background checking you have, if

455
00:24:44.650 --> 00:24:47.140
you've got that many, The
size becomes a problem, but

456
00:24:47.140 --> 00:24:50.770
you're absolutely right. That that
is probably one of the

457
00:24:50.770 --> 00:24:54.730
things that's going to allow
visual basic 10 to begin

458
00:24:54.730 --> 00:24:56.950
to succeed as a dynamic
language, because they're going to

459
00:24:56.950 --> 00:24:59.770
give people that sense upfront.
I would also add Scott

460
00:24:59.770 --> 00:25:03.220
that those, you know, thousand
projects solutions are very rare

461
00:25:03.280 --> 00:25:06.640
and that most development is
done within the scope of

462
00:25:06.640 --> 00:25:10.240
something that the background compiler
can handle very well. Absolutely.

463
00:25:10.240 --> 00:25:12.040
Yeah, that's true. I was
just bringing that up as

464
00:25:12.040 --> 00:25:14.080
an edge case. That's true.
I think it's interesting to

465
00:25:14.080 --> 00:25:15.970
look at the idea of,
well, let's run it all

466
00:25:15.970 --> 00:25:18.670
the time and keep it
running and ma and make

467
00:25:18.670 --> 00:25:22.030
up for anything that might
be gained by an upfront

468
00:25:22.030 --> 00:25:24.130
compilation. I'll tell you. That's
one of the reasons that

469
00:25:24.130 --> 00:25:27.010
I haven't fully gone over
to C sharp yet is

470
00:25:27.010 --> 00:25:30.700
because that background compiler is
wonderful. And you know, you

471
00:25:30.700 --> 00:25:34.250
use that for a while
and it's damn nice. I

472
00:25:34.250 --> 00:25:38.590
don't know. It's And the
religious arguments continue. I think

473
00:25:38.590 --> 00:25:40.210
that's probably a good place
to start. Let's see if

474
00:25:40.210 --> 00:25:42.010
we can get Andrews to
come on the show and

475
00:25:42.010 --> 00:25:45.670
tell us what direction he's
taking. C-sharp FORO No, it's

476
00:25:45.670 --> 00:25:47.890
not a, it's not a
big religion thing. The religious

477
00:25:47.890 --> 00:25:50.650
Wars are over, you know,
it's just a matter of

478
00:25:50.680 --> 00:25:53.530
what works best for the
job and what, what, you

479
00:25:53.530 --> 00:25:56.350
know, the trade offs are
already there. Everybody knows the

480
00:25:56.350 --> 00:25:59.410
issues. It's it's Ultimately we
just want to do good

481
00:25:59.410 --> 00:26:01.390
work, get our jobs done
and write in a language

482
00:26:01.390 --> 00:26:04.000
that makes us feel good.
Exactly. Pick the, pick the

483
00:26:04.000 --> 00:26:07.330
shoe that fits. Cool. Well,
thanks Patrick, for taking the

484
00:26:07.330 --> 00:26:08.830
time out of your lunch
hour to come in and,

485
00:26:08.970 --> 00:26:11.950
and do a show with
me. And that's our show

486
00:26:11.950 --> 00:26:14.590
for today. I think girl.
Yes, it is. Thank you,

487
00:26:14.590 --> 00:26:17.260
Patrick. Thank you, Scott. And
thank you for listening and

488
00:26:17.260 --> 00:26:19.330
we'll see you next week
on Hanselman. It's.


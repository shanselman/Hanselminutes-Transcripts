WEBVTT FILE

1
00:00:01.230 --> 00:00:04.350
Hi, this is Scott. I
really appreciate our sponsors because

2
00:00:04.350 --> 00:00:07.320
they make the show possible.
Today's show is sponsored by

3
00:00:07.320 --> 00:00:11.490
developer express, become a UI
superhero with dev express controls

4
00:00:11.490 --> 00:00:16.020
and libraries. Deliver elegant.net solutions
that address customer needs today

5
00:00:16.410 --> 00:00:20.490
by leveraging your existing knowledge,
you can build next generation

6
00:00:20.520 --> 00:00:24.600
touch enabled solutions for tomorrow,
you can download your free

7
00:00:24.720 --> 00:00:49.040
30 day trial@dxdothanselminutes.com. That's dx.hanselminutes.com.
<inaudible> From hanselminutes.com. It's Hansel

8
00:00:49.040 --> 00:00:53.780
minutes, our weekly discussion with
web developer and technologist Scott

9
00:00:53.780 --> 00:00:58.880
Hanselman. This is Lawrence Ryan announcing
show number four 72. In

10
00:00:58.880 --> 00:01:03.050
this episode, Scott talks with
Aaron standard about the aca.net

11
00:01:03.050 --> 00:01:09.140
open source project and the
actor model. This is Scott

12
00:01:09.140 --> 00:01:11.300
Hanselman. This is another episode
of Hansel minutes, and I

13
00:01:11.300 --> 00:01:14.540
am chatting today with Aaron
standard, who works on a

14
00:01:14.540 --> 00:01:18.140
project called archive.net. How are
you? Hi, Scott. Good to

15
00:01:18.140 --> 00:01:20.210
see you. Yeah, thanks for
doing this. I appreciate it.

16
00:01:20.210 --> 00:01:22.550
We, we hung out a
little bit at dotnet fringe,

17
00:01:22.550 --> 00:01:25.640
which is a very fine
conference here in Portland. Yes,

18
00:01:25.640 --> 00:01:28.160
it was, it was a
lot of fun. We gave,

19
00:01:28.340 --> 00:01:30.890
I guess, gosh, like seven
hours of the workshops on

20
00:01:30.890 --> 00:01:35.360
ahca.net and Sunday, and then
had a talk on Monday

21
00:01:35.360 --> 00:01:37.220
and then a little lightening
talk on Tuesday. Yeah, you

22
00:01:37.220 --> 00:01:39.740
did more than just a
presentation. You did a whole

23
00:01:39.740 --> 00:01:42.830
day of workshops. Just breaking
it down. Yeah, I thought

24
00:01:42.830 --> 00:01:44.300
I was going to die
by the time I was

25
00:01:44.300 --> 00:01:47.900
done speaking for like seven
hours straight or whatever it

26
00:01:47.900 --> 00:01:50.450
was pulse, all the questions
I got asked afterwards, but

27
00:01:50.450 --> 00:01:52.430
it was really fun. We
got to train, I think,

28
00:01:52.430 --> 00:01:55.310
50 people on oca.net in
one sitting. So that was

29
00:01:55.310 --> 00:01:58.340
cool. Have you ever done
training like that before? I've

30
00:01:58.340 --> 00:02:00.470
done? Actually, I used to
work as an evangelist at

31
00:02:00.470 --> 00:02:04.970
Microsoft. Did I, did I
did. I worked on the

32
00:02:04.970 --> 00:02:09.290
field team in the United States
for startups in Southern California.

33
00:02:09.290 --> 00:02:11.810
And so we did, I
started this series of no

34
00:02:11.810 --> 00:02:14.330
JS on Azure boot camps.
This would have been like

35
00:02:14.840 --> 00:02:18.740
really late 2011, early 2012.
And I D I've started

36
00:02:18.740 --> 00:02:20.990
on that before to sort
of an all day format,

37
00:02:20.990 --> 00:02:24.440
but usually I had usually
had more people to sort

38
00:02:24.440 --> 00:02:27.440
of help and everything else.
And the content was kind

39
00:02:27.440 --> 00:02:30.620
of, I would say there's
a little bit, there was

40
00:02:30.620 --> 00:02:33.560
a lot less new concepts
to cover and that stuff,

41
00:02:33.590 --> 00:02:36.260
yeah. Everyone was already pretty
familiar with JavaScript and how

42
00:02:36.260 --> 00:02:38.990
web servers work. Yeah, yeah,
yeah. I've actually done. I

43
00:02:38.990 --> 00:02:42.680
used to do full time
training, like, like three, three,

44
00:02:42.680 --> 00:02:45.680
three weeks, a month, 40
hours a week, eight hours

45
00:02:45.680 --> 00:02:48.170
a day standing up in
front of people. And this

46
00:02:48.170 --> 00:02:51.170
was like teaching people classic
ASP. So you had to

47
00:02:51.170 --> 00:02:54.080
teach them like, here's a
request like, Whoa, Whoa, Whoa,

48
00:02:54.080 --> 00:02:58.310
slow down. So you had
to introduce people to ahca.net

49
00:02:58.310 --> 00:03:01.860
to what is that introduced
it to me. Sure. So

50
00:03:01.860 --> 00:03:05.310
ahca.net is a port of
a project called AHCA that

51
00:03:05.310 --> 00:03:08.370
was invented for the JVM
and it was written in

52
00:03:08.370 --> 00:03:12.540
Scala and Java. And what
OCHA is, is an implementation

53
00:03:12.600 --> 00:03:14.910
of the actor model. The
actor model is a very

54
00:03:14.910 --> 00:03:19.470
old concurrent programming technique stemming
back from like 1973 is

55
00:03:19.470 --> 00:03:22.170
when I think it was
invented and the first real

56
00:03:22.170 --> 00:03:24.780
commercial implementation of it that
we all sort of know

57
00:03:24.780 --> 00:03:28.050
and recognize today was the
Erling and OTP programming language.

58
00:03:29.100 --> 00:03:32.400
So if you read the
case study about WhatsApp and

59
00:03:32.400 --> 00:03:35.340
how they're able to have,
you know, like 12 engineers

60
00:03:35.340 --> 00:03:39.570
basically manage their entire infrastructure
for doing 500 million messages a

61
00:03:39.570 --> 00:03:42.720
day or whatever it was,
they're, they're really good. Earl

62
00:03:42.720 --> 00:03:47.670
length, success story type safe.
This company behind, behind the

63
00:03:47.670 --> 00:03:50.730
ACA framework wanted to bring
that same sort of concurrent

64
00:03:50.730 --> 00:03:54.870
programming model to the JVM.
And so they were really

65
00:03:54.870 --> 00:03:57.780
successful in doing that. And
then AHCA kind of evolved

66
00:03:57.780 --> 00:04:02.220
into being a really powerful,
distributed programming framework from there.

67
00:04:02.700 --> 00:04:04.890
One of the properties of
the actor model that makes

68
00:04:04.890 --> 00:04:09.570
that possible is this notion
of location transparency. So what

69
00:04:09.630 --> 00:04:12.930
the actor model really is,
is essentially, you know, an

70
00:04:12.930 --> 00:04:17.070
object oriented programming, everything's an
object, right? And the character

71
00:04:17.070 --> 00:04:21.330
model everything's either an actor
or message. So actors represent

72
00:04:21.330 --> 00:04:25.530
these little classes that effectively
act as like microprocesses, they

73
00:04:25.530 --> 00:04:29.250
can be restarted. They can
be started on a remote

74
00:04:29.250 --> 00:04:32.550
machine, etc. And the way
actors communicate with each other

75
00:04:32.550 --> 00:04:35.400
is via message passing. And
one of the things that

76
00:04:35.400 --> 00:04:39.810
makes it really powerful is
that one act message passing

77
00:04:39.810 --> 00:04:44.190
is inherently asynchronous actors run
on their own thread. You

78
00:04:44.190 --> 00:04:47.070
can have a million actors
share a small thread pool.

79
00:04:48.390 --> 00:04:51.360
And the other thing that's
really special about it is

80
00:04:51.360 --> 00:04:54.210
that if an actor wants
to communicate with another actor

81
00:04:54.210 --> 00:04:57.390
on a remote machine, that
detail is transparent to use

82
00:04:57.390 --> 00:05:00.270
the programmer for sending a
message to a local actor

83
00:05:00.300 --> 00:05:02.760
versus an actor running on
a machine in a remote

84
00:05:02.760 --> 00:05:06.720
data center, a thousand miles
away is a implementation detail

85
00:05:06.720 --> 00:05:08.760
that you don't have to
think about when you're, when

86
00:05:08.760 --> 00:05:11.250
you're sending a message. It's
just, it's something that the,

87
00:05:11.250 --> 00:05:14.580
the location transparency built into
the programming models it takes

88
00:05:14.580 --> 00:05:17.520
care of. Okay. So there's
a lot of concepts there.

89
00:05:17.520 --> 00:05:19.500
So let's, let's tease them
apart a little bit cause

90
00:05:19.500 --> 00:05:23.880
I've had a lot of
questions. So first I remember

91
00:05:23.880 --> 00:05:28.470
being around in the mid
nineties, gosh, is that 20

92
00:05:28.470 --> 00:05:31.410
years ago, you know, basically
when we were doing things

93
00:05:31.410 --> 00:05:35.340
like comm right, the component
object model, and then DICOM,

94
00:05:35.350 --> 00:05:38.670
and it was talked about
that location, transparency was an

95
00:05:38.670 --> 00:05:41.490
implementation detail. I may have
actually been on stage at

96
00:05:41.490 --> 00:05:45.150
some point and said those
words, and there were things

97
00:05:45.150 --> 00:05:47.820
about DICOM that really worked.
But then there was also

98
00:05:48.210 --> 00:05:50.550
kind of a, an oscillation
in the industry where we

99
00:05:50.550 --> 00:05:53.160
switched to the opposite side
and said, wow, we really

100
00:05:53.160 --> 00:05:56.670
should recognize that latency is
a thing and web services.

101
00:05:56.670 --> 00:05:58.910
Then it went the opposite
direction. Not only were they

102
00:05:58.910 --> 00:06:01.730
high latency, but we also
kind of explicitly said that

103
00:06:02.060 --> 00:06:06.560
out of process, cross system
calls costs, how do you

104
00:06:06.560 --> 00:06:10.690
reconcile those two things? So
that's a great question. And

105
00:06:10.780 --> 00:06:14.290
one of the things that's
different between sort of D

106
00:06:14.290 --> 00:06:16.570
calm and calm and the
actor model is that the

107
00:06:16.570 --> 00:06:20.140
actor model is asynchronous by
default, right? So when I

108
00:06:20.140 --> 00:06:22.240
send a message to an
actor, even one of my

109
00:06:22.240 --> 00:06:26.170
local process, it's going to
be, it might not respond

110
00:06:26.170 --> 00:06:29.590
to my message immediately. It
might have a queue of,

111
00:06:29.620 --> 00:06:31.360
you know, million other messages
in front of it has

112
00:06:31.360 --> 00:06:34.060
to work through. And there
might be some delay in

113
00:06:34.060 --> 00:06:35.620
it responding to me. And
that's just on a local

114
00:06:35.620 --> 00:06:38.770
process. Well, if you think
about what the delay might

115
00:06:38.770 --> 00:06:42.100
look like over the network,
particularly when there's latency involved

116
00:06:42.100 --> 00:06:44.470
and all sorts of other
stuff, if you're traveling over

117
00:06:44.470 --> 00:06:48.520
the open internet, that latency
just becomes something you account

118
00:06:48.520 --> 00:06:50.890
for in the design of
your actor system. So you

119
00:06:50.890 --> 00:06:55.360
can use techniques, like for
instance, at the ask method

120
00:06:55.360 --> 00:06:57.760
inside the actor model, where
you say, I expect this

121
00:06:57.760 --> 00:07:00.490
response back from this actor
within this hard time. I

122
00:07:00.490 --> 00:07:03.730
mean this real time constraint.
And if I don't get

123
00:07:03.730 --> 00:07:05.800
a response back, we're going
to time out and then

124
00:07:05.800 --> 00:07:09.250
do something else. So that's
sort of built into your

125
00:07:09.250 --> 00:07:11.920
thinking and modeling about the
problem is that latency is

126
00:07:11.920 --> 00:07:16.150
just a side effect of
asynchronously. Okay. So then if

127
00:07:16.150 --> 00:07:19.480
I can paraphrase to make
sure that I understood with

128
00:07:19.570 --> 00:07:23.200
common D comment was more
of a remote procedure call,

129
00:07:23.500 --> 00:07:25.330
kind of a thing. We're
going to take this object

130
00:07:25.330 --> 00:07:28.180
that has methods on it
and remote it, and then

131
00:07:28.570 --> 00:07:31.420
pretend that it's not really
remote and then feel bad

132
00:07:31.420 --> 00:07:34.810
when it's slow. And you're
saying in a message passing

133
00:07:34.810 --> 00:07:39.400
model, you're, you're expecting that
this isn't an instantaneous thing

134
00:07:39.400 --> 00:07:41.740
that's going to happen. It's
a, Hey, go ahead and

135
00:07:41.740 --> 00:07:43.660
do this, queue this up,
put this order in a

136
00:07:44.050 --> 00:07:47.260
cart or whatever. And because
your system is asynchronous, presumably

137
00:07:47.260 --> 00:07:50.390
all the way back up
into the UI. Yup. Then,

138
00:07:50.390 --> 00:07:53.890
then, then it's a much
different model. Yeah, exactly. So

139
00:07:54.190 --> 00:07:59.050
actors get dispatched asynchronously. So
an actor like actors by

140
00:07:59.050 --> 00:08:03.160
default are extremely lazy. We
have this image on one

141
00:08:03.160 --> 00:08:06.070
of our blog posts were
introduced the concept of actors

142
00:08:06.070 --> 00:08:09.940
where it's literally a mailman
sleeping inside a mailbox. That's

143
00:08:09.940 --> 00:08:12.130
sort of the right model
for thinking about what actors

144
00:08:12.130 --> 00:08:14.470
do. If they aren't receiving
messages, they're just hanging out,

145
00:08:14.510 --> 00:08:17.620
not really doing anything. But
when I messaged arrives in

146
00:08:17.620 --> 00:08:21.040
an actor's mailbox, the actor
then gets dispatched, handles it

147
00:08:21.130 --> 00:08:23.110
and then goes back to
sleep or waits for another

148
00:08:23.110 --> 00:08:26.560
message to come to it.
So the idea is that,

149
00:08:26.620 --> 00:08:29.710
you know, actors are all,
we're all sort of message.

150
00:08:29.720 --> 00:08:32.770
Passing is done asynchronously all
the time, regardless of the

151
00:08:32.770 --> 00:08:37.030
scope of how the actors
are deployed. Okay. So then

152
00:08:37.120 --> 00:08:39.730
when, when I was doing
this stuff, you know, long

153
00:08:39.730 --> 00:08:43.480
time ago we had sockets
on ports and then we

154
00:08:43.480 --> 00:08:47.650
had queues, what kinds of
things can actors communicate over?

155
00:08:48.550 --> 00:08:52.540
So right now by default
actors communicate over sockets. So

156
00:08:52.540 --> 00:08:56.850
it's all done over TCP
or UDP, and you have

157
00:08:56.850 --> 00:08:59.340
the ability to go and
write other custom transports if

158
00:08:59.340 --> 00:09:01.260
you wanted to. So for
instance, if you really wanted

159
00:09:01.260 --> 00:09:03.990
to use a named pipe
or something like that, you

160
00:09:03.990 --> 00:09:07.620
could use that to communicate
between actors, other models that

161
00:09:07.620 --> 00:09:10.620
we do see though, from
customers who are usually trying

162
00:09:10.620 --> 00:09:13.290
to, when I say customers,
I'm referring to my company,

163
00:09:13.290 --> 00:09:17.310
pedal bridge, we provide commercial
support, brocket.net, but what we

164
00:09:17.310 --> 00:09:20.520
see them do, oftentimes they
might have a preexisting system

165
00:09:20.520 --> 00:09:23.880
that has something like an
service bus or rabbit MQ

166
00:09:24.180 --> 00:09:26.760
sitting behind their web front
end. And they want to

167
00:09:26.760 --> 00:09:31.050
use okta.net to more efficiently
handle the processing of those

168
00:09:31.050 --> 00:09:34.110
published messages in that queue.
So a lot of times

169
00:09:34.110 --> 00:09:36.390
what we'll see people do
is write a system that

170
00:09:36.390 --> 00:09:39.900
has a NACA cluster consume
messages off of an existing

171
00:09:39.900 --> 00:09:43.620
message queue. We don't really
recommend that for communicating between

172
00:09:43.620 --> 00:09:47.220
actors because that's so heavy
compared to the builtin actor

173
00:09:47.220 --> 00:09:50.970
message queue and network transport
stuff that oca.net already gives

174
00:09:50.970 --> 00:09:55.050
you. But that's, that's, that's
one model we do see

175
00:09:55.050 --> 00:09:58.110
for people who are transitioning
off of some older system

176
00:09:58.110 --> 00:10:01.640
onto an actor based one.
So as, as someone who's

177
00:10:01.640 --> 00:10:04.100
spent a lot of time
building distributed systems where we

178
00:10:04.100 --> 00:10:07.280
wanted to be able to
choose our transports, how worried

179
00:10:07.280 --> 00:10:10.190
should I be when I
hear that I'm buying into

180
00:10:10.640 --> 00:10:13.130
a model that is not
only a, you know, an

181
00:10:13.130 --> 00:10:18.560
architectural model, but also presumably
an unknown implementation of some

182
00:10:18.560 --> 00:10:20.780
kind of sockets thing that
I've never heard of. Like

183
00:10:21.200 --> 00:10:23.510
I was thinking, Oh, this
is a cool abstraction. And

184
00:10:23.510 --> 00:10:25.400
now I'm thinking, Oh wow,
I have to think about

185
00:10:26.090 --> 00:10:28.130
like, I have to worry
about sockets. Should I worry

186
00:10:28.130 --> 00:10:30.350
about that? Or should I
just let it go? Well,

187
00:10:30.500 --> 00:10:33.500
You shouldn't worry about that.
What OCHA done that gives

188
00:10:33.500 --> 00:10:36.890
you is one. Those are,
there's a built in addressing

189
00:10:36.890 --> 00:10:40.970
system. Every actor has its
own unique URI. And so

190
00:10:40.970 --> 00:10:42.560
when you use and that's,
and that detailed, by the

191
00:10:42.560 --> 00:10:45.410
way, it's usually abstracted away
from you, the actor reference,

192
00:10:45.440 --> 00:10:48.320
which is how actors communicate
in both OCHA and ocha.net,

193
00:10:48.380 --> 00:10:50.960
it's like a handle to
an actor. You don't send

194
00:10:50.960 --> 00:10:53.360
a message directly to an
actor instance. You send a

195
00:10:53.360 --> 00:10:56.990
message to its handle, and
that handles responsible for putting

196
00:10:56.990 --> 00:10:59.780
a message into an actor's
mailbox. Then the mailbox is

197
00:10:59.780 --> 00:11:02.840
responsible for sort of activating
the actor. So there's sort

198
00:11:02.840 --> 00:11:06.050
of a decoupling of the
different pieces of the messaging

199
00:11:06.050 --> 00:11:11.390
infrastructure. There transports like TCP
connections. The ahca.net manages will

200
00:11:11.390 --> 00:11:13.730
be opened for you automatically
when you need to send

201
00:11:13.730 --> 00:11:17.630
a message to a remote
address, the AHCA cluster module,

202
00:11:17.720 --> 00:11:20.690
which is an abstraction that
we have even bigger abstraction

203
00:11:20.690 --> 00:11:23.180
that we have sitting on
top of our remoting capabilities

204
00:11:24.020 --> 00:11:28.520
will distract away a lot
of the addressing and socket

205
00:11:28.520 --> 00:11:30.320
management stuff for you to
a point where all you

206
00:11:30.320 --> 00:11:33.260
have to do is connect
to one node. That is

207
00:11:33.280 --> 00:11:36.620
a well known IP address.
And then from there, your

208
00:11:36.890 --> 00:11:40.310
every individual aka.net process will
be able to essentially form

209
00:11:40.310 --> 00:11:43.280
a connection to any other
node in your network. And

210
00:11:43.280 --> 00:11:46.310
that's sort of handled for
you. Automagically That one node

211
00:11:47.330 --> 00:11:49.310
have all knowledge. Is that,
is that a single point

212
00:11:49.310 --> 00:11:51.980
of failure? No. The one
node you can actually have

213
00:11:51.980 --> 00:11:54.280
more than one node than
one well known node to

214
00:11:54.280 --> 00:11:56.410
communicate with. You just need
to have at least one.

215
00:11:56.440 --> 00:11:59.770
I see. So this is
a clustering strategy that Cassandra

216
00:11:59.770 --> 00:12:02.830
and react and a couple
of other big distributed database

217
00:12:02.830 --> 00:12:05.380
technologies use it's called a
seed node is the exactly.

218
00:12:05.980 --> 00:12:08.290
Yeah. So you see the
cluster with one, one or

219
00:12:08.350 --> 00:12:10.540
more nodes at a well
known address. And that's your

220
00:12:10.540 --> 00:12:13.060
sort of entrance point if
discovering all the other ones

221
00:12:13.060 --> 00:12:15.330
that have joined And then
as nodes come and go,

222
00:12:15.330 --> 00:12:17.010
do they all let each
other know and they'll vote

223
00:12:17.010 --> 00:12:18.480
about what's going on in
the current state of the

224
00:12:18.480 --> 00:12:21.780
city. Yeah, exactly. They use
a gossip protocol to sort

225
00:12:21.780 --> 00:12:24.360
of say, Hey, I can't
connect node a can't connect

226
00:12:24.360 --> 00:12:26.670
to node C anymore. Node
B can't connect to it

227
00:12:26.670 --> 00:12:28.620
either. Okay. Then the leader
will go in and say,

228
00:12:28.650 --> 00:12:30.860
all right, well, no, it
would be he's dead. We

229
00:12:30.870 --> 00:12:33.330
gotta just, you know, go
ahead and remove it from

230
00:12:33.330 --> 00:12:36.300
our, from our routing tables
and everything else. Right. I,

231
00:12:36.300 --> 00:12:38.340
in my mind, when you
just said that gossip protocol,

232
00:12:38.340 --> 00:12:40.260
I have this image in
my mind of like people

233
00:12:40.260 --> 00:12:43.620
texting, like I haven't seen
Frank in a week. Yeah.

234
00:12:43.620 --> 00:12:45.990
I see. All right. I
see. Okay. Thanks. So I

235
00:12:45.990 --> 00:12:47.910
don't think he made it
out of the club. It

236
00:12:47.910 --> 00:12:51.600
took, it took it really
hard last night. Okay. So

237
00:12:52.140 --> 00:12:54.000
if I want to talk
to an actor, I talked

238
00:12:54.000 --> 00:12:56.640
to an actor, a reference
to an actor that goes

239
00:12:56.640 --> 00:13:00.840
over a transport that I
shouldn't worry about and goes

240
00:13:00.840 --> 00:13:05.250
into the actor's mailbox, which
is an internal cue, or

241
00:13:05.250 --> 00:13:07.380
is it being held in
memory It's being held in

242
00:13:07.380 --> 00:13:10.140
memory? It's a, essentially what
it is just a set

243
00:13:10.140 --> 00:13:13.230
of synchronized cues with different
channels. So there's some messages

244
00:13:13.230 --> 00:13:16.740
to get prioritized ahead of
others. So system messages that

245
00:13:16.740 --> 00:13:20.640
are built into okta.net, which
include things like, Hey, you

246
00:13:20.640 --> 00:13:23.340
need to restart because you're
in some faulted state, that

247
00:13:23.340 --> 00:13:26.220
sort of stuff is a
system message. Do I have

248
00:13:26.220 --> 00:13:30.420
to does that durable? Do
I worry about the memory,

249
00:13:30.450 --> 00:13:33.540
the mailbox being in memory?
So we don't have to

250
00:13:33.540 --> 00:13:36.930
worry about the mailbox being
in memory. So to speak.

251
00:13:37.270 --> 00:13:39.600
What we do need to
do though, is for scenarios

252
00:13:39.600 --> 00:13:42.300
where you have messages, where
you need to have guaranteed

253
00:13:42.300 --> 00:13:46.200
delivery by default orcas message,
delivery guarantee is best effort,

254
00:13:46.350 --> 00:13:49.230
which means at most once
month. So that's a pretty

255
00:13:49.230 --> 00:13:51.960
minimal effort when you just
say It's best to kind

256
00:13:51.960 --> 00:13:56.460
of ironically named right, best,
best effort. It's like, I'm

257
00:13:56.460 --> 00:13:58.230
going to do my best.
I will ring your doorbell

258
00:13:58.230 --> 00:14:00.870
once I'll ring your doorbell
ones and I'll leave the

259
00:14:00.870 --> 00:14:04.890
package down. So that's, that's,
what's built into Okta by

260
00:14:04.890 --> 00:14:07.410
default, what you can do.
We have it. So the

261
00:14:07.410 --> 00:14:09.870
way OCHA works is think
of it like home Depot,

262
00:14:09.870 --> 00:14:13.740
you have additional modules that
provide new sets of tools

263
00:14:13.740 --> 00:14:16.230
and parts you'd use to
build a system. We have

264
00:14:16.230 --> 00:14:19.920
one module called AKA dot
persistence. And this is a

265
00:14:19.920 --> 00:14:22.620
way of setting up two
things. One actors that have

266
00:14:22.620 --> 00:14:25.680
durable internal state, where they
basically are able to take

267
00:14:25.680 --> 00:14:29.850
messages and events, source them
to something like Cassandra or

268
00:14:29.850 --> 00:14:33.180
SQL server or Azure table
storage. And if that actor

269
00:14:33.180 --> 00:14:36.420
dies, let's say the entire
process crashes like a machine

270
00:14:36.420 --> 00:14:39.300
went down and you're out
in your Azure cluster and

271
00:14:39.300 --> 00:14:42.030
it comes back. Then it's
able to go and rehydrate

272
00:14:42.030 --> 00:14:45.270
it state from internal source,
we have a special built

273
00:14:45.270 --> 00:14:49.350
in actor called a guaranteed
delivery actor that is able

274
00:14:49.350 --> 00:14:52.190
to maintain a buffer of
that need to be sent

275
00:14:52.220 --> 00:14:55.970
over a wire to another
remote system. And it expects

276
00:14:55.970 --> 00:14:59.030
an acknowledgement back. That message
has not only been received,

277
00:14:59.030 --> 00:15:01.370
but it's also been processed
by the other end of

278
00:15:01.370 --> 00:15:04.760
that connection. And that point,
it basically, DQS the message.

279
00:15:04.760 --> 00:15:06.200
And it's, you don't have
to worry about it being

280
00:15:06.200 --> 00:15:09.400
persisted anymore because it's been
handled. You mentioned that I

281
00:15:09.400 --> 00:15:13.510
might use Sondra, but isn't
Cassandra another distributed system that's

282
00:15:13.720 --> 00:15:15.580
not written in.net that why
would I want to have

283
00:15:15.580 --> 00:15:18.970
two distributed systems talking to
each other? Basically all it

284
00:15:18.970 --> 00:15:21.010
is is that the OCHIN
up resistance module has a

285
00:15:21.010 --> 00:15:24.220
pluggable layer to work with
whatever data store you're already

286
00:15:24.220 --> 00:15:26.860
using. Yeah. So I can
introduce OCHA to an environment

287
00:15:26.860 --> 00:15:30.070
where I'm already having some
success with Cassandra. Yeah, exactly.

288
00:15:30.190 --> 00:15:33.100
So, and when I used
aka.net and production, I was

289
00:15:33.100 --> 00:15:36.610
already using Cassandra. And so
I used, I use that

290
00:15:36.610 --> 00:15:38.800
as my sort of backup
for messages that needed to

291
00:15:38.800 --> 00:15:43.930
have some durability. And, but
we have a pull request

292
00:15:43.960 --> 00:15:46.390
out there for SQL server
module. And I think we

293
00:15:46.390 --> 00:15:49.150
have a contributor who wrote
get event store plugin, rocket

294
00:15:49.150 --> 00:15:51.910
oper system. Yeah. Yeah. I
was thinking what this would

295
00:15:51.910 --> 00:15:55.450
look like with service bus.
Yeah. Service bus would be

296
00:15:55.450 --> 00:15:59.290
another one potentially. I think
I've, I've seen some people

297
00:15:59.290 --> 00:16:01.930
want to do integrations. This,
this wouldn't necessarily be an

298
00:16:01.930 --> 00:16:06.040
academic persistence implementation, but Azure
event hubs has been something

299
00:16:06.040 --> 00:16:08.170
that people have been real
interest. Yeah. Yeah. So, okay.

300
00:16:08.470 --> 00:16:11.440
All right. So act a
reference over a transport to

301
00:16:11.440 --> 00:16:15.010
a mailbox. Mailbox is an
internal cue. And then actors,

302
00:16:15.010 --> 00:16:16.960
I assume, have some behavior
that they want to do

303
00:16:16.960 --> 00:16:20.380
based on whether or not
that mailbox message is actionable.

304
00:16:20.860 --> 00:16:24.340
Yeah, Exactly. So when you're
writing your actor code, the

305
00:16:24.340 --> 00:16:26.500
only method you really need
to fill in by default

306
00:16:26.560 --> 00:16:28.660
is what's called the on
receive method. And it just

307
00:16:28.660 --> 00:16:31.270
takes a plain old object
as it's it's sort of

308
00:16:31.270 --> 00:16:35.170
property. And that object is
your message. And so you

309
00:16:35.170 --> 00:16:37.180
have to do a little
bit of, I guess, pattern

310
00:16:37.180 --> 00:16:39.670
matching. This is sort of
the functional programming name for

311
00:16:39.670 --> 00:16:42.340
doing this, where you inspect
the message by its type,

312
00:16:42.730 --> 00:16:45.420
is this message is string,
is this message, Turn it

313
00:16:45.420 --> 00:16:48.040
into a switch statement. How
does my magical distributed system

314
00:16:48.040 --> 00:16:50.170
not turn into a switch
statement of like, are you

315
00:16:50.170 --> 00:16:54.130
a string, right? You're not
gonna use a string So

316
00:16:54.130 --> 00:16:57.220
well, the serialization is handled
for you transparently. So that's

317
00:16:57.490 --> 00:16:59.380
one of the things that's
really nice is that we

318
00:16:59.380 --> 00:17:01.780
have a serialization system that
makes it, so if you're

319
00:17:01.780 --> 00:17:04.330
passing a message to another
actor in memory, that's all

320
00:17:04.330 --> 00:17:06.880
handled via in memory cues.
So there's no network transport

321
00:17:06.880 --> 00:17:10.330
there over remote system. We
sort of abstract the detail

322
00:17:10.330 --> 00:17:12.880
of it being serialized and
just make sure that on

323
00:17:12.880 --> 00:17:14.590
either end of the connection,
you don't have to worry

324
00:17:14.590 --> 00:17:17.260
about it. So we use
a combination of Google protocol,

325
00:17:17.260 --> 00:17:20.560
buffers and binary, Jason for
that nice, Both very fast,

326
00:17:20.560 --> 00:17:25.000
very tight protocols. Yup. And
when you get a message

327
00:17:25.000 --> 00:17:27.730
back, we have a couple
tools you can use in

328
00:17:27.730 --> 00:17:30.130
C sharp for doing pattern
matching. We have an F

329
00:17:30.140 --> 00:17:32.530
sharp API too, and you
can use the builtin powder

330
00:17:32.540 --> 00:17:34.870
matching the, the language supports
right out of the box

331
00:17:34.870 --> 00:17:37.360
there, but in C sharp,
we have two tools for

332
00:17:37.360 --> 00:17:39.820
you. One is we have
a special type of actor

333
00:17:39.820 --> 00:17:42.790
called a receive actor that
allows you to find a

334
00:17:42.790 --> 00:17:45.880
Lambdas and predicates for doing
pattern matching that are strongly

335
00:17:45.880 --> 00:17:48.490
typed, right. And they're also
very fast by the way.

336
00:17:48.520 --> 00:17:51.660
So they get sort compiled
and cashed and you're able

337
00:17:51.660 --> 00:17:54.000
to do things like is
this messages string, and does

338
00:17:54.000 --> 00:17:59.220
the strings start with law
effectively? And that's the sort

339
00:17:59.220 --> 00:18:01.620
of stuff that we're able
to, we're able to sort

340
00:18:01.620 --> 00:18:04.400
of make easy for C
sharp developers. If I'm doing

341
00:18:04.400 --> 00:18:06.470
a distributed system and I've
done, I used to work

342
00:18:06.470 --> 00:18:07.790
in, I don't know if
I told you about this,

343
00:18:07.790 --> 00:18:10.640
but I used to work
in banking, retail banking. So

344
00:18:10.640 --> 00:18:13.010
I worked on a large
<inaudible> based distributed system that

345
00:18:13.010 --> 00:18:15.950
ran a number of large
banks. And we struggled with

346
00:18:16.190 --> 00:18:19.610
the identity, the object identity,
like we like strong types,

347
00:18:19.670 --> 00:18:22.130
but at the same time,
you know, this object is

348
00:18:22.130 --> 00:18:23.570
going to be an account
and I'm going to send

349
00:18:23.570 --> 00:18:25.130
it over to this other
machine. And it needs to

350
00:18:25.130 --> 00:18:27.420
think about an account. Am
I using an interface? Are

351
00:18:27.420 --> 00:18:29.390
we sharing a DLL? Are
we just putting it in

352
00:18:29.390 --> 00:18:32.330
a hash table? You know,
the object identity, as it

353
00:18:32.330 --> 00:18:35.480
relates to serialization has been
a challenge historically. How do

354
00:18:35.480 --> 00:18:37.760
you deal with that? What
we do right now is

355
00:18:37.760 --> 00:18:41.390
for a distributed system where
let's say you have multiple

356
00:18:41.390 --> 00:18:44.510
ocha.net sort of services that
are I've formed a cluster

357
00:18:44.510 --> 00:18:47.840
together. The way we have
people work with that problem

358
00:18:47.840 --> 00:18:51.020
today is making sure you
have a shared assembly that

359
00:18:51.020 --> 00:18:54.020
defines all those common message
definitions that are going to

360
00:18:54.020 --> 00:18:56.990
be passed over the network.
So that way, when we,

361
00:18:56.990 --> 00:19:01.070
you know, Jason Dunn at D
serializes your network requests back

362
00:19:01.070 --> 00:19:04.100
into a poco object, it
has a common definition of

363
00:19:04.100 --> 00:19:07.100
both ends of the wire.
We're playing around with some

364
00:19:07.100 --> 00:19:09.950
ideas now for being able
to do that dynamically without

365
00:19:10.070 --> 00:19:12.920
needing to deploy an assembly
at runtime, because one issue

366
00:19:12.920 --> 00:19:16.280
that comes up is the
notion of version to messages,

367
00:19:16.280 --> 00:19:18.500
right? What if I need
to make an update to

368
00:19:18.500 --> 00:19:20.690
this message? That's a big
part of my, at my

369
00:19:20.690 --> 00:19:22.550
domain. How do I deal
with that? This was a

370
00:19:22.550 --> 00:19:24.980
huge problem for us 15
years ago, because we might

371
00:19:24.980 --> 00:19:27.380
want to change the message,
but there's certain parts of

372
00:19:27.380 --> 00:19:30.470
the system that are, let's
just say it is less

373
00:19:30.470 --> 00:19:33.290
likely to let us drop
in a new DLL. Yup.

374
00:19:34.010 --> 00:19:35.900
So now they're not likely
to let you drop in

375
00:19:35.900 --> 00:19:38.150
a DLL where you have,
you know, the, the payment

376
00:19:38.150 --> 00:19:40.730
gateway or whatever sitting. Right.
So we ended up just

377
00:19:40.730 --> 00:19:44.900
doing hash tables. Yeah. So
one of the things that

378
00:19:44.900 --> 00:19:47.570
we, so a couple of
patterns that I've seen our

379
00:19:47.570 --> 00:19:50.450
users use for dealing with
this one is this the

380
00:19:50.450 --> 00:19:54.170
tolerant reader pattern where you
basically are able to Wallace

381
00:19:54.170 --> 00:19:56.270
systems in a state where
some of it's updated and

382
00:19:56.270 --> 00:19:59.630
some of it's not the
older clients and still read

383
00:19:59.630 --> 00:20:02.690
the parts of the newer
messages without cause of throwing

384
00:20:02.690 --> 00:20:05.480
an exception or failing. So
that's one idea. That's a

385
00:20:05.480 --> 00:20:09.410
Martin Fowler pattern, tolerant reader,
and that's, I personally have

386
00:20:09.410 --> 00:20:12.410
used that and it's been
successful. The other thing I've

387
00:20:12.410 --> 00:20:15.020
seen people do is actually
version when they do have

388
00:20:15.020 --> 00:20:17.480
to do a major change,
you shouldn't be changing your

389
00:20:17.480 --> 00:20:20.570
message types all the time.
Right. Of course do. If

390
00:20:20.570 --> 00:20:24.230
you're lucky, it's additive, it's
additive, right. So when people

391
00:20:24.230 --> 00:20:26.150
need to make a major
change, I've also seen them

392
00:20:26.150 --> 00:20:28.970
use namespaces and their assemblies.
Right. Well, they'll go ahead

393
00:20:28.970 --> 00:20:31.220
and have a separate namespace
for V one V two

394
00:20:31.220 --> 00:20:34.340
V three. And I've personally
done that before, too. So

395
00:20:34.370 --> 00:20:36.800
those are not as elegant
as something that can, you

396
00:20:36.800 --> 00:20:40.880
know, hot load and assembly
definition, or maybe have your

397
00:20:40.880 --> 00:20:45.680
own form of well dynamics
sort of serialization Typing or

398
00:20:45.680 --> 00:20:47.950
some kind of like what
used to called assembly neutral

399
00:20:47.950 --> 00:20:51.520
interfaces, where if it lines
up, right, if you have

400
00:20:51.610 --> 00:20:54.770
an object, regardless of identity,
from a dotnet perspective, I

401
00:20:54.770 --> 00:20:56.410
forgot a person object, and
it's got a first name

402
00:20:56.410 --> 00:20:58.630
and a last name and
they both got strings, your

403
00:20:58.630 --> 00:21:01.180
person, and my person are
equivalent. So I can have

404
00:21:01.180 --> 00:21:03.190
my own implementation of a
person and you can have

405
00:21:03.190 --> 00:21:05.380
your own implementation person. And
they could even even have

406
00:21:05.380 --> 00:21:08.350
different implementations as long as
their public properties line up.

407
00:21:09.030 --> 00:21:11.550
Yeah, exactly. And that's essentially
the taller and reader in

408
00:21:11.550 --> 00:21:15.570
a nutshell. Oh yeah. But
I didn't come up with

409
00:21:15.570 --> 00:21:18.870
the idea and take credit.
You could have had a

410
00:21:18.870 --> 00:21:24.450
Martin Fowler blog post. Yeah.
Take that. Okay. So Then

411
00:21:24.450 --> 00:21:26.430
that enactor does, if I
want, if I, if I'm

412
00:21:26.430 --> 00:21:27.840
an actor that gets a
message and I want to

413
00:21:27.900 --> 00:21:30.030
write to a database, do
I just write to the

414
00:21:30.030 --> 00:21:32.130
database or do I tell
another actor like a child

415
00:21:32.130 --> 00:21:34.170
actor to do that for
me? So that's a great

416
00:21:34.170 --> 00:21:36.780
question. So one of the
benefits of using actors is

417
00:21:36.780 --> 00:21:40.500
reliability and there's a lot
of design patterns around it.

418
00:21:40.500 --> 00:21:43.470
And so Earlings philosophy when
they first really implemented it

419
00:21:43.830 --> 00:21:46.200
was that it is cheaper
just to try something and

420
00:21:46.200 --> 00:21:48.660
let the actor fail or
die than it is to

421
00:21:48.660 --> 00:21:51.360
do, try catch restart and
all this other sort of

422
00:21:51.360 --> 00:21:54.120
stuff that we would normally
do in everyday procedural programming.

423
00:21:54.630 --> 00:21:55.980
But one of the things
we need to do to

424
00:21:55.980 --> 00:21:58.740
make sure that's done reliably
is use some patterns that

425
00:21:58.740 --> 00:22:04.200
delegate dangerous work, like network
calls or parsing, or, you

426
00:22:04.200 --> 00:22:06.720
know, writing to the file
system, to actors that are

427
00:22:06.720 --> 00:22:09.870
purpose built for doing that.
So if you have a

428
00:22:09.870 --> 00:22:14.160
natural factors, would you say
Character, actor, actors, you know

429
00:22:14.160 --> 00:22:15.390
what I mean? I don't
know who we can get

430
00:22:15.390 --> 00:22:17.970
to do this reliably. I
think John Malcovich is available.

431
00:22:18.000 --> 00:22:20.070
Oh, he'll be perfect. Well,
we don't have to worry

432
00:22:20.070 --> 00:22:22.800
about that job. I just
invented that by the way,

433
00:22:22.830 --> 00:22:28.260
suck it Fowler. The character
Article called the character actor.

434
00:22:28.440 --> 00:22:32.580
That's purpose-built actors. There you
go. Purpose-built actors right there.

435
00:22:32.580 --> 00:22:34.680
You know, one of the
things. So one of the

436
00:22:34.680 --> 00:22:36.600
things that took me, like
I'm embarrassed, it took me

437
00:22:36.600 --> 00:22:38.670
this long to figure this
out. So in OCHA, you

438
00:22:38.670 --> 00:22:40.980
use props to create an
actor. Props is like a

439
00:22:40.980 --> 00:22:44.130
formula for basically how you
build an actor. And it

440
00:22:44.130 --> 00:22:46.860
took me like a year
to realize, Oh, because actors

441
00:22:46.860 --> 00:22:50.370
need props in order to
act. Yeah. It was like

442
00:22:50.370 --> 00:22:53.010
on, I was like, man,
I, This is, what's so

443
00:22:53.010 --> 00:22:56.100
fun about object oriented programming
and patterns and stuff like

444
00:22:56.100 --> 00:22:59.640
that is that the, when
the analogies are good, like,

445
00:22:59.700 --> 00:23:02.550
like the ones that you're
using, they resonate. And it

446
00:23:02.760 --> 00:23:04.950
really helps you understand the
system. I mean, in this

447
00:23:04.950 --> 00:23:09.120
case here, this all works
For me. Yup. Okay. So

448
00:23:09.120 --> 00:23:12.450
you said purpose built actors,
character actors, right. We'll go

449
00:23:12.450 --> 00:23:16.290
and do that specific kind
of work and they're reusable.

450
00:23:16.290 --> 00:23:19.620
I assume they're generic. Yeah,
absolutely. And they can be

451
00:23:19.620 --> 00:23:22.620
deployed anywhere and sort of
the actor hierarchy actors are

452
00:23:22.620 --> 00:23:25.590
organized and like a family
tree. So I'll get, it

453
00:23:25.590 --> 00:23:27.570
gives you the sort of
like, well, route actor, the

454
00:23:27.570 --> 00:23:30.660
very top of the, of
the stack. And then every

455
00:23:30.660 --> 00:23:33.030
time you go and create,
what's called a top level

456
00:23:33.030 --> 00:23:37.080
actor. These are the headlines.
There we go. Really good

457
00:23:37.080 --> 00:23:39.150
with the figurative language. Yeah.
I'm ready to go. I'm

458
00:23:39.150 --> 00:23:41.340
going to write a whole
papers on this. So the

459
00:23:41.340 --> 00:23:43.890
head you have your headliner,
then you might have some

460
00:23:43.890 --> 00:23:47.630
supporting actors, the headliner creates.
And then after that you've

461
00:23:47.630 --> 00:23:49.610
got your character actors and
then you might have some

462
00:23:49.610 --> 00:23:53.080
stunt doubles after that, right?
Yeah. Okay. That makes sense.

463
00:23:53.080 --> 00:23:55.150
So there really is a
family tree and they're actually

464
00:23:55.150 --> 00:23:58.330
talking to each other and
there's ownership issues, right? Like

465
00:23:58.330 --> 00:24:00.580
if, if what happens if
the parent dies just everyone

466
00:24:00.580 --> 00:24:03.160
else underneath them go away.
Oh yeah. So if the

467
00:24:03.160 --> 00:24:05.920
parent dies that whole rest
of the actor hierarchy gets

468
00:24:05.920 --> 00:24:08.680
wiped out. Okay. So one
of the things that's built

469
00:24:08.680 --> 00:24:11.890
into actors though, is the
concept of parental supervision. Parents

470
00:24:11.890 --> 00:24:15.520
supervise their children. So if
a child fails, let's go

471
00:24:15.520 --> 00:24:18.850
ahead and say, that customer
actor we had before it

472
00:24:18.850 --> 00:24:20.830
goes and creates a child
actor, we'll call it. It's

473
00:24:20.830 --> 00:24:23.800
a database actor sure. For
writing to the database. And

474
00:24:23.800 --> 00:24:26.230
that actor fails. Let's say,
you know, your connection to

475
00:24:26.230 --> 00:24:30.250
SQL server gets lost or
something. The parent actor will

476
00:24:30.250 --> 00:24:33.400
go ahead and get the
exception that actor threw back

477
00:24:33.430 --> 00:24:36.040
as a message. And it'll
make your decision about what

478
00:24:36.040 --> 00:24:38.230
to do. How should it
reconcile the fate of that

479
00:24:38.230 --> 00:24:41.980
actor? So it has three
choices it can make. One

480
00:24:41.980 --> 00:24:44.830
is it can tell the
actor to restart, which is

481
00:24:44.830 --> 00:24:47.110
the default third choice. Okay.
We're going to go ahead

482
00:24:47.110 --> 00:24:50.260
and reboot this actor back
to its clean state. So

483
00:24:50.260 --> 00:24:52.420
all the internal state and
that child will be wiped

484
00:24:52.420 --> 00:24:54.340
out and it'll go ahead
and use the props that

485
00:24:54.340 --> 00:24:57.010
we created or come, go
back to an initial clean

486
00:24:57.010 --> 00:25:00.550
state. Okay. Take two, take
two. Exactly. And we'll do

487
00:25:00.550 --> 00:25:02.380
up to T by default,
we'll do up to take

488
00:25:02.380 --> 00:25:05.320
10 within some period of
time and then we'll decide,

489
00:25:05.320 --> 00:25:08.680
okay, this actor is permanently
screwed. You'll never work in

490
00:25:08.680 --> 00:25:11.290
this town again, son. Exactly.
And we'll just kill it.

491
00:25:11.320 --> 00:25:13.870
Okay. Then the last thing
that the app that an

492
00:25:13.900 --> 00:25:16.000
actor can do as part
of a supervision strategy is

493
00:25:16.000 --> 00:25:18.340
say, I can't figure this
out. I'm going to escalate

494
00:25:18.340 --> 00:25:21.790
to my parents and see
what's going on. Yeah. Call

495
00:25:21.790 --> 00:25:24.550
their agent exactly. Or call
the producer or Interesting. So

496
00:25:24.550 --> 00:25:26.110
this makes me think about
it in the terms of

497
00:25:26.260 --> 00:25:29.260
exception handling. I'm used to
it as being scoping at

498
00:25:29.260 --> 00:25:32.590
the language level, but this
is exception handling scoped as

499
00:25:32.590 --> 00:25:35.620
a tree of objects. And
rather than the exception throwing

500
00:25:35.620 --> 00:25:38.680
up outside of a call
stack, it's throwing up and

501
00:25:38.680 --> 00:25:42.910
going up within this, this
tree of actors. Okay. You're

502
00:25:42.910 --> 00:25:45.700
monitoring all of that. Like
the larger orchestration framework is

503
00:25:45.700 --> 00:25:48.550
aware of what's going on.
So the actually it's kind

504
00:25:48.550 --> 00:25:52.060
of cool. The it's it's
actually pretty decentralized. So the,

505
00:25:52.060 --> 00:25:54.850
you know, the central OCHA,
Donna actors have no idea

506
00:25:54.880 --> 00:25:58.000
like the system actors that
are responsible for addressing and

507
00:25:58.000 --> 00:26:00.730
all the plumbing and that
stuff. They have no idea

508
00:26:00.730 --> 00:26:03.250
about failures happening way out
on the edge of the

509
00:26:03.250 --> 00:26:07.030
family tree, you know, great
cousin, Jimmy or whatever has

510
00:26:07.030 --> 00:26:10.810
something goes wrong with them.
You know, the top actor

511
00:26:10.810 --> 00:26:12.510
at the top of the
hierarchy has no idea. And

512
00:26:12.510 --> 00:26:15.850
it does because it doesn't
destabilize the entire system. Exactly.

513
00:26:15.850 --> 00:26:19.090
So failures are very, are
local essentially until they're not

514
00:26:19.150 --> 00:26:21.520
right. If you have some
cascading failure that goes all

515
00:26:21.520 --> 00:26:24.310
the way up, then that's
then at that point, the

516
00:26:24.310 --> 00:26:26.770
entire actor, family tree might
reboot. Right? You've got an

517
00:26:26.770 --> 00:26:28.780
extra, he's being a dork,
but it's in the background

518
00:26:28.780 --> 00:26:30.370
of the camera. You don't
worry about it, but the

519
00:26:30.370 --> 00:26:32.800
guy knocks Brad Pitt over,
then we have a problem.

520
00:26:32.920 --> 00:26:36.730
Yes, exactly. Can the system
recover if something really bad

521
00:26:36.730 --> 00:26:39.790
happens? Yes. It can. The
systems are designed. One of

522
00:26:39.790 --> 00:26:42.790
the benefits of actor's systems
is that they are self

523
00:26:42.790 --> 00:26:46.200
healing. So they're able to
recover from failures. And what

524
00:26:46.200 --> 00:26:49.500
might happen is in the
worst case scenario, let's say

525
00:26:49.830 --> 00:26:52.410
like just short of the
process crashing and having to

526
00:26:52.410 --> 00:26:55.170
be restarted. Let's say you
have an acception that kills

527
00:26:55.170 --> 00:26:57.570
off every, all of your
top level actors and they

528
00:26:57.570 --> 00:27:00.180
all need to be restarted.
So it'd be something really

529
00:27:00.180 --> 00:27:03.960
bad. Like some, usually it's
some network resource that, that

530
00:27:03.960 --> 00:27:07.770
application absolutely depends on failing.
That would cause that what

531
00:27:07.770 --> 00:27:10.860
could happen is this is
the, your application will reboot

532
00:27:10.860 --> 00:27:13.650
to its initial state and
start building itself back up

533
00:27:13.680 --> 00:27:16.740
again. And if you're using
capabilities like arc it up,

534
00:27:16.740 --> 00:27:18.840
persistence for some of that
data is backed up to

535
00:27:18.840 --> 00:27:21.000
a database. It can recover
its state on its way

536
00:27:21.000 --> 00:27:24.560
back down. Why would it
be preferable for the AHCA

537
00:27:24.560 --> 00:27:28.700
system to reboot quote unquote
reboot rather than just rebooting

538
00:27:28.700 --> 00:27:31.700
the machine or the Docker
container or the windows, you

539
00:27:31.700 --> 00:27:34.010
know, or the pro at
what point is a reboot,

540
00:27:34.010 --> 00:27:35.600
really a reboot. And when
should you just freshen the

541
00:27:35.600 --> 00:27:38.000
whole thing? Well, the reboot
of the actors is done

542
00:27:38.000 --> 00:27:42.260
solely through your software, right?
Requires no human supervision, making

543
00:27:42.260 --> 00:27:44.510
the choice to reboot a
machine. You can program that,

544
00:27:44.510 --> 00:27:47.660
of course, you know, using
some plugins or the Azure

545
00:27:47.660 --> 00:27:50.240
SDK or something else like
that to go and automatically

546
00:27:50.240 --> 00:27:53.330
do it. Or you can
use like process monitoring tools

547
00:27:53.330 --> 00:27:56.030
to go and do that.
Right. But typically the idea

548
00:27:56.030 --> 00:27:58.820
behind the actor model is
that every single little micro

549
00:27:58.820 --> 00:28:02.240
process, every individual actor can
be rebooted independently if needed.

550
00:28:02.660 --> 00:28:05.390
I hate to do that
though. Like I used to

551
00:28:05.390 --> 00:28:07.940
work on systems where they
were, they had memory leaks,

552
00:28:08.150 --> 00:28:09.860
and rather than dealing with
them, they would just say,

553
00:28:09.890 --> 00:28:12.680
Oh, we'll just recycle this,
you know, every 20 minutes.

554
00:28:12.860 --> 00:28:17.540
So they built in abuse
of rebooting as a part

555
00:28:17.540 --> 00:28:19.040
of the system because they
found it. It was such

556
00:28:19.040 --> 00:28:23.180
a great feature. Do I
want my actors restarting all

557
00:28:23.180 --> 00:28:25.760
the time? No, you don't
want your actors restarting all

558
00:28:25.760 --> 00:28:28.220
the time, because that means
your application by actors only

559
00:28:28.220 --> 00:28:30.980
restart when you throw an
exception. So that means something

560
00:28:30.980 --> 00:28:33.380
you're doing something bad. If
your actors are restarting a

561
00:28:33.380 --> 00:28:36.920
lot, what you do want
though is actors are cheap,

562
00:28:36.920 --> 00:28:40.070
disposable resources. You can go
ahead and create a big

563
00:28:40.100 --> 00:28:42.920
hierarchy of actors for some
job. And then you send

564
00:28:42.920 --> 00:28:45.920
the top actor of that
hierarchy, a poison pill. And

565
00:28:45.920 --> 00:28:48.350
it basically goes and kills
off that entire part of

566
00:28:48.350 --> 00:28:51.440
the tree. That's totally fine
doing that sort of stuff.

567
00:28:51.440 --> 00:28:55.460
All the time. Actors are
cheap. You can fit 2.6

568
00:28:55.460 --> 00:28:57.500
million of them in one
gig of Ram or something

569
00:28:57.500 --> 00:29:01.580
like that. So, you know,
going, going, going back to

570
00:29:01.580 --> 00:29:03.860
our little Hollywood analogy here,
most of them work as

571
00:29:03.860 --> 00:29:07.250
waiters during the daytime anyway.
Right? Exactly. I'm an actor.

572
00:29:07.280 --> 00:29:10.370
Oh, really? What restaurant do
you work at? So this

573
00:29:10.370 --> 00:29:13.190
is a port of OCA
for the JVM. Do you,

574
00:29:13.300 --> 00:29:15.320
do you no longer have
a relationship with them or

575
00:29:15.320 --> 00:29:17.120
do you all hang out
together? How does that work

576
00:29:17.120 --> 00:29:20.120
when you port something between
their language? So we actually

577
00:29:20.120 --> 00:29:22.340
have we at first were
they kind of left us

578
00:29:22.340 --> 00:29:25.790
to our own devices. We
were me and Roger, the

579
00:29:25.790 --> 00:29:28.310
two founders of the ahca.net
project, both kind of were

580
00:29:28.520 --> 00:29:32.480
doing this for our own
independent reasons, teamed up together.

581
00:29:32.810 --> 00:29:35.210
And after the project started
to make some steam from

582
00:29:35.270 --> 00:29:38.150
terms of actually implementing real
features and everything else, we

583
00:29:38.150 --> 00:29:40.010
reached out to type SAPE
and asked if we could

584
00:29:40.010 --> 00:29:43.810
call the framework, AKA net
and their CTO, Jonas, the

585
00:29:43.810 --> 00:29:46.420
original author of AHCA was
like, yeah, sure. Why not?

586
00:29:48.180 --> 00:29:51.960
Oh, that's adorable. Yeah, exactly
random people. Okay. Yeah. Good

587
00:29:51.960 --> 00:29:55.770
luck with that. So, but
then I guess about a

588
00:29:55.770 --> 00:29:57.960
couple of months ago, as
the project started to get

589
00:29:57.960 --> 00:30:01.110
really big and we started
getting a lot more traction

590
00:30:01.110 --> 00:30:03.630
and we had, you know,
hundreds of users and people

591
00:30:03.630 --> 00:30:06.450
tweeting about it. And then
my company Pepperberg bridge started

592
00:30:06.870 --> 00:30:10.650
then Roland, Roland, Coon, the
chief architect of Oka reached

593
00:30:10.650 --> 00:30:13.230
out and said, Hey, you
know, we should probably like

594
00:30:13.230 --> 00:30:15.690
work together to make sure
you guys are, you know,

595
00:30:15.720 --> 00:30:18.390
Lauren, all the same lessons
we learned the hard way

596
00:30:18.390 --> 00:30:21.330
and everything else. Very nice.
Yeah. So we have a

597
00:30:21.330 --> 00:30:24.540
partnership with them. And Roland
actually is there in our,

598
00:30:24.570 --> 00:30:27.090
we have a Gitter chat.
It's like IRC for GitHub,

599
00:30:27.120 --> 00:30:30.360
basically Roland's there. And he
answers questions from time to

600
00:30:30.360 --> 00:30:32.760
time. I've seen him active
over the past few days

601
00:30:33.300 --> 00:30:36.210
and me and the other
contributors we've even reported bugs

602
00:30:36.210 --> 00:30:40.110
and AHCA that we found
when porting things, ahca.net, we

603
00:30:40.110 --> 00:30:43.140
have pretty open communication with
their team. And the thing

604
00:30:43.140 --> 00:30:46.860
that we're really trying to
achieve with a port is

605
00:30:46.860 --> 00:30:49.200
one. We want to make
it idiomatic C sharp and

606
00:30:49.200 --> 00:30:51.270
F sharp, right? We don't
want people to deal with

607
00:30:51.270 --> 00:30:54.570
weird constructs that feel like
they're leftovers from the JVM.

608
00:30:55.110 --> 00:30:57.180
But at the same time,
we also want to preserve

609
00:30:57.180 --> 00:31:00.630
the knowledge that the AHCA
team accrued through years of

610
00:31:00.630 --> 00:31:05.850
super heavy production use AKA
powers, parts of Walmart, Amazon

611
00:31:05.850 --> 00:31:09.930
cloud blizzard, and every single
deployment of Apache spark uses

612
00:31:09.930 --> 00:31:12.960
AHCA under the hood. So
there is a lot of

613
00:31:12.960 --> 00:31:15.750
really heavy usage of their
framework. And so we want

614
00:31:15.750 --> 00:31:17.970
to a lot of, and
a lot of the problems

615
00:31:17.970 --> 00:31:20.520
that come up are really
subtle things that they only

616
00:31:20.520 --> 00:31:23.010
found out because some customer
of theirs ran into it.

617
00:31:23.220 --> 00:31:25.680
No. Now I think I
know the answer to this

618
00:31:25.680 --> 00:31:27.690
cause I did it for
years and I don't mean

619
00:31:27.690 --> 00:31:30.210
to sound like a shell,
but do you think.net can

620
00:31:30.210 --> 00:31:34.470
handle big distributed systems like
this? Absolutely. I've built one

621
00:31:34.920 --> 00:31:38.550
on top, on top of
ocha.net, Cassandra and asp.net. It

622
00:31:38.550 --> 00:31:42.540
totally can. What dot nets
lacked for a long time

623
00:31:42.540 --> 00:31:45.540
in the distributed system space?
I really feel like has

624
00:31:45.540 --> 00:31:49.110
been one a, a culture
and an attitude of we

625
00:31:49.110 --> 00:31:50.850
can do this. You know,
I think there's been a

626
00:31:50.850 --> 00:31:54.060
lot of, I think a
lot of.net developers have maybe

627
00:31:54.060 --> 00:31:58.110
had a, a feeling of
not being good enough to

628
00:31:58.110 --> 00:31:59.850
really take on these problems.
And I think that's BS.

629
00:32:00.180 --> 00:32:03.330
Yeah. There's an inferiority complex
Very already complex. There you

630
00:32:03.330 --> 00:32:05.130
go. So I think that's
BS and I think that's

631
00:32:05.130 --> 00:32:07.050
people are starting to change
their minds about that now

632
00:32:07.050 --> 00:32:10.110
to the second part of
it is, is I think

633
00:32:10.110 --> 00:32:12.810
we've really lacked a good
set of tools for doing

634
00:32:12.810 --> 00:32:15.720
big data for a long
time. I think that a

635
00:32:15.720 --> 00:32:18.780
lot of the innovation there
really came from Python and

636
00:32:18.780 --> 00:32:22.110
JVM sort of sort of
worlds, but in dotnet land,

637
00:32:22.110 --> 00:32:23.670
we're starting to see a
lot more of it. Some

638
00:32:23.670 --> 00:32:26.250
of the other stuff they
showed off at dotnet fringe,

639
00:32:26.250 --> 00:32:29.460
for instance, like Lenas talk
on embrace a is another

640
00:32:29.460 --> 00:32:32.010
really good example of a,
of a powerful, you know,

641
00:32:32.010 --> 00:32:37.500
distributed programming framework that's available
exclusively in.net. So I really

642
00:32:37.500 --> 00:32:40.790
think that net does have
a future In big data.

643
00:32:41.180 --> 00:32:42.380
I don't think that we're
going to, you're going to

644
00:32:42.380 --> 00:32:46.610
see something like hadoop.net anytime
soon. But I do think

645
00:32:46.610 --> 00:32:50.540
for a lot of the
problems that everyday.net developers face

646
00:32:50.960 --> 00:32:54.450
having frameworks like ocha.net and
brace or liens and others

647
00:32:54.470 --> 00:32:57.050
available's tools to do it
will help improve the state

648
00:32:57.050 --> 00:32:58.880
of our art to a
point where this sort of

649
00:32:59.600 --> 00:33:02.780
distributed systems programming is pretty
common in.net. And I think

650
00:33:02.780 --> 00:33:05.120
that will happen over the
next couple of years. Yeah,

651
00:33:05.240 --> 00:33:07.820
absolutely. And I think also
it's on us as people

652
00:33:07.820 --> 00:33:09.440
who've been in the community
for a number of years

653
00:33:10.070 --> 00:33:12.950
to let folks know about
this. I'm finding that the

654
00:33:12.950 --> 00:33:15.530
number one thing I see
in the dotnet community is

655
00:33:15.530 --> 00:33:17.810
that just people don't know
about other really awesome open

656
00:33:17.810 --> 00:33:21.500
source projects. So I appreciate
you bringing ARCA dinette to

657
00:33:21.500 --> 00:33:24.020
us and to me and
sharing with me today on

658
00:33:24.020 --> 00:33:26.960
the show. Well, thank you
very much, Scott. I really

659
00:33:26.960 --> 00:33:29.840
appreciate the opportunity to help
spread the word about alka.net.

660
00:33:30.020 --> 00:33:32.870
And if we can help
empower.net developers out there to

661
00:33:32.870 --> 00:33:35.450
take on challenges that didn't
feel like they could do

662
00:33:35.450 --> 00:33:37.460
before. And that's a huge
win for me in my

663
00:33:37.460 --> 00:33:43.520
book. Very cool. You can
check out AHCA dot net@getahcaakka.net.

664
00:33:44.090 --> 00:33:47.930
Great documentation. Great. Getting started.
You have something interesting running

665
00:33:47.930 --> 00:33:51.260
within 15 minutes. Thanks so
much Aaron standard for chatting

666
00:33:51.260 --> 00:33:54.320
with me today. This has
been another episode of Hanselminutes

667
00:33:54.320 --> 00:33:55.700
and we'll see you again
next week.


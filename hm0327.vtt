WEBVTT FILE

1
00:00:12.060 --> 00:00:17.760
From hanselminutes.com. It's Hanselman. It's
a weekly discussion with web

2
00:00:17.760 --> 00:00:22.290
developer and technologist Scott Hanselman.
This is Lawrence Ryan announcing show

3
00:00:22.290 --> 00:00:28.500
number three 29. Recorded live
Thursday, July 19th, 2012. This episode is

4
00:00:28.500 --> 00:00:31.500
brought to you by Tellerik
offering the best in developer

5
00:00:31.500 --> 00:00:41.010
tools and support online@telerikdotcomandbyfranklins.net training
developers to work smarter and

6
00:00:41.010 --> 00:00:44.460
now offering gesture pack a
powerful gesture, recording and recognition

7
00:00:44.460 --> 00:00:51.990
system for Microsoft connect for
windows developers details@gesturepak.com. In this

8
00:00:51.990 --> 00:00:55.440
episode, Scott talks with emo
landward about when R T

9
00:00:55.470 --> 00:01:02.150
and windows eight for.net programmers.
Hi, this is Scott Hanselman.

10
00:01:02.150 --> 00:01:04.250
This is another episode of
Hansel minutes. And today I'm

11
00:01:04.250 --> 00:01:07.640
talking with emo land worth
who works on windows runtime.

12
00:01:07.670 --> 00:01:10.490
Thanks for chatting with me
today. Good morning. Hey, how

13
00:01:10.490 --> 00:01:13.730
are you? I'm good. I'm
good. Good day. So let

14
00:01:13.730 --> 00:01:17.240
me understand this. You, you
work on windows runtime or

15
00:01:17.240 --> 00:01:20.360
they call it when R
T and this is the

16
00:01:20.360 --> 00:01:23.720
new programming model that is
kind of introduced in windows

17
00:01:23.720 --> 00:01:25.730
eight. And what I wanted
to talk to you about

18
00:01:25.730 --> 00:01:30.260
is how this fits in,
because I've heard explanations of

19
00:01:30.260 --> 00:01:33.740
windows runtime before. And I
don't like the explanations that

20
00:01:33.740 --> 00:01:36.800
I'm hearing. They're, they're too
confusing. They make it seem

21
00:01:36.800 --> 00:01:39.860
either like a bigger deal
than it is or a

22
00:01:39.860 --> 00:01:43.100
smaller deal than it is.
And there's all this fluid,

23
00:01:43.220 --> 00:01:45.650
there's all this fear, uncertainty
and doubt. People are saying

24
00:01:45.980 --> 00:01:50.450
it replaces.net and.net. People should
be afraid and other people

25
00:01:50.450 --> 00:01:53.660
are saying, you know, destroys
everything. Other people say that

26
00:01:53.660 --> 00:01:55.850
this is really amazing and
it's this great new thing.

27
00:01:55.850 --> 00:01:58.670
And I want to get
a balanced understanding. So I

28
00:01:58.670 --> 00:02:01.490
figured I'd go straight to
you to talk about it.

29
00:02:01.820 --> 00:02:04.220
Does that sound like a
plan to you? That sounds

30
00:02:04.220 --> 00:02:09.110
awesome. So technically I'm not
working on the, you know,

31
00:02:09.210 --> 00:02:11.870
the windows perspective I'm actually
working on the.net side of

32
00:02:11.870 --> 00:02:15.500
things, so even better. That's
great. So basically that should

33
00:02:16.180 --> 00:02:17.720
answer the question, whether it
doesn't, that is dead. It's

34
00:02:17.720 --> 00:02:21.770
not, we are very happily
working with winter tea and

35
00:02:22.280 --> 00:02:26.450
I think the overall picture
is pretty similar to basically

36
00:02:26.450 --> 00:02:29.180
everything that we did before.
So if you could just

37
00:02:29.180 --> 00:02:32.060
think of like a, you
know, an old school WinForms,

38
00:02:32.630 --> 00:02:40.310
you know, don't need 2.0
app. The thing that <inaudible>,

39
00:02:40.320 --> 00:02:43.460
if you, you know, if
you had to do something

40
00:02:43.460 --> 00:02:46.130
that wasn't part of the
framework, and if you think

41
00:02:46.130 --> 00:02:50.420
of winter tea being basically
the successor of winter 32,

42
00:02:50.840 --> 00:02:52.460
so you no longer have
to pee and Volk and

43
00:02:52.460 --> 00:02:57.770
said, you can use winter
and it's just nicer in

44
00:02:57.770 --> 00:02:59.860
essence. So if you call
winner T API is from

45
00:02:59.860 --> 00:03:03.790
code, it looks almost exactly
the same as regular.net code.

46
00:03:03.790 --> 00:03:06.190
So it's, it's, it's just
a better version of wind

47
00:03:06.190 --> 00:03:09.420
32 at a very, very
high level. Okay. So that's,

48
00:03:09.450 --> 00:03:11.880
that's, that's a good place
to start. So I started

49
00:03:12.480 --> 00:03:17.010
programming many years ago in
windows before wind 32, when

50
00:03:17.010 --> 00:03:20.790
hello world was about 90
lines and, you know, fast

51
00:03:20.790 --> 00:03:25.110
forward to today. And if
you really want to exploit

52
00:03:25.110 --> 00:03:26.730
the hardware for lack of
a better word, if you

53
00:03:26.730 --> 00:03:29.730
really want to get down
to it, when 32 and

54
00:03:29.730 --> 00:03:32.940
the windows API APIs are
where it's at, I mean,

55
00:03:32.940 --> 00:03:35.070
that's where the power is.
And every once in a

56
00:03:35.070 --> 00:03:37.710
while, you'll do something in.net.
If you're a dotnet programmer

57
00:03:37.710 --> 00:03:42.510
like me and you'll hit
a wall in.net, and then

58
00:03:42.510 --> 00:03:44.910
you have to go down
to the windows layer and

59
00:03:44.910 --> 00:03:47.880
really call something like, just
recently, I was working on

60
00:03:47.880 --> 00:03:51.690
this pan tilt, zoom camera,
and I wanted to do

61
00:03:51.690 --> 00:03:53.220
it all in time. That,
cause that's what I know,

62
00:03:54.090 --> 00:03:55.770
not really interested in doing
it in C or C

63
00:03:55.770 --> 00:03:58.650
plus plus, and I hit
a wall immediately because there

64
00:03:58.650 --> 00:04:03.030
are no dotnet APIs that
really represent cameras on windows.

65
00:04:03.210 --> 00:04:05.880
And then I was into
direct show and calm and

66
00:04:05.880 --> 00:04:09.570
I felt like I was
in hell. Yeah. And that's

67
00:04:09.570 --> 00:04:11.730
exactly the problem. Like if
you, if you think back

68
00:04:11.730 --> 00:04:13.830
in the very early days
of.net, you know, and don't

69
00:04:13.830 --> 00:04:16.590
necessarily, you know, 1.1 and
2.0, we had a whole

70
00:04:16.590 --> 00:04:20.430
bunch of people whose job
is basically just was repping

71
00:04:20.430 --> 00:04:23.880
wind 32 work home-based API
APIs in a nice.net outfit

72
00:04:23.880 --> 00:04:27.180
so that you can easily
consume those. So I think

73
00:04:27.270 --> 00:04:29.580
from a dotnet perspective, I
would not, not necessarily draw

74
00:04:29.580 --> 00:04:31.650
the line and say when
32 were a column is

75
00:04:31.680 --> 00:04:35.070
where the power is. It's
just a different technology to,

76
00:04:35.130 --> 00:04:38.760
you know, do API APIs.
And from a net perspective,

77
00:04:38.760 --> 00:04:42.200
you basically prefer.net. API is
not because, you know, there

78
00:04:42.200 --> 00:04:44.760
are dotnet APIs, but just
because they are more usable

79
00:04:45.180 --> 00:04:48.570
that typically have friendlier names
and you can just new

80
00:04:48.570 --> 00:04:51.210
up stuff, you don't have
to poke in their registry.

81
00:04:51.210 --> 00:04:53.520
You don't have to do
any magic stuff. Basically it

82
00:04:53.520 --> 00:04:58.140
just works. And basically the
problem that we had is

83
00:04:58.140 --> 00:04:59.910
going to be wrapped the
winter, ready to work home-based

84
00:04:59.910 --> 00:05:02.880
API, is it windows or
other Microsoft people provided is

85
00:05:02.880 --> 00:05:07.770
that we were basically abstracting
their API this way and

86
00:05:07.770 --> 00:05:09.740
rep them in hours. So
whenever they edit the feature

87
00:05:09.750 --> 00:05:11.550
in later releases, we had
to do the same broken

88
00:05:11.550 --> 00:05:14.790
our side. So a good
example is like investor. They

89
00:05:14.790 --> 00:05:18.180
introduced all these, you know,
nice UI features in the

90
00:05:18.180 --> 00:05:21.570
shell, but the glass Chrome
and whatever. And if you

91
00:05:21.570 --> 00:05:24.120
use WPF, for example, you
have a hard time using

92
00:05:24.120 --> 00:05:27.420
those because it's WPF, you
know, didn't have time, you

93
00:05:27.420 --> 00:05:30.870
know, implementing those or, you
know, providing API APIs and

94
00:05:31.200 --> 00:05:33.570
that side for those. So
basically the people had to

95
00:05:33.570 --> 00:05:36.720
do stuff on their own
to actually use the new

96
00:05:36.720 --> 00:05:39.810
features. And the whole goal
of winter tea is basically

97
00:05:39.810 --> 00:05:42.930
to stop that and to
basically say, what if the

98
00:05:43.020 --> 00:05:45.990
API is that are already
provided by Microsoft for the

99
00:05:45.990 --> 00:05:49.080
native developers, for the C
plus plus type developers, if

100
00:05:49.080 --> 00:05:51.540
they would already be in
a shape where we don't

101
00:05:51.540 --> 00:05:53.790
longer need to wrap them
for you for usability reasons,

102
00:05:53.790 --> 00:05:57.710
because they're already really, really
usable. And that is basically

103
00:05:57.710 --> 00:05:59.150
what we in our at
T provides when our T

104
00:05:59.150 --> 00:06:02.480
basically provides a new technology
to do APIs in windows

105
00:06:02.840 --> 00:06:06.110
at the lowest level, outside
the CLR, right? For CNC

106
00:06:06.110 --> 00:06:10.130
plus developers. But if you
consume them from.net, you can

107
00:06:10.130 --> 00:06:14.990
directly consume them. There's no
like, you know, develop on

108
00:06:14.990 --> 00:06:17.120
our side in your way
that, you know, reps these

109
00:06:17.120 --> 00:06:19.280
APIs and gives them to
you. You can just directly

110
00:06:19.280 --> 00:06:22.180
consume it. That's a really
interesting way to think about

111
00:06:22.180 --> 00:06:24.460
it because I think that
this is my opinion, but

112
00:06:24.460 --> 00:06:29.020
I think that the word
runtime has, has, and had

113
00:06:29.050 --> 00:06:33.970
a lot of baggage. So
when I heard windows runtime,

114
00:06:34.030 --> 00:06:38.560
I'm thinking that like.net is,
is gone away and it's

115
00:06:38.560 --> 00:06:42.520
being replaced by this entirely
new CLR thing. But when

116
00:06:42.520 --> 00:06:45.880
you explain it, the idea
that you're taking the windows

117
00:06:45.880 --> 00:06:47.650
API APIs, and like you
said, not necessarily the most

118
00:06:47.650 --> 00:06:49.630
powerful ones, but simply the
ones that are, that are

119
00:06:49.630 --> 00:06:52.210
the ones I want, whether
they're powerful or not, doesn't

120
00:06:52.210 --> 00:06:54.340
matter. The fact is I
want to move my camera

121
00:06:54.910 --> 00:06:57.250
and I had to drop
into a very low level

122
00:06:57.250 --> 00:07:03.310
world. That's not comfortable. And
the, the abstraction leaked through,

123
00:07:03.580 --> 00:07:05.590
I mean, it was just,
it was just leaking C

124
00:07:05.590 --> 00:07:07.780
plus plus and calm throughout
everything I was trying to

125
00:07:07.780 --> 00:07:11.920
do. And I was doing
all this work to rap,

126
00:07:12.280 --> 00:07:14.560
rap, rap, rap, and that's
such a dirty word to

127
00:07:14.560 --> 00:07:19.300
go and rap and hide
complexity. So you're saying that

128
00:07:19.630 --> 00:07:22.240
when our T has an
API that lets you get

129
00:07:22.240 --> 00:07:25.930
to native stuff and windows
do do low-level high level,

130
00:07:25.930 --> 00:07:28.300
all sorts of different stuff,
everything from beep to move

131
00:07:28.300 --> 00:07:32.260
cameras around. But when I
consume them from.net, they look

132
00:07:32.260 --> 00:07:36.430
like they're in.net. They look
like they're really high level

133
00:07:36.490 --> 00:07:43.180
API APIs. I mean, effectively,
There's probably two important things

134
00:07:43.180 --> 00:07:45.850
that make this look like.net.
API is the very first

135
00:07:45.850 --> 00:07:48.370
thing is if you think
of comm, you always think

136
00:07:48.370 --> 00:07:52.630
of things like, I dunno,
I camera underscore two acts

137
00:07:52.630 --> 00:07:56.830
or something ugly names. And
the other thing is you

138
00:07:56.830 --> 00:07:59.830
have to deal with things
that are not necessarily things

139
00:07:59.830 --> 00:08:01.660
you want to do with,
like, what is the format

140
00:08:01.660 --> 00:08:03.250
of the string? Is it
a B string? Is it

141
00:08:03.250 --> 00:08:06.730
a terminated string? Like they
have like 500 types for

142
00:08:06.730 --> 00:08:08.800
the same thing, more or
less. And I think these

143
00:08:08.800 --> 00:08:11.770
are the two major things
where complexity income kicks in.

144
00:08:11.770 --> 00:08:14.470
If you consume it from
the net today and in

145
00:08:14.470 --> 00:08:18.370
winter T you know, some
people might know him, his

146
00:08:18.370 --> 00:08:20.950
name is crystal Solina. He
wrote the design guidelines that

147
00:08:21.400 --> 00:08:24.040
we pushed basically through the
whole.net stack and make sure

148
00:08:24.040 --> 00:08:26.170
that when we implemented API,
as we do it, you

149
00:08:26.170 --> 00:08:28.660
know, in the, in the,
in the same way, like

150
00:08:28.660 --> 00:08:31.690
methods that ethical actions are
called always add and not

151
00:08:31.690 --> 00:08:35.350
sometimes pre pen, sometimes UPenn,
sometimes ed and we made

152
00:08:35.350 --> 00:08:37.870
sure that we are consistent.
And when the way I

153
00:08:37.880 --> 00:08:41.260
T guys came along and
designed their, their APIs, they

154
00:08:41.590 --> 00:08:44.710
explicitly asked for Christoph's expertise
and said, can you help

155
00:08:44.710 --> 00:08:46.900
us design our APIs in
such a way that they

156
00:08:46.900 --> 00:08:51.040
look familiar to you guys?
And so just by naming

157
00:08:51.040 --> 00:08:54.250
stuff in a little bit
easier way, I think lots

158
00:08:54.250 --> 00:08:58.020
of the, you know, calm
Albinus already disappears. And the

159
00:08:58.020 --> 00:09:00.450
other big thing is they
simplify their type system a

160
00:09:00.450 --> 00:09:02.850
lot by basically saying there's
only a single type for

161
00:09:02.850 --> 00:09:04.590
string, you know, and they're
going to have to convert

162
00:09:04.590 --> 00:09:07.170
one string to the other
address, you know, for the,

163
00:09:07.710 --> 00:09:09.870
for the, for the front
of it. And I think

164
00:09:09.870 --> 00:09:13.410
this is probably the two
biggest things that they did,

165
00:09:13.470 --> 00:09:15.510
like on the surface, like
when you drill deeper, of

166
00:09:15.510 --> 00:09:17.430
course, when our T and
this is where the runtime

167
00:09:17.430 --> 00:09:20.190
part kicks in runtime, if
you think of runtime and

168
00:09:20.190 --> 00:09:22.560
you think of the CLR,
that's the wrong thing. The

169
00:09:22.560 --> 00:09:25.500
CLR runtime is more like
a VM, a virtual machine

170
00:09:25.770 --> 00:09:29.420
because it provides things like,
you know, I L it

171
00:09:29.490 --> 00:09:33.360
provides things like a garbage
collector and linkages competitor, that

172
00:09:33.360 --> 00:09:36.060
sort of thing. Whereas the
classic, you know, very old

173
00:09:36.060 --> 00:09:38.160
C run time is just
a set of APIs. And

174
00:09:38.160 --> 00:09:40.920
it's called a runtime because,
you know, instead of utility

175
00:09:41.340 --> 00:09:44.100
methods or functions that you
can call that do stuff

176
00:09:44.130 --> 00:09:47.880
for you, like memory or
location location. And if you

177
00:09:47.880 --> 00:09:50.790
think of modern apps like
apps today, you know, talking

178
00:09:50.790 --> 00:09:53.520
to the camera is almost
as basic as, you know,

179
00:09:53.580 --> 00:09:56.370
allocating memory. So it makes
sense that the operating system

180
00:09:56.370 --> 00:09:59.490
provides those for you. And,
you know, they just went

181
00:09:59.490 --> 00:10:01.830
with the term runtime because
that's what, you know, even

182
00:10:01.830 --> 00:10:04.110
native developers use all the
time, but they don't mean

183
00:10:04.110 --> 00:10:08.010
like full blown seal, our
execution environment with all the

184
00:10:08.010 --> 00:10:10.620
things that we would call
managed. They're not part of

185
00:10:10.620 --> 00:10:13.370
an RT. That's, that's where
I think things get a

186
00:10:13.370 --> 00:10:15.860
little confusing because the word
runtime, like we said is

187
00:10:15.860 --> 00:10:19.340
so overloaded, but you're saying
that it's not like a

188
00:10:19.340 --> 00:10:23.480
complete runtime in that it's
not someone else's perspective on

189
00:10:23.480 --> 00:10:26.390
what the CLR should look
like. Correct. There is no

190
00:10:26.390 --> 00:10:29.810
GC, for example, like the,
the way the whole winter

191
00:10:29.810 --> 00:10:33.620
T system works is effectively
the same way converts today.

192
00:10:33.620 --> 00:10:37.370
You just add reference, you
release the draft counted. And

193
00:10:37.370 --> 00:10:39.620
so there's no need for
a garbage collector when you,

194
00:10:39.650 --> 00:10:41.840
when you stop using stuff,
you know, their vest count

195
00:10:41.840 --> 00:10:45.890
goes to zero and stuff
just disappears. And so it's

196
00:10:45.890 --> 00:10:48.350
basically just a set of
API that you call. And

197
00:10:48.350 --> 00:10:50.390
then on top of that,
there's a whole bunch of

198
00:10:50.390 --> 00:10:52.610
things that are supposed to
make your life easier. So

199
00:10:52.610 --> 00:10:54.650
for example, in C plus,
plus they did some language

200
00:10:54.650 --> 00:10:57.290
extensions so that you don't
have to do rest counting

201
00:10:57.290 --> 00:10:59.930
yourself that the language can
do it for you. So

202
00:10:59.930 --> 00:11:02.150
it almost looks like don't
have to actually deal okay.

203
00:11:02.160 --> 00:11:04.370
Memory, but, you know, in
two plus plus it's part

204
00:11:04.370 --> 00:11:06.410
of the language that makes
it easier. And then the

205
00:11:06.410 --> 00:11:10.700
C sharp side, we obviously
have MVP this well, like

206
00:11:10.700 --> 00:11:17.060
we, the CLR has a,
yeah, basically it has all

207
00:11:17.060 --> 00:11:20.390
the mechanisms to deal with
calm already. So we basically

208
00:11:20.390 --> 00:11:23.690
just leveraged that and updated
it to work very nicely

209
00:11:23.690 --> 00:11:26.150
with when our T's. So
from both sides, whether you

210
00:11:26.150 --> 00:11:27.680
look from the C plus
plus side, or from the

211
00:11:27.680 --> 00:11:31.250
CSR upside, it looks as
being part of the, of

212
00:11:31.250 --> 00:11:34.880
your everyday language activities. If
you think that way, and

213
00:11:34.880 --> 00:11:37.910
the same goes for JavaScript
as well. And this is

214
00:11:37.910 --> 00:11:40.520
what the, what the windows
guys call language projection. So

215
00:11:40.520 --> 00:11:42.830
they basically tried to work
with all the languages and

216
00:11:42.830 --> 00:11:45.650
technologies together to make sure
that when our T is

217
00:11:45.650 --> 00:11:49.850
not necessarily the lowest common
denominator, but a really great

218
00:11:49.850 --> 00:11:52.460
system, and it can be
adopted to brick wall that,

219
00:11:52.460 --> 00:11:54.880
you know, in all the
wallet speed, JavaScript C sharp

220
00:11:54.880 --> 00:11:57.270
or C plus plus. Okay.
So that was my next

221
00:11:57.270 --> 00:12:00.870
question. I want to understand
this word projections. So I'm

222
00:12:00.870 --> 00:12:03.450
a dotnet programmer. So I
care, you know, not only

223
00:12:03.450 --> 00:12:05.790
about dinette, but primarily about.net,
because that's where I feel

224
00:12:05.790 --> 00:12:08.580
like I can get the,
get the work done. So

225
00:12:08.850 --> 00:12:11.790
I can call when our
T APIs and they'll feel

226
00:12:11.850 --> 00:12:15.600
like.net APIs. It doesn't, I'm
not going to feel like

227
00:12:15.600 --> 00:12:17.370
I'm in a new world
when I go doing this,

228
00:12:17.370 --> 00:12:20.670
it should feel familiar and
comfortable. Is that correct? Yes,

229
00:12:20.850 --> 00:12:23.070
that's the goal. Okay. So
the part that's interesting to

230
00:12:23.070 --> 00:12:27.690
me is that then this
is really not about.net. It's

231
00:12:27.690 --> 00:12:30.060
about making the windows API
callable from anything. And that's

232
00:12:30.060 --> 00:12:33.690
what this projection term is.
Yes, that's, that's what projection

233
00:12:33.690 --> 00:12:38.610
basically means very fancy term,
but it's, it's, it's not

234
00:12:38.610 --> 00:12:43.320
very complicated. Is it projection
like metadata? Is it a

235
00:12:43.320 --> 00:12:45.780
piece of metadata that gives
a language enough information to

236
00:12:45.780 --> 00:12:48.270
call? I, could I write
a projection? I don't know

237
00:12:48.270 --> 00:12:49.740
if I'm using the words,
right. But if, what if

238
00:12:49.740 --> 00:12:52.500
I wanted to call when,
when a R T from

239
00:12:52.500 --> 00:12:54.540
Ruby, what would I w
what would I have to

240
00:12:54.540 --> 00:12:55.950
write? Would I be writing
a projection, or would I

241
00:12:55.950 --> 00:12:59.220
be calling into a projection?
No, you would ride your

242
00:12:59.220 --> 00:13:01.950
own a debtor. So basically,
if you think from the

243
00:13:01.950 --> 00:13:06.270
winner T side, they basically
have defined how their, what

244
00:13:06.270 --> 00:13:08.850
they call the ABI level,
which is the application binary

245
00:13:08.850 --> 00:13:11.640
interface. So they talk about
like, how are things encoded?

246
00:13:11.640 --> 00:13:13.770
Like, how does metadata be
represented? Like, how do I

247
00:13:13.770 --> 00:13:17.010
discover what my sets are
available? And in fact, the

248
00:13:17.010 --> 00:13:19.380
underlying metadata forma that when
our team is using is

249
00:13:19.380 --> 00:13:21.180
more or less the same
that the net is using.

250
00:13:21.180 --> 00:13:24.450
So they also using assemblies,
but they don't contain code.

251
00:13:24.450 --> 00:13:26.910
Right. They just use the
metadata part of the, of

252
00:13:26.910 --> 00:13:29.850
the, of the dotnet assemblies,
if you will, to encode

253
00:13:29.880 --> 00:13:32.850
what APIs are available to
you, right? And then there

254
00:13:32.850 --> 00:13:34.860
are certain windows API that
you have to call in

255
00:13:34.860 --> 00:13:37.800
order to really instantiate objects
and to, and to get

256
00:13:37.800 --> 00:13:40.080
them. But this is all
part of the, of the

257
00:13:40.080 --> 00:13:43.230
winter T spec. And if
you were a language implementer,

258
00:13:43.230 --> 00:13:45.120
let's say, Ruby, for example,
you can just use that.

259
00:13:45.120 --> 00:13:47.280
And then you will have
to do some work on

260
00:13:47.280 --> 00:13:48.480
your side. So if we're
going to, you have to

261
00:13:48.480 --> 00:13:52.020
make a decision how the
strings, that Ruby has a

262
00:13:52.020 --> 00:13:56.700
mapping to the strings that
demo, or sorry, that when

263
00:13:56.700 --> 00:13:59.430
at T has so basically
in the Danette side of

264
00:13:59.430 --> 00:14:03.600
things, we can just directly
basically posit them along, because

265
00:14:03.600 --> 00:14:05.910
it just happens to be
that the underlying format is

266
00:14:05.910 --> 00:14:09.180
the same on both sides.
So there's no string copying

267
00:14:09.180 --> 00:14:12.870
involved, but if you decide
to encode strings completely differently

268
00:14:13.200 --> 00:14:14.970
than probably you want to
have some smarts in your

269
00:14:14.970 --> 00:14:18.630
language, on your compiler to
convert those strings automatically for

270
00:14:18.630 --> 00:14:21.000
your users, because otherwise it
will be, you know, painful

271
00:14:21.000 --> 00:14:23.430
again. And that is what
we mean by projection. Language

272
00:14:23.430 --> 00:14:26.100
has to make a decision
to haul their constructs, like

273
00:14:26.100 --> 00:14:29.100
in strings and so on
fly well with the, with

274
00:14:29.130 --> 00:14:32.580
the other side, which is
the lower level when our

275
00:14:32.580 --> 00:14:37.110
team ABI level. Okay. So
I think this is where

276
00:14:38.370 --> 00:14:40.770
it's funny. There's several levels
of confusion here. So the

277
00:14:40.770 --> 00:14:43.740
first we talked about the
word runtime, I think that

278
00:14:43.740 --> 00:14:47.100
provided confusion. Cause it is
in fact a runtime, but

279
00:14:47.100 --> 00:14:51.770
that word freaks out.net. People
who feel like we own

280
00:14:51.920 --> 00:14:54.800
all runtimes. You know what
I mean? So that's kinda

281
00:14:54.800 --> 00:14:57.320
like the first step, but
then the next one is

282
00:14:57.320 --> 00:15:01.970
really interesting is that when,
when we, the.net people think

283
00:15:01.970 --> 00:15:03.770
about.net, we think of it
as kind of an all

284
00:15:03.770 --> 00:15:06.920
or nothing thing. And you
just said that the metadata

285
00:15:06.920 --> 00:15:11.240
format used by windows runtime
to, to talk about these,

286
00:15:11.570 --> 00:15:16.100
these API APIs is, is.net
itself, but not in the,

287
00:15:16.110 --> 00:15:18.560
you know, it's, that's not
the right word. The format

288
00:15:18.770 --> 00:15:21.230
that it's encoded in is
that the standard that we've

289
00:15:21.230 --> 00:15:25.280
released, the ECMO three 35
metadata format, the format that.net

290
00:15:25.280 --> 00:15:28.700
uses is the same. And
that kind of muddies the

291
00:15:28.700 --> 00:15:33.710
waters and makes, makes it
blurry between what's dot net.

292
00:15:33.710 --> 00:15:37.340
And what's not, but really
you guys just didn't need

293
00:15:37.340 --> 00:15:39.320
to invent a new format.
So you picked one that

294
00:15:39.320 --> 00:15:43.240
already existed. Correct. They could
have just chosen whatever format,

295
00:15:43.240 --> 00:15:45.340
write it big. If you
go very hard, you could,

296
00:15:45.340 --> 00:15:47.830
they could even have used
XML for that. But, you

297
00:15:47.830 --> 00:15:49.540
know, it's just not the
most efficient way to store

298
00:15:49.540 --> 00:15:53.500
the information, but yeah, it's
just like, you know, other

299
00:15:53.500 --> 00:15:55.510
guys already did the work,
so why reinvent the wheel?

300
00:15:56.230 --> 00:15:58.660
Okay. Are there other pieces
of dotnet that are used

301
00:15:58.660 --> 00:16:01.600
or is the metadata the
primary thing? I think my

302
00:16:01.600 --> 00:16:04.180
editor is totally the primary
thing. And then of course,

303
00:16:04.240 --> 00:16:06.640
like naming conventions or that
sort of thing is also

304
00:16:06.640 --> 00:16:09.610
reused if you think of
that way. But I think

305
00:16:09.610 --> 00:16:13.090
as the underlying thing, I
can't really think of, of

306
00:16:13.120 --> 00:16:15.460
many other things. Like, of
course, if you think of

307
00:16:15.460 --> 00:16:19.060
API design, like, you know,
you know, depart just the

308
00:16:19.060 --> 00:16:23.380
naming conventions, like for example,
when at T also has

309
00:16:23.380 --> 00:16:26.320
a low level like type
system, if you will. So

310
00:16:26.320 --> 00:16:28.630
they also have to provide
collections for example, because if

311
00:16:28.630 --> 00:16:31.900
they provide APIs that return
many objects, you want to

312
00:16:31.900 --> 00:16:34.000
have to, you know, a
unified set of APIs that

313
00:16:34.000 --> 00:16:37.450
represent those collection types. And
so they have, for example,

314
00:16:37.660 --> 00:16:40.390
Iterable, which is basically the
winter tea equivalent of what

315
00:16:40.600 --> 00:16:43.450
they thought that developers now
is. I knew mobile. And

316
00:16:43.450 --> 00:16:46.450
so they're not like low
level types, but they're common

317
00:16:46.450 --> 00:16:49.750
enough that the.net side decided
to have a projection. So

318
00:16:49.750 --> 00:16:52.240
if you call a winter
tap API, that takes time,

319
00:16:52.270 --> 00:16:54.970
it's doable on the.net side,
it seems like it takes

320
00:16:54.970 --> 00:16:56.860
nine new mobile, and you
can just pass on you.

321
00:16:56.860 --> 00:16:58.270
I knew more, you don't
have to write any code

322
00:16:58.270 --> 00:17:00.970
for that. It just happens
automatically. And this is also

323
00:17:00.970 --> 00:17:04.210
part of the projection layer
and originally designs. Like I

324
00:17:04.220 --> 00:17:07.090
think they were like many
different flavors of light trouble.

325
00:17:07.090 --> 00:17:09.550
Like if you think of
the C plus plus STL

326
00:17:09.550 --> 00:17:12.130
the Santa template library, they
have like 500 ways to

327
00:17:12.130 --> 00:17:15.040
do like iterations over collections.
So their model of the

328
00:17:15.040 --> 00:17:17.250
same thing on the C
plus on the, on the

329
00:17:17.340 --> 00:17:20.170
winter T side, but in
the design review meetings, we

330
00:17:20.170 --> 00:17:22.360
basically said, well, it's very
hard for us to do

331
00:17:22.360 --> 00:17:25.090
the projection. It's a very
common thing. Many language features

332
00:17:25.090 --> 00:17:27.750
on our site depend on
that and can be simplified

333
00:17:27.750 --> 00:17:30.910
these things. So I think
there's this overall that's Ted

334
00:17:30.910 --> 00:17:33.610
on one thing, and it's
not make too many things.

335
00:17:34.060 --> 00:17:37.210
I think this general attitude
of.net being more productive because

336
00:17:37.210 --> 00:17:40.930
we have fewer concepts to
deal. Birth thing is also

337
00:17:41.160 --> 00:17:44.590
part of the, of the
winter T design philosophy. And

338
00:17:44.590 --> 00:17:47.110
so it's more like a
reuse and it's the thinking

339
00:17:47.350 --> 00:17:50.610
that went over. I don't,
there is many other pieces

340
00:17:51.210 --> 00:17:55.760
in technology wise that reuse.
So my initial reaction to

341
00:17:55.760 --> 00:17:59.350
this idea of I Iterable
and I innumerable, it might

342
00:17:59.350 --> 00:18:01.940
kind of like my gut
reaction is that, you know,

343
00:18:01.940 --> 00:18:04.580
someone is looking in a
thesaurus trying to find another

344
00:18:04.580 --> 00:18:06.890
word. That means the same
thing. And I editable and

345
00:18:06.890 --> 00:18:10.790
I innumerable are effectively identical.
And then, and then I'm

346
00:18:10.790 --> 00:18:14.780
thinking why, aren't why isn't
the window's runtime using more.net,

347
00:18:17.240 --> 00:18:21.980
no idioms, but then I'm
kind of remembering that that.net

348
00:18:21.980 --> 00:18:24.860
is not the, is not
the only customer of when

349
00:18:24.860 --> 00:18:29.480
RT presumably, correct. It has
to look like windows for

350
00:18:29.900 --> 00:18:32.630
C plus plus and JavaScript
as well. I presume that

351
00:18:32.630 --> 00:18:35.180
I could for each over
an iPad or a bowl,

352
00:18:35.600 --> 00:18:37.550
and as I've gotten a
program that would feel comfortable,

353
00:18:38.660 --> 00:18:40.880
can I do the same
thing in JavaScript using, you

354
00:18:40.880 --> 00:18:45.050
know, dot each in different
JavaScript type idioms? I'm not

355
00:18:45.050 --> 00:18:47.270
too familiar with JavaScript, but
yeah, I would think so.

356
00:18:48.800 --> 00:18:50.150
Okay. So let me, I've
got, I'm trying to get

357
00:18:50.150 --> 00:18:52.550
to, is the idea that,
that that's, that's the point

358
00:18:52.580 --> 00:18:56.240
is that I think I'm
understanding the point now that

359
00:18:56.510 --> 00:18:59.080
you've got these windows, API
APIs, they are native API

360
00:18:59.080 --> 00:19:03.290
APIs. They're built into windows
and you have to find

361
00:19:03.290 --> 00:19:07.250
a balance between being really
awesome on windows, but not

362
00:19:07.280 --> 00:19:10.880
making the programmer who's using
their own language of choice,

363
00:19:10.880 --> 00:19:16.130
feel uncomfortable. So a JavaScript
person writing windows code shouldn't

364
00:19:16.130 --> 00:19:18.500
feel like, Oh, this is
gross. This feels windows Z.

365
00:19:18.770 --> 00:19:21.080
They should feel like, Oh,
this is JavaScript. I know

366
00:19:21.080 --> 00:19:23.900
JavaScript. And the dotnet programmer,
shouldn't have to be learning

367
00:19:23.900 --> 00:19:25.700
new stuff. They're gonna go,
Oh, for each grade I

368
00:19:25.700 --> 00:19:28.220
can for each just like,
you know, just like I'm

369
00:19:28.220 --> 00:19:31.490
familiar with. So it should,
it's a balance between feeling

370
00:19:31.910 --> 00:19:35.390
idiomatic and comfortable in the
language and still not watering

371
00:19:35.390 --> 00:19:38.210
down the power of windows.
Is that correct? That is

372
00:19:38.390 --> 00:19:42.620
pretty much the best thing
I've heard so far. Yeah.

373
00:19:43.610 --> 00:19:46.010
I think, I think that
like, if you, if you

374
00:19:46.010 --> 00:19:50.480
look up there the very
first design sessions, or like,

375
00:19:50.490 --> 00:19:53.210
like, you know, architectural sessions
for winter tea that were

376
00:19:53.210 --> 00:19:55.970
on build, for example, they
had these slides and then

377
00:19:55.970 --> 00:19:59.000
that confused many, many people
because C sharp was on

378
00:19:59.000 --> 00:20:00.650
the one hand side on
desktop apps. It was listed

379
00:20:00.650 --> 00:20:03.290
on top of the.net side.
And then on the Metro

380
00:20:03.290 --> 00:20:05.510
side of assistant top of
winter tee. So people thought,

381
00:20:05.810 --> 00:20:08.000
or if you're using C-sharp
in winter tea, you actually

382
00:20:08.000 --> 00:20:10.910
compiled down to native and
then magically you, you run

383
00:20:10.910 --> 00:20:13.190
on this windows runtime, but
that's not the case. It's

384
00:20:13.190 --> 00:20:16.610
just API APIs. And yes,
the goal of the NRT

385
00:20:16.610 --> 00:20:20.210
system is to enable windows,
to provide APIs. And they're

386
00:20:20.240 --> 00:20:23.210
immediately consumable from the programming
language. And the immediate part

387
00:20:23.210 --> 00:20:26.060
is the important thing, because
in the, in the past,

388
00:20:26.900 --> 00:20:31.370
every language already always has
provided reference around operating system

389
00:20:31.370 --> 00:20:34.280
stuff. But then the problem
is when the operating system

390
00:20:34.280 --> 00:20:38.570
guys evolve over time, languages
couldn't expose it as quickly.

391
00:20:38.930 --> 00:20:41.030
And this is why sometimes
people said, Oh yeah, if

392
00:20:41.030 --> 00:20:42.620
you really want to use
the API, you really have

393
00:20:42.620 --> 00:20:44.210
to go to plus sauce
because it's the only way

394
00:20:44.210 --> 00:20:46.550
you can actually consume it.
And then if you have

395
00:20:46.550 --> 00:20:48.430
to add customers, yes, you
have to write a wrapper

396
00:20:48.430 --> 00:20:50.290
on up here in between.
And all of these things

397
00:20:50.290 --> 00:20:53.170
go away because all of
these projections are now done.

398
00:20:53.500 --> 00:20:56.170
So whenever someone in renewals
decides to use a new

399
00:20:56.170 --> 00:21:00.970
API, it's immediately in all
three languages. You know, I

400
00:21:00.970 --> 00:21:03.610
should say stacks because like,
it's the JavaScript stack, it's

401
00:21:03.610 --> 00:21:05.920
the CLRs stack. And then
it's the native stick. They're

402
00:21:05.930 --> 00:21:08.230
all available in all of
the, and then all of

403
00:21:08.230 --> 00:21:11.890
these texts immediately. So the
operating system can evolve over

404
00:21:11.890 --> 00:21:15.430
time and language Zang and
develop press can immediately start

405
00:21:15.430 --> 00:21:18.240
consuming those as they come
along. And I think that

406
00:21:18.240 --> 00:21:22.170
that's really good news for
the developers as well. Okay.

407
00:21:22.410 --> 00:21:25.320
So does that mean that
if I write a win

408
00:21:25.530 --> 00:21:30.480
R T API, it'll be
awesome on all three programming

409
00:21:30.480 --> 00:21:34.770
interfaces. That is the goal.
Surely you have to do

410
00:21:34.770 --> 00:21:37.140
some work to make it
awesome and all of these

411
00:21:37.140 --> 00:21:39.750
things. So for example, if
you decide to expose something

412
00:21:39.750 --> 00:21:43.110
and when our T you
have to think about having,

413
00:21:43.110 --> 00:21:46.980
like, if you implemented in,
in, in, let's say a.net,

414
00:21:47.310 --> 00:21:50.160
you have to think that
your consumers are mobily, not

415
00:21:50.160 --> 00:21:52.830
necessarily in.net, right. They might
be in.net, but they also

416
00:21:52.830 --> 00:21:55.560
might be in Java script
or in C plus plus.

417
00:21:56.190 --> 00:21:58.170
So you have to make
sure that when you author

418
00:21:58.530 --> 00:22:00.840
a winner, a key component,
you have to adhere to

419
00:22:00.840 --> 00:22:04.980
the winter tea rules. And
they're slightly different from the.net

420
00:22:04.980 --> 00:22:07.740
rules for authors and DLLs,
but they are not completely

421
00:22:07.740 --> 00:22:10.170
different. So you still have
the concept of classes and

422
00:22:10.170 --> 00:22:12.180
methods and so on and
so forth, but there are

423
00:22:12.180 --> 00:22:16.320
certain types for example, that
you shouldn't or expose. So

424
00:22:16.330 --> 00:22:18.260
for example, if you write
an async method that you

425
00:22:18.270 --> 00:22:20.670
would return a task, right?
But on the winter T

426
00:22:20.670 --> 00:22:23.190
side, they don't have tests.
They have a different way

427
00:22:23.190 --> 00:22:25.530
to represent asynchronous operation. So
you have to call a

428
00:22:25.530 --> 00:22:28.530
method that converts them. So
why did we do a

429
00:22:28.530 --> 00:22:31.380
language projection for that while,
because it was too complicated

430
00:22:31.830 --> 00:22:33.870
and they couldn't cover all
the cases. So we decided

431
00:22:33.870 --> 00:22:36.360
to make it more obvious
for developers so that they

432
00:22:36.360 --> 00:22:40.020
can make the corner case
decisions themselves. And to say,

433
00:22:40.020 --> 00:22:42.210
well, here at API has
that convert between the winner

434
00:22:42.210 --> 00:22:46.380
T representation of async API
and task object. And then

435
00:22:46.380 --> 00:22:48.690
you have to offer those
and basically convert between them.

436
00:22:49.590 --> 00:22:51.450
But there are not many,
like, it always sounds very

437
00:22:51.450 --> 00:22:53.490
complicated when people start talking
about these things. But I

438
00:22:53.490 --> 00:22:55.680
mean, all in all, if
you just start writing a

439
00:22:56.250 --> 00:22:59.460
key component, you would just
go to VSU, create a

440
00:22:59.460 --> 00:23:02.070
new class library, you change
the output type to when

441
00:23:02.070 --> 00:23:05.190
MD, which stands for windows
metadata instead of the regular

442
00:23:05.190 --> 00:23:07.530
DLL. And then you start
coding and then you get

443
00:23:07.530 --> 00:23:09.750
compiler errors as for stuff
that you're not supposed to

444
00:23:09.750 --> 00:23:11.820
do. And they will ultimately
guide you in the right

445
00:23:11.820 --> 00:23:16.350
direction. There shouldn't be much
to worry about. So the

446
00:23:16.350 --> 00:23:18.360
task async was the next
thing. Cause we've got a

447
00:23:18.360 --> 00:23:21.150
lot of really cool stuff
around async in.net. And we've

448
00:23:21.150 --> 00:23:26.160
also got a lot of
really cool stuff around parallelism,

449
00:23:26.340 --> 00:23:30.870
you know, with a task
parallel library. So these are

450
00:23:30.870 --> 00:23:36.290
becoming idioms that that.net programmers
are going to expect. Are

451
00:23:36.300 --> 00:23:40.260
there a lot of idioms
that don't have support and

452
00:23:40.260 --> 00:23:42.090
when our T that one
should watch for, and are

453
00:23:42.090 --> 00:23:47.060
those idioms that you'll kind
of continue to expand? I

454
00:23:47.060 --> 00:23:49.310
think, except for the, like,
I mean, the nice thing

455
00:23:49.730 --> 00:23:52.880
with the winter tea async
offers that they return. I

456
00:23:52.880 --> 00:23:56.960
think it's called <inaudible>. I
remember correctly and then derived

457
00:23:57.290 --> 00:23:59.620
objects for them as well.
Is that from a Donette

458
00:23:59.620 --> 00:24:02.000
perspective, if you start consuming
those, you won't see a

459
00:24:02.000 --> 00:24:05.120
task off, let's say into
whatever the API returns, you

460
00:24:05.120 --> 00:24:07.790
would see whatever the winter
tea type is, but you

461
00:24:07.790 --> 00:24:11.000
can immediately use the C
sharp language extensions await in

462
00:24:11.000 --> 00:24:15.230
async to basically directly await
these operations. And this just

463
00:24:15.260 --> 00:24:18.050
works because as you shop
compiler itself, service, you know,

464
00:24:18.080 --> 00:24:21.050
didn't really bake the motion
of tasking for a way.

465
00:24:21.050 --> 00:24:23.150
They basically said, if you
provide the right message on

466
00:24:23.150 --> 00:24:25.250
the other guy, then you
kind of wait this effectively.

467
00:24:25.520 --> 00:24:27.560
So it's the same as
with link. It was the

468
00:24:27.560 --> 00:24:29.840
same way, right? If you
implement a certain pattern API,

469
00:24:29.930 --> 00:24:32.480
you could use link queries
on top of those. So

470
00:24:32.480 --> 00:24:35.690
from a C sharp perspective,
you just consume APIs. There

471
00:24:35.690 --> 00:24:38.120
shouldn't be much to worry
about. It will just work

472
00:24:38.120 --> 00:24:41.270
as you would expect it
naturally, if you also want

473
00:24:41.270 --> 00:24:44.420
our T components themselves, then
yes, you have to be

474
00:24:44.420 --> 00:24:46.190
aware of that. You know,
when our T side you

475
00:24:46.190 --> 00:24:48.740
don't have to deal with,
or you can use tasks,

476
00:24:49.160 --> 00:24:53.600
but if you basically split
the cam into two people,

477
00:24:53.900 --> 00:24:56.000
one just consuming when our
tap has the other one

478
00:24:56.030 --> 00:24:59.690
producing them, you find that
the producing campus much smaller

479
00:24:59.690 --> 00:25:02.900
anyway. So typically you have
component vendors that will be,

480
00:25:02.900 --> 00:25:05.990
you know, let's say both
new components, let's say, and

481
00:25:05.990 --> 00:25:10.100
you daytime picker up for
demo, for example. And yes,

482
00:25:10.100 --> 00:25:13.610
they probably offered them in,
in William D. But this

483
00:25:13.610 --> 00:25:17.180
is don't. I don't think
this is the mainstream scenario.

484
00:25:17.180 --> 00:25:20.500
I think the mainstream sentence
scenario is consuming APS. Okay.

485
00:25:20.740 --> 00:25:23.170
So when you're consuming API
APIs, I know that in

486
00:25:23.920 --> 00:25:28.060
the idea of profiles is
becoming more, more common in.net.

487
00:25:28.900 --> 00:25:31.450
You have your references that
appear over on the right

488
00:25:31.450 --> 00:25:34.570
hand side and the solution
Explorer. And those, those are

489
00:25:34.720 --> 00:25:37.720
then collected more and more
and more we're seeing in.net

490
00:25:37.930 --> 00:25:41.710
collections of, of API. So
like there's the portable library

491
00:25:41.710 --> 00:25:44.590
stuff where you can say,
here are the API APIs,

492
00:25:44.590 --> 00:25:46.180
and here are the references
that I want to share.

493
00:25:46.540 --> 00:25:49.300
And even, even we on
the, on the website have

494
00:25:49.310 --> 00:25:51.880
been thinking about maybe collapsing
those references into some kind

495
00:25:51.880 --> 00:25:53.860
of a web profile. So
that would make it easier.

496
00:25:53.860 --> 00:25:59.710
And there wouldn't be so
many DLLs like visible when

497
00:25:59.710 --> 00:26:03.490
you are targeting a Metro
applicant, Metro style application and.net.

498
00:26:04.180 --> 00:26:06.790
There's this Metro style profile,
just like as if I

499
00:26:06.790 --> 00:26:09.250
were writing a portable library
to run an Xbox, I

500
00:26:09.250 --> 00:26:11.590
can, I can use specific
things and other ones are

501
00:26:11.590 --> 00:26:15.340
unavailable to me, help me
understand when, when can a.net

502
00:26:15.340 --> 00:26:19.150
person call windows runtime API?
Can I write a console

503
00:26:19.150 --> 00:26:24.160
app and call when our
T methods? No, you can't.

504
00:26:24.250 --> 00:26:27.520
And the reason being that
we didn't expose those APIs,

505
00:26:27.520 --> 00:26:31.270
if your target Metro, and
this is also not necessarily

506
00:26:31.270 --> 00:26:34.030
news for developers, but if
you are remembering the civil

507
00:26:34.030 --> 00:26:36.970
light days, when we produce
civil light, we didn't expose

508
00:26:36.970 --> 00:26:39.160
all of those net. We
only exposed some subset of

509
00:26:39.160 --> 00:26:42.460
the doughnut API APIs because
civil led was a separate

510
00:26:43.110 --> 00:26:47.850
version of.net altogether. And Metro
is similar in the sense

511
00:26:47.850 --> 00:26:49.710
that the number of APIs
that we give to you

512
00:26:49.710 --> 00:26:53.520
is severely restricted. And the
reason being that, you know,

513
00:26:53.560 --> 00:26:55.800
you want to make sure
that you basically see the

514
00:26:55.800 --> 00:26:58.170
right API, is that applicable
to Metro style apps and

515
00:26:58.170 --> 00:27:01.620
not all of the history
of.net, which is 10 years

516
00:27:01.620 --> 00:27:04.290
worth of, you know, APIs
and not all that make

517
00:27:04.290 --> 00:27:07.440
sense. Some of them have
actually been obsoleted or deprecated.

518
00:27:07.440 --> 00:27:09.210
Some of them are actually
quite dangerous if you use

519
00:27:09.210 --> 00:27:12.570
them, you know, not necessarily
correctly. And it's very easy

520
00:27:12.570 --> 00:27:15.510
to use them incorrectly. And
so we decided to subset

521
00:27:15.770 --> 00:27:19.830
the set of API significantly
for Metro and all in

522
00:27:19.830 --> 00:27:22.500
all, we are down to
maybe 35% or whatever of

523
00:27:22.500 --> 00:27:24.090
the, of the full frame
we give to you a

524
00:27:24.100 --> 00:27:26.160
Metro. And we've seen this
as the right set of

525
00:27:26.160 --> 00:27:28.650
APIs that we don't think
we, we, we, we hid

526
00:27:28.650 --> 00:27:31.350
anything from you because we
didn't like you to use

527
00:27:31.350 --> 00:27:34.350
it. It's just that we,
we, we think having wind

528
00:27:34.350 --> 00:27:37.230
forms and WPF, for example,
it doesn't make sense because

529
00:27:37.230 --> 00:27:38.760
if you at a Metro
app, for example, you have

530
00:27:38.760 --> 00:27:41.790
to use the RTS anyways.
So it doesn't make sense

531
00:27:41.790 --> 00:27:45.300
to expose them to you.
And so the challenge now

532
00:27:45.300 --> 00:27:48.540
for that development is obviously
that typically you don't just

533
00:27:48.540 --> 00:27:51.090
write apps, right? You also
write libraries that you can

534
00:27:51.090 --> 00:27:54.540
reuse across different apps. And
so this is a part

535
00:27:54.540 --> 00:27:56.700
of a class that really
kicks in. So if you

536
00:27:56.700 --> 00:27:59.640
basically target different platforms, portable
costs, I will make sure

537
00:27:59.640 --> 00:28:01.410
that you get the right
set of APIs that is

538
00:28:01.410 --> 00:28:06.270
effectively in the intersection of
the, of the platforms. However,

539
00:28:06.270 --> 00:28:09.030
moving forward, we think this
is not necessarily something we

540
00:28:09.030 --> 00:28:12.600
want to do much anymore,
because if you think of

541
00:28:12.600 --> 00:28:16.650
civil and internet, for example,
the subset was almost arbitrary,

542
00:28:16.650 --> 00:28:18.600
right? If you look at
string, for example, string might

543
00:28:18.600 --> 00:28:22.830
have 50 members on.net and
only 25 on civilized because,

544
00:28:22.830 --> 00:28:25.620
you know, just the way
it was designed now in

545
00:28:25.620 --> 00:28:27.840
the new world, what we
have done in, in, in

546
00:28:27.870 --> 00:28:32.070
this release, we basically said
we break down or assemblies

547
00:28:32.100 --> 00:28:35.280
in more fine grain, smaller
components. So for example, ms

548
00:28:35.280 --> 00:28:37.560
call-up, as it is, today
is a big pile of

549
00:28:37.890 --> 00:28:41.110
stuff that is almost unrelated.
Like there's remoting in it,

550
00:28:41.130 --> 00:28:44.910
there's reflection in it, there's
strings in them, there's collection

551
00:28:44.910 --> 00:28:47.820
types in them. So if
you create a new platform,

552
00:28:47.820 --> 00:28:50.130
it's very likely that you
will subsidize call it one

553
00:28:50.130 --> 00:28:52.230
way or the other. And
so in the new world,

554
00:28:52.230 --> 00:28:56.040
we basically created smaller assemblies.
So for example, or if

555
00:28:56.040 --> 00:28:57.090
you have a bit of
members call it, there's no

556
00:28:57.090 --> 00:28:59.850
court system runtime, but this
is really, really, really small.

557
00:28:59.850 --> 00:29:02.760
It only contains basically the
primitive types and a few

558
00:29:02.760 --> 00:29:05.280
interfaces. And that's it even
collections is the longer part

559
00:29:05.280 --> 00:29:08.850
of that. Collections is a
separate assembly. And so the

560
00:29:08.850 --> 00:29:11.850
idea is, if you decide
what assemblies you actually want

561
00:29:11.850 --> 00:29:16.800
to depend on, then you
binary that you're competing against

562
00:29:16.800 --> 00:29:21.060
those things is binary compatible
with all future platforms. You

563
00:29:21.060 --> 00:29:23.220
know, that support the dependencies
that you have, but you

564
00:29:23.220 --> 00:29:25.500
can be sure if you're
depends on system runtime, version

565
00:29:25.500 --> 00:29:29.340
one, every platform that supports
system runtime, version one, your

566
00:29:29.340 --> 00:29:32.310
applicate, your binary is compatible
with that support of a

567
00:29:32.310 --> 00:29:35.390
class diver. Instead of being
a separate class library, it

568
00:29:35.390 --> 00:29:37.710
would be just the default.
You just create class libraries,

569
00:29:37.980 --> 00:29:41.440
you'll pick your dependencies. And
depending on the dependencies, you

570
00:29:41.440 --> 00:29:43.420
were a portable to a
platform, or you're not portable

571
00:29:43.420 --> 00:29:45.760
to their platform, but it's
really up to you. It's

572
00:29:45.760 --> 00:29:48.430
no longer DePaul them that,
Oh, shoot. If I created

573
00:29:48.430 --> 00:29:51.490
the.net class library, I cannot
just copy that one to

574
00:29:51.580 --> 00:29:55.470
<inaudible> because it's a different
platform. When, when I hear

575
00:29:55.470 --> 00:29:58.560
that you're that people are
limiting API APIs, it makes

576
00:29:58.560 --> 00:30:02.580
me feel limited. Like, like
you're saying you found the

577
00:30:02.580 --> 00:30:07.290
right subset, but kind of
experience usually means that that's

578
00:30:07.290 --> 00:30:09.720
great, except for that one
function that I really have

579
00:30:09.720 --> 00:30:13.350
to call that you, you
know, removed, how do you,

580
00:30:14.040 --> 00:30:17.970
how do you get around
that? So right now there's

581
00:30:17.970 --> 00:30:20.730
no way around it, but
we made sure that we

582
00:30:20.730 --> 00:30:23.700
didn't just arbitrarily, you know,
throw a dice. So basically

583
00:30:23.700 --> 00:30:25.440
what we did when we
decided what API is we

584
00:30:25.440 --> 00:30:28.470
exposed, we, we do, we
did two things. First of

585
00:30:28.470 --> 00:30:31.440
all, for, for, for certain
areas, let's say collections, for

586
00:30:31.440 --> 00:30:35.310
example, we decided to stick
with existing tech problems. So

587
00:30:35.310 --> 00:30:37.680
for example, the idea was
if you already shipped the

588
00:30:37.680 --> 00:30:40.890
platform with that set of
APIs, chances are that this

589
00:30:40.890 --> 00:30:43.830
is the right subset for
our, for, you know, this

590
00:30:43.830 --> 00:30:47.070
set of people because, you
know, we didn't just decide

591
00:30:47.070 --> 00:30:49.950
to remove certain methods. For
example, the other thing that

592
00:30:49.950 --> 00:30:53.220
we did is we analyzed
the phone app store for

593
00:30:53.220 --> 00:30:56.940
API usages. So we basically
created a list of APIs

594
00:30:56.940 --> 00:30:58.680
and then said, you know,
how many times are those

595
00:30:58.680 --> 00:31:00.570
called per apps? So we
know which APIs are called

596
00:31:00.570 --> 00:31:03.990
frequently and which APIs are
not called frequently. And we

597
00:31:03.990 --> 00:31:06.030
made sure that if we,
if we remove APIs that

598
00:31:06.030 --> 00:31:08.160
are used frequently, we have
to have really good reasons

599
00:31:08.160 --> 00:31:10.320
to remove those API. So
for example, it's a dangerous

600
00:31:10.320 --> 00:31:13.440
API sort of applicable to
Metro because it's wind farms,

601
00:31:13.440 --> 00:31:17.310
for example. And so we
hope that by construction, we,

602
00:31:17.310 --> 00:31:20.100
we, we avoided the trap
of just, you know, we

603
00:31:20.100 --> 00:31:24.510
moving, you know, someone's favorite
APIs, of course, it's a

604
00:31:24.510 --> 00:31:27.060
V one. If you think
of it, it's a new

605
00:31:27.060 --> 00:31:31.860
product. So chances are their
API is missing, but there's

606
00:31:31.860 --> 00:31:33.720
no way for you around
it. Because if you submit

607
00:31:33.720 --> 00:31:35.370
your app to the app
store, the app store itself,

608
00:31:35.400 --> 00:31:37.950
actually validates that you only
use the APS you're supposed

609
00:31:37.950 --> 00:31:41.430
to use it. And the
reason being is that, you

610
00:31:41.430 --> 00:31:43.590
know, if you think of
security problems or whatever else,

611
00:31:44.850 --> 00:31:46.560
the windows app store guys
really want to make sure

612
00:31:46.560 --> 00:31:49.170
that if, if I, as
a consumer download an app,

613
00:31:49.200 --> 00:31:51.810
I have confidence that the
app doesn't, you know, own

614
00:31:51.810 --> 00:31:55.110
my computer or started doing
crazy stuff. So they really

615
00:31:55.110 --> 00:31:57.210
want to make sure that
the apps have high quality.

616
00:31:57.210 --> 00:31:58.590
And one of the ways
to ensure it is to

617
00:31:58.590 --> 00:32:01.080
make sure that they, that,
you know, the right API

618
00:32:01.080 --> 00:32:03.090
is available and not like
the interest API is, are

619
00:32:03.090 --> 00:32:07.230
exposed. Okay. All right. So
it's not arbitrary. I mean,

620
00:32:07.230 --> 00:32:09.690
there's analysis going on here
and you know what we're

621
00:32:09.690 --> 00:32:12.360
calling and cause I just,
I would hate to start

622
00:32:12.360 --> 00:32:16.090
getting really excited about Metro
and then discover that, that,

623
00:32:16.090 --> 00:32:17.850
that, that one method that
I need is not going

624
00:32:17.850 --> 00:32:21.360
to be available. No, and
I think one other thing

625
00:32:21.440 --> 00:32:24.180
too, to be aware of
is that as we go

626
00:32:24.180 --> 00:32:27.240
along now, in the future,
we create new platforms, new

627
00:32:27.240 --> 00:32:30.870
platforms that we create will
be based on the assemblies

628
00:32:31.230 --> 00:32:34.590
that we give you and
Metro. So the Metro, if

629
00:32:34.670 --> 00:32:37.440
you don't have to deal
with assemblies, because if you

630
00:32:37.740 --> 00:32:41.000
create a Metro app, the
assembly list that you see

631
00:32:41.360 --> 00:32:43.790
is collapsed to basically I
think just two things. One

632
00:32:43.790 --> 00:32:47.030
of them says windows runtime,
and the other one says,

633
00:32:48.230 --> 00:32:50.210
but that for Metro style
apps or something along those

634
00:32:50.210 --> 00:32:54.260
lines, right? Yeah. We just
give you a basically, you

635
00:32:54.260 --> 00:32:56.360
know, all of the dotnet
assemblies that are exposed to

636
00:32:56.360 --> 00:32:58.670
Metro, but if you actually
look at the binary that

637
00:32:58.670 --> 00:33:01.670
you're producing, you have dependencies
on stuff like system collections,

638
00:33:01.760 --> 00:33:04.070
system, runtime, that sort of
thing. And if you actually

639
00:33:04.070 --> 00:33:05.780
go to the, to the
reference assemblies for the way

640
00:33:05.780 --> 00:33:08.390
we show you all the
assemblies, this is basically the

641
00:33:08.390 --> 00:33:10.450
set of SMEs that we
would give to you in

642
00:33:10.460 --> 00:33:13.820
future versions of go, whatever
other runtime we invent. Right?

643
00:33:14.480 --> 00:33:16.130
And so we are really
confident that this is the

644
00:33:16.130 --> 00:33:18.740
right set of APIs and
we probably add more contracts

645
00:33:18.740 --> 00:33:20.330
along the way. So for
example, the, right now there

646
00:33:20.330 --> 00:33:23.930
is no contract for, sorry,
no assembly for console, because

647
00:33:23.930 --> 00:33:26.330
guess what a Metro comes
with doesn't make sense. But

648
00:33:26.330 --> 00:33:27.980
if we would create like
a new version of the

649
00:33:27.980 --> 00:33:30.620
one time that would specifically
target console apps, for example,

650
00:33:31.070 --> 00:33:33.680
yeah. Chances are, there is
a system dot console and

651
00:33:34.430 --> 00:33:36.530
this is a new assembly
probably because it doesn't make

652
00:33:36.530 --> 00:33:39.850
sense to keep it in
the other assemblies. Okay. Cool.

653
00:33:39.880 --> 00:33:41.530
All right. Well, I feel
like I get it now.

654
00:33:41.590 --> 00:33:45.200
I was a little bit
concerned as a.net guy, that

655
00:33:45.790 --> 00:33:47.920
there was some evil going
on here or there was

656
00:33:47.920 --> 00:33:52.300
some tension, but it seems,
it seems better. I did

657
00:33:52.300 --> 00:33:55.060
see, I see, I feel,
I feel less concerned. I

658
00:33:55.060 --> 00:33:57.910
did not want to learn
an entirely different runtime. That

659
00:33:57.910 --> 00:33:59.710
was like a parallel universe.
You know what I mean?

660
00:34:00.160 --> 00:34:03.370
Yup. And we hope we
didn't create that either. All

661
00:34:03.370 --> 00:34:05.500
right. Very cool. Thanks Emma,
for talking to me today,

662
00:34:07.300 --> 00:34:10.450
this has been another episode
of Hansel minutes. We'll see

663
00:34:10.450 --> 00:34:11.380
you again next week.


WEBVTT FILE

1
00:00:04.890 --> 00:00:17.540
<inaudible> Hansel minutes. It's Hansel
minutes, a weekly discussion with

2
00:00:17.540 --> 00:00:22.220
web developer and technologist Scott
Hanselman. This is Lawrence Ryan announcing

3
00:00:22.220 --> 00:00:28.400
show number three 27. Recorded
live Thursday, July 5th, 2012. This episode

4
00:00:28.400 --> 00:00:31.100
is brought to you by
Tellerik offering the best in

5
00:00:31.100 --> 00:00:40.430
developer tools and support online@andtelerikdotcomandbyfranklin.net
training developers to work smarter.

6
00:00:40.880 --> 00:00:43.850
And now I'll bring gesture,
pack a powerful gesture, recording

7
00:00:43.850 --> 00:00:47.870
and recognition system for Microsoft
connect for windows developers details

8
00:00:47.870 --> 00:00:52.760
at <inaudible> dot com. In
this episode, Scott talks with

9
00:00:52.760 --> 00:01:00.410
Damien Edwards and Levi Broderick
about asynchronous programming. Hi, this

10
00:01:00.410 --> 00:01:02.600
is Scott Hanselman. This is
another episode of Hansel minutes

11
00:01:03.080 --> 00:01:05.930
today. I've got Damien Edwards
on the phone, the quintessential

12
00:01:05.930 --> 00:01:09.380
guest, and also we are
joined by Levi Broderick, who

13
00:01:09.380 --> 00:01:12.890
is probably the smartest guy
on the call right now.

14
00:01:12.890 --> 00:01:16.910
Sorry, Damien, we're going to
talk about async. Thanks for

15
00:01:16.940 --> 00:01:21.650
talking to me today, guys.
Thanks for having us. I

16
00:01:21.860 --> 00:01:25.730
think that most people just
don't get how to do

17
00:01:25.730 --> 00:01:28.850
asynchronous programming and.net. And I'm
going to throw my own

18
00:01:28.850 --> 00:01:30.410
name in there as one
of the people that just

19
00:01:30.410 --> 00:01:34.130
doesn't get it. I think
that people think that they

20
00:01:34.130 --> 00:01:37.160
have some expensive thing that
they want to do. And

21
00:01:37.160 --> 00:01:39.680
their initial reaction is that,
Oh, I'll fire off a

22
00:01:39.680 --> 00:01:42.740
background thread. You know, if
they're using asp.net, they might

23
00:01:42.740 --> 00:01:45.890
use Q user work item
or something and they'll fire

24
00:01:45.890 --> 00:01:48.710
off a background thread. They'll
think it kind of works.

25
00:01:48.710 --> 00:01:50.660
They don't really test it
because doing that kind of

26
00:01:50.660 --> 00:01:54.410
testing is hard and maybe
it'll work. Maybe it won't

27
00:01:54.410 --> 00:01:58.250
work. If they're really in
trouble, they might start poking

28
00:01:58.250 --> 00:02:01.640
around inside of a machine
dot config and messing around

29
00:02:01.640 --> 00:02:04.880
with a number of threads
per CPU that asp.net gets.

30
00:02:06.170 --> 00:02:09.020
But ultimately they're not even
doing async. Are they Damien

31
00:02:14.150 --> 00:02:17.720
A very small set of
scenarios that makes sense to

32
00:02:17.990 --> 00:02:25.880
leverage. And unless you really
understand what it means, one

33
00:02:25.880 --> 00:02:27.170
of the things we really
want to do over the

34
00:02:27.170 --> 00:02:32.810
next year, coming out with
this big push in the

35
00:02:32.810 --> 00:02:39.350
language and the framework is
really help people understand in

36
00:02:39.350 --> 00:02:47.150
web application scenarios, how can
they leverage the features? So

37
00:02:47.210 --> 00:02:50.300
I think to myself that
there's basically four things that

38
00:02:50.300 --> 00:02:52.670
I might want to use
async for, but you're saying

39
00:02:52.670 --> 00:02:55.340
that maybe most people are
using it too much. So

40
00:02:55.340 --> 00:02:57.020
I'm trying to understand that
we're trying to promote this,

41
00:02:57.020 --> 00:03:00.760
or are we trying to
dissuade people from In my

42
00:03:00.760 --> 00:03:06.490
mind, there's really only three
concrete scenarios where async makes

43
00:03:06.490 --> 00:03:10.840
sense in asp.net in a
web application. And only one

44
00:03:10.840 --> 00:03:12.520
of the only one of
those is actually popular. The

45
00:03:12.520 --> 00:03:15.220
other two are very, very
rare. So the first one

46
00:03:15.280 --> 00:03:17.950
is the one that most
people associate with it, which

47
00:03:17.950 --> 00:03:21.430
is IO. So this is,
and this includes file IO

48
00:03:21.430 --> 00:03:25.240
network IO database IO, which
is generally just network IO

49
00:03:26.950 --> 00:03:28.630
and then web service calls
is the other one, which

50
00:03:28.630 --> 00:03:32.200
obviously is network IO as
well. So any time that

51
00:03:32.200 --> 00:03:35.200
your service side I used
to be our net code

52
00:03:35.230 --> 00:03:39.070
is making a database call
or a web service call

53
00:03:39.070 --> 00:03:41.380
or a network call or
talking to the file system

54
00:03:41.770 --> 00:03:46.690
that can be done asynchronously
such that while that operation

55
00:03:46.690 --> 00:03:51.130
is in progress, asp.net, doesn't
have to be consuming a

56
00:03:51.160 --> 00:03:56.770
thread, which is a CPU
resource on, on that box

57
00:03:56.770 --> 00:03:58.720
while that operation is taking
place. And then once the

58
00:03:58.720 --> 00:04:01.840
operation is finished, asp.net will
do the work to bring

59
00:04:01.840 --> 00:04:04.390
that request, sort of rehydrate
it and then continue it

60
00:04:04.390 --> 00:04:06.190
on. Now that you have
the result from that call.

61
00:04:06.460 --> 00:04:08.290
So that's, that's the, that's
the first one and that's

62
00:04:08.290 --> 00:04:09.970
the most popular one. And
we can drill into these

63
00:04:09.970 --> 00:04:12.130
a little bit more as
we go on. The second

64
00:04:12.130 --> 00:04:15.670
one is when you, the
scenario where you actually have

65
00:04:15.670 --> 00:04:18.970
for a given request, you
need to retrieve lots of

66
00:04:18.970 --> 00:04:23.230
different pieces of information. Generally
from off box systems. I

67
00:04:23.230 --> 00:04:25.720
had a scenario once where
I was building a dashboard

68
00:04:25.750 --> 00:04:28.480
type system, the users, the
user count was going to

69
00:04:28.480 --> 00:04:31.780
be very, very low, you
know, maybe only five to

70
00:04:31.780 --> 00:04:35.800
10 users, but this dashboard
would have to call out

71
00:04:35.800 --> 00:04:38.410
to lots of different API
to collect information. Some of

72
00:04:38.410 --> 00:04:41.410
those APIs were local performance
counters. Some of them were

73
00:04:41.410 --> 00:04:44.350
logs. Some of them were
databases. And I wanted to

74
00:04:44.350 --> 00:04:48.190
show this sort of aggregate
of, of this information on

75
00:04:48.190 --> 00:04:50.950
the page now, rather than
having the request for that

76
00:04:50.950 --> 00:04:53.080
page take, as long as
it would take to call

77
00:04:53.080 --> 00:04:55.630
each of those things, serially,
they may have been 15

78
00:04:55.630 --> 00:04:58.540
or 20 of them. I
literally did them all in

79
00:04:58.540 --> 00:05:01.480
parallel so that I could
get that page response down

80
00:05:01.480 --> 00:05:04.930
to a couple of seconds
rather than 20 seconds. And

81
00:05:04.930 --> 00:05:07.330
I did so knowing that
I was going to actually

82
00:05:07.330 --> 00:05:11.920
be consuming more resources that
is more threads for that

83
00:05:11.920 --> 00:05:14.140
request while I was doing
that, because a lot of

84
00:05:14.140 --> 00:05:16.840
those things that I was
calling into didn't have asynchronous

85
00:05:16.840 --> 00:05:19.840
API APIs like calling into
performance counters and things like

86
00:05:19.840 --> 00:05:22.570
that, generally don't aren't asynchronous.
So I actually had to

87
00:05:22.570 --> 00:05:25.450
use more threads to get
a better response time because

88
00:05:25.450 --> 00:05:28.210
the type of page that
I was building required information

89
00:05:28.210 --> 00:05:30.460
from lots of different places.
And I didn't mind doing

90
00:05:30.460 --> 00:05:32.560
that because it had a
very low user count. I

91
00:05:32.560 --> 00:05:35.080
had lots of CPU despair,
and I only had to

92
00:05:35.080 --> 00:05:37.210
support a very small number
of users at any one

93
00:05:37.210 --> 00:05:41.320
time to do it. So
the third scenario is long

94
00:05:41.320 --> 00:05:44.170
running event driven requests. So
this is the idea where

95
00:05:44.170 --> 00:05:46.510
you have a request that
comes in and then the

96
00:05:46.510 --> 00:05:49.690
request goes to sleep for
some time waiting for some

97
00:05:49.720 --> 00:05:53.080
other event to take place.
And when that event takes

98
00:05:53.080 --> 00:05:55.810
place, you want the request
to continue and then send

99
00:05:55.810 --> 00:05:59.450
a response to the client.
This is really popular when

100
00:05:59.450 --> 00:06:01.700
you're trying to do things
like HTTP streaming, which is

101
00:06:01.700 --> 00:06:04.250
what signaler does under the
covers, where you have a

102
00:06:04.250 --> 00:06:06.680
request come in, you want
the request to stay open

103
00:06:06.680 --> 00:06:09.710
for a long time and
only wake up to pump

104
00:06:09.710 --> 00:06:12.590
data down to the client
when some events has taken

105
00:06:12.590 --> 00:06:14.930
place sort of elsewhere. So
you want that request to

106
00:06:14.930 --> 00:06:17.870
be async for, for all
the times when it isn't

107
00:06:17.870 --> 00:06:20.690
doing anything. So they're the
three concrete scenarios that are,

108
00:06:20.690 --> 00:06:22.520
you generally identify it. And
as I said, the first

109
00:06:22.520 --> 00:06:25.420
one is really the only
really popular one. Okay. So

110
00:06:25.420 --> 00:06:28.030
I, I, I chop them
up differently. That's actually really

111
00:06:28.030 --> 00:06:29.380
a nice way to think
about that. I w I

112
00:06:29.380 --> 00:06:33.400
was chopping them up file
access database access, calling out

113
00:06:33.400 --> 00:06:35.560
to the network and then
CPU bound thing. So almost

114
00:06:35.560 --> 00:06:40.020
a different, a different aspect,
a different slice, but a

115
00:06:40.060 --> 00:06:42.910
lot more sense. It does
bring up the question though,

116
00:06:42.910 --> 00:06:46.780
that you, you mentioned asynchronous
stuff, you mentioned running things

117
00:06:46.780 --> 00:06:49.300
in the background, which is
different. And I think people

118
00:06:49.300 --> 00:06:52.990
sometimes use those words interchangeably
and then running things in

119
00:06:52.990 --> 00:06:55.420
parallel. So there might be
an instance where I might

120
00:06:55.420 --> 00:06:58.540
want to, in response to
a page view on my

121
00:06:58.540 --> 00:07:04.480
site, fire off a background
thread for a reason, split

122
00:07:04.480 --> 00:07:08.440
it into multiple parallel execution
paths. And then some of

123
00:07:08.440 --> 00:07:12.880
those might do things on
asynchronous IO. Is that correct?

124
00:07:13.810 --> 00:07:19.690
Correct. It's kind of a,
is really a relative term.

125
00:07:19.780 --> 00:07:22.630
I mean, something can, can
or cannot be async relative

126
00:07:22.630 --> 00:07:27.040
to something else. Whereas the
idea of parallelism and multithreaded

127
00:07:27.040 --> 00:07:29.980
programming is more concrete. It's
like, well, multithreaded means I'm

128
00:07:29.980 --> 00:07:33.040
controlling more than one thread
or a background thread means

129
00:07:33.040 --> 00:07:35.590
that I actually kicked off
a thread in the background

130
00:07:35.590 --> 00:07:37.540
from the thing that I
kicked it off from such

131
00:07:37.540 --> 00:07:39.160
for it to do some
work. And I may care

132
00:07:39.160 --> 00:07:40.990
about when it finishes and
I might not. So it

133
00:07:40.990 --> 00:07:42.550
might be a fire and
forget, or it might be

134
00:07:42.550 --> 00:07:47.050
a parallel type of operation.
And so, yeah, understanding those

135
00:07:47.050 --> 00:07:49.960
terms can interchange them can
sometimes lead to a little

136
00:07:49.960 --> 00:07:53.140
bit of confusion. But when
we talk about async in

137
00:07:53.140 --> 00:07:57.580
asp.net, what we generally talk
about is the specific support

138
00:07:57.580 --> 00:08:01.780
in asp.net to have a
request handled by the asp.net

139
00:08:01.780 --> 00:08:05.230
runtime in an asynchronous manner
that is using one of

140
00:08:05.230 --> 00:08:10.540
the asynchronous programming models. that.net
actually provides you such that

141
00:08:10.540 --> 00:08:13.630
when asp.net gets notification, that
the request is now in

142
00:08:13.630 --> 00:08:16.180
async mode, that there's now
nothing more for it to

143
00:08:16.180 --> 00:08:19.030
do until something else finishes
that it can free up

144
00:08:19.030 --> 00:08:21.850
resources from the request until
the async operation has finished.

145
00:08:23.290 --> 00:08:25.720
Levi, could you, could you
help me understand that when

146
00:08:25.720 --> 00:08:29.830
a request comes into asp.net,
when I load a page

147
00:08:30.370 --> 00:08:33.430
that that is handled by
what, what kind of thread

148
00:08:33.430 --> 00:08:36.160
is that that's called a
real quick request thread or

149
00:08:36.160 --> 00:08:38.380
a user request, or what
does that in asp.net? That

150
00:08:38.380 --> 00:08:41.470
is, that is rendering my
page and then returning backed

151
00:08:41.470 --> 00:08:46.630
into a pool. So in
the.net framework, we have basically

152
00:08:46.630 --> 00:08:53.020
two big categories. The first
are just regular users threads

153
00:08:53.470 --> 00:08:56.880
that you can do by
calling the, The system dot

154
00:08:56.880 --> 00:09:00.480
threading dot thread constructor, and
then saying dot start on

155
00:09:00.480 --> 00:09:04.350
that. And you as a
user, as a developer, are

156
00:09:04.350 --> 00:09:06.810
able to just say, do
this bit of work. And

157
00:09:06.810 --> 00:09:08.370
then this thread is not
going to be used for

158
00:09:08.370 --> 00:09:10.800
anything else anymore. The thread
goes away once the work

159
00:09:10.800 --> 00:09:14.430
has finished, the dominant framework
also has a thread pool.

160
00:09:14.910 --> 00:09:17.970
And the nice thing about
thread pools is that they

161
00:09:17.970 --> 00:09:22.170
can reuse threads over and
over and over again. And

162
00:09:22.320 --> 00:09:25.800
threads in windows are, I
don't want to say they're

163
00:09:25.920 --> 00:09:29.340
expensive because they're not really
expensive, but they're also not

164
00:09:29.340 --> 00:09:32.610
cheap because every time a
thread is created or torn

165
00:09:32.610 --> 00:09:36.030
down windows basically has to
do a slight of hand

166
00:09:36.030 --> 00:09:39.630
in order to, in order
to arrange resources for you

167
00:09:39.960 --> 00:09:42.840
in order to make sure
that the appropriate data is,

168
00:09:43.320 --> 00:09:47.550
is available to the core.
That's running that thread now

169
00:09:47.670 --> 00:09:52.110
in asp.net. Whenever we do
request processing, we're actually using

170
00:09:52.140 --> 00:09:57.270
the CLR ThreadPool. So if
a developer uses ThreadPool doc,

171
00:09:57.270 --> 00:10:01.110
you use or work item,
that's using the same resources

172
00:10:01.140 --> 00:10:04.740
that asp.net would have used
to do regular page processing.

173
00:10:06.050 --> 00:10:09.980
Oh, okay. Interesting. So if
someone like, like, let's just

174
00:10:09.980 --> 00:10:13.580
say someone who is not
Levi or Damien, I'm not

175
00:10:13.580 --> 00:10:19.010
naming names wants to make,
decides to naively, make something

176
00:10:19.010 --> 00:10:23.840
work faster in asp.net, and
they start firing off Q

177
00:10:23.840 --> 00:10:27.320
user work item. They're really
taking threads away. They're starving

178
00:10:27.860 --> 00:10:31.880
asp.net for, you know, resources
it could be using to

179
00:10:31.880 --> 00:10:35.870
be doing page work. Yeah,
that's correct. Now to be

180
00:10:35.870 --> 00:10:40.400
fair, the doughnut framework is
pretty good. At least in

181
00:10:40.400 --> 00:10:43.070
dotnet four or five, it's
better, but it's pretty good

182
00:10:43.070 --> 00:10:45.530
about detecting when there aren't
enough threads in the thread

183
00:10:45.530 --> 00:10:48.110
pool, and it will start
injecting new threads to handle

184
00:10:48.110 --> 00:10:51.110
the incoming workload. But in
general, though, that point is

185
00:10:51.110 --> 00:10:52.880
correct. If you do it,
the Redbook use or work

186
00:10:52.880 --> 00:10:56.960
item, you're taking the same
resources@asp.net was trying to use

187
00:10:56.960 --> 00:11:01.130
to do request processing. I
I've worked at a lot

188
00:11:01.130 --> 00:11:02.990
of different companies and a
lot of different things. And

189
00:11:02.990 --> 00:11:06.830
one of the unfortunate things
at, at companies, whether it

190
00:11:06.830 --> 00:11:09.790
be banking or whether they
be insurance companies, is that

191
00:11:09.800 --> 00:11:13.760
everybody thinks that they are
a unique snowflake. And they

192
00:11:13.760 --> 00:11:16.820
all think that what they're
doing is magical and amazing

193
00:11:16.820 --> 00:11:20.660
and different from what everyone
else is doing. And no

194
00:11:20.660 --> 00:11:23.720
matter what they are smarter
than the idiots at Microsoft.

195
00:11:25.160 --> 00:11:28.670
So Y whether that's true
or not, we don't know.

196
00:11:28.670 --> 00:11:31.160
But there's one thing that
I find consistently is that

197
00:11:31.190 --> 00:11:34.310
when a company reaches a
certain size and a certain

198
00:11:34.340 --> 00:11:39.080
amount of, in their mind,
unique snowflake newness, they immediately

199
00:11:39.080 --> 00:11:42.140
start messing around and machine
dot config and web doc

200
00:11:42.140 --> 00:11:45.080
and fig and changing things
away from the defaults. And

201
00:11:45.080 --> 00:11:47.750
when I talked to Stephan
Chaco, who's one of the

202
00:11:48.890 --> 00:11:53.830
asp.net internals geniuses around the
office here. He, there is

203
00:11:53.830 --> 00:11:56.530
almost never a reason for
you to be messing around

204
00:11:56.530 --> 00:11:59.030
with the defaults. Can you
help me understand this, this

205
00:11:59.050 --> 00:12:03.600
phenomenon, Levi, The phenomenon as
to why people would want

206
00:12:03.600 --> 00:12:05.640
to mess with it? Well,
if we presume that they

207
00:12:05.640 --> 00:12:08.220
are in fact not unique
snowflakes, but they feel that

208
00:12:08.220 --> 00:12:10.290
this is a knob or
a dial or a switch

209
00:12:10.290 --> 00:12:12.720
that they need to mess
around with, because obviously the

210
00:12:12.720 --> 00:12:16.260
guys at Redmond have made
the mistake that whatever number

211
00:12:16.260 --> 00:12:20.010
of concurrent requests per CPU
is set, or number of

212
00:12:20.010 --> 00:12:23.820
threads per thread, pool is
allowed, is wrong. And for

213
00:12:23.820 --> 00:12:28.260
what they're doing at their
fancy company is, is, is

214
00:12:28.260 --> 00:12:32.340
special. And they'll end up
just turning knobs and dials

215
00:12:32.340 --> 00:12:34.650
trying to solve a problem.
And I think that maybe

216
00:12:34.650 --> 00:12:37.500
the problem is that we,
as a, as a, as

217
00:12:37.500 --> 00:12:39.840
an industry, just aren't doing
this work correctly when it

218
00:12:39.840 --> 00:12:43.530
comes to async and background
processing. So I'm, I'm not

219
00:12:43.530 --> 00:12:46.020
going to let our team
get away. Scot-free on this

220
00:12:46.020 --> 00:12:51.900
one in earlier versions of
asp.net, we actually did cap

221
00:12:52.200 --> 00:12:55.530
the default number of requests
per CPU at a very

222
00:12:55.530 --> 00:12:58.350
low number. I think it
was maybe 12 requests per

223
00:12:58.350 --> 00:13:04.380
CPU. And honestly, with the
amount of memory that's in

224
00:13:04.380 --> 00:13:08.340
most servers, I mean, we're
talking, you know, eight, 12,

225
00:13:08.490 --> 00:13:12.540
24 gigabytes of Ram. You
can certainly do more than

226
00:13:12.540 --> 00:13:15.210
12 requests per CPU, even
if all of those threads

227
00:13:15.210 --> 00:13:19.020
are blocking, waiting for some
event to take place. I

228
00:13:19.020 --> 00:13:21.450
think that might be the
reason that a lot of

229
00:13:21.450 --> 00:13:26.520
people like messing with these
switches, just because there's still

230
00:13:26.520 --> 00:13:31.140
this misconception, that ASP dot
nuts still does not scale

231
00:13:31.140 --> 00:13:35.310
well, where in FORO, especially
we've made great strides so

232
00:13:35.310 --> 00:13:38.460
that that's no longer the
case. Do you know what

233
00:13:38.460 --> 00:13:41.910
those values are now, guys?
Yeah. So I think it's

234
00:13:41.910 --> 00:13:44.490
at least a hundred per
fraud or per score. I

235
00:13:44.490 --> 00:13:48.870
thought 5,000 concurrent requests per
CPU and ASP net for

236
00:13:49.140 --> 00:13:52.710
by default, we've had to
fiddle with these a lot

237
00:13:52.710 --> 00:13:54.900
when doing signalized testing, which
is why I've had some

238
00:13:54.900 --> 00:13:56.910
recent experience with it, but
I used to be on

239
00:13:56.910 --> 00:13:58.770
it. Isn't the only thing
in the pipeline that you

240
00:13:58.770 --> 00:14:00.600
have to be aware of.
Of course, I mean, I

241
00:14:00.600 --> 00:14:03.150
S is sitting in front
of asp.net and it has

242
00:14:03.150 --> 00:14:07.140
its own queuing and, and
sort of throttling mechanisms that

243
00:14:07.140 --> 00:14:09.990
you have to be aware
of. So by default, the

244
00:14:09.990 --> 00:14:12.810
Apple, there's some settings on
the outpull one of which

245
00:14:12.810 --> 00:14:16.860
is the queue depth for
the HCPCS. And that is

246
00:14:16.860 --> 00:14:20.310
default to it's a thousand
or 5,000 the car. Remember

247
00:14:20.460 --> 00:14:23.610
it's, it's much smaller than
the default asp.net settings. If

248
00:14:23.610 --> 00:14:26.100
you have more than one
CPU. So if you're trying

249
00:14:26.100 --> 00:14:30.480
to tune for concurrency, that
is you want to choose

250
00:14:30.480 --> 00:14:33.900
such that your web server
can deal with lots and

251
00:14:33.900 --> 00:14:38.010
lots of simultaneously running web
requests at the same time,

252
00:14:39.000 --> 00:14:41.370
then you need, you sometimes
need to go and adjust

253
00:14:41.370 --> 00:14:44.970
these settings because in a
very, very high load web

254
00:14:44.970 --> 00:14:49.290
server, you can get beyond
5,000 current requests per CPU

255
00:14:49.290 --> 00:14:53.120
or 5,000 current requests for
the entire, but generally that's

256
00:14:53.120 --> 00:14:55.430
a lot of load you
need to be getting before

257
00:14:55.430 --> 00:14:56.960
you hit that sort of
thing. The reason we have

258
00:14:56.960 --> 00:14:58.820
to do it in signal
hours, because most of our

259
00:14:58.820 --> 00:15:01.430
requests never go away. We
create a request and then

260
00:15:01.430 --> 00:15:03.890
it stays open forever while
we pump data over it.

261
00:15:03.890 --> 00:15:07.220
So we have to tune
the server to do long

262
00:15:07.220 --> 00:15:13.160
running concurrent requests versus lots
and lots of very short

263
00:15:13.160 --> 00:15:18.850
running requests for high throughput.
So I've been doing asp.net

264
00:15:18.850 --> 00:15:21.580
for a long time and.net
since the day it came

265
00:15:21.580 --> 00:15:24.940
out. That's almost 10 years
now. And a couple of

266
00:15:24.940 --> 00:15:29.170
days ago, I was working
on a, a pan tilt

267
00:15:29.170 --> 00:15:31.630
zoom thing that I'm working
on and get a camera

268
00:15:31.630 --> 00:15:34.960
working. And I ended up
finding an old, old library.

269
00:15:34.960 --> 00:15:37.120
So I'm in dotnet four
or five doing some work.

270
00:15:37.120 --> 00:15:41.170
And I pull in this.net
one, one library, and I

271
00:15:41.170 --> 00:15:45.880
find myself doing begin, start
pan and end start pan.

272
00:15:45.880 --> 00:15:47.950
And it took me awhile
to get my brain back

273
00:15:47.950 --> 00:15:50.890
on top of this. And
then I pulled in another

274
00:15:50.890 --> 00:15:55.270
library and it had something,
something async in, something, something

275
00:15:55.600 --> 00:16:00.490
async completed, but my brain
is starting to get more

276
00:16:00.490 --> 00:16:03.220
tuned to the way that
the, the, the tasks and

277
00:16:03.220 --> 00:16:05.560
background tasks and thing, like
things like that are working.

278
00:16:06.100 --> 00:16:08.410
What what's going on there.
Why am I in one

279
00:16:08.410 --> 00:16:12.670
project thinking about three different
kinds of, of asynchronous programming

280
00:16:12.670 --> 00:16:16.750
and does one encapsulate the
other? Is it like a

281
00:16:16.750 --> 00:16:20.050
series of onion layers where
one lays on top of

282
00:16:20.050 --> 00:16:25.930
the, the next Damien? No,
unfortunately in some cases, yes,

283
00:16:26.110 --> 00:16:28.420
but mostly no. So let,
let, let us go through

284
00:16:28.420 --> 00:16:33.910
the sorted history of asynchronous
programming and.net. And we will

285
00:16:34.150 --> 00:16:37.360
hopefully clarify what all these
different things mean. Unfortunately, there

286
00:16:37.360 --> 00:16:40.810
is some overlap. So in.net,
one slash one, one world,

287
00:16:41.110 --> 00:16:45.490
we had what was called
APM, the asynchronous programming model.

288
00:16:45.880 --> 00:16:51.070
And this is the begin
slash end method pairs that

289
00:16:51.070 --> 00:16:52.750
you talked about. So if
you had some type of

290
00:16:52.750 --> 00:16:57.790
operation that when cold could
be done asynchronously, meaning that

291
00:16:58.210 --> 00:17:01.630
you could re immediately return
to the application, give them

292
00:17:01.630 --> 00:17:05.350
some token that represents whether
that operation has finished or

293
00:17:05.350 --> 00:17:10.360
not. And then also have
the Cola passing, a delegate,

294
00:17:10.810 --> 00:17:13.900
which the consumer, which the
not the consumer, the other

295
00:17:13.900 --> 00:17:16.750
side will call back when
the async operation is finished,

296
00:17:17.050 --> 00:17:19.990
then you would expose that
operation with two methods. One

297
00:17:19.990 --> 00:17:22.570
would be a begin method
that returned an IAA sync

298
00:17:22.570 --> 00:17:26.270
result. That's I think result
it's an interface in, in,

299
00:17:26.270 --> 00:17:29.350
in the.net based class library.
And then there would be

300
00:17:29.350 --> 00:17:33.100
an end pair to that
method, which would return either

301
00:17:33.100 --> 00:17:35.770
void. If it was the
type of async a method

302
00:17:35.770 --> 00:17:39.220
that didn't return anything, or
it would return some object.

303
00:17:39.250 --> 00:17:41.320
If you were perhaps looking
up something from a database,

304
00:17:41.320 --> 00:17:44.170
for instance, maybe a data
Raider or something like that.

305
00:17:46.210 --> 00:17:48.400
That's a model that's used
for any kind of asynchronous

306
00:17:48.430 --> 00:17:50.760
programming. Like I talking to
hardware, or you could be

307
00:17:50.760 --> 00:17:54.480
talking to a database, it's
just do something begin. Then

308
00:17:54.480 --> 00:17:58.170
there's a call back. And
then you say, and in

309
00:17:58.170 --> 00:18:01.640
the middle of that callback.
So yeah, when you pass

310
00:18:01.640 --> 00:18:04.280
in a callback and then
the other side, we'll call

311
00:18:04.280 --> 00:18:06.620
that call back when it's
finished. And then the call

312
00:18:06.620 --> 00:18:08.540
back at you passed in
inside the body of that

313
00:18:08.540 --> 00:18:11.930
call back. You will call
the end method, passing in

314
00:18:11.930 --> 00:18:15.400
the original IAA sync results
that the begin method returned,

315
00:18:15.410 --> 00:18:17.390
because the, I think result
is kind of the token

316
00:18:17.390 --> 00:18:21.920
that represents that asynchronous operation.
And then once you call

317
00:18:21.920 --> 00:18:23.900
and the other side will
give you back the result,

318
00:18:23.900 --> 00:18:26.690
if there was a result
to be handed back. So

319
00:18:26.770 --> 00:18:31.670
it's not, it's an easy
program programming sort of paradigm

320
00:18:31.670 --> 00:18:34.880
to understand if you're doing
one asynchronous operation, you can

321
00:18:34.880 --> 00:18:37.340
kind of get your head
around that fairly easily. Where

322
00:18:37.340 --> 00:18:39.350
I always had trouble with
APM was when I had

323
00:18:39.350 --> 00:18:42.860
to do any type of
asynchronous composition, where I wanted

324
00:18:42.860 --> 00:18:45.260
to say, do this asynchronous
task. And then when that's

325
00:18:45.260 --> 00:18:48.560
finished do this asynchronous task,
then fire off these two

326
00:18:48.560 --> 00:18:51.620
in parallel asynchronously. And then
when the whole thing finishes,

327
00:18:51.890 --> 00:18:54.830
continue, want to do something
else that type of programming

328
00:18:54.830 --> 00:18:58.490
with APM was really difficult
because the perimeters didn't exist

329
00:18:58.520 --> 00:19:01.580
in.net to help you do
that. Composition, you had to

330
00:19:01.580 --> 00:19:06.170
write your own custom IAA
sync result implementations, or you

331
00:19:06.170 --> 00:19:10.130
had to chain your own
custom callback delegates in order

332
00:19:10.130 --> 00:19:12.110
to say, when this is
finished, do that, then kick

333
00:19:12.110 --> 00:19:14.870
this off and then do
that. So that led to

334
00:19:14.870 --> 00:19:18.120
what we had in dotnet
two, which was, which was

335
00:19:18.230 --> 00:19:21.830
what we called a vented
asynchronous or EAP the event

336
00:19:21.830 --> 00:19:25.850
at asynchronous pattern. So EAP
where those letters again, and

337
00:19:25.850 --> 00:19:28.520
that's where we start to
see these new method pairs

338
00:19:29.630 --> 00:19:31.910
or a method plus an
event. So you alluded to

339
00:19:31.910 --> 00:19:34.910
it, you said you saw
something like Fu a sink

340
00:19:35.240 --> 00:19:39.710
and then food completed event.
And the idea of this

341
00:19:39.710 --> 00:19:42.830
was that you would call
food a sink after you

342
00:19:42.830 --> 00:19:46.640
had subscribed an event handler
to the food completed events.

343
00:19:47.240 --> 00:19:49.550
Now it doesn't actually sound
all that different. If you

344
00:19:49.550 --> 00:19:52.430
think about it, all they're
really doing is hiding the

345
00:19:52.430 --> 00:19:55.430
IAA sink result from you.
And rather than you providing

346
00:19:55.430 --> 00:19:59.480
a callback, you've attached the
call back to an event

347
00:19:59.510 --> 00:20:02.480
that will get raised by
the object that you find

348
00:20:02.480 --> 00:20:05.240
this, I think method on
there. The big difference though,

349
00:20:05.240 --> 00:20:09.260
is that the event at
async programming model utilizes something

350
00:20:09.260 --> 00:20:12.740
under the covers called a
synchronization context. So that it's

351
00:20:12.740 --> 00:20:15.230
really good for things like
UI frameworks, where you have

352
00:20:15.230 --> 00:20:18.110
this idea of a UI
thread, this main thread, the

353
00:20:18.110 --> 00:20:20.660
application is running on, and
then you want to do

354
00:20:20.690 --> 00:20:24.080
a synchronous work in the
background. And when that's finished,

355
00:20:24.080 --> 00:20:27.080
you need to marshal that
result back onto the correct

356
00:20:27.080 --> 00:20:30.080
thread. Before you can update
your UI. The event async

357
00:20:30.080 --> 00:20:32.540
pattern kind of did this
for you under the covers.

358
00:20:32.540 --> 00:20:35.390
We had objects like the
background worker class, which a

359
00:20:35.390 --> 00:20:38.030
lot of people would have
used in WinForms where you

360
00:20:38.030 --> 00:20:39.590
sort of gave it a
delegate to run in the

361
00:20:39.590 --> 00:20:41.600
background, and it would go
off and fire a new

362
00:20:41.600 --> 00:20:44.540
thread. And it would, then
it would fire events back

363
00:20:44.540 --> 00:20:47.380
on the UI thread telling
you when there was progress

364
00:20:47.770 --> 00:20:49.780
and when the thing had
finished. So you didn't have

365
00:20:49.780 --> 00:20:51.940
to worry about this whole
marshaling of data from one

366
00:20:51.940 --> 00:20:57.010
thread to another. So that's
APM and EAP. And then

367
00:20:57.010 --> 00:21:01.390
in.net four, they introduced the
task asynchronous patent or T

368
00:21:01.390 --> 00:21:04.480
a P. Some people will
know this as TPL, the

369
00:21:04.480 --> 00:21:08.530
task parallel library. And this
is where we saw a

370
00:21:08.530 --> 00:21:11.350
new set of types. And
you said a primitives introduced

371
00:21:11.350 --> 00:21:13.750
in the framework that are
labeled us to get a

372
00:21:13.750 --> 00:21:16.540
handle on an asynchronous operation
a bit like I think

373
00:21:16.540 --> 00:21:19.630
result except this time it's
called task. And the task

374
00:21:19.630 --> 00:21:22.240
represents a promise. It represents
the fact that something is

375
00:21:22.240 --> 00:21:24.820
running it's either finished already,
or it might finish in

376
00:21:24.820 --> 00:21:27.790
the future, but rather than
just being a token, that

377
00:21:27.790 --> 00:21:29.860
I then am able to
pass into some other methods

378
00:21:29.860 --> 00:21:34.120
to get the result. The
task itself includes other methods

379
00:21:34.120 --> 00:21:36.310
that I can use to
do composition. So I can

380
00:21:36.310 --> 00:21:38.920
say here is the task
it represents is facing corporation.

381
00:21:39.220 --> 00:21:42.460
When that's finished dot continue
with, go off and do

382
00:21:42.460 --> 00:21:45.880
this other bunch of work
and getting passed into the

383
00:21:45.880 --> 00:21:49.510
delegates you pass in. There
is the previous task that

384
00:21:49.510 --> 00:21:51.220
finished. So if it had
a result, you can just

385
00:21:51.220 --> 00:21:55.810
grab it off that task.
So tap introduced much, much

386
00:21:55.810 --> 00:22:00.430
nicer composition models for asynchronous
programming while still utilizing the

387
00:22:00.430 --> 00:22:03.580
synchronization context. If you, if
necessary, if you want to,

388
00:22:03.580 --> 00:22:06.910
you can do that underneath
the covers to do synchronization

389
00:22:06.910 --> 00:22:12.720
between different threads in different
contexts, The async await keywords.

390
00:22:14.400 --> 00:22:19.560
Levi. How did those make
that better for pap sounds

391
00:22:19.560 --> 00:22:24.000
really, really straight forward, but
people didn't necessarily flood in

392
00:22:24.000 --> 00:22:27.720
that direction and like start
using this and clearly Anders

393
00:22:27.720 --> 00:22:29.640
and the powers that be,
felt the need to go

394
00:22:29.640 --> 00:22:33.780
and do keywords and that
added to the mix here.

395
00:22:35.250 --> 00:22:39.360
So remember how Damien was
talking about composition? The fact

396
00:22:39.360 --> 00:22:43.140
that when you want a
task it's finished, you can

397
00:22:43.140 --> 00:22:46.180
provide it a piece of
work to continue with a

398
00:22:46.200 --> 00:22:52.200
continuation retain most programmers in
C sharp and VB, because

399
00:22:52.200 --> 00:22:55.320
C sharp and VB are
imperative languages, as opposed to

400
00:22:55.320 --> 00:22:58.200
a functional language. They don't
really think in terms of

401
00:22:58.200 --> 00:23:04.110
continuations. It's very, it's very
odd for a programmer who's

402
00:23:04.110 --> 00:23:07.650
used to these languages to
have to kind of divide

403
00:23:07.650 --> 00:23:11.760
his program up into a
series of callbacks. And a

404
00:23:11.760 --> 00:23:15.690
series of callbacks is unfortunately
what the task parallel library

405
00:23:15.840 --> 00:23:19.830
takes as a parameter. Now,
the async and awake keywords

406
00:23:19.830 --> 00:23:23.760
make this a lot easier
because they'll automatically turn your

407
00:23:23.760 --> 00:23:27.810
method that is marked using
the async and awake keywords

408
00:23:28.290 --> 00:23:31.680
into a giant state machine
that can provide its own

409
00:23:31.680 --> 00:23:36.090
series of callbacks. It's very
similar to what the yield

410
00:23:36.090 --> 00:23:40.140
keyword does in C sharp.
So if you imagine, if

411
00:23:40.140 --> 00:23:44.880
you imagine that you write
a regular synchronous program and

412
00:23:44.930 --> 00:23:47.240
all of a sudden you
want to start calling the

413
00:23:47.240 --> 00:23:51.260
method that ends in async,
it returns a task. If

414
00:23:51.260 --> 00:23:55.160
you prefix that call with
the await keyword, the compiler

415
00:23:55.160 --> 00:23:59.390
will actually split that method
into two. The first part

416
00:23:59.390 --> 00:24:02.600
of the method, the first,
the first method will be

417
00:24:02.600 --> 00:24:06.650
everything that is before the
call to the task returning

418
00:24:06.650 --> 00:24:11.060
method. The second method will
be everything that is after

419
00:24:11.270 --> 00:24:14.750
the call to the task
returning method. And the compiler

420
00:24:14.750 --> 00:24:18.590
will automatically turn that second
half of your code into

421
00:24:18.590 --> 00:24:23.690
a callback and pass it
into the task routines. So

422
00:24:24.020 --> 00:24:26.510
you get all of the
benefits of using the task

423
00:24:26.540 --> 00:24:30.800
async pattern, but you get
the nice language syntax of

424
00:24:31.040 --> 00:24:34.220
making your program. Look as
if it were written synchronously,

425
00:24:34.520 --> 00:24:37.340
you as a developer, don't
have to worry about splitting

426
00:24:37.340 --> 00:24:40.070
your application up like this.
The compiler does it on

427
00:24:40.070 --> 00:24:44.230
your behalf. Interesting. You know,
this makes, this might be

428
00:24:44.710 --> 00:24:48.700
my ignorance showing, but this
makes me think about 10

429
00:24:48.700 --> 00:24:53.440
years ago, when we all
learned about I disposable and

430
00:24:53.440 --> 00:24:56.830
try catch finally, and things
like that, and you would

431
00:24:56.830 --> 00:24:59.830
go and you'd make something,
you would do a try

432
00:24:59.830 --> 00:25:02.020
catch finally, and then you
dispose it. And then someone

433
00:25:02.020 --> 00:25:05.200
came out with using, and
you would say using this

434
00:25:05.200 --> 00:25:07.810
particular variable, and then you'd
have a scope block and

435
00:25:07.810 --> 00:25:10.090
you do your thing. And
then we would all rush

436
00:25:10.090 --> 00:25:14.260
over into <inaudible> or reflector.
And we say, look, you

437
00:25:14.260 --> 00:25:16.660
said using, and they put
a try catch finally, and

438
00:25:16.660 --> 00:25:20.200
seeing the finally they put
a dispose automatically for you.

439
00:25:20.200 --> 00:25:21.880
And we just thought that
was amazing. That was the

440
00:25:21.880 --> 00:25:26.620
greatest thing. This is another
example of that small comparatively

441
00:25:26.620 --> 00:25:31.240
small, or apparently small syntactic
sugar. That really turns into

442
00:25:31.240 --> 00:25:35.620
an astonishingly useful pattern under,
under the wire all done

443
00:25:35.620 --> 00:25:38.290
by the UN under the
covers all done by the

444
00:25:38.290 --> 00:25:43.270
compiler. Oh yeah, certainly. And
if you, if you go

445
00:25:43.270 --> 00:25:46.090
take a look at a
program that's using async await

446
00:25:46.090 --> 00:25:48.970
and open it up in
reflect or ill spy or

447
00:25:49.060 --> 00:25:52.900
build as, or something you'll,
your mind will be blown

448
00:25:53.080 --> 00:25:56.110
by the IOL that's generated
by Dan, before you look

449
00:25:56.110 --> 00:26:00.250
at that, Maybe it's best
that we not look at

450
00:26:00.250 --> 00:26:03.940
that. Actually all those things.
Speaking of things that we

451
00:26:03.940 --> 00:26:08.470
should look at, Rick Anderson,
one of the technical writers

452
00:26:08.470 --> 00:26:11.110
and a really talented guy
on our team has got

453
00:26:11.140 --> 00:26:13.840
this amazing article that everyone's
gotta read. And it's a

454
00:26:13.840 --> 00:26:16.630
crime that there's not more
comments on this article, where

455
00:26:16.630 --> 00:26:20.440
he talks about doing asynchronous
methods in asp.net for, and

456
00:26:20.440 --> 00:26:22.330
he points out a couple
of things in here. First,

457
00:26:22.660 --> 00:26:25.390
he's got some really great
examples where he's using web

458
00:26:25.390 --> 00:26:28.960
forms to do async, which
I think all of, you

459
00:26:28.960 --> 00:26:32.440
know, makes the point that
really, really smart people do

460
00:26:32.920 --> 00:26:37.330
a web forms to smart
people don't necessarily need to

461
00:26:37.330 --> 00:26:40.300
go over to MVC to
get a really productive environment.

462
00:26:40.630 --> 00:26:42.550
But he's got this bit
of code here where he

463
00:26:42.550 --> 00:26:46.110
says, he's got, he's going
to call into three, three

464
00:26:46.110 --> 00:26:49.440
web services. So the page
load does some stuff. Then

465
00:26:49.440 --> 00:26:51.450
it fires off into three
web services and it doesn't,

466
00:26:51.510 --> 00:26:55.920
it does those asynchronously. And
he says, await task went

467
00:26:55.920 --> 00:27:00.480
all. And then he passes
in the three tasks. If

468
00:27:00.480 --> 00:27:03.720
I understand correctly, is that
literally saying, hang out here

469
00:27:03.720 --> 00:27:07.520
until all three of these
are done, Damien, It is

470
00:27:07.610 --> 00:27:10.670
saying that, but rather than
saying, hang out here and

471
00:27:10.670 --> 00:27:15.440
consume a thread, it's saying,
make this request sort of

472
00:27:15.860 --> 00:27:18.800
spin down for now. And
then when all these things

473
00:27:18.800 --> 00:27:21.680
come back, spin the request
up again, grab a new

474
00:27:21.680 --> 00:27:24.110
thread and continue execution. So
that's what we call an

475
00:27:24.140 --> 00:27:30.020
async wait versus a blocking.
Wait, That is something that

476
00:27:30.380 --> 00:27:33.860
would be amazingly difficult and
frustrating. A couple of years

477
00:27:33.860 --> 00:27:38.510
back speaking to what Levi
was talking about, about chaining

478
00:27:38.510 --> 00:27:42.650
things together. When I was
doing this asynchronous work and

479
00:27:42.650 --> 00:27:46.970
background work on this, this
little camera, I think I

480
00:27:46.970 --> 00:27:49.880
got four or five deep,
and it was like, you'd

481
00:27:49.880 --> 00:27:52.010
call something and then you'd
wait for the call back.

482
00:27:52.040 --> 00:27:54.500
And then in that callback,
you'd go and fire something

483
00:27:54.500 --> 00:27:56.240
else off and then wait
for that call back. And

484
00:27:56.240 --> 00:27:59.120
I ended up with, you
know, five, six, seven different

485
00:27:59.120 --> 00:28:01.940
methods. It became really, really
difficult to get my head

486
00:28:01.940 --> 00:28:05.900
around this and what, what
was happening. And I kept

487
00:28:05.900 --> 00:28:07.700
going back and forth. Do
I want to do this

488
00:28:07.700 --> 00:28:11.360
as one giant function with
20 curly braces and nest

489
00:28:11.360 --> 00:28:13.010
them? Or do I want
to make a bunch of

490
00:28:13.010 --> 00:28:17.420
little tiny functions to do
something very simple? Yeah. Yeah.

491
00:28:17.870 --> 00:28:19.610
When I, when I see
code like that, I mean,

492
00:28:19.610 --> 00:28:21.080
I think I actually had
to look at the code

493
00:28:21.080 --> 00:28:23.870
that you were writing. I,
again, get into those. I

494
00:28:23.870 --> 00:28:25.400
I'm the same as you.
I go, well, shall I

495
00:28:25.400 --> 00:28:27.020
do this? Like, you know,
maybe like I would do

496
00:28:27.020 --> 00:28:29.390
Java script and just have
a whole bunch of Nicole Banks,

497
00:28:29.840 --> 00:28:32.660
should I split them out?
Like VF sort of leads

498
00:28:32.660 --> 00:28:35.420
me to do by using
plus equals plus equals creating

499
00:28:35.420 --> 00:28:39.470
extra delegates that I then
call, or maybe I should

500
00:28:39.470 --> 00:28:42.560
do a little bit more
work and create my own

501
00:28:42.560 --> 00:28:46.130
wrapper around this entire mess
and create sort of a

502
00:28:46.130 --> 00:28:49.100
mini fluent API for doing
this. So I can say

503
00:28:49.370 --> 00:28:51.680
do this. And then that
returns something that I can

504
00:28:51.680 --> 00:28:54.080
then do something else on.
And then that returns something

505
00:28:54.080 --> 00:28:56.780
that I can then do
something else on. And while

506
00:28:56.780 --> 00:28:58.340
that may sound like a
lot of work, if all

507
00:28:58.340 --> 00:29:00.020
you're trying to do is
clean up the code of

508
00:29:00.020 --> 00:29:03.770
a specifically complex series of
operations where you're trying to

509
00:29:03.770 --> 00:29:06.110
do six or seven or
more things that are asynchronous.

510
00:29:06.380 --> 00:29:09.650
I think sometimes it's worth
the work because it really

511
00:29:09.710 --> 00:29:11.990
will generally only take you
a very short amount of

512
00:29:11.990 --> 00:29:14.090
time. And your code will
be that much easier to

513
00:29:14.090 --> 00:29:17.030
read in turn when scanning
through and trying to understand

514
00:29:17.030 --> 00:29:20.210
what this block of 40
lines is doing. It will

515
00:29:20.210 --> 00:29:23.810
be much clearer to you
later on Levi kind of

516
00:29:23.810 --> 00:29:26.120
in conclusion. Why do you
think that all of this

517
00:29:26.120 --> 00:29:28.700
is happening now? Why did
it take this long for

518
00:29:28.700 --> 00:29:32.540
async to, to come to.net?
Is this something that's that's

519
00:29:33.590 --> 00:29:35.030
if I go and look
at lists, are they already

520
00:29:35.030 --> 00:29:37.190
doing this? Did they do
this like awesome 40 years

521
00:29:37.190 --> 00:29:38.990
ago? And we're just now
catching up or is there

522
00:29:38.990 --> 00:29:41.800
a particular reason you think
that frameworks are towards async

523
00:29:41.800 --> 00:29:47.920
today? So if you look@the.net
framework in particular, I think

524
00:29:47.920 --> 00:29:49.510
a lot of that has
to do with the fact

525
00:29:49.510 --> 00:29:52.660
that since.net is supposed to
be one of the ways

526
00:29:52.660 --> 00:29:56.710
of writing good windows, eight
applications in particular, they wanted

527
00:29:56.710 --> 00:30:01.180
people to use asynchronous methods
precisely because they use fewer

528
00:30:01.180 --> 00:30:06.010
resources, less CPU time. And
it's honestly better on the

529
00:30:06.010 --> 00:30:10.120
battery for mobile devices, but
that that's just talking about

530
00:30:10.120 --> 00:30:13.750
the client side on the
server side, you really have

531
00:30:13.750 --> 00:30:16.420
issues of scale. We have
all of these cloud services

532
00:30:16.420 --> 00:30:20.830
now where you're expected to
be able to handle hundreds,

533
00:30:21.220 --> 00:30:25.600
thousands, tens of thousands of
simultaneous users. And when I

534
00:30:25.600 --> 00:30:29.050
say simultaneous, I mean, you
know, there are that many

535
00:30:29.050 --> 00:30:35.830
connections actually active to the
server at once, and it's

536
00:30:35.830 --> 00:30:41.230
just not practical to have
10,000 threads running in the

537
00:30:41.530 --> 00:30:46.420
S process, each threads taking
up a 250 kilobyte stack.

538
00:30:46.750 --> 00:30:49.060
I mean, you're going to
start using gigabytes of memory

539
00:30:49.060 --> 00:30:53.290
just to handle threading at
that point. And as far

540
00:30:53.290 --> 00:30:57.430
as scale goes, that's just
a nonstarter. Damien, do you

541
00:30:57.430 --> 00:31:00.160
have anything that you want
to add in conclusion, just

542
00:31:00.160 --> 00:31:04.660
that asp.net has had support
for this asynchronous stuff? Pretty

543
00:31:04.660 --> 00:31:07.960
much since the very beginning,
but I think the most

544
00:31:07.960 --> 00:31:10.120
work we've done on this
is in the latest release

545
00:31:10.120 --> 00:31:12.460
in four or five. And
Levi did an awful lot

546
00:31:12.460 --> 00:31:16.240
of work to ensure that
the async model in asp.net

547
00:31:16.240 --> 00:31:19.180
works really, really well with
the new icing, a white

548
00:31:19.180 --> 00:31:21.310
language support that we've introduced
and on there four or

549
00:31:21.310 --> 00:31:22.930
five as well. So if
you haven't looked at it

550
00:31:22.930 --> 00:31:25.030
yet, it doesn't matter if
you are a web forms,

551
00:31:25.030 --> 00:31:29.590
programmer, an MVC programmer, or
even coding raw HTTP handlers,

552
00:31:29.590 --> 00:31:31.900
and they should to be
modules. I think you'll find

553
00:31:31.900 --> 00:31:35.180
that I'm using the async
abilities and A's, but on

554
00:31:35.200 --> 00:31:38.080
it today, you should be
able to, it's a much

555
00:31:38.080 --> 00:31:39.490
happier place to be than
it was a couple of

556
00:31:39.490 --> 00:31:42.970
years ago. Put it that
way. You guys are going

557
00:31:42.970 --> 00:31:44.320
to give me links that
we'll put in the show

558
00:31:44.320 --> 00:31:49.110
notes For articles and MSDN
things and two and tutorials

559
00:31:49.110 --> 00:31:51.870
that we think that people
should, should check out. And

560
00:31:52.080 --> 00:31:54.150
maybe, yeah, If you think
about it, a couple of

561
00:31:54.150 --> 00:31:57.600
ideas of open source projects,
that would be advanced example

562
00:31:58.010 --> 00:31:59.490
And signal out is the
first one that comes to

563
00:31:59.490 --> 00:32:04.050
mind. Cause he really see
what tuned and continually tuned

564
00:32:04.050 --> 00:32:07.350
asynchronous work sp.net looks like
they should check out the

565
00:32:07.350 --> 00:32:12.030
signal on my brain. Alright.
This has been another episode

566
00:32:12.030 --> 00:32:14.220
of Hansel minutes. We'll see
you again next week.


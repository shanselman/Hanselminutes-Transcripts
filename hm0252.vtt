WEBVTT FILE

1
00:00:05.040 --> 00:00:17.670
<inaudible> from hanselminutes.com. It's Hansel
minutes, a weekly discussion with

2
00:00:17.670 --> 00:00:22.620
web developer and technologists. Scott
Hanselman. This is Lawrence Ryan announcing

3
00:00:22.620 --> 00:00:28.740
show number two 52 recorded
live Thursday, February 3rd, 2011. Support for

4
00:00:28.740 --> 00:00:32.250
Hansel minutes is provided by
Telerik rad controls, the most

5
00:00:32.250 --> 00:00:35.910
comprehensive suite of components for
windows forms and asp.net web

6
00:00:35.910 --> 00:00:45.030
applications online@wwwdottelerik.com. In this episode,
Scott talks with Paul bets

7
00:00:45.120 --> 00:00:50.900
about extending the reactive framework.
Hi, this is Scott Hanselman.

8
00:00:50.910 --> 00:00:54.210
This is another episode of
Hanselminutes today. We've got Paul

9
00:00:54.210 --> 00:00:57.930
bets on a Microsoft engineer,
deep in the machine somewhere.

10
00:00:57.930 --> 00:01:01.200
Where do you work now?
Paul? These days I'm working

11
00:01:01.200 --> 00:01:04.600
on in office labs. So
we're working on kind of

12
00:01:04.910 --> 00:01:08.310
the future productivity, kind of
what our office is going

13
00:01:08.310 --> 00:01:12.600
to do beyond 2010. And
what's interesting, how can we

14
00:01:12.600 --> 00:01:17.550
take these trends in the
industry and kind of mix

15
00:01:17.550 --> 00:01:20.880
them together and make a
great office experience. And before

16
00:01:20.880 --> 00:01:23.370
you used to like, what
patch the Colonel, you worked

17
00:01:23.370 --> 00:01:25.950
somewhere in the middle of
the beach. Yeah. So, so

18
00:01:25.950 --> 00:01:28.080
when I was in college,
I told, I told everyone

19
00:01:28.080 --> 00:01:29.940
it's like, yeah, I really
want to do UI when

20
00:01:29.940 --> 00:01:31.710
I applied to Microsoft. And
they're like, you know what?

21
00:01:31.710 --> 00:01:35.670
We got the place for
you, the S Colonel and

22
00:01:35.670 --> 00:01:39.090
drivers. So, but it was
very cool. It got to

23
00:01:39.090 --> 00:01:43.830
see all kinds of different
things, you know? Oh, like,

24
00:01:44.040 --> 00:01:45.750
you know, down to Sheba,
call us up. And they're

25
00:01:45.750 --> 00:01:49.290
like, we're making this new
machine, but we're having some

26
00:01:49.290 --> 00:01:52.050
problems. We need you to
fix this, fix this windows

27
00:01:52.290 --> 00:01:54.930
issue. And that's what I
did. It was very cool.

28
00:01:55.740 --> 00:01:58.500
Wow. That's another show right
there. But the thing I

29
00:01:58.500 --> 00:02:00.510
wanted to talk to you
about is that there's this

30
00:02:00.510 --> 00:02:02.490
thing that I've talked to
Eric Meyer about a while back

31
00:02:02.490 --> 00:02:07.590
called the RX reactive extensions.
And recently I think last

32
00:02:07.590 --> 00:02:09.480
week that became like an
official thing. It was a

33
00:02:09.480 --> 00:02:12.090
labs thing that would have
been worked on and kind

34
00:02:12.090 --> 00:02:15.390
of a, of an incubator.
And then it has become

35
00:02:15.390 --> 00:02:19.230
official. It is supported and
people can download it, but

36
00:02:19.230 --> 00:02:22.590
it's confusing. And I'm not,
even though I did a

37
00:02:22.590 --> 00:02:24.210
full show with Eric and
I think I pretty much

38
00:02:24.240 --> 00:02:26.940
get it. I'm not a
hundred percent there. And then

39
00:02:26.940 --> 00:02:30.180
you've gone and extended it,
taking the concept of model,

40
00:02:30.180 --> 00:02:34.080
view, view model, and merged
it with, with RX and

41
00:02:34.080 --> 00:02:37.380
made something even more interesting
that that could potentially change

42
00:02:37.380 --> 00:02:41.370
how someone would write a
UI. So can you start

43
00:02:41.370 --> 00:02:44.280
me at the beginning and
explain what reactive programming is

44
00:02:44.280 --> 00:02:48.690
and how RX relates to
that? Sure. So the way

45
00:02:48.690 --> 00:02:50.550
that I like to think
of it is that I

46
00:02:50.550 --> 00:02:52.830
like to take, start with
link. You know, a lot

47
00:02:52.830 --> 00:02:56.130
of people understand link. We
have, you know, this array

48
00:02:56.130 --> 00:02:58.080
and then we kind of
build this pipeline of like

49
00:02:58.080 --> 00:03:01.090
selects and wares and first,
and then at the other

50
00:03:01.090 --> 00:03:04.600
end, we have a new
array, right? So for a

51
00:03:04.600 --> 00:03:06.640
lot of patterns, this is
really useful. Like, you know,

52
00:03:06.670 --> 00:03:08.530
if I was writing a
compiler, then link is really

53
00:03:08.530 --> 00:03:10.960
cool. Cause I have an
input and then I transform

54
00:03:10.960 --> 00:03:12.550
it a lot. And then
I end up with an

55
00:03:12.550 --> 00:03:18.880
output, right. So, but we
have this other paradigm, like

56
00:03:18.880 --> 00:03:21.730
a reactive paradigm, which, which
people have done been doing

57
00:03:21.730 --> 00:03:25.900
reactive paradigm programming for a
long time, right? Every user

58
00:03:25.900 --> 00:03:31.240
interfaces is reactive programming, right.
Because we're, we're having this

59
00:03:31.240 --> 00:03:34.450
event come in this click
or a mouse and then

60
00:03:34.450 --> 00:03:36.790
we're responding to it. Right.
It's not like we know

61
00:03:36.790 --> 00:03:38.860
ahead of time, what's going
to happen. Right. We don't

62
00:03:38.860 --> 00:03:41.970
have the list of clicks
that will always happen. We

63
00:03:41.970 --> 00:03:44.580
mostly sit around and wait
for someone to poke us

64
00:03:45.270 --> 00:03:53.160
and say something has happened.
Yeah, exactly, exactly. So we

65
00:03:53.220 --> 00:03:54.960
w it would be cool
if we could take that

66
00:03:54.960 --> 00:03:59.490
same, same link ideas and
then kind of apply it

67
00:03:59.490 --> 00:04:03.180
to things that are coming
in. So instead of, instead

68
00:04:03.180 --> 00:04:05.490
of having an event, a
really simple event called key

69
00:04:05.490 --> 00:04:08.130
up, that's not really what
I really want to know.

70
00:04:08.130 --> 00:04:11.880
What I really want to
know is when somebody, you

71
00:04:11.880 --> 00:04:14.430
know, does this and this
and this and this, then

72
00:04:14.430 --> 00:04:16.920
tell me that and where,
where the sequence of the

73
00:04:16.920 --> 00:04:20.700
things is like something meaningful
to my program. Like I

74
00:04:20.700 --> 00:04:25.020
took the, the object and
then put it in this

75
00:04:25.020 --> 00:04:27.820
other list, right. Dragged and
dropped it, or something is

76
00:04:27.910 --> 00:04:31.680
the more concretely putting it
more concretely. It was very

77
00:04:31.680 --> 00:04:35.460
low level. Right. But if
someone typed a capital letter

78
00:04:35.460 --> 00:04:38.370
that might be slightly higher
level. And if someone typed

79
00:04:38.370 --> 00:04:41.880
in S C O that
might be even higher level,

80
00:04:41.880 --> 00:04:44.010
is that the kind of
thing you're talking about? Yeah,

81
00:04:44.010 --> 00:04:47.400
exactly. Like taking these, taking
when, when we program with

82
00:04:47.400 --> 00:04:50.130
events are, are our Lego
pieces. So to say are

83
00:04:50.130 --> 00:04:53.130
really small. And it's like
trying to build everything using

84
00:04:53.130 --> 00:04:57.990
these really small pieces. And
so react to re the

85
00:04:57.990 --> 00:05:01.320
reactive extensions, lets us build
bigger pieces. Right. And then

86
00:05:01.320 --> 00:05:03.690
once we build that bigger
piece, we can kind of

87
00:05:03.690 --> 00:05:06.210
combine those two bigger pieces
into an even bigger piece.

88
00:05:06.330 --> 00:05:08.880
Right. So it lets us,
it lets us basically kind

89
00:05:08.880 --> 00:05:13.440
of take, take these different
parts and make bigger parts

90
00:05:13.560 --> 00:05:15.480
so that we can kind
of reason about them better.

91
00:05:18.480 --> 00:05:25.950
Okay. And is this just
event filtering It's event filtering?

92
00:05:26.550 --> 00:05:31.230
It's combining really the, the
description that a lot of

93
00:05:31.230 --> 00:05:34.830
people give to, to the
reactive extensions is linked to

94
00:05:34.830 --> 00:05:38.700
events, but really what you're
doing, it ends up, it

95
00:05:38.700 --> 00:05:42.090
feels like it's really like
linked to state machine in

96
00:05:42.090 --> 00:05:44.730
the sense that when, if
you want it to describe

97
00:05:44.730 --> 00:05:50.040
this complicated pattern in terms
of events, you'd have to

98
00:05:50.040 --> 00:05:52.680
use a bunch of booleans
like, you know, is in

99
00:05:52.680 --> 00:05:55.650
drag drop or isn't that.
And, and once you get

100
00:05:55.650 --> 00:05:59.930
enough of those booleans then
your code really confusing. And

101
00:05:59.930 --> 00:06:04.100
so, so using the reactor
extensions, we can, we can

102
00:06:04.100 --> 00:06:06.410
get rid of these booleans
and then just say in

103
00:06:06.410 --> 00:06:09.830
a very like link style
away, you know, this is

104
00:06:09.830 --> 00:06:12.440
what I want to, this
is what I'm actually interested

105
00:06:12.440 --> 00:06:15.460
in. Tell me when that
happens. Okay. One of the

106
00:06:15.460 --> 00:06:18.430
things that Eric had talked
about when I talked to

107
00:06:18.430 --> 00:06:22.240
him before was the idea
of, of pushing events to

108
00:06:22.240 --> 00:06:24.400
me, like, like I said
before, like getting poke and

109
00:06:24.400 --> 00:06:26.920
saying, Hey, click, click, Hey,
click, react to this click,

110
00:06:26.920 --> 00:06:29.350
click click versus what do
you call it? A pull

111
00:06:29.350 --> 00:06:33.760
model. Can you talk about
that? Sure. So, so I

112
00:06:33.760 --> 00:06:37.630
think that the way to
kind of reason about it

113
00:06:37.630 --> 00:06:39.160
is, is that I like
to think of it as

114
00:06:39.160 --> 00:06:41.890
that, you know, I innumerable
is this interface that kind

115
00:06:41.890 --> 00:06:43.870
of represents a list. Like
we think of it as

116
00:06:43.930 --> 00:06:45.670
I knew, if I have
an iron numerable I have

117
00:06:45.670 --> 00:06:49.930
a list. So I observable
is just like a list,

118
00:06:49.930 --> 00:06:52.450
but it's a list of
things that will happen. So

119
00:06:52.450 --> 00:06:56.170
it's kind of like a
future list it's so we

120
00:06:56.170 --> 00:06:58.120
can take, we can treat,
I observe will like a

121
00:06:58.120 --> 00:07:00.820
list, but a list of
things that are going to

122
00:07:00.820 --> 00:07:03.070
happen in the future. And
then, and then we will

123
00:07:03.070 --> 00:07:05.800
take these things that are
coming in and then throw

124
00:07:05.800 --> 00:07:08.110
it through the same pipeline.
Right. And so end up

125
00:07:08.110 --> 00:07:10.570
with a new pipeline, just
like when we take an

126
00:07:10.570 --> 00:07:12.910
eye innumerable and select and
wear it, we ended up

127
00:07:12.910 --> 00:07:18.250
with a numerable. Right. So
the cool thing is we

128
00:07:18.250 --> 00:07:21.610
can use the same language
that we use for describe

129
00:07:21.610 --> 00:07:24.370
for lists and we can
do it for, I call

130
00:07:24.370 --> 00:07:26.560
them future lists. So when
I observed what was like

131
00:07:26.580 --> 00:07:30.940
a list to the future,
So to say, okay, so

132
00:07:30.940 --> 00:07:35.050
can you explain where the
reactive extension stop and where

133
00:07:35.050 --> 00:07:40.480
your ideas starts? Sure. So,
so kind of my inspiration

134
00:07:40.480 --> 00:07:44.680
was, you know, looking over
like blog posts and stack

135
00:07:44.680 --> 00:07:48.460
overflow, people would try to
use reactive extensions with, with

136
00:07:48.460 --> 00:07:52.060
MVVM and, and which is
the model view, view, model

137
00:07:53.470 --> 00:07:55.810
pattern that's used in Silverlight
and WPF a lot. And

138
00:07:55.820 --> 00:07:58.150
I'm, I'm really interested in
Silverlight and WPF as well.

139
00:07:58.510 --> 00:08:00.250
And so I was like,
well, let's see how we

140
00:08:00.250 --> 00:08:03.100
can put these together. So
a few people on, on

141
00:08:03.100 --> 00:08:07.480
stack overflow are like, well,
okay. So, you know, if

142
00:08:07.480 --> 00:08:09.850
this I observable was the
source of events, like what

143
00:08:09.850 --> 00:08:13.090
are events that, that are
common and what are things

144
00:08:13.090 --> 00:08:15.520
that we don't usually think
of events? And so one

145
00:08:15.520 --> 00:08:18.380
of the things was a,
an I command. So in,

146
00:08:18.380 --> 00:08:21.370
in WPF and Silverlight, we've
got this interface called I

147
00:08:21.370 --> 00:08:25.240
command, which is, is kind
of an abstraction for a

148
00:08:25.240 --> 00:08:28.450
user command. So it can
do two things. Right. It

149
00:08:28.450 --> 00:08:31.570
can tell you when this
command is available, can execute.

150
00:08:31.720 --> 00:08:35.950
Right. And then it can
has execute, which lets you

151
00:08:35.950 --> 00:08:41.110
do the thing. Right. So
I was like, well, it's

152
00:08:41.110 --> 00:08:42.910
kind of an eye observable
in the sense that every

153
00:08:42.910 --> 00:08:45.130
time you hit execute, that's
kind of like a signal,

154
00:08:45.490 --> 00:08:49.570
Like an event. Right. So
it was like, okay, so

155
00:08:49.570 --> 00:08:52.090
let's make, let's make an
I command. That is an

156
00:08:52.160 --> 00:08:57.000
observable. So we can watch
like subscribe to whenever somebody

157
00:08:57.000 --> 00:09:00.180
pushes a command. So I
take a button and tie

158
00:09:00.180 --> 00:09:02.640
it to a command and
now I can subscribe to

159
00:09:02.640 --> 00:09:05.360
whenever everyone pushes the button.
So that was, that was

160
00:09:05.360 --> 00:09:08.480
one big thing. Okay. So
I'm just, again, my job

161
00:09:08.510 --> 00:09:11.750
as host is to ask
ignorant questions. It sounded confused,

162
00:09:11.750 --> 00:09:18.500
which will be easy. Sure.
Subscribe isn't subscribing to event.

163
00:09:18.530 --> 00:09:20.930
How is that different from
just hooking up an event

164
00:09:20.930 --> 00:09:26.780
handler and reacting to it?
Sure. So, so, so when

165
00:09:26.780 --> 00:09:28.910
you hook up an event
handler, you will always get

166
00:09:28.910 --> 00:09:33.590
the, you will always get
the notification. Right. So, but

167
00:09:33.590 --> 00:09:35.930
because if it's an I
observable, then I can put

168
00:09:35.930 --> 00:09:39.350
stuff between it. I can
put like where, right. Where,

169
00:09:39.620 --> 00:09:45.920
where a web service call
isn't running. Right. So I

170
00:09:45.920 --> 00:09:47.990
can ignore things that I'm
not interested in. I could

171
00:09:47.990 --> 00:09:50.810
say that I'm only interested
in this command when something

172
00:09:50.810 --> 00:09:53.450
else is true. I'm only
interested in the OK button

173
00:09:53.780 --> 00:09:57.200
when the password and confirm
password match. Right. So, so

174
00:09:57.410 --> 00:10:00.050
in, in my, in my
subscribe, I'd have to kind

175
00:10:00.050 --> 00:10:03.170
of encapsulate that in the
event handler and for small

176
00:10:03.170 --> 00:10:06.440
things. Right. It's, it's just
as easy. Right. You know,

177
00:10:06.440 --> 00:10:08.120
I can put an if
statement in my event handler.

178
00:10:08.180 --> 00:10:11.540
Right. But as you get
bigger and bigger and bigger,

179
00:10:11.810 --> 00:10:15.590
these event handlers get crazier
and crazier and crazier. Right.

180
00:10:15.590 --> 00:10:19.670
Okay. And so, so I
could declare like a variable

181
00:10:19.670 --> 00:10:25.340
that says like, okay, button
only when web service calls

182
00:10:25.340 --> 00:10:29.210
and running or only when
passwords match. And then I

183
00:10:29.210 --> 00:10:31.940
could combine that with other
things just like in link

184
00:10:31.940 --> 00:10:36.110
when I can say like,
you know, array where select,

185
00:10:36.500 --> 00:10:38.690
and then I could take
that variable and say first.

186
00:10:41.330 --> 00:10:46.250
Hmm. Okay. I see. So,
so your bill, you're taking

187
00:10:46.250 --> 00:10:48.800
this and again, I appreciate
your use of Lego metaphor.

188
00:10:48.950 --> 00:10:52.820
That wasn't very nice. You
are taking really low level

189
00:10:52.820 --> 00:10:57.680
things, building them up. We
using filters and the things

190
00:10:57.680 --> 00:11:00.260
we're used to in link
up to the point where

191
00:11:00.260 --> 00:11:02.840
you've gone from just being
a simple event, filter to

192
00:11:02.840 --> 00:11:07.280
being really a little state
machine, all expressed as a

193
00:11:07.280 --> 00:11:11.480
single link statement to say
something like, I only want

194
00:11:11.480 --> 00:11:14.840
this thing to happen when
these two password dialogue or

195
00:11:14.840 --> 00:11:19.160
these two password, text boxes
are, are the same. And

196
00:11:19.160 --> 00:11:22.990
the password length is greater
than three. Exactly. That then

197
00:11:23.000 --> 00:11:25.430
that is a state. So
is this a, is this

198
00:11:25.430 --> 00:11:28.130
a, how is this different
from like visual state manager

199
00:11:28.130 --> 00:11:31.250
and silver, Silverlight where you
can describe a whole bunch

200
00:11:31.250 --> 00:11:34.550
of States and it handles
the coordination. It's actually kind

201
00:11:34.550 --> 00:11:37.640
of similar in the sense
that this, this lets you

202
00:11:37.640 --> 00:11:43.100
maintain your application state. Whereas
visual state manager will reshuffle

203
00:11:43.100 --> 00:11:45.320
the UI to match that
state. And one of the

204
00:11:45.320 --> 00:11:47.900
cool things you can do
is you can say like,

205
00:11:48.290 --> 00:11:53.180
you know, a button okay.
Dot select, and then select

206
00:11:53.260 --> 00:11:56.110
visual state you want. Right.
So you could return like

207
00:11:56.110 --> 00:12:00.970
loading as, and then subscribed
to that and say visual

208
00:12:00.970 --> 00:12:05.470
state manager dot go to
state. Right. So you could,

209
00:12:05.500 --> 00:12:08.290
you could write code really
easily that that takes your

210
00:12:08.290 --> 00:12:12.010
application state and follows it
and then moves it and

211
00:12:12.010 --> 00:12:15.510
then, and then signals your
visual state to change. Okay.

212
00:12:15.870 --> 00:12:18.390
I think I'm understanding, but
I'm also putting my mind

213
00:12:18.390 --> 00:12:20.220
in the, I'm putting myself
in the mind of the

214
00:12:20.310 --> 00:12:21.990
listener. And I'm wondering if
they may be a little

215
00:12:21.990 --> 00:12:27.120
confused right now. So events
are, are pushed out to

216
00:12:27.120 --> 00:12:29.970
me. And I know about
events like button click and

217
00:12:30.000 --> 00:12:33.390
key down and they come
really fast. They come, they

218
00:12:33.390 --> 00:12:36.840
come a lot and each
time they, they, they, they

219
00:12:36.840 --> 00:12:40.620
arrive. I get called. So
my, you know, my key

220
00:12:40.620 --> 00:12:44.220
down event might be happening.
Lots of in, we're not

221
00:12:44.220 --> 00:12:46.110
just talking about key down.
It could be mouse over

222
00:12:46.110 --> 00:12:50.550
and every potential event that's
out there. Then those are

223
00:12:50.550 --> 00:12:52.910
all kind of push events.
And then I'm, I'm, I'm,

224
00:12:52.910 --> 00:12:57.690
I'm, they're announced their interrupts
almost. And then in, in

225
00:12:57.690 --> 00:13:01.530
reactive extensions, I am kind
of pulling from a collection

226
00:13:01.530 --> 00:13:04.950
of these events. One of
the things that I'm having

227
00:13:04.950 --> 00:13:08.100
trouble getting my head around
is if there's a collection

228
00:13:08.100 --> 00:13:11.440
of events, how am I
pulling from them at, at,

229
00:13:11.480 --> 00:13:13.560
at, at real time at
the right speed? I mean,

230
00:13:13.560 --> 00:13:15.780
with an interrupt, it's like,
Hey, a key went down.

231
00:13:15.870 --> 00:13:18.990
You can't wait, deal with
me now. But with, with

232
00:13:18.990 --> 00:13:22.500
a, with a collection of
events, it makes me wonder

233
00:13:22.500 --> 00:13:24.780
if I might get behind,
because I'm kind of like

234
00:13:24.900 --> 00:13:29.730
doing the, the, the Lucille
ball kind of like the,

235
00:13:30.360 --> 00:13:32.220
of the chocolates or on
the conveyor belt and going

236
00:13:32.220 --> 00:13:33.900
really fast. And I have
been able to keep up.

237
00:13:33.900 --> 00:13:37.020
So suddenly things start going
wrong. Can these events get

238
00:13:37.020 --> 00:13:41.640
ahead of me? And I
get, I get behind. So

239
00:13:42.150 --> 00:13:44.730
the reactive extensions kind of
guarantees that they'll never get,

240
00:13:44.790 --> 00:13:47.370
you'll never get behind. And
one of the things we've

241
00:13:47.370 --> 00:13:49.650
talked, we haven't talked about
yet is, is the reactive

242
00:13:49.650 --> 00:13:52.350
extensions are kind of interesting
in the sense that you

243
00:13:52.350 --> 00:13:57.240
described this pipeline and you
don't describe, you're describing what

244
00:13:57.240 --> 00:13:59.940
will happen. You, you're not
describing how it will happen.

245
00:13:59.970 --> 00:14:01.770
And so what I mean
with how it will happen

246
00:14:01.770 --> 00:14:05.940
is so with link, we
always know that that when

247
00:14:05.940 --> 00:14:09.540
I do my, for each
that's, that's the thread in

248
00:14:09.540 --> 00:14:11.640
which it's going to run.
So it's, you know, when

249
00:14:11.640 --> 00:14:14.100
I do for each, it's
going to run through this

250
00:14:14.100 --> 00:14:18.870
pipeline one item at a
time, right? So by default,

251
00:14:20.490 --> 00:14:23.730
it's going, when it's going
to follow in reactive extensions,

252
00:14:23.730 --> 00:14:26.940
it's going to go through
this pipeline on whoever initiated

253
00:14:26.940 --> 00:14:29.760
the event. Right? So if
it fires key up it's

254
00:14:29.760 --> 00:14:32.160
as if the key up
handler did all that stuff,

255
00:14:34.230 --> 00:14:35.700
but one of the cool
things is you can use,

256
00:14:35.700 --> 00:14:39.300
what's called a scheduler and
you can say, okay, I

257
00:14:39.300 --> 00:14:42.270
want this, this set of
things to happen on another

258
00:14:42.270 --> 00:14:44.700
threat. And, but I'm going
to describe it in the

259
00:14:44.700 --> 00:14:46.470
same way. So if I
wanted to change it to

260
00:14:46.470 --> 00:14:48.600
say, I don't want it
to run on another threat,

261
00:14:48.600 --> 00:14:51.350
I want it to run
on the UI thread. That's

262
00:14:51.350 --> 00:14:54.920
just like one little parameter,
right? So I can describe,

263
00:14:54.920 --> 00:14:58.010
like, not only what I
want to happen, I can

264
00:14:58.010 --> 00:14:59.840
tell where I want it
to happen. And the react

265
00:14:59.900 --> 00:15:02.540
extensions kind of handles a
lot of the synchronization and

266
00:15:02.540 --> 00:15:04.580
locking stuff. So you don't
have to worry about like,

267
00:15:05.270 --> 00:15:07.550
am I going to run
over this local variable or

268
00:15:07.550 --> 00:15:09.380
things? And it kind of
guarantees that things happen in

269
00:15:09.380 --> 00:15:14.050
order. Right. I see. So
this is like the reactive

270
00:15:14.050 --> 00:15:17.110
extensions is a very good
example of, of a layer

271
00:15:17.110 --> 00:15:19.690
of abstraction that is hiding
so much stuff and so

272
00:15:19.690 --> 00:15:22.660
much complexity underneath it that
it does seem kind of

273
00:15:22.810 --> 00:15:26.110
surprisingly and impossibly simple, But
there is a lot of

274
00:15:26.140 --> 00:15:29.950
work going on underneath. Yeah,
exactly. They're, they're handling a

275
00:15:29.950 --> 00:15:32.350
lot of the locking and
things like that, that you

276
00:15:32.350 --> 00:15:34.540
wouldn't have to do your
own yourself. And the thing

277
00:15:34.540 --> 00:15:36.970
that I like really like
about the reactive extensions is

278
00:15:36.970 --> 00:15:41.200
it lets you describe what
you want to happen right.

279
00:15:41.230 --> 00:15:43.600
In, in a way that's
succinct. And when I, when

280
00:15:43.600 --> 00:15:46.470
I think about like, can
execute on a button, I

281
00:15:46.480 --> 00:15:49.960
phrase it in, like this
button can be enabled when

282
00:15:50.470 --> 00:15:53.860
these two fields are not
empty. Right. And so I

283
00:15:53.860 --> 00:15:56.260
want to write that in
one sentence, kind of in

284
00:15:56.260 --> 00:15:59.350
one statement. And if I
do that with events, I

285
00:15:59.350 --> 00:16:01.270
can't do that. I have
to like say a little

286
00:16:01.270 --> 00:16:03.190
bit of a here, a
little bit of an event

287
00:16:03.190 --> 00:16:05.680
handler. And then I have
to check all these things

288
00:16:06.100 --> 00:16:08.440
and maybe, you know, back
in the day, if you

289
00:16:08.440 --> 00:16:10.990
coded like WinForms, or even
before that, like VB, you

290
00:16:10.990 --> 00:16:14.560
had this like update UI
function, right. This function that

291
00:16:14.560 --> 00:16:17.740
would just, anytime something changed
you called update UI and

292
00:16:17.740 --> 00:16:21.580
would change all the controls
to match. Right. And so

293
00:16:21.580 --> 00:16:24.190
instead I can say like
in this one really succinct

294
00:16:24.580 --> 00:16:27.820
kind of the way I'm
thinking about it, statement is

295
00:16:27.820 --> 00:16:31.420
like, I want this to
be clickable when this does

296
00:16:31.420 --> 00:16:35.590
true. Hi, this is Scott
coming to you from another

297
00:16:35.590 --> 00:16:38.890
place in time. Are you
using agile practices to manage

298
00:16:38.890 --> 00:16:41.140
your software development? There's lots
of tools in the market

299
00:16:41.140 --> 00:16:43.150
that manage the steps of
a project, but most of

300
00:16:43.150 --> 00:16:46.420
them focus on individual roles,
get ready for a solution

301
00:16:46.420 --> 00:16:48.850
that caters for the success
of the whole team. Guys

302
00:16:48.850 --> 00:16:52.720
at Tellerik introduced team pulse
to an agile project management

303
00:16:52.720 --> 00:16:56.320
tool. That'll help you gather
ideas, estimate plan, track progress

304
00:16:56.320 --> 00:17:00.100
in a common workspace. Finally
companies, regardless of their size

305
00:17:00.100 --> 00:17:02.110
can use a lightweight and
convenient tool that makes all

306
00:17:02.110 --> 00:17:05.470
the stakeholders work as a
United team. Even if they're

307
00:17:05.470 --> 00:17:08.800
in different countries by combining
intuitive user interface and the

308
00:17:08.800 --> 00:17:11.620
power server light team poles
removes the roadblocks that you

309
00:17:11.620 --> 00:17:14.920
typically face and applying agile
in an effective manner, no

310
00:17:14.920 --> 00:17:18.340
more lost data, no disparate
systems, no lack of critical

311
00:17:18.340 --> 00:17:22.420
analytics regarding the health and
philosophy project. So if yourself

312
00:17:22.670 --> 00:17:25.330
get a free copy for
five users in one project

313
00:17:25.330 --> 00:17:31.990
at tellerik.com/team polls. And please
do thank tolerance for supporting

314
00:17:31.990 --> 00:17:36.760
Hanselman it's on their Facebook
fan page, facebook.com/t L E

315
00:17:36.760 --> 00:17:40.780
R I K coloring. We
do appreciate it. There wouldn't

316
00:17:40.780 --> 00:17:42.760
be a Hansel minutes if
there wasn't, Tellerik helping us.

317
00:17:44.320 --> 00:17:47.470
Okay. Now I think we're
circling and circling the drain.

318
00:17:47.500 --> 00:17:50.640
This is where I think
it just made sense. So

319
00:17:50.640 --> 00:17:53.040
it just like link is
really nice in that you

320
00:17:53.040 --> 00:17:56.160
can, you can condense things,
not into one giant fluent

321
00:17:56.190 --> 00:17:58.560
kind of crazy sentence. Like
some people are doing, but

322
00:17:58.560 --> 00:18:02.880
into a nice succinct take
this list. Give me those

323
00:18:02.880 --> 00:18:05.880
things that start with a
capital a then short from

324
00:18:05.880 --> 00:18:08.100
there and return another list.
Just like you said, at

325
00:18:08.100 --> 00:18:10.830
the beginning, you, you build
together a nice little pipeline

326
00:18:10.830 --> 00:18:13.830
that says here's the list
that I have. Here's the

327
00:18:13.830 --> 00:18:16.860
list that I want. And
rather than building four loops

328
00:18:16.860 --> 00:18:19.350
of four loops or four
loops with link, I can

329
00:18:19.350 --> 00:18:21.240
just write it and say,
here's kind of what I

330
00:18:21.240 --> 00:18:25.080
want. And then you're describing
the same thing for events.

331
00:18:25.140 --> 00:18:28.730
Yup. Yup. Here's the interesting
thing that, that really kind

332
00:18:28.730 --> 00:18:31.700
of blew my mind and
made the re reactive extensions

333
00:18:31.700 --> 00:18:35.720
kind of apply to everything.
So if you think about

334
00:18:36.050 --> 00:18:39.890
so WPF and Silverlight have
this interface called, I notified

335
00:18:39.890 --> 00:18:41.930
property changed and you, and
you use it on your

336
00:18:41.930 --> 00:18:44.930
view model and model objects,
this interface that says, Hey,

337
00:18:44.930 --> 00:18:49.130
a property changed. So normally,
you know, with a regular,

338
00:18:49.190 --> 00:18:53.690
just good old fashioned class,
we don't know when properties

339
00:18:53.690 --> 00:18:56.000
change. We'd have to like
ask over and over and

340
00:18:56.000 --> 00:18:58.550
say like, Hey, is this
property changed? Is it, is

341
00:18:58.550 --> 00:19:01.430
it so I know I
notify property change, let's us

342
00:19:01.580 --> 00:19:05.870
say, Hey, let's us call
be called back when a

343
00:19:05.870 --> 00:19:10.940
property changes. Right. And so
once I realized that property

344
00:19:10.940 --> 00:19:14.510
change notifications are events, that
was a big like kind

345
00:19:14.510 --> 00:19:18.560
of like light bulb moment,
right? Because then if property

346
00:19:18.560 --> 00:19:22.220
change notifications or events, then
they should be property change

347
00:19:22.250 --> 00:19:25.310
objects should be observable. Right.
That kind of makes the

348
00:19:25.310 --> 00:19:30.350
reactive extensions apply to anything
because really, you know, an

349
00:19:30.350 --> 00:19:32.930
object that you can watch
when things change is a

350
00:19:32.930 --> 00:19:36.680
really useful thing, regardless of
whether you're in NVC or

351
00:19:36.680 --> 00:19:41.450
you're in WPF or you're
a console application. Right. Okay.

352
00:19:41.450 --> 00:19:43.520
So do you use this
in server life, but you

353
00:19:43.520 --> 00:19:47.690
think that this is something
that's useful everywhere? Yeah. So,

354
00:19:47.720 --> 00:19:51.320
so I kind of split
it apart. So there's a

355
00:19:51.320 --> 00:19:54.410
core library that doesn't depend
on Silverlight because I actually

356
00:19:54.410 --> 00:19:56.300
heard from people on the,
on the web that they

357
00:19:56.300 --> 00:19:59.210
were using it in MVC
projects and, and kind of

358
00:19:59.210 --> 00:20:01.940
just cutting out pieces and
pasting them into their project.

359
00:20:02.390 --> 00:20:05.630
So like your view model
object, right. They would use

360
00:20:05.630 --> 00:20:09.430
this in their MDC projects
and the same thing we,

361
00:20:09.430 --> 00:20:13.550
we also have in reactive
UI, a, a it's called

362
00:20:13.550 --> 00:20:17.810
a reactive collection, which is
an observable collection. So you

363
00:20:17.810 --> 00:20:20.510
can say like, tell me
when items are added or

364
00:20:20.510 --> 00:20:27.140
removed And that's an event
too. Right. Okay. And so

365
00:20:27.140 --> 00:20:30.740
it's also an observable. One
of the things that I've

366
00:20:30.740 --> 00:20:33.920
struggled with when trying to
create my, my Silverlight applications

367
00:20:33.950 --> 00:20:38.750
is I'm an old, old,
old WinForms guy. And I

368
00:20:38.750 --> 00:20:42.530
always end up kind of
with a Boolean somewhere managing

369
00:20:42.530 --> 00:20:44.870
state, or, you know, some,
some variable out there that's

370
00:20:44.870 --> 00:20:49.380
keeping track of, of, you
know, just something hacky. Hmm.

371
00:20:51.560 --> 00:20:55.050
Are these libraries and the
different things like MVVM, MVVM

372
00:20:55.050 --> 00:20:58.800
light. We had Lauren putting
y'all on the show a

373
00:20:58.800 --> 00:21:02.610
while back talking about MVVM
reactive UI, are these all

374
00:21:02.610 --> 00:21:07.470
things that are gonna literally
make my UI clean and

375
00:21:07.470 --> 00:21:10.650
tight and perfect. I mean,
I've always wanted to have

376
00:21:11.010 --> 00:21:14.720
an application that didn't have
state booleans floating around and

377
00:21:14.770 --> 00:21:17.520
in a, in a global
space, but they always seem

378
00:21:17.520 --> 00:21:21.120
to end up there. Is
this my lack of ability

379
00:21:21.120 --> 00:21:23.340
or is this, is this
actually possible now with these,

380
00:21:23.460 --> 00:21:28.560
these, these libraries? I think
that that, because of the

381
00:21:28.560 --> 00:21:32.520
way that these are this
pattern set up and remember

382
00:21:32.520 --> 00:21:36.570
MVVM was kind of invented
after WPF. And so, so

383
00:21:36.570 --> 00:21:39.510
I think that it wasn't
really totally integrated. And so,

384
00:21:39.510 --> 00:21:42.780
so people, myself included definitely
struggle in like, how can

385
00:21:42.780 --> 00:21:45.090
I get rid of this
hacky Boolean? Like, you know,

386
00:21:45.090 --> 00:21:46.680
if you give up and
like in the, in the

387
00:21:46.680 --> 00:21:48.810
window handler, you had an
event and you're like, okay,

388
00:21:48.810 --> 00:21:52.290
this is an MVVM proper.
Right. But I think that's

389
00:21:52.290 --> 00:21:54.000
one of my goals is
to be able to write

390
00:21:54.060 --> 00:21:56.580
with reactive UI to kind
of come up with like,

391
00:21:56.580 --> 00:21:58.880
how can I get rid
of these hacky things and

392
00:21:58.890 --> 00:22:01.200
be able to write things
in a way that's, that's

393
00:22:01.200 --> 00:22:06.000
understandable and, and does what
it says and kind of

394
00:22:06.030 --> 00:22:09.720
clean. So I don't, I
don't think it's quite there

395
00:22:09.720 --> 00:22:12.630
yet, but it's, it's, it's
on its way. I think

396
00:22:12.630 --> 00:22:15.750
there's some really interesting things
you could do. Hmm. I

397
00:22:15.750 --> 00:22:17.760
guess I'm trying to find
out whether or not it's

398
00:22:17.760 --> 00:22:20.580
just my lack of ability
that's preventing me from pulling

399
00:22:20.580 --> 00:22:22.620
this off, or if I
can blame it on a

400
00:22:22.620 --> 00:22:26.640
lack of knowledge Available libraries.
I think, I think that,

401
00:22:26.700 --> 00:22:30.180
that if, if it's your
lack of ability, then you're

402
00:22:30.180 --> 00:22:31.740
not the only one, I
think a lot of people

403
00:22:31.740 --> 00:22:34.110
are struggling with like, how
can I do things like

404
00:22:34.110 --> 00:22:40.950
focus? Right. Well, I appreciate
that. Yeah. I definitely as

405
00:22:40.950 --> 00:22:43.830
well, like in my, in
my side projects, I'm like,

406
00:22:43.860 --> 00:22:46.080
ah, this is, this is
not MBM and I'm doing

407
00:22:46.080 --> 00:22:48.060
it wrong, but I got
to get it out the

408
00:22:48.060 --> 00:22:51.840
door. Right? Yeah. Personally, I
don't like that feeling of

409
00:22:51.840 --> 00:22:53.820
I'm doing it wrong. That
seems to happen a lot.

410
00:22:54.270 --> 00:22:57.450
Like when a library forces
me into an I'm doing

411
00:22:57.450 --> 00:23:00.330
it wrong moment, you know,
no one wants to have

412
00:23:00.330 --> 00:23:02.490
the library making you feel
bad, you know, that the

413
00:23:02.490 --> 00:23:05.550
library is poorly designed. If
it, in fact makes you

414
00:23:05.550 --> 00:23:09.000
feel bad about yourself while
you're using it. So definitely

415
00:23:11.160 --> 00:23:14.850
great to feel very happy
about themselves. Yeah. Yeah. A

416
00:23:14.850 --> 00:23:17.420
quick aside, if you got
any of this in, in

417
00:23:17.430 --> 00:23:19.770
new gap is where the
active, extensions and reactive UI

418
00:23:19.800 --> 00:23:22.230
in the new get a
package manager such that I

419
00:23:22.230 --> 00:23:25.770
can easily bring this down.
Yeah. So I recently added

420
00:23:26.220 --> 00:23:28.380
the latest version and the
cool thing is that it

421
00:23:28.380 --> 00:23:30.780
brings in all of the
reactive extensions for you. So

422
00:23:30.780 --> 00:23:32.700
it has that dependency thing,
or it'll just look up

423
00:23:32.700 --> 00:23:34.980
like, you know, pulling all
the libraries you need. So

424
00:23:35.010 --> 00:23:38.070
you just click on reactive
UI and then it'll pull

425
00:23:38.070 --> 00:23:41.550
everything down. So even from,
even from silver light, I

426
00:23:41.550 --> 00:23:45.320
just go and say, install,
Package, reactive UI, or the

427
00:23:45.320 --> 00:23:48.250
user interface, And this will
come down. Yep. So we

428
00:23:48.250 --> 00:23:52.690
support Silverlight for.net three, five.net
four. And then there is

429
00:23:52.690 --> 00:23:56.810
a separate package because of
kind of issue in new,

430
00:23:56.810 --> 00:24:00.070
get called react UI dash
WP seven. So you can

431
00:24:00.070 --> 00:24:05.110
use it with windows phones.
Okay. All right. So we've

432
00:24:05.110 --> 00:24:09.490
got the reactive extensions that
kind of switch the event

433
00:24:09.490 --> 00:24:12.160
model on its ear, allow
us to kind of, you

434
00:24:12.190 --> 00:24:17.020
do link to events effectively.
Then we've got your framework

435
00:24:17.020 --> 00:24:21.400
and classes that integrate with
that library that are really

436
00:24:21.400 --> 00:24:24.670
focused on doing things correctly.
You're, you're enabling us with

437
00:24:25.540 --> 00:24:29.410
your reactive object and your
different extension methods to make

438
00:24:29.410 --> 00:24:33.250
that even more intuitive and
even more, more friendly with

439
00:24:33.250 --> 00:24:35.350
me in my report. Yeah.
And it's, and it's kind

440
00:24:35.350 --> 00:24:37.690
of rewriting some of the
bridge code that a lot

441
00:24:37.690 --> 00:24:39.640
of people were writing. Like
when I saw people using

442
00:24:39.640 --> 00:24:44.290
reactive extensions with MVVM like,
you know, with MVVM light,

443
00:24:44.620 --> 00:24:46.990
they would have to write
up a lot of like

444
00:24:47.020 --> 00:24:49.750
glucose, like a lot of
just kind of redundant the

445
00:24:49.750 --> 00:24:51.160
same thing over and over
again. And it's like, well,

446
00:24:51.160 --> 00:24:53.020
let's just get rid of
that. And so they can

447
00:24:53.410 --> 00:24:56.680
kind of write, like, I'm
really interested in when the,

448
00:24:58.090 --> 00:25:00.940
you know, name, property changes.
Just give me an observable

449
00:25:00.970 --> 00:25:03.520
whenever the name property changes.
And instead of writing, like,

450
00:25:03.520 --> 00:25:06.430
you know, observable from event,
blah, blah, blah dot where

451
00:25:06.430 --> 00:25:10.870
property change, you can just
say this dot observable from

452
00:25:10.870 --> 00:25:13.960
property, and then you can
use an expression. So you

453
00:25:13.960 --> 00:25:17.860
say like texts Name, and
then now you've got an

454
00:25:17.860 --> 00:25:21.610
observable that fires, whenever name
changes on your, on your

455
00:25:21.610 --> 00:25:24.910
object. Okay. So just kind
of reducing the kind of

456
00:25:24.910 --> 00:25:27.880
junk code you have to
write that kind of obscures

457
00:25:28.030 --> 00:25:32.020
your intent. I've seen a
number of things lately from,

458
00:25:32.680 --> 00:25:36.070
I know that Daniel Catalino
sent me something called magic,

459
00:25:36.070 --> 00:25:39.220
and there's a number of
cool kind of code weaving

460
00:25:39.250 --> 00:25:42.370
type of aspect oriented things
that a lot of people

461
00:25:42.370 --> 00:25:44.740
who, who deal with I
notified property changed a lot,

462
00:25:45.010 --> 00:25:46.930
come up with creative ways
to get rid of it.

463
00:25:47.950 --> 00:25:49.930
And, and for those who
aren't familiar with it, the

464
00:25:49.930 --> 00:25:52.810
idea is that you, you
probably just want to have

465
00:25:52.900 --> 00:25:56.590
public string first name and
public string, last name, except

466
00:25:56.590 --> 00:26:00.100
you have to announce in
the setter that something's happened

467
00:26:00.100 --> 00:26:04.120
and that's often considered distasteful.
So there's lots of libraries

468
00:26:04.120 --> 00:26:07.720
to make it easier. You
can like use the magic

469
00:26:07.720 --> 00:26:11.470
library and you basically literally
put in an attribute called

470
00:26:11.500 --> 00:26:15.160
magic on it. And it
will automatically insert that for

471
00:26:15.160 --> 00:26:19.060
you, there's post build steps
that do things and didn't

472
00:26:19.060 --> 00:26:24.790
change the code. Just write
post compile time. That seems

473
00:26:24.790 --> 00:26:26.830
like the, the, the, the
only thing that's not like

474
00:26:27.640 --> 00:26:31.180
nice about this from a
boilerplate perspective is that, you

475
00:26:31.180 --> 00:26:33.760
know, kind of half the
code you're writing is the

476
00:26:33.760 --> 00:26:37.780
border plate raise and set
if changed type of stuff.

477
00:26:37.930 --> 00:26:41.620
Do you have any thoughts
about that? Yeah. So one

478
00:26:41.620 --> 00:26:43.650
of these days I'm going
to convince Anders to add

479
00:26:43.650 --> 00:26:45.840
macros to C-sharp and then
this whole thing will be

480
00:26:45.840 --> 00:26:49.710
easier. I think, I think
that without using kind of

481
00:26:50.130 --> 00:26:54.420
aspect rewriting, I have kind
of come up well, you

482
00:26:54.420 --> 00:26:55.770
know, a lot of other
people have it too, that

483
00:26:55.830 --> 00:26:59.520
the shortest way to write
this pattern. Right. But you

484
00:26:59.520 --> 00:27:02.550
mentioned like combining, combining properties
together. And that's one other

485
00:27:02.550 --> 00:27:06.660
interesting thing that, that I've
kind of the reactive extensions

486
00:27:06.660 --> 00:27:10.080
really help you with is,
is one thing that almost

487
00:27:10.080 --> 00:27:13.560
the most interesting thing about
reactive UI is taking a

488
00:27:13.560 --> 00:27:15.840
property and turning it into
observable. So I want to

489
00:27:15.840 --> 00:27:18.150
listen to when a property
changes and you can also

490
00:27:18.150 --> 00:27:20.820
do the opposite. You can
take an observable and turn

491
00:27:20.820 --> 00:27:22.710
it into a property. And
this is really useful for

492
00:27:22.710 --> 00:27:29.850
like, like output properties. Like
for example, you have say

493
00:27:29.850 --> 00:27:33.360
a color picker, right? And
so you have red, green,

494
00:27:33.360 --> 00:27:37.380
blue, three boxes, and then
you have, you need to

495
00:27:37.380 --> 00:27:40.380
draw the actual color. Right?
And so the color is

496
00:27:40.380 --> 00:27:43.050
going to change when either
the red, the green or

497
00:27:43.050 --> 00:27:45.840
the blue change. And so
you could make, you can

498
00:27:45.840 --> 00:27:49.530
make an observable that combines
the properties, red, green, blue

499
00:27:49.530 --> 00:27:53.760
text boxes, and then output
a color. And so, but

500
00:27:53.760 --> 00:27:56.310
WPF needs needs a property
to buy into it. Doesn't

501
00:27:56.310 --> 00:27:58.380
know how to bind to
observables. And so one of

502
00:27:58.380 --> 00:28:00.150
the things we provide is
a way to take an

503
00:28:00.150 --> 00:28:02.760
observable and put it into,
I kind of call it

504
00:28:02.760 --> 00:28:05.880
an output property. It's kind
of like this, this thing

505
00:28:05.880 --> 00:28:09.450
that you can't set, but
it's going to change. And

506
00:28:09.450 --> 00:28:13.050
then WPF will say, Oh
yeah, this property changed. So

507
00:28:13.050 --> 00:28:18.180
it's taking these three, three
discrete individual properties and then

508
00:28:18.180 --> 00:28:21.540
combining them together and then
notifying WPF when it changes.

509
00:28:22.520 --> 00:28:24.620
That's interesting. I could see
that being useful for date

510
00:28:24.620 --> 00:28:27.770
times, if you've got five
or six text boxes that

511
00:28:27.770 --> 00:28:31.130
all represent a daytime in
aggregate, you could assemble a

512
00:28:31.130 --> 00:28:33.710
date from a bunch of
text boxes. That's an interesting

513
00:28:33.710 --> 00:28:35.630
way to do what in,
in the, in the MPC

514
00:28:35.630 --> 00:28:37.550
and the asp.net MVC, where
we would call like a

515
00:28:37.550 --> 00:28:40.970
custom model binder, where we
have something coming in on

516
00:28:40.970 --> 00:28:44.390
the input that can't be
easily explained in a single

517
00:28:44.390 --> 00:28:48.050
text box or in a
single piece of, of name

518
00:28:48.050 --> 00:28:53.510
value. Yeah. Yeah. It's kind
of, if you use Silverlight

519
00:28:53.510 --> 00:28:56.450
and WPF, you have this
high value converter, right. That

520
00:28:56.450 --> 00:28:59.300
lets you just take a
type or take one property

521
00:28:59.300 --> 00:29:01.730
and then turn it into
another one, but kind of

522
00:29:01.820 --> 00:29:04.940
the reactive extensions lets you
build these super powered. I

523
00:29:04.940 --> 00:29:08.810
value converters that can, you
know, convert all kinds of

524
00:29:08.810 --> 00:29:13.220
different things and combine things
together in interesting ways. It's

525
00:29:13.220 --> 00:29:15.950
kind of a just-in-time I
value converter. I've written a

526
00:29:15.950 --> 00:29:19.340
number of I value converters
that do like bullying, divisible

527
00:29:19.340 --> 00:29:22.910
or bullying, you know, or
visible to re had this

528
00:29:22.910 --> 00:29:25.510
one. That was actually, there's
an interesting question. So what

529
00:29:25.510 --> 00:29:29.860
was working on this windows
seven phone application and I

530
00:29:29.870 --> 00:29:32.960
have a flag in my
view model that indicates whether

531
00:29:32.960 --> 00:29:36.260
or not an article has
been read and I wanted

532
00:29:36.260 --> 00:29:41.440
to present a style and
basically change the color of

533
00:29:41.440 --> 00:29:42.940
an item based on whether
or not it had been

534
00:29:42.940 --> 00:29:46.720
read or not. And it
became this whole complicated creation

535
00:29:46.720 --> 00:29:49.570
of like I value converter.
And then there was a,

536
00:29:50.090 --> 00:29:54.550
a big style binding expression.
And all I really wanted

537
00:29:54.550 --> 00:29:56.680
to do was turn this
thing blue when that Boolean

538
00:29:56.680 --> 00:29:59.890
is true and it ended
up being like 19 lines

539
00:29:59.890 --> 00:30:01.900
of code, it felt gross
and I can't help, but

540
00:30:01.900 --> 00:30:08.460
thinking it's probably slow too.
Yeah. So, so in, in,

541
00:30:08.520 --> 00:30:12.060
in, in react to the
UI, you just say observable

542
00:30:12.060 --> 00:30:16.500
from property, the bul.select, right.
Cause we want to take

543
00:30:16.500 --> 00:30:18.570
whenever the bul changes and
then kind of make a

544
00:30:18.570 --> 00:30:22.110
new thing and then select
maybe a style name and

545
00:30:22.110 --> 00:30:25.140
then we say.to property and
then that would send it

546
00:30:25.500 --> 00:30:29.700
to a certain property. Maybe
we call it like red

547
00:30:29.700 --> 00:30:34.680
style or something like that.
Right. And is this slow?

548
00:30:34.980 --> 00:30:37.290
I mean like they're there
whenever I have a library

549
00:30:37.290 --> 00:30:40.890
that gets sufficiently far away
from the low level stuff,

550
00:30:40.920 --> 00:30:44.160
I start to worry that,
you know, observable for property,

551
00:30:44.160 --> 00:30:46.650
you know, making something from
something else that sounds like

552
00:30:46.650 --> 00:30:50.400
that would be slow on
a phone. So I haven't

553
00:30:50.400 --> 00:30:53.670
done too much testing on,
on phone performance. I've definitely

554
00:30:53.670 --> 00:30:55.620
done a lot of profiling
to see like how can

555
00:30:55.620 --> 00:30:59.190
I make sure that we're
not, you know, allocating objects

556
00:30:59.190 --> 00:31:00.810
that we don't need to
and things like this, but

557
00:31:01.290 --> 00:31:05.280
I built this program that
it would, one of the

558
00:31:05.280 --> 00:31:07.830
things aspects of it was
it would display this number,

559
00:31:07.830 --> 00:31:10.020
counting up really fast, you
know, like if you're using

560
00:31:10.680 --> 00:31:13.290
like a gas gauge, right.
And you'll see like the

561
00:31:13.290 --> 00:31:15.750
number like spin up as
fast as a candidate originally,

562
00:31:15.750 --> 00:31:16.950
I thought I was going
to have to go really

563
00:31:16.950 --> 00:31:19.800
low level and like override
the render and like do

564
00:31:19.800 --> 00:31:22.200
all this crazy stuff. But
originally I was just like,

565
00:31:22.200 --> 00:31:24.060
okay, let's write it. Let's
write it the easy way,

566
00:31:24.330 --> 00:31:26.820
you know, and just see
how bad it is basically.

567
00:31:27.810 --> 00:31:30.870
And actually because of, because
of the GPU acceleration and,

568
00:31:30.870 --> 00:31:33.930
and how well this binding
stuff works. And actually it

569
00:31:33.930 --> 00:31:36.900
wasn't bad at all. Right.
It was updating, I think

570
00:31:36.900 --> 00:31:41.070
every 200 milliseconds and, and
the CPU usage was like

571
00:31:41.070 --> 00:31:45.720
6% and it wasn't bad
at all. So I was

572
00:31:45.720 --> 00:31:48.600
actually surprised that that sometimes
it will matter, right. If

573
00:31:48.600 --> 00:31:51.180
I was building like a
S like, you know, something

574
00:31:51.180 --> 00:31:53.490
that operating on a S
on the stock exchange change,

575
00:31:53.490 --> 00:31:57.810
I'd probably hit that limit.
Right. But I think for

576
00:31:57.810 --> 00:32:00.420
a lot of people's programs,
so you can write it

577
00:32:00.420 --> 00:32:01.920
that way, but it's the
same thing with link, right.

578
00:32:02.220 --> 00:32:06.330
You know, link has a
performance penalty and you write

579
00:32:06.330 --> 00:32:09.930
it the elegant easy to
read maintainable way. And then

580
00:32:10.770 --> 00:32:12.810
you profile to find the
bits that you really need

581
00:32:12.810 --> 00:32:17.460
to rewrite is as four
loops and, and ugly. All

582
00:32:17.460 --> 00:32:20.340
right. So is there a
sample? I mean, I understand

583
00:32:20.340 --> 00:32:23.820
that anyone can download a
library, but where's the canonical,

584
00:32:24.390 --> 00:32:27.810
you know, application is full
of text boxes and examples.

585
00:32:28.290 --> 00:32:30.450
Have you, have you made
like an address, an address

586
00:32:30.870 --> 00:32:32.850
book or something that uses
all of these features in

587
00:32:32.850 --> 00:32:34.740
a, in an appropriate way
that will teach me just

588
00:32:34.740 --> 00:32:37.920
by reading the code? Yeah.
So I wrote a sample

589
00:32:37.920 --> 00:32:40.700
and I'm working on writing
another, or there's, there's a

590
00:32:40.700 --> 00:32:44.990
windows phone sample, a WPF
sample. And I'm actually working

591
00:32:44.990 --> 00:32:48.170
on writing a third sample
based on Scott. I know

592
00:32:48.170 --> 00:32:51.920
you've heard of the Pomodoro
timers, right. Where you have

593
00:32:51.920 --> 00:32:54.890
this work for 25 minutes
and then break for five

594
00:32:54.890 --> 00:32:58.430
minutes. And so I'm working
on writing a program that

595
00:32:58.490 --> 00:33:01.640
not only does that with
the reactive extensions, it also

596
00:33:01.640 --> 00:33:06.740
tests it. And so you
can imagine testing it. What

597
00:33:06.890 --> 00:33:09.590
would kind of be a
little difficult, right? Because, because

598
00:33:09.590 --> 00:33:12.050
you'd have to wait a
lot of time, right. Because

599
00:33:12.050 --> 00:33:14.300
it's a timer, right. Your
start in the new weight,

600
00:33:14.300 --> 00:33:16.760
and then you can hit
pause and then start again.

601
00:33:18.170 --> 00:33:21.060
But the reactive extension has
this really cool thing. And

602
00:33:21.080 --> 00:33:23.390
I actually describe it in
a, in a blog post

603
00:33:23.750 --> 00:33:25.580
where you can test things
that would normally take a

604
00:33:25.580 --> 00:33:31.070
lot of time instantly like
running in and simulating time

605
00:33:31.070 --> 00:33:34.910
passing. Right. Which is really
cool because you can take

606
00:33:34.910 --> 00:33:36.320
tests that would normally have
to have a lot of

607
00:33:36.320 --> 00:33:39.470
sleeps and kind of like
delays or, or call out

608
00:33:39.470 --> 00:33:41.270
to some web service and
takes a lot of time

609
00:33:41.570 --> 00:33:45.020
and you can fake them
out and make your tests

610
00:33:45.020 --> 00:33:47.210
run at full speed, which
is really cool. Like I

611
00:33:47.240 --> 00:33:51.110
discovered that a while back
and suddenly my, my really

612
00:33:51.380 --> 00:33:56.060
unreliable thread dot sleep tests
turned into really, really clean

613
00:33:56.060 --> 00:34:01.000
fast tests, which was really
cool. Okay, excellent. Well, I'm

614
00:34:01.010 --> 00:34:02.570
gonna go check this out.
I'm very excited that it's

615
00:34:02.570 --> 00:34:05.510
in new get that makes
me feel very positive and

616
00:34:05.510 --> 00:34:07.820
I look forward to seeing
your current sample. And then

617
00:34:07.820 --> 00:34:11.930
you're the one that you're
on the way. Yep. Does

618
00:34:11.930 --> 00:34:14.120
this have a home, like
a top level domain, or

619
00:34:14.120 --> 00:34:16.580
we find this a deep
in a, in get hub

620
00:34:16.580 --> 00:34:20.780
somewhere. It is currently deep
in get hub. I really

621
00:34:20.840 --> 00:34:24.140
shouldn't register a top level
domain, but right now the

622
00:34:24.140 --> 00:34:25.790
get hub page is the
best one. And it links

623
00:34:25.790 --> 00:34:27.800
to my blog. I write
a lot about the reactive

624
00:34:27.800 --> 00:34:32.180
extensions and about applying it
to you user interfaces. So,

625
00:34:32.720 --> 00:34:34.370
so it's a good place
to like, at least see

626
00:34:34.370 --> 00:34:37.400
what you can do with
the reactive extensions. I think

627
00:34:37.400 --> 00:34:38.690
a lot of people are
like, well, how can I

628
00:34:38.690 --> 00:34:41.420
use this? Like, so I
think it gives a lot

629
00:34:41.420 --> 00:34:43.160
of people, at least a
lot of ideas, even if

630
00:34:43.160 --> 00:34:47.000
they're not interested in the
actual code. Very cool. Well,

631
00:34:47.000 --> 00:34:50.060
I will add links to
the, to your blog, to

632
00:34:50.060 --> 00:34:53.990
the library. There's also a,
a video of you explaining

633
00:34:53.990 --> 00:34:58.700
this online for the checkout.
And hopefully before this show

634
00:34:58.700 --> 00:35:01.250
goes live, you'll spend $5
and buy a domain. So

635
00:35:01.430 --> 00:35:05.960
otherwise someone. All right. Sounds
good. Very cool. Thanks Paul,

636
00:35:05.960 --> 00:35:09.770
for talking to us today.
Yeah. Thanks a lot. This

637
00:35:09.770 --> 00:35:12.620
has been another episode of
Hansel minutes. We'll see you

638
00:35:12.620 --> 00:35:13.340
again next week.


WEBVTT FILE

1
00:00:00.630 --> 00:00:03.750
Hi, this is Scott. I
really appreciate our sponsors because

2
00:00:03.750 --> 00:00:07.080
they make the show possible.
Today's show is sponsored by

3
00:00:07.080 --> 00:00:11.340
Tellerik create compelling app experiences
across any screen with the

4
00:00:11.340 --> 00:00:16.200
Tellerik platform Telerx end to
end platform. Uniquely combines industry

5
00:00:16.200 --> 00:00:19.890
leading UI tools with cloud
services to simplify the entire

6
00:00:19.890 --> 00:00:24.390
app development cycle Tellerik offers
everything.net developers need to build

7
00:00:24.390 --> 00:00:33.810
quality apps faster. Try it
free at tellerik.com/platform that's tellerik.com/platform.

8
00:00:35.520 --> 00:00:37.590
One more thing. Let me
tell you about a new

9
00:00:37.590 --> 00:00:41.820
sponsor Reagan. If you're wanting
to detect and diagnose errors

10
00:00:41.820 --> 00:00:44.550
and crashes in your software,
even find problems that you

11
00:00:44.550 --> 00:00:47.940
didn't know existed to improve
your software and Ray gun

12
00:00:47.940 --> 00:00:50.130
might be perfect for you.
He had a few lines

13
00:00:50.130 --> 00:00:52.620
of code your application, and
in minutes, you'll get real

14
00:00:52.620 --> 00:00:55.560
time error reports with all
the information that you need

15
00:00:55.560 --> 00:00:58.320
to fix bugs fast, you
can even hook it up

16
00:00:58.320 --> 00:01:02.700
to your team chat, bug
tracking development, workflow tools, Reagan

17
00:01:02.700 --> 00:01:07.470
covers all major web and
mobile programming languages, including.net, the

18
00:01:07.470 --> 00:01:11.070
full Xamarin stack JavaScript, and
many more. Go check out

19
00:01:11.070 --> 00:01:16.590
Reagan today@reagan.io. I use this
myself on my little startup

20
00:01:16.950 --> 00:01:19.920
and I really, really recommend
this product. It is a

21
00:01:19.920 --> 00:01:39.890
great, great product. Check it
out. Ray gun@reagan.io. <inaudible> From

22
00:01:39.890 --> 00:01:44.990
Hansel minutes.com. It's Hanselman. It's
a weekly discussion with web

23
00:01:44.990 --> 00:01:49.940
developer and technologist Scott Hanselman.
This is Lawrence Ryan announcing show

24
00:01:49.940 --> 00:01:54.020
number four 83. In this
episode, Scott talks with Mario

25
00:01:54.020 --> 00:02:02.240
Heuer about debugging windows problem.
This is Scott Hanselman. This

26
00:02:02.240 --> 00:02:04.760
is another episode of Hansel
minutes. And today I'm chatting

27
00:02:04.760 --> 00:02:08.210
with Mario Hewitt and you
are an a, would you

28
00:02:08.210 --> 00:02:11.750
say you're an expert in
debugging.net issues and production? Oh,

29
00:02:11.780 --> 00:02:14.690
Hey Scott, I'm an expert.
No, I don't. I wouldn't

30
00:02:14.690 --> 00:02:17.480
say an expert. Are you
experienced, what is unique about

31
00:02:17.480 --> 00:02:21.170
your experience in debugging? Things
like this? Oh, it's been

32
00:02:21.170 --> 00:02:24.050
a passion of mine for
a long, long time. I'm

33
00:02:24.320 --> 00:02:27.290
pretty much insight kind of
started at at Microsoft. And

34
00:02:28.340 --> 00:02:32.570
it's interesting. The debugging per
se, or the tool that

35
00:02:32.570 --> 00:02:35.030
we call the debugger is
kinda has a bad rep,

36
00:02:35.060 --> 00:02:37.910
so to speak because most
of the time when people

37
00:02:38.660 --> 00:02:41.540
have to use it is
because you need to figure

38
00:02:41.540 --> 00:02:44.840
out what you did wrong.
And I certainly do my

39
00:02:44.840 --> 00:02:47.210
fair share of that as
well. But over the years,

40
00:02:47.210 --> 00:02:50.570
what I've done is I've
used these debuggers to help

41
00:02:50.570 --> 00:02:55.880
me understand the internals of
whatever abstraction I'm working with.

42
00:02:55.880 --> 00:03:00.100
So for example, you know,
the windows, how the heat

43
00:03:00.100 --> 00:03:03.670
Works, or in the case
of.net, you can understand how

44
00:03:03.670 --> 00:03:07.240
the, the managed heap and
the garbage collection. And so

45
00:03:08.830 --> 00:03:11.640
I like the debugger. I've
always, always liked it. It's

46
00:03:11.640 --> 00:03:15.340
it's helped me fix my
stuff. And it's really helped

47
00:03:15.340 --> 00:03:17.500
me gain a lot of
insight into the inner workings

48
00:03:17.500 --> 00:03:21.540
of, of the system. Do
you think it's super important

49
00:03:21.540 --> 00:03:23.700
for people to understand these
things? Cause I feel like

50
00:03:23.700 --> 00:03:27.060
there's a, you know, there's
a, a class of, of

51
00:03:27.060 --> 00:03:29.910
developer who really just, they
use the product and they

52
00:03:29.910 --> 00:03:32.100
kind of, if it works
great and if it doesn't,

53
00:03:32.130 --> 00:03:34.140
well, I don't know what
happened. It's a black box

54
00:03:34.140 --> 00:03:36.510
I'm, I'm lost. And then
there's a class of people

55
00:03:36.510 --> 00:03:39.510
who, who want to, you
know, look underneath and see

56
00:03:39.510 --> 00:03:42.960
what's inside. Yeah, no, I
mean, that's, that's a, that's

57
00:03:42.960 --> 00:03:47.130
a very good point for
look back in the days

58
00:03:47.130 --> 00:03:52.650
when, in the case of
memory, before we had.net as

59
00:03:52.650 --> 00:03:54.720
trivial as it sounds that
I'm going to allocate them

60
00:03:54.720 --> 00:03:56.580
for something, it was actually
the source of a lot

61
00:03:56.580 --> 00:03:59.550
of, a lot of problems,
right. And what we ended

62
00:03:59.550 --> 00:04:02.700
up doing with.net. And we
said, we said, let's get

63
00:04:02.700 --> 00:04:04.800
rid of all those problems.
We just kind of automatically

64
00:04:04.800 --> 00:04:07.590
do all this for you.
And, and so we made

65
00:04:07.590 --> 00:04:09.870
it really simple. You don't
have to worry about it

66
00:04:09.870 --> 00:04:14.370
anymore, but as with anything
else, I think at the

67
00:04:14.370 --> 00:04:15.840
end of the day, we're
just working sort of with

68
00:04:15.840 --> 00:04:20.130
an abstraction, that's doing things
for you. And you may

69
00:04:20.130 --> 00:04:22.650
end up in these sort
of edge cases or corner

70
00:04:22.650 --> 00:04:27.570
cases of the obstruction. And
unless you understand how it

71
00:04:27.600 --> 00:04:29.760
works, so you can really
get yourself into trouble. So

72
00:04:29.760 --> 00:04:31.440
it's a little bit of
a double edged sword making

73
00:04:31.440 --> 00:04:34.590
things easier. But at the
same time, when you do

74
00:04:34.590 --> 00:04:38.400
step outside of those boundaries
and you don't have the

75
00:04:38.400 --> 00:04:40.350
knowledge of the internals, then
it gets really, really tough.

76
00:04:41.010 --> 00:04:45.750
Yeah. There's this ongoing phrase
or joke that I've told

77
00:04:45.750 --> 00:04:47.790
for years. And I think
people have heard it so

78
00:04:47.790 --> 00:04:50.160
many times from me that
they're tired of it, but

79
00:04:50.220 --> 00:04:52.770
it's still appropriate in this
instance, which is, you know,

80
00:04:52.980 --> 00:04:58.290
each additional layer of abstraction
is indistinguishable from magic. You

81
00:04:58.290 --> 00:05:00.690
know, it really is right.
That the garbage question, the

82
00:05:00.690 --> 00:05:04.770
garbage collector is magic. And
I've always felt that they

83
00:05:04.770 --> 00:05:08.670
taught us assembler in school
so that we would know

84
00:05:08.670 --> 00:05:11.040
how hard it was and
how magical it all is.

85
00:05:11.100 --> 00:05:14.220
And then they would give
us each additional layer of

86
00:05:14.220 --> 00:05:17.720
abstraction. They would give a
C and then we'd go,

87
00:05:17.760 --> 00:05:19.980
Oh, that really kind of
sucked. And then they give

88
00:05:19.980 --> 00:05:23.640
us C plus plus, and
then we're like, yeah, that

89
00:05:23.640 --> 00:05:25.380
kind of sucks. And you
know, it would go like

90
00:05:25.380 --> 00:05:26.970
that and we'd go all
the way up. And now

91
00:05:26.970 --> 00:05:30.720
we can just start Willy
nilly, just make an objects

92
00:05:30.720 --> 00:05:32.700
and huge graphs of objects.
And we don't even think

93
00:05:32.700 --> 00:05:34.680
about like most of us
don't even think about memory

94
00:05:34.680 --> 00:05:38.880
management and it's all wonderful
until it completely doesn't work.

95
00:05:39.780 --> 00:05:42.210
And then you either know
the layer of abstraction or

96
00:05:42.210 --> 00:05:44.940
you're just stuck forever. Yeah,
yeah, no, that's, I think

97
00:05:45.170 --> 00:05:51.660
that's, that's very, very accurate.
Right. And it's, you don't

98
00:05:51.660 --> 00:05:55.560
have to necessarily delve super
deep into it. Right. There,

99
00:05:55.620 --> 00:05:58.220
there are certain things that
at a surface layer that

100
00:05:58.220 --> 00:06:00.950
you have to understand what
the carpet's collector is doing

101
00:06:01.580 --> 00:06:04.670
so that when you get
into these cases, you have

102
00:06:04.670 --> 00:06:09.190
the ability to, to resolve
it. Yeah. The, how far

103
00:06:09.190 --> 00:06:10.840
should we be able to
go though? Because I feel

104
00:06:10.840 --> 00:06:13.750
like, you know, some of
the diagnostics and tools in

105
00:06:13.750 --> 00:06:17.410
visual studio are useful, but
should every developer who's writing

106
00:06:17.410 --> 00:06:21.280
a basic website, have to
go into wind DBG, you

107
00:06:21.280 --> 00:06:26.650
know, how far down do
you go? Yeah. You know,

108
00:06:26.650 --> 00:06:29.590
the it's, it's kind of
what you were talking about

109
00:06:29.590 --> 00:06:32.740
before is, is you today.
I open up the us,

110
00:06:32.740 --> 00:06:36.490
you know, and I do
a new website that's hosted

111
00:06:36.490 --> 00:06:39.280
on Azure and I go
crazy. And I do all

112
00:06:39.280 --> 00:06:41.170
these things. I have no
idea what am I allocating

113
00:06:41.170 --> 00:06:47.380
or how it's being managed.
And when bad things happen,

114
00:06:47.770 --> 00:06:52.360
the, you are driven by
necessity to go as deep

115
00:06:52.470 --> 00:06:55.210
as, as you must be
able to get your app

116
00:06:55.450 --> 00:06:57.430
back up and running. Right.
I mean, that's, that's really

117
00:06:57.430 --> 00:06:59.590
what it sort of boils
down to a lot of

118
00:06:59.590 --> 00:07:02.380
the things that I end
up debugging when it comes

119
00:07:02.380 --> 00:07:07.720
to memory issues, you know,
we're not talking about my

120
00:07:07.750 --> 00:07:11.680
sort of hosted blog somewhere.
We're talking about major sort

121
00:07:11.680 --> 00:07:15.640
of enterprise customers and they
just, they can't afford when

122
00:07:15.640 --> 00:07:19.930
they're mission critical apps go
down. And, and it really

123
00:07:19.930 --> 00:07:21.640
just at that point, it's
you go as deep as

124
00:07:21.640 --> 00:07:25.000
you must. Right. Is it
usually just one small thing?

125
00:07:25.000 --> 00:07:27.610
Like if you have some
giant production site, you know,

126
00:07:27.670 --> 00:07:30.340
big, big company or big
co as we like to

127
00:07:30.340 --> 00:07:33.040
say, so you're, you're onsite
at big co and you're

128
00:07:33.040 --> 00:07:35.470
debugging their system and something's
not right. Let's say that

129
00:07:35.470 --> 00:07:39.100
every three hours it hangs
and then you have to

130
00:07:39.100 --> 00:07:40.360
go and debug that and
figure it out. And you

131
00:07:40.360 --> 00:07:42.520
find out that you could
find that, Oh, well, this

132
00:07:42.520 --> 00:07:46.240
object is not getting collected
or the garbage collectors stuck

133
00:07:46.330 --> 00:07:49.180
every three hours because of
something. And then you fix

134
00:07:49.180 --> 00:07:52.060
that one issue, that spot
issue. But then there's also

135
00:07:52.060 --> 00:07:55.750
the chance that you might
discover a fundamental misunderstanding or

136
00:07:55.750 --> 00:07:59.620
mistake architecturally. And they've, you
know, you found a bandaid

137
00:08:00.100 --> 00:08:04.030
on cancer, but their application
is simply wrong. And how

138
00:08:04.030 --> 00:08:06.580
often does that happen? But
you know, that, that happens

139
00:08:06.580 --> 00:08:10.780
quite a bit because I
usually have to dive kind

140
00:08:10.780 --> 00:08:14.710
of deep into their applications.
So for example, when I'm

141
00:08:14.710 --> 00:08:17.350
using these things called memory
dumps and stuff like that,

142
00:08:17.740 --> 00:08:19.750
I usually end up finding
what you were talking about.

143
00:08:19.780 --> 00:08:21.940
Right? You have a gazillion
objects of this type. And

144
00:08:21.940 --> 00:08:24.910
so, you know, if you
do this, that will go

145
00:08:24.910 --> 00:08:28.150
away. But during that investigation,
yeah, absolutely. I ended up

146
00:08:28.150 --> 00:08:30.730
finding, you know, things here
and things there. And sometimes

147
00:08:30.790 --> 00:08:35.020
as, as bad as you
mentioned that, that the overall

148
00:08:35.020 --> 00:08:40.600
architecture is, is broken. Right.
And all we're doing, like

149
00:08:40.600 --> 00:08:44.500
you said, is we're band-aiding
into that point. But yeah,

150
00:08:44.530 --> 00:08:46.990
I do end up finding
a lot of different things

151
00:08:46.990 --> 00:08:48.970
as part of my investigations.
And, you know, obviously those

152
00:08:48.970 --> 00:08:54.280
are sort of brought, brought
to light and you know,

153
00:08:54.280 --> 00:08:56.370
it, it, it depends on
who you're working with and,

154
00:08:56.370 --> 00:08:58.920
and, and things like that.
But sometimes they address those

155
00:08:58.920 --> 00:09:00.660
other issues as well. And
sometimes it's like, well, as

156
00:09:00.660 --> 00:09:04.200
long as that one bandaid,
right, the biggest issue is,

157
00:09:04.200 --> 00:09:08.550
is, is over. Let's just
run with it. Let's not

158
00:09:08.550 --> 00:09:12.540
necessarily worry about something that
may, may be a problem,

159
00:09:12.540 --> 00:09:14.490
but it may not be
as big of a problem

160
00:09:14.490 --> 00:09:18.200
as our application. Now let's
try to walk through some

161
00:09:18.200 --> 00:09:20.690
of this stuff in a
structured, in a structured way.

162
00:09:21.770 --> 00:09:23.540
We, we all know how
to go and hit F

163
00:09:23.540 --> 00:09:26.930
five and, and, you know,
sit in an interactive debugger.

164
00:09:27.410 --> 00:09:29.840
But we also know that
we can go into task

165
00:09:29.840 --> 00:09:33.530
manager and right click on
something and say, create dump.

166
00:09:34.790 --> 00:09:37.220
What is the difference between
that going into task manager,

167
00:09:37.220 --> 00:09:39.530
right. Clicking saying, create, dump,
what am I looking at

168
00:09:39.530 --> 00:09:41.690
it when I see that?
And then a dump that

169
00:09:41.690 --> 00:09:47.540
might be created on a
crash. Okay. So if we

170
00:09:47.540 --> 00:09:50.690
start with, with the notion
of using visual studio, right,

171
00:09:50.750 --> 00:09:54.200
let's say you had your
little, your mission critical app

172
00:09:54.200 --> 00:09:56.840
out there, and he was
misbehaving. So one of the

173
00:09:56.840 --> 00:09:59.510
options that you have is
using visual studio diagnostics, which

174
00:09:59.510 --> 00:10:03.080
is a phenomenal debugger. I
mean, it's, it's absolutely beautiful,

175
00:10:03.110 --> 00:10:06.680
right? It allows you to
go and look at the

176
00:10:06.680 --> 00:10:09.710
source code calls, tax data
tips, and things like that.

177
00:10:11.330 --> 00:10:14.750
And that works with what
we call live debugging. So

178
00:10:14.750 --> 00:10:18.380
that means your application is,
is, is up there running,

179
00:10:18.380 --> 00:10:22.190
although it's not as healthy
as it could be. And,

180
00:10:22.220 --> 00:10:26.180
but it's still taking requests
like calls or users or

181
00:10:26.180 --> 00:10:28.790
doing things in your app.
So if I take a

182
00:10:28.790 --> 00:10:30.800
visual studio and I say,
Hey, I'm going to go

183
00:10:30.800 --> 00:10:34.910
in and debug that application,
what ends up happening is

184
00:10:35.090 --> 00:10:39.170
everything pauses, Right? It's a
single threaded thing. One, you

185
00:10:39.170 --> 00:10:42.800
stop the process and a
debugger attaches to it. And

186
00:10:42.800 --> 00:10:45.680
no one else can look
at this application while you're

187
00:10:45.680 --> 00:10:48.620
doing your debugging exit. Exactly.
And so if your application

188
00:10:48.950 --> 00:10:52.040
is, I dunno, a credit
card, transaction and system, that's

189
00:10:52.040 --> 00:10:55.790
making you million dollars an
hour. If it's going to

190
00:10:55.790 --> 00:11:00.470
take you 10 hours to,
to do lab debugging, you've

191
00:11:00.470 --> 00:11:04.940
lost a lot of money,
right. So that's usually, I'd

192
00:11:04.940 --> 00:11:07.280
say, I'd go. As far
as 99% of the time,

193
00:11:07.460 --> 00:11:09.290
that's not out of the
gate, it's not an option.

194
00:11:09.290 --> 00:11:13.550
Right. And so what ends
up happening then is, well,

195
00:11:13.910 --> 00:11:16.430
the application is steadily getting
worse and worse and worse.

196
00:11:16.940 --> 00:11:19.550
So when it gets to
a point where it's really

197
00:11:19.550 --> 00:11:23.780
bad, it simply gets restarted.
Right. That's kind of the

198
00:11:23.780 --> 00:11:27.260
mitigation. So that's the, in
the old days in I

199
00:11:27.290 --> 00:11:29.450
and the IAS world, I
would see people putting in

200
00:11:29.450 --> 00:11:33.200
a recycle time on, they
would recycle the app pool

201
00:11:33.200 --> 00:11:36.920
every four hours. Exactly. And
that's basically a declaration that

202
00:11:36.920 --> 00:11:38.990
my application sucks, but I
really don't know why, but

203
00:11:38.990 --> 00:11:43.130
it mostly works. So we'll
just torch it and start

204
00:11:43.130 --> 00:11:46.160
over every few hours. Exactly.
Right. And, and that might

205
00:11:46.160 --> 00:11:50.240
be that the problem manifests
itself over several weeks, or

206
00:11:50.240 --> 00:11:52.250
it could be that it's
as quick as, you know,

207
00:11:52.250 --> 00:11:56.830
maybe twice a day, something
like that. Right. But that

208
00:11:56.830 --> 00:12:00.850
still presents a challenge for
us as, as, as owners

209
00:12:00.850 --> 00:12:04.150
of the code behind that
app. Because even though a

210
00:12:04.150 --> 00:12:08.440
restart sounds innocent enough, you
are still during a restart,

211
00:12:08.440 --> 00:12:10.960
you have an interruption of
some sort, right. The app

212
00:12:10.960 --> 00:12:12.820
goes down and it comes
back up. And during that

213
00:12:12.820 --> 00:12:19.180
time it's not servicing. Right.
Right. Yeah. And, and as

214
00:12:19.180 --> 00:12:21.880
developers, as owners of that
app, well, we obviously feel

215
00:12:21.880 --> 00:12:25.120
very responsible cause we're passionate
developers and we want to

216
00:12:25.120 --> 00:12:27.130
get to root. Cause we
don't want to be the

217
00:12:27.130 --> 00:12:31.720
reason why we have a
five minute, you know, pause

218
00:12:31.750 --> 00:12:34.930
when the restart happens. And
so we're left with trying

219
00:12:34.930 --> 00:12:37.630
to figure out a different
way besides live debugging that

220
00:12:37.630 --> 00:12:43.270
doesn't stop the restart process,
but it should give us

221
00:12:43.270 --> 00:12:45.100
information that we can kind
of look at on the

222
00:12:45.100 --> 00:12:49.990
side. Right. And that's what
we refer to. As, as

223
00:12:49.990 --> 00:12:52.720
you mentioned, in task manager,
memory dumps or crash dumps,

224
00:12:53.830 --> 00:12:57.670
that's basically the ability to
S to, to take an

225
00:12:57.670 --> 00:13:02.920
application and say, write everything
that is in memory for

226
00:13:02.920 --> 00:13:05.940
this application out to a
file. And this is like,

227
00:13:05.970 --> 00:13:08.160
it's like a pause, right?
You're you're not just setting

228
00:13:08.160 --> 00:13:10.530
a break point on a
line it's as if you're

229
00:13:10.530 --> 00:13:13.140
setting as many break points
as there are threads, and

230
00:13:13.140 --> 00:13:15.690
you're saying everybody stop, and
then you freeze dry it

231
00:13:15.750 --> 00:13:18.900
like, like in drastic park,
right. The bug gets stuck

232
00:13:18.900 --> 00:13:21.600
in Amber, you take the
entire process and you freeze.

233
00:13:22.230 --> 00:13:26.070
Exactly. Exactly. So is it
like, like when I debug,

234
00:13:26.100 --> 00:13:28.440
I am usually debugging it
and I'm thinking in the

235
00:13:28.440 --> 00:13:30.720
context of one thread, but
if I have a dump,

236
00:13:30.750 --> 00:13:32.910
I can jump between threads
and see, where did I

237
00:13:32.910 --> 00:13:34.920
end up stopping on that
thread or that thread or

238
00:13:34.920 --> 00:13:38.760
that Right. Yep. You, you,
you pretty much have complete

239
00:13:38.910 --> 00:13:42.630
access to all the threads,
all the memory that the,

240
00:13:42.630 --> 00:13:46.050
that the process was consuming.
The, the key difference though,

241
00:13:46.050 --> 00:13:48.930
that I should mention here
in relationship to live debugging

242
00:13:48.930 --> 00:13:52.370
is that it is a
static snapshot in time, the,

243
00:13:52.370 --> 00:13:56.190
the dump. So you are,
you, you're not able to

244
00:13:56.190 --> 00:13:59.400
open up the dump and
control execution as he couldn't

245
00:13:59.400 --> 00:14:01.320
live debugging in the sense
that you can't set a

246
00:14:01.320 --> 00:14:04.020
break point and tell it
to resume. Right. Because it's

247
00:14:04.020 --> 00:14:09.990
really just a memory dumper
say, yeah, it's a moment.

248
00:14:10.830 --> 00:14:16.020
Exactly. And, and, you know,
sometimes when you first tell

249
00:14:16.230 --> 00:14:18.180
engineers about this, they're like,
well, how useful can that

250
00:14:18.180 --> 00:14:20.280
be? Right. I mean, I
need my five. I need

251
00:14:20.280 --> 00:14:22.830
my, you know, setting breakpoints
that I can see what's

252
00:14:22.830 --> 00:14:27.360
happening. And it's a little
more painful than live debugging,

253
00:14:27.390 --> 00:14:31.560
but a lot of problems,
surprisingly, a lot of problems

254
00:14:31.560 --> 00:14:36.120
can be troubleshot by, by
using memory dumps alone. Why

255
00:14:36.120 --> 00:14:39.840
do you think that there
is a perceived chasm or

256
00:14:39.840 --> 00:14:43.920
gap between live debugging, which
seems very accessible and understandable

257
00:14:44.310 --> 00:14:50.490
and dumped debugging, which seems
like magic Gap in the

258
00:14:50.490 --> 00:14:53.000
sense of there's a gap
And under like, like an

259
00:14:53.000 --> 00:14:55.130
accessibility, like I could feel
like I could sit down

260
00:14:55.130 --> 00:14:57.770
with my eight year old
and say, yeah, you push

261
00:14:57.800 --> 00:15:00.350
play. It's just like a
VCR and you set a

262
00:15:00.350 --> 00:15:02.510
break point and then you
go step, step, step, but

263
00:15:02.510 --> 00:15:06.140
then you hit play again.
Like that makes sense. But

264
00:15:06.350 --> 00:15:09.260
for someone to take a
dump and look at it

265
00:15:09.260 --> 00:15:14.990
and say, I can visualize
the procedural instructions. Right. That

266
00:15:14.990 --> 00:15:17.330
takes a whole other way
of thinking, you know what

267
00:15:17.330 --> 00:15:20.000
I mean? You're not just
pausing television and then going

268
00:15:20.000 --> 00:15:22.460
frame by frame, which makes
sense. And then pushing play

269
00:15:22.460 --> 00:15:25.550
and it continues along. You're,
you're looking at a moment

270
00:15:25.550 --> 00:15:28.790
in time and then trying
to imagine what the system

271
00:15:28.790 --> 00:15:32.590
looked like. Yeah. Yeah. That's,
that's absolutely right. So the

272
00:15:34.360 --> 00:15:41.080
it's interesting in the sense
that the dump files that

273
00:15:41.320 --> 00:15:44.560
it's true, the dump files
do require you to have

274
00:15:44.620 --> 00:15:46.870
sort of a different mindset
than what you live debug.

275
00:15:46.870 --> 00:15:48.850
Right. When you live debug,
for example, if you had

276
00:15:48.850 --> 00:15:52.090
a crash, for some reason,
you hit it in the

277
00:15:52.090 --> 00:15:56.200
debugger, it pops open and
you get the call stack

278
00:15:56.200 --> 00:16:00.730
and you can expect things
with dumped debugging while you

279
00:16:00.730 --> 00:16:03.010
might not even be at
the point where that exception

280
00:16:03.010 --> 00:16:05.680
was thrown. Right. Right. Yeah.
That's another issue, right? You're

281
00:16:05.680 --> 00:16:10.030
you could be well before
it, or you could be

282
00:16:11.020 --> 00:16:15.790
long after. And so that
then requires a different mindset

283
00:16:15.790 --> 00:16:19.060
because you can't just simply
say, well, I, none of

284
00:16:19.060 --> 00:16:21.610
the threads in the dump
are currently in the process

285
00:16:21.610 --> 00:16:25.270
of throwing exception. Therefore it
never happened. So you would

286
00:16:25.270 --> 00:16:26.950
have to do things like,
well, let me just go

287
00:16:26.950 --> 00:16:29.650
and look at all the
memory exceptions in dotnet are

288
00:16:29.650 --> 00:16:33.070
really just first-class type citizens.
Right. And so if I

289
00:16:33.070 --> 00:16:35.230
could query the memory in
the dump and say, are

290
00:16:35.230 --> 00:16:38.800
there any instances of a
type exception? And they will

291
00:16:38.800 --> 00:16:41.440
kind of dump all those
out for me. And if

292
00:16:41.440 --> 00:16:43.510
it actually does show something,
well, that's a pretty good

293
00:16:43.660 --> 00:16:47.260
indicator, right? That it's that
an exception at some point

294
00:16:47.260 --> 00:16:52.270
or another did occur. So
it's a matter of, instead

295
00:16:52.270 --> 00:16:55.960
of looking at threads, running
in, like you doing live

296
00:16:55.960 --> 00:16:58.630
debugging, it's a matter of
looking at the state of

297
00:16:58.630 --> 00:17:02.350
memory to come up with
theories about how you ended

298
00:17:02.350 --> 00:17:06.220
up in that bad spot.
Right. And then You hopefully

299
00:17:06.250 --> 00:17:08.350
take, take these dumps as
much as you can in

300
00:17:08.350 --> 00:17:11.260
order to look for the
smoking gun and say, Oh,

301
00:17:11.290 --> 00:17:14.140
we happened to catch it
at that exact moment. Yes,

302
00:17:14.170 --> 00:17:18.070
exactly. Yeah. And to be
honest with its memory, dumps

303
00:17:18.070 --> 00:17:21.220
have gotten such a bad
rep. And you know, when

304
00:17:21.220 --> 00:17:24.190
you're in a scenario, you
need to debug something and

305
00:17:24.190 --> 00:17:26.260
you happen to say, well,
you guys need to go

306
00:17:26.260 --> 00:17:28.420
and get me a memory
dump. And then you see

307
00:17:28.420 --> 00:17:31.960
people running for the door.
Screaming to me, the memory

308
00:17:31.960 --> 00:17:37.280
dump is just another source
of diagnostics data. The, the

309
00:17:37.300 --> 00:17:40.570
unfortunate part is, is that
the experience by which we

310
00:17:40.840 --> 00:17:45.820
look at that data is
not the sexiest experience that

311
00:17:45.820 --> 00:17:48.250
you could have. Right. Well,
that's looking at you, you

312
00:17:48.250 --> 00:17:51.810
get, you can spoil by
visual studio debugging Experience. Yeah,

313
00:17:51.840 --> 00:17:54.750
absolutely. I mean, if I
opened a downfall right now,

314
00:17:54.760 --> 00:17:57.120
my machine and I say,
okay, I just want to

315
00:17:57.120 --> 00:18:01.680
see how many threads there
are. That's the Tilda come

316
00:18:01.680 --> 00:18:05.220
in. I mean, how intuitive
is that? It's completely unintuitive

317
00:18:05.220 --> 00:18:09.180
and that's right. That's the
thing, right? When DBG, or

318
00:18:09.180 --> 00:18:14.160
as my friends call it,
wind bag is completely magic.

319
00:18:14.190 --> 00:18:15.840
Like one of the, you
know, it's always been on

320
00:18:15.840 --> 00:18:18.000
my list of things to
do, like take a Pluralsight

321
00:18:18.000 --> 00:18:20.070
course on how to use
wind DBG because people who

322
00:18:20.160 --> 00:18:23.640
know how to use it,
like test Fernandez. She's amazing.

323
00:18:23.640 --> 00:18:27.030
I've seen her on channel
nine, debug these ridiculous production

324
00:18:27.030 --> 00:18:29.610
issues because it's like watching
someone in the matrix, you

325
00:18:29.610 --> 00:18:31.140
know, and they, like, they
can see all of the,

326
00:18:31.620 --> 00:18:34.020
the hex values are falling.
I'm like, Oh yeah, look,

327
00:18:34.020 --> 00:18:35.730
there's too many hash tables
on the, on the heap.

328
00:18:35.770 --> 00:18:38.950
I'm like, what, what slow
down. Yeah. Yeah, no, it

329
00:18:39.010 --> 00:18:43.080
is really interesting. Like you
you'd go and you tasked

330
00:18:43.080 --> 00:18:46.200
with, you're brought in to
go in and fix this

331
00:18:46.200 --> 00:18:49.080
problem. That application B has.
Right. And the developers that

332
00:18:49.830 --> 00:18:52.830
have been looking at this
for weeks. And so you

333
00:18:52.830 --> 00:18:54.690
come in and you say,
well, let's generate a dump.

334
00:18:54.690 --> 00:18:56.850
You get it. And you
know, you run a couple

335
00:18:56.850 --> 00:19:00.660
of commands and you say,
well, here's your problem. And

336
00:19:00.660 --> 00:19:03.390
it's just, it's amazing to
see the reaction to that.

337
00:19:04.710 --> 00:19:07.260
And that's oftentimes, it's a
starting point for people. They,

338
00:19:07.260 --> 00:19:09.690
they, they realize they can
see the power behind this.

339
00:19:09.690 --> 00:19:12.480
And, and they're willing to
take that, that big learning

340
00:19:12.480 --> 00:19:15.690
curve around the experience. Right.
And, and really start drilling

341
00:19:15.690 --> 00:19:20.310
into it. I want to
take a brief moment to

342
00:19:20.310 --> 00:19:23.940
thank my sponsors sync fusion
this week, the first and

343
00:19:23.940 --> 00:19:27.930
only complete Hadoop distribution designed
for windows is now available

344
00:19:27.930 --> 00:19:31.560
from sync fusion. You can
literally deploy a production ready,

345
00:19:31.560 --> 00:19:35.550
big data cluster in minutes.
This revolutionary big data platform

346
00:19:35.550 --> 00:19:37.500
will not only change the
way that you approach big

347
00:19:37.500 --> 00:19:41.850
data, but it is 100%
free for everyone with free

348
00:19:41.850 --> 00:19:45.540
commercial support for sync fusion,
plus members learn more at

349
00:19:45.540 --> 00:19:54.540
sync, fusion.com/big data. Are there
like example like apps, like

350
00:19:54.630 --> 00:19:56.760
the way that you learn
this stuff is by doing

351
00:19:56.760 --> 00:19:58.350
it in production. But I
wonder if we could have

352
00:19:58.350 --> 00:20:01.680
some apps that were poorly
written on purpose, you know,

353
00:20:01.920 --> 00:20:05.460
what the five or six
or 20 classic debugging things,

354
00:20:06.330 --> 00:20:08.640
and then send someone off
on a, on a, a

355
00:20:08.640 --> 00:20:11.430
lab of some kind with
like, you know, here's how

356
00:20:11.430 --> 00:20:15.050
you use wind DBG to
diagnose something. Yeah, no, I,

357
00:20:15.050 --> 00:20:17.970
I that's absolutely. I think
you mentioned a test verandas

358
00:20:18.000 --> 00:20:21.180
and I think on her
blog, is it it broken?

359
00:20:21.180 --> 00:20:23.190
It is fix it. You
should. I believe that's, that's

360
00:20:23.190 --> 00:20:27.360
her blog and she does
more than just blog. I

361
00:20:27.360 --> 00:20:29.760
mean, she's got labs up
there. I believe where, you

362
00:20:29.760 --> 00:20:34.050
know, she's written a poorly
behaving application and she puts

363
00:20:34.050 --> 00:20:37.200
it out there and kind
of allows people to look

364
00:20:37.200 --> 00:20:39.780
at a real thing. Excellent.
I practice it, this stuff,

365
00:20:39.960 --> 00:20:43.320
I will put her, I
will find those labs and

366
00:20:43.320 --> 00:20:44.670
she's been on the show
before and I'll have her

367
00:20:44.670 --> 00:20:47.320
run again, but I will
put those up on the

368
00:20:47.320 --> 00:20:48.910
show notes because those are,
those are going to be

369
00:20:48.910 --> 00:20:51.730
fantastic. So let's, let's talk
a little bit about the

370
00:20:51.730 --> 00:20:54.550
managed heap and we always
hear about gen one, gen

371
00:20:54.550 --> 00:20:56.980
two and all these generations
of garbage collection. Maybe you

372
00:20:56.980 --> 00:21:00.000
could talk a little bit
about that. Yeah. So the,

373
00:21:01.110 --> 00:21:03.420
if we look at the,
sort of what the fundamental

374
00:21:04.290 --> 00:21:07.620
concept is behind the managed
team or the garbage collector

375
00:21:07.630 --> 00:21:10.920
more specifically, is that I
no longer have to mess

376
00:21:10.920 --> 00:21:14.490
around with a frigging. My
memory that's handled by me

377
00:21:14.490 --> 00:21:18.840
by this thing called the
garbage collector. And if you

378
00:21:18.840 --> 00:21:22.500
look at an application that
allocates a quite a bit

379
00:21:22.500 --> 00:21:27.870
of memory, the garbage collector
is charged with walking, all

380
00:21:27.870 --> 00:21:30.300
of that memory, all of
these objects that you've allocated

381
00:21:31.080 --> 00:21:34.500
and at every single step
making a decision, whether or

382
00:21:34.500 --> 00:21:38.520
not that object is alive,
right? Meaning that someone have

383
00:21:38.520 --> 00:21:41.700
a reference to this object
in code. So that would

384
00:21:41.700 --> 00:21:46.110
be Scott's class, you know,
pointing to an instance of

385
00:21:46.170 --> 00:21:49.350
the Mario class. Well, right.
And if no one has

386
00:21:49.560 --> 00:21:51.630
a reference, then that would
be garbage collected at some

387
00:21:51.630 --> 00:21:54.180
point. Exactly. Yeah, exactly. So,
and, and that's, that's really

388
00:21:54.180 --> 00:21:55.650
at the end of the
day, what, what the garbage

389
00:21:55.650 --> 00:21:58.770
collector is all about. But
if my application let's say

390
00:22:00.000 --> 00:22:02.940
super memory hungry and not
in a bad way, in

391
00:22:02.940 --> 00:22:04.590
the sense that I have
the bug, but, and I'm

392
00:22:04.590 --> 00:22:09.150
using up, I dunno, say
six gigs of memory. Now

393
00:22:09.150 --> 00:22:12.150
the garbage collector periodically goes
and says, gosh, I got

394
00:22:12.150 --> 00:22:15.540
to walk six gigs of
memory to figure out whether

395
00:22:15.540 --> 00:22:18.570
or not things are garbage
that can take up quite

396
00:22:18.570 --> 00:22:21.570
a bit of time. Right?
And that means that during

397
00:22:21.570 --> 00:22:25.080
a garbage collector, generally speaking,
all your threads in your

398
00:22:25.080 --> 00:22:28.530
process are paused. So they're
not making progress. So if

399
00:22:28.530 --> 00:22:30.080
it takes a while for
it to walk through all

400
00:22:30.090 --> 00:22:33.300
the six gigs, your application
experience, isn't going to be

401
00:22:33.300 --> 00:22:35.430
the greatest. And so what
the GC does is basically

402
00:22:35.430 --> 00:22:37.050
says, Hey, I'm going to,
I'm going to break your

403
00:22:37.050 --> 00:22:42.210
entire memory space up into
chunks. No one has generations.

404
00:22:42.780 --> 00:22:47.100
And the first generation is
generation zero. So when you

405
00:22:47.100 --> 00:22:50.010
write your code, say string
builder SQL the new string

406
00:22:50.010 --> 00:22:54.750
builder. That instance starts its
life in generation zero. Right

407
00:22:56.430 --> 00:22:58.740
now, the next time the
garbage collection happens, it goes

408
00:22:58.740 --> 00:23:00.630
and looks at all the
objects in generations. They were

409
00:23:00.630 --> 00:23:04.620
only and says, what's garbage.
Well, what's garbage. It gets

410
00:23:04.620 --> 00:23:09.570
tossed out. And what's not
now gets promoted into the

411
00:23:09.570 --> 00:23:16.770
next generation, which is generation
one. Okay. And generation zero

412
00:23:16.770 --> 00:23:22.980
is collected far more frequently
than generation one. Right. Okay.

413
00:23:23.000 --> 00:23:26.510
If that same object in
generation one still is referenced

414
00:23:26.520 --> 00:23:28.950
at the next garbage collection,
then the object gets promoted

415
00:23:28.950 --> 00:23:33.150
into generation two. I see.
So it ages into that

416
00:23:33.150 --> 00:23:35.250
new generation. It's like, Oh,
you've been around here for

417
00:23:35.250 --> 00:23:38.850
awhile. You can stay here.
Yeah, exactly. And Oh yeah.

418
00:23:38.940 --> 00:23:40.470
Even more. So is it
fair to say that if

419
00:23:40.470 --> 00:23:42.480
it stays around longer, it's
fair to assume that it

420
00:23:42.480 --> 00:23:47.030
may continue to stay around?
Yeah, absolutely. Okay. Long lived

421
00:23:47.030 --> 00:23:50.990
objects, you know, they, they,
the, the GC sort of

422
00:23:51.260 --> 00:23:53.210
makes the assumption that, Hey,
if it's been around for

423
00:23:53.210 --> 00:23:56.210
that long, you now in
generation two, and I'm going

424
00:23:56.210 --> 00:23:57.710
on the assumption that you're
going to be around for

425
00:23:57.710 --> 00:24:01.250
awhile. And there's no reason
for me at every single

426
00:24:01.250 --> 00:24:04.120
garbage collection to come and
look at you again. Oh,

427
00:24:04.120 --> 00:24:07.750
interesting. So generational garbage collection
is as, is an efficiency

428
00:24:07.750 --> 00:24:09.760
as much as anything else.
It's a way of saying,

429
00:24:10.060 --> 00:24:12.160
I'm going to stop checking
on you. You seem reliable.

430
00:24:12.160 --> 00:24:13.900
We'll let you, we'll let
you stay here. I'll check

431
00:24:13.900 --> 00:24:18.160
on you less frequently because
you seem so healthy. Exactly.

432
00:24:19.000 --> 00:24:25.180
And the generation two is,
is not fixed in size,

433
00:24:25.180 --> 00:24:28.270
right? So if you keep
allocating more objects that keep

434
00:24:28.300 --> 00:24:30.820
going into generation to generation
to just keeps growing and

435
00:24:30.820 --> 00:24:33.970
growing and growing versus generation
zero and one, which are

436
00:24:33.970 --> 00:24:36.550
more fixed in size and
smaller. And that's why they're

437
00:24:36.550 --> 00:24:39.040
more aggressively collected. Cause there's
an upper bound for how

438
00:24:39.040 --> 00:24:43.480
long that will take. Okay.
But I've heard of this

439
00:24:43.480 --> 00:24:47.950
phrase called the Jew or
the garbage collection midlife crisis.

440
00:24:48.430 --> 00:24:55.600
Okay. And you know, basically
it's this idea that generation

441
00:24:55.600 --> 00:24:57.610
two garbage collections, those are
the ones that kind of

442
00:24:57.610 --> 00:25:00.490
happen a lot. Like the
generation one generation, zero are

443
00:25:00.490 --> 00:25:02.830
little, little things, things that
stay around for a short

444
00:25:02.920 --> 00:25:06.550
period of time. But if,
if objects get promoted all

445
00:25:06.550 --> 00:25:10.480
the way up from zero
one and two, but then

446
00:25:10.510 --> 00:25:15.640
they happen to shortly thereafter,
get, get, you know, die,

447
00:25:15.670 --> 00:25:21.760
get, get collected. Then basically
they were promoted to generation

448
00:25:21.760 --> 00:25:25.210
two too quickly. And we're
S our process of spending

449
00:25:25.210 --> 00:25:27.490
a lot of time in
the garbage collector, it might

450
00:25:27.490 --> 00:25:29.740
be spending, you know, 20,
30% of its time in

451
00:25:29.740 --> 00:25:33.160
the garbage collector. Do we
want to think about garbage

452
00:25:33.160 --> 00:25:35.830
collection? Do we want to
think about how we share,

453
00:25:35.830 --> 00:25:38.110
how we hang on to
objects or do we just

454
00:25:38.110 --> 00:25:42.100
trust that the garbage collector
will do it? No. Yeah.

455
00:25:42.190 --> 00:25:45.130
That's a good question. And
I, and I think on

456
00:25:45.130 --> 00:25:48.070
average, right, you really don't
have to think about it.

457
00:25:48.940 --> 00:25:53.020
It, it, there has been
a lot of effort and

458
00:25:53.020 --> 00:25:56.260
testing across different workloads and
what I'm describing with the

459
00:25:56.260 --> 00:25:58.060
GC right now, he's kind
of at a high level,

460
00:25:58.060 --> 00:25:59.950
but there is a lot
of heuristics in there. Right?

461
00:26:00.520 --> 00:26:02.410
And so on average people,
you really don't have to

462
00:26:02.410 --> 00:26:03.910
worry about it. I don't
think I've been in a

463
00:26:03.910 --> 00:26:07.540
situation where someone has said,
well, now I got to

464
00:26:07.540 --> 00:26:11.800
start kind of designing my
object lifetimes around this because

465
00:26:11.980 --> 00:26:15.670
I can be more efficient
than the GC. Okay. There

466
00:26:15.670 --> 00:26:19.060
are other States collect is
not a good idea. Generally

467
00:26:19.060 --> 00:26:21.280
speaking. No, no, because the
GC is kind of a

468
00:26:22.060 --> 00:26:25.900
self tuning mechanism. It looks
at your allocation patterns and

469
00:26:26.230 --> 00:26:29.800
adjust itself to those. And
if you start sprinkling out,

470
00:26:29.980 --> 00:26:33.940
GC collects, it's going to
kind of skew that you

471
00:26:33.940 --> 00:26:37.240
can actually end up with
worse performance. Hmm. I back

472
00:26:37.240 --> 00:26:41.140
in the day and the
day is 2002, 2003, a

473
00:26:41.140 --> 00:26:44.130
couple of, you know, generations
of dotnet ago. And definitely

474
00:26:44.430 --> 00:26:47.820
the garbage collector has become
improved since then, there was

475
00:26:47.820 --> 00:26:52.560
recommendations to try to tidy
up your objects and by

476
00:26:52.560 --> 00:26:55.200
tidy them up, I mean,
set them to no Mark

477
00:26:55.200 --> 00:26:58.800
them as not being used.
If you're about to do

478
00:26:58.800 --> 00:27:03.450
something like call a web
service or call a, you

479
00:27:03.450 --> 00:27:05.460
know, call a day to
make a database call. And

480
00:27:05.460 --> 00:27:09.450
the idea being that if
the object is around, when

481
00:27:09.450 --> 00:27:12.090
you're about to do something
that's long running, that's gonna

482
00:27:12.090 --> 00:27:16.140
last for 300 milliseconds or
half a second, then that

483
00:27:16.140 --> 00:27:20.160
object will end up being
promoted to generation two. Didn't

484
00:27:20.160 --> 00:27:22.380
really need to be prone
to generation two, and then

485
00:27:22.380 --> 00:27:25.620
you're going to go and
clean it up afterwards. So

486
00:27:26.010 --> 00:27:30.030
one philosophy was to set
things to know that can

487
00:27:30.030 --> 00:27:32.550
be set to know before
you go off and do

488
00:27:32.550 --> 00:27:37.010
something, is the garbage collectors
smarter now than that? Yeah,

489
00:27:37.040 --> 00:27:41.600
I think by setting the
objects that, you know, are

490
00:27:41.600 --> 00:27:44.690
garbage to know you are
making an assumption that, you

491
00:27:44.690 --> 00:27:47.560
know, when the garbage collection
is going to happen and

492
00:27:47.560 --> 00:27:54.080
therefore the promotion will happen.
Right. And I personally, even

493
00:27:54.080 --> 00:27:56.300
if it is true in
certain cases, and you can

494
00:27:56.300 --> 00:27:59.300
kind of get, get lucky
that it happens to be

495
00:27:59.300 --> 00:28:03.320
true. It's not something that
I personally would spend my

496
00:28:03.320 --> 00:28:05.930
time on, on doing encode
anymore. Okay. So that's not

497
00:28:05.930 --> 00:28:08.630
where the best amount of
like the most useful amount

498
00:28:08.630 --> 00:28:10.940
of your time is spent.
It's not super valuable because

499
00:28:10.940 --> 00:28:15.140
you are ultimately, you are
trying to assume something. Yeah,

500
00:28:15.290 --> 00:28:18.530
that's absolutely right. And, you
know, making assumptions about the

501
00:28:18.530 --> 00:28:22.670
garbage collector is a, is
a, is no, I don't

502
00:28:22.670 --> 00:28:24.920
think you're going to get
enough bang for your buck

503
00:28:24.920 --> 00:28:28.730
back on that. Okay. That
makes sense. So then what

504
00:28:28.730 --> 00:28:31.220
is the difference between really,
really small objects and lots

505
00:28:31.220 --> 00:28:33.770
of them, and then, you
know, I'm doing 4k here

506
00:28:33.770 --> 00:28:35.570
in 20 K there, and
then suddenly I've got a

507
00:28:35.570 --> 00:28:40.520
300 K object or a
half a gig object. Yeah.

508
00:28:40.640 --> 00:28:44.390
So the, at the end
of the day, the GCs

509
00:28:44.390 --> 00:28:48.230
is kind of just a
memory manager, right. And anyone

510
00:28:48.230 --> 00:28:50.210
that's ever written the memory
manager at some point or

511
00:28:50.210 --> 00:28:56.390
another, has to face the
fact of memory fragmentation. And

512
00:28:56.390 --> 00:29:01.610
that's basically where you end
up with quite a bit

513
00:29:01.610 --> 00:29:05.360
of free memory overall, but
just not enough contiguous memory

514
00:29:05.360 --> 00:29:08.750
to satisfy an allocation. And
this is just like watching

515
00:29:08.750 --> 00:29:11.660
the, kind of the hypnotic
defragmentation that we've watched and

516
00:29:11.660 --> 00:29:15.380
windows XP, you know? No,
I I've always felt that

517
00:29:15.380 --> 00:29:19.460
no, no self-respecting geek could
just hit defrag and walk

518
00:29:19.460 --> 00:29:23.910
away. You just have to
watch. He's like, Oh yeah,

519
00:29:23.960 --> 00:29:27.740
you see all these things.
Right, exactly. So that's happening

520
00:29:27.740 --> 00:29:30.500
in memory and in a
way, isn't it? It does.

521
00:29:30.500 --> 00:29:35.180
It does. And, and instead
of basically throwing your arms

522
00:29:35.180 --> 00:29:37.490
up and saying, well, I
don't care. You do you,

523
00:29:37.490 --> 00:29:40.190
as the developer care about
member fragmentation, the GC actually

524
00:29:40.190 --> 00:29:44.020
attempts to, to solve that
problem for you. And the

525
00:29:44.020 --> 00:29:48.330
way that it does that
is at periodic times, it

526
00:29:48.370 --> 00:29:51.160
looks at your heap and
says, well, maybe it looks

527
00:29:51.160 --> 00:29:53.170
a little fragmented. Therefore I'm
going to be nice to

528
00:29:53.170 --> 00:29:55.990
you, and I'm going to
compact it for you, which

529
00:29:55.990 --> 00:29:58.600
means that you take all
of the non-free blocks of

530
00:29:58.600 --> 00:30:00.760
the busy blogs. You put
them on one side and

531
00:30:00.760 --> 00:30:03.130
they take all the free
blogs, turn it into one

532
00:30:03.130 --> 00:30:07.120
big free block and then
shove it right next to

533
00:30:07.120 --> 00:30:09.570
the busy blocks. Right. And
that takes time though. I

534
00:30:09.570 --> 00:30:12.960
mean, that does take time.
That's when you're doing garbage

535
00:30:12.960 --> 00:30:16.890
collections, gen two garbage collections,
when you're D fragmenting memory

536
00:30:16.890 --> 00:30:20.100
or thinking about D fragmenting
memory, you're not, you know,

537
00:30:20.130 --> 00:30:27.540
doing your business. Exactly. Exactly.
And the, the interesting thing

538
00:30:27.540 --> 00:30:30.120
is like you mentioned, it's,
it's, it, it has a

539
00:30:30.120 --> 00:30:34.770
cost associated with it. And
compaction really just means moving

540
00:30:34.770 --> 00:30:37.890
objects around on the heat.
And if you move an

541
00:30:37.890 --> 00:30:39.780
object, what does that really
amount to at the end

542
00:30:39.780 --> 00:30:42.630
of the day, while it's,
it's a memory copy, right?

543
00:30:43.230 --> 00:30:45.750
You're just copying from place
a to place B and

544
00:30:45.750 --> 00:30:48.570
the cost of a memory
Copley is directly proportional to

545
00:30:48.600 --> 00:30:51.870
the size of the object.
So if I have a

546
00:30:51.870 --> 00:30:54.570
10 byte instance of something,
and it's pretty small, it's

547
00:30:54.570 --> 00:30:56.970
pretty fast. But if I
have a 300 K instance

548
00:30:57.900 --> 00:30:59.280
moving, that is going to
take a little bit more

549
00:30:59.280 --> 00:31:02.850
time. Right. And so that's
why the garbage collector decided

550
00:31:02.850 --> 00:31:06.060
to split your memory into
two separate areas, which is

551
00:31:06.060 --> 00:31:09.060
one, is for the small,
small objects. And one is

552
00:31:09.060 --> 00:31:14.490
for larger objects. So anything,
and this is an implementation

553
00:31:14.490 --> 00:31:18.660
detail, nothing to rely on,
but the sort of threshold

554
00:31:18.660 --> 00:31:21.900
today is 85 K that's
the threshold, anything smaller than

555
00:31:21.900 --> 00:31:24.600
that goes into this smaller
heat. And then you think

556
00:31:24.600 --> 00:31:26.730
bigger to the bigger heat.
And is that just a

557
00:31:26.730 --> 00:31:29.580
magical number? Is someone felt
like, yeah, 85 K it's

558
00:31:29.580 --> 00:31:33.090
thinking it's one of those
things like pricing like 99 cents.

559
00:31:33.090 --> 00:31:35.910
That's a good price, a
dollar and 5 cents. Oh, that's

560
00:31:35.910 --> 00:31:39.570
too expensive. Well, I might've
started out that way, but

561
00:31:39.570 --> 00:31:42.330
I think over the years,
this, you know, gained a

562
00:31:42.330 --> 00:31:44.910
lot of experience with different
apps, different types of app,

563
00:31:44.910 --> 00:31:46.650
different workloads. And I think
there's been a lot of

564
00:31:46.650 --> 00:31:51.210
sort of testing and research
done around that. And obviously,

565
00:31:51.210 --> 00:31:52.950
I, I don't know all
the details about it, but

566
00:31:53.010 --> 00:31:56.250
of course they arrived at
that threshold as being the

567
00:31:56.250 --> 00:32:00.390
key. Right. And so you
end up with the small

568
00:32:00.390 --> 00:32:02.870
and large heaps and that's
great. And the small object

569
00:32:02.880 --> 00:32:05.340
heap is nicely compacted, but
here's the kicker to this

570
00:32:05.340 --> 00:32:09.570
whole thing. The reason why
large objects go on this

571
00:32:09.570 --> 00:32:11.940
special little heap is because
of that, heap is not

572
00:32:11.940 --> 00:32:17.640
compacted because of the cost
associated with compaction. Okay. For

573
00:32:17.640 --> 00:32:20.370
large objects. And that's the,
really the biggest difference between

574
00:32:20.370 --> 00:32:24.510
the two is small object
compacted, which means no memory,

575
00:32:24.510 --> 00:32:28.740
fragmentation, large object heap, not
compacted, which means you're back

576
00:32:28.740 --> 00:32:32.280
to square one. You can
get into a memory fragmentation

577
00:32:32.280 --> 00:32:37.230
issues. Okay. So in all
of this, what is it

578
00:32:37.230 --> 00:32:40.280
that, what, what does it
take be a good debugger?

579
00:32:40.490 --> 00:32:43.020
You know, is it a
personality? Is it a, a

580
00:32:43.040 --> 00:32:45.350
certain style? Do I have
to be studying things, reading

581
00:32:45.350 --> 00:32:47.450
things if I want to
be not just a good

582
00:32:47.450 --> 00:32:51.800
programmer, but a good debugger,
what does it take? Yeah,

583
00:32:51.800 --> 00:32:55.460
that's a good question. So
usually when I, when I

584
00:32:55.460 --> 00:33:00.710
talk to engineers about that,
they don't usually, they, they

585
00:33:00.710 --> 00:33:04.160
think I'm a, Oh, what's
the word not making fun

586
00:33:04.220 --> 00:33:07.100
of or being too simplistic.
But my statement is always

587
00:33:07.100 --> 00:33:10.190
that debugging is really the
single most trivial thing that

588
00:33:10.190 --> 00:33:13.160
you could possibly do. Ah,
that seems the opposite of

589
00:33:13.160 --> 00:33:17.180
what I would expect. Right.
The hard part about debugging

590
00:33:17.210 --> 00:33:22.090
is understanding the internals, right?
That's really the, the, the

591
00:33:22.100 --> 00:33:24.800
biggest Drake I often get
asked, well, isn't there a

592
00:33:24.800 --> 00:33:27.110
cheat sheet of commands for
windy BG. And I'm like,

593
00:33:27.110 --> 00:33:30.130
exactly, where's the hockey. I
can make you one. I

594
00:33:30.130 --> 00:33:33.260
don't know if they're going
to make sense, like output

595
00:33:33.260 --> 00:33:35.930
of those commands, right? Because
you really need to understand

596
00:33:35.930 --> 00:33:37.520
what the debugger is telling
you. And it's telling you

597
00:33:37.520 --> 00:33:41.330
things at such a low
level that then the majority

598
00:33:41.330 --> 00:33:43.820
of time is really just
understanding that internal part of

599
00:33:43.820 --> 00:33:47.660
it. The other thing I
like to tell people, and

600
00:33:47.660 --> 00:33:51.410
I think this is true,
no matter if you're developing

601
00:33:51.410 --> 00:33:53.810
or debugging, is that it's
really not a spectator sport.

602
00:33:54.200 --> 00:33:57.620
So, you know, can't listen
to me talk about it.

603
00:33:58.580 --> 00:34:00.050
It's not going to really
help you really got to

604
00:34:00.050 --> 00:34:03.800
sit there and do it.
And especially with these native

605
00:34:03.950 --> 00:34:06.500
debuggers who like windy BG,
that doesn't have the greatest

606
00:34:06.500 --> 00:34:10.880
experience over the dumps, it's
a matter of practicing, practicing,

607
00:34:10.880 --> 00:34:13.820
and, you know, for better
or for were actually for

608
00:34:13.820 --> 00:34:18.530
worse, there's no shortage of
things to practice on it's

609
00:34:18.530 --> 00:34:21.800
it seems like one of
those things that seems impossible

610
00:34:21.800 --> 00:34:24.920
and seems out of your
scope until you do it.

611
00:34:24.980 --> 00:34:27.650
And then you're like, Oh,
okay, I get this. I

612
00:34:27.650 --> 00:34:31.310
can do this. And there
are, of course there are

613
00:34:31.310 --> 00:34:33.890
things, you know, there's we
mentioned Tessa's blog and there

614
00:34:33.890 --> 00:34:37.340
is, there are some courses
out in Pluralsight that will

615
00:34:37.340 --> 00:34:40.880
walk you through it. I
have a couple of books

616
00:34:40.880 --> 00:34:45.050
out. They're not as obviously
as interactive as, as watching

617
00:34:45.050 --> 00:34:48.020
someone do it, but they
focus mostly on the internals.

618
00:34:49.850 --> 00:34:53.180
I think the internals part
of debugging. So it seems

619
00:34:53.180 --> 00:34:56.630
like a lot of people,
they kind of forget that

620
00:34:56.630 --> 00:35:00.140
debugging is an art. And
I mean, you'd be surprised

621
00:35:00.140 --> 00:35:01.790
how many people that you
would talk to in an

622
00:35:01.790 --> 00:35:04.340
enterprise who may have been
developing for 10 or 15

623
00:35:04.340 --> 00:35:07.160
years and don't spend any
time in the call stack

624
00:35:07.490 --> 00:35:10.160
like that, that toolbox window
doesn't get opened up. And

625
00:35:10.160 --> 00:35:13.010
I think step zero, if
you're listening to this podcast

626
00:35:13.010 --> 00:35:15.380
is open up the call
stacks are to familiarize yourself

627
00:35:15.380 --> 00:35:17.810
with the software that your
software sits on top of.

628
00:35:18.290 --> 00:35:22.580
Exactly. Yep. Excellent. Very, very
good summary. Yep. I appreciate

629
00:35:22.580 --> 00:35:24.170
that. Well, thanks so much
for chatting with me today.

630
00:35:24.260 --> 00:35:25.730
Oh yeah. Thanks a lot.
Thanks for hanging on the

631
00:35:25.730 --> 00:35:29.360
show. This has been another
episode of Hanselminutes and we'll

632
00:35:29.360 --> 00:35:30.530
see you again next week.


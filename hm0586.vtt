WEBVTT FILE

1
00:00:00.210 --> 00:00:03.360
Hi, this is Scott. I
really appreciate our sponsors because

2
00:00:03.360 --> 00:00:06.300
they make the show possible.
Today's show is sponsored by

3
00:00:06.300 --> 00:00:10.500
developer express, become a UI
superhero with dev express controls

4
00:00:10.500 --> 00:00:15.000
and libraries. Deliver elegant.net solutions
that address customer needs today

5
00:00:15.420 --> 00:00:19.470
by leveraging your existing knowledge,
you can build next generation

6
00:00:19.500 --> 00:00:23.610
touch enabled solutions for tomorrow,
you can download your free

7
00:00:23.700 --> 00:00:45.560
30 day trial@dxdothanselminutes.com. That's dx.hanselminutes.com
<inaudible>. This is Scott Hanselman.

8
00:00:45.560 --> 00:00:47.870
This is another episode of
Hansel minutes. And today I'm

9
00:00:47.870 --> 00:00:51.680
talking with Torsten ball. He
wrote an interpreter book, and

10
00:00:51.680 --> 00:00:54.440
it's a fan of compilers
and interpreters. And wants us

11
00:00:54.440 --> 00:00:57.530
to write one too. How
are you? Hey, Scott, I'm

12
00:00:57.530 --> 00:01:00.680
fine. How are you? I'm
brilliant. And I'm happy to

13
00:01:00.680 --> 00:01:03.230
be talking to you cause
you've self published this great

14
00:01:03.230 --> 00:01:07.100
book called writing and interpreter
in go, and you can

15
00:01:07.100 --> 00:01:11.630
get it@interpreterbook.com and it got
me thinking about kind of

16
00:01:11.630 --> 00:01:14.990
the computer science that I
learned in school and how

17
00:01:14.990 --> 00:01:17.720
it relates to the kind
of the software engineering that

18
00:01:17.720 --> 00:01:20.900
I do today and every
day. And it kind of

19
00:01:21.320 --> 00:01:24.230
begs the question, why would
I want to write an

20
00:01:24.230 --> 00:01:27.140
interpreter or a compiler at
this point in my career?

21
00:01:27.830 --> 00:01:31.550
Right? So, you know, my
one, my number one answer

22
00:01:31.550 --> 00:01:34.280
to this is always you
probably not going to write

23
00:01:34.280 --> 00:01:37.910
a compiler or interpreter for
work in a production environment.

24
00:01:37.940 --> 00:01:41.360
But if you dig into
this topic, you're going to

25
00:01:41.360 --> 00:01:45.230
learn so much more about
your tools, which are your

26
00:01:45.230 --> 00:01:49.520
programming language. You added her,
you, you know, IDE then

27
00:01:49.520 --> 00:01:52.340
you ever thought you would,
because, you know, once you

28
00:01:52.340 --> 00:01:55.310
learn about interpreters, you can
suddenly understand where those memory

29
00:01:55.310 --> 00:01:58.520
leaks are coming from. You
know what the parts are

30
00:01:58.550 --> 00:02:01.000
hours. You know, what an
AST is, you know, what

31
00:02:01.010 --> 00:02:04.160
a Sintex three is, you
know, how you would ride

32
00:02:04.160 --> 00:02:07.580
a garbage collector. You know,
you know what compiling means,

33
00:02:07.580 --> 00:02:12.350
and you can suddenly start
to build tools that you

34
00:02:12.350 --> 00:02:15.650
didn't think were possible for
you to ride before. Once

35
00:02:15.650 --> 00:02:18.680
you realize that all this
stuff is actually within reach

36
00:02:18.680 --> 00:02:21.200
and it's not that hard
to do or hard to

37
00:02:21.200 --> 00:02:25.880
understand, and it's not some
magic, you know, because compilers

38
00:02:25.880 --> 00:02:30.290
have this image of mystique
and you know, they're pretty

39
00:02:30.290 --> 00:02:33.620
hard to understand they're complex.
They're huge. And only certain

40
00:02:33.620 --> 00:02:40.790
people can write them. And
I think that it's, it's,

41
00:02:40.790 --> 00:02:43.370
it's not something you're gonna
earn a lot of money

42
00:02:43.370 --> 00:02:45.440
with in the sense that
you're not going to be

43
00:02:45.440 --> 00:02:48.470
hired as a compiler writer,
but it gives you a

44
00:02:48.470 --> 00:02:50.780
lot more leverage in your
day to day job where

45
00:02:50.780 --> 00:02:54.620
you probably work higher up
the stack and use compilers

46
00:02:54.650 --> 00:02:58.310
and interpreters because they're tools,
you use them every day

47
00:02:58.370 --> 00:03:00.910
and the better you them,
the better you can wheel

48
00:03:00.930 --> 00:03:06.330
them. I remember the last
time I wrote an interpreter

49
00:03:06.390 --> 00:03:11.450
was probably 20 plus years
ago. And usually in the,

50
00:03:11.450 --> 00:03:14.910
in the class, the teacher
would give us some pretend

51
00:03:14.910 --> 00:03:17.820
language they would make up
and they would give us

52
00:03:17.820 --> 00:03:20.520
a spec for that pretend
language. And then as I

53
00:03:20.520 --> 00:03:24.420
recall, I used a tool
called Lex and a tool

54
00:03:24.420 --> 00:03:28.530
called a yak, why a
CC? And I wrote the

55
00:03:28.530 --> 00:03:30.960
whole thing in, in classic
C. We didn't even have

56
00:03:30.960 --> 00:03:34.320
C plus plus at that
time. And for people just

57
00:03:34.320 --> 00:03:38.640
getting started in computer science,
as I recall, it wasn't

58
00:03:38.640 --> 00:03:41.730
very fun and it was
very confusing. And once it

59
00:03:41.730 --> 00:03:45.720
was done, I forgot all
about it. Right, right. So,

60
00:03:45.750 --> 00:03:49.080
all right, this is D
I could talk about this

61
00:03:49.080 --> 00:03:52.770
for hours, but you know,
this is actually the reason

62
00:03:53.090 --> 00:03:56.400
why I wrote the book
because it started with me

63
00:03:56.400 --> 00:03:59.700
being interested in writing interpreters
or compilers. You know, I

64
00:03:59.700 --> 00:04:03.150
set myself to go, I'm
a self-taught developer. I didn't

65
00:04:03.150 --> 00:04:05.820
go to college or university
and a student didn't study

66
00:04:05.820 --> 00:04:08.700
computer science. So I never
took the, you know, compilers

67
00:04:08.700 --> 00:04:11.730
course. And I set myself
the goal. And I said

68
00:04:11.730 --> 00:04:13.260
to a friend, you know,
I'm going to write a

69
00:04:13.260 --> 00:04:16.980
compiler. And what I found
out is that all these

70
00:04:16.980 --> 00:04:19.200
resources, you know, that teach
you how to write a

71
00:04:19.200 --> 00:04:22.200
compiler or how to write
an interpreter. They're pretty close

72
00:04:22.200 --> 00:04:26.790
to what you just described.
People are always taking, you

73
00:04:26.790 --> 00:04:29.880
know, shortcuts. They're saying, use
this tool, use that tool,

74
00:04:29.910 --> 00:04:34.710
and don't write the parts
of yourself and just ignore

75
00:04:34.710 --> 00:04:37.080
this part. You can skip
this. You don't need to

76
00:04:37.080 --> 00:04:42.060
understand this. And you know,
my favorite one is let's

77
00:04:42.060 --> 00:04:45.810
use an example language, which
looks nothing like any language

78
00:04:45.810 --> 00:04:48.900
you've ever used and implement
an interpreter for that, which

79
00:04:48.900 --> 00:04:53.070
can be super, super confusing.
And this is the reason

80
00:04:53.070 --> 00:04:55.020
why I decided that if
I'm going to write a

81
00:04:55.020 --> 00:04:58.860
book about his or, you
know, generate build a resource

82
00:04:59.040 --> 00:05:02.220
as a learning resource, I'm
going to use a real

83
00:05:02.280 --> 00:05:06.210
programming language or something that
looks like a real programming

84
00:05:06.210 --> 00:05:09.650
language. And what came out
of it was a programming

85
00:05:09.650 --> 00:05:12.840
language called monkey, which we
implement in my book and

86
00:05:12.840 --> 00:05:15.960
it looks fairly close to
JavaScript. It has curly braces.

87
00:05:15.960 --> 00:05:18.810
It has first-class functions. It
has a few different data

88
00:05:18.810 --> 00:05:25.020
types. It has strings bullions
arrays, hashes hash maps, and

89
00:05:25.050 --> 00:05:28.620
it looks like a real
programming language. And there are

90
00:05:28.620 --> 00:05:32.640
no shortcuts in the book.
So I decided Lee said,

91
00:05:33.540 --> 00:05:36.810
we're going to write our
own parser, and we're going

92
00:05:36.810 --> 00:05:39.390
to write our own Lexar.
And we are not going

93
00:05:39.390 --> 00:05:43.740
to use Lex and yak
and use these the 30

94
00:05:43.740 --> 00:05:46.620
year old tools with, you
know, the only documentation is

95
00:05:46.620 --> 00:05:50.040
the man page in a
unique system. And we are

96
00:05:50.040 --> 00:05:53.310
not going to use them
to implement our language, but

97
00:05:53.310 --> 00:05:56.400
we're going to build everything
from scratch. And this is

98
00:05:56.400 --> 00:05:58.730
going to take a lot
time, but with going to

99
00:05:58.730 --> 00:06:00.860
do it bit by bit,
and we're going to learn

100
00:06:00.860 --> 00:06:03.350
a lot. And at the
end, we're going to have

101
00:06:03.350 --> 00:06:07.100
an interpreter. That's I don't
know, it's I think 3000

102
00:06:07.100 --> 00:06:11.270
lines of code, maybe it's
fully tested and we understand

103
00:06:11.270 --> 00:06:15.440
every line of it. So
that was my intention, because

104
00:06:16.070 --> 00:06:19.490
as you just described it,
it's super frustrating to always

105
00:06:19.520 --> 00:06:25.400
been, you know, blindly led
around and around stuff and

106
00:06:25.400 --> 00:06:27.800
told you have to ignore
this. You can skip this.

107
00:06:27.800 --> 00:06:29.930
You don't need to worry
about this because as a

108
00:06:29.930 --> 00:06:34.040
beginner, you need to understand
something. You need to grab

109
00:06:34.040 --> 00:06:37.580
a hold of something. And
most people actually say that

110
00:06:37.610 --> 00:06:41.600
the most people learned the
best way by giving straight

111
00:06:41.600 --> 00:06:44.660
recipes in the beginning, if
you're an absolute beginner, the

112
00:06:44.660 --> 00:06:47.570
best is you have a
recipe that takes you from

113
00:06:47.570 --> 00:06:50.000
a to Z and you
just have to follow it

114
00:06:50.000 --> 00:06:56.180
step by step, without any,
you know, complex, abstract explanations

115
00:06:56.180 --> 00:07:00.940
about the topic in general
and stuff like That. Do

116
00:07:00.940 --> 00:07:03.280
you think that people are
out there in the world

117
00:07:03.280 --> 00:07:06.700
writing their code and just
trusting these black boxes? And

118
00:07:07.030 --> 00:07:09.160
for most people, you know,
the code goes into a

119
00:07:09.160 --> 00:07:12.820
compiler and then a miracle
happens and then there are

120
00:07:12.820 --> 00:07:15.670
executable pops out the other
end and they truly have

121
00:07:15.670 --> 00:07:18.840
no concept of what happened
in the inside. Sure, sure.

122
00:07:19.090 --> 00:07:22.630
Of course. At the end
of the day, that that's

123
00:07:22.630 --> 00:07:26.080
part of the job. You,
you can't go chasing every

124
00:07:26.080 --> 00:07:30.040
black hole. You can keep
digging, you know, you can't

125
00:07:30.040 --> 00:07:34.180
just jump into every rabbit
hole and see what, what

126
00:07:34.180 --> 00:07:36.760
comes out at the other
end. If you do that,

127
00:07:36.790 --> 00:07:39.280
you just, you're never going
to stop because computers have

128
00:07:39.280 --> 00:07:44.620
grown so complex over the
years, that it's impossible for

129
00:07:44.620 --> 00:07:47.170
any person to understand all
of that. You know, you

130
00:07:47.170 --> 00:07:50.860
can understand the whole stack
and that's been true for

131
00:07:50.860 --> 00:07:54.160
the last, I dunno, 20
or 30 years, maybe. So

132
00:07:54.160 --> 00:07:58.330
you have to stop somewhere.
But again, the point is,

133
00:07:58.360 --> 00:08:01.630
if you understand some of
it at the lower level,

134
00:08:01.630 --> 00:08:05.440
you can leverage that further
up, but you have to

135
00:08:05.440 --> 00:08:08.980
know where to draw the
line. You know, once you

136
00:08:08.980 --> 00:08:13.540
start thinking about compilers or
interpreters, you suddenly thinking about

137
00:08:14.320 --> 00:08:17.500
intermediate languages. And then you're
starting to think about assembly

138
00:08:17.500 --> 00:08:21.160
language. And if you're down
at that level, it's just

139
00:08:21.160 --> 00:08:24.250
a shot step away to
think about CPS and how

140
00:08:24.250 --> 00:08:26.590
they are built. And then
you start thinking about machine

141
00:08:26.590 --> 00:08:28.960
code, and then you realize
that machine code is just

142
00:08:29.260 --> 00:08:31.810
the result of other crowed
and it can contain box

143
00:08:31.810 --> 00:08:34.540
two and your CPU can
contain box. And you know,

144
00:08:34.540 --> 00:08:36.700
you suddenly get dizzy and
you have to sit down

145
00:08:36.700 --> 00:08:39.940
and you realize, Oh, maybe
this wasn't so easy after

146
00:08:39.940 --> 00:08:41.800
all, you know that that's
probably where you have to

147
00:08:41.800 --> 00:08:44.530
draw the line. Once you
get dizzy, you know, you

148
00:08:44.530 --> 00:08:49.360
have to stop somewhere. But
I think, I don't know

149
00:08:49.480 --> 00:08:52.480
what kind of plays into
this topic. It's this whole

150
00:08:53.320 --> 00:08:57.570
thing about leaky abstractions. You
know, some abstractions are so

151
00:08:57.570 --> 00:09:00.120
good that you actually don't
have to worry about any

152
00:09:00.120 --> 00:09:04.050
of it. And I'd say
most relational databases are just

153
00:09:04.050 --> 00:09:06.240
like that because you have
to, you know, you can

154
00:09:06.240 --> 00:09:09.630
just tell them what to
do, why are SQL? And

155
00:09:09.990 --> 00:09:12.900
they get your, your results
back and you don't have

156
00:09:12.900 --> 00:09:15.480
to worry about the storage
engine and you don't have

157
00:09:15.480 --> 00:09:18.150
to row about how an
index, you know, wrote the

158
00:09:18.150 --> 00:09:22.980
disc or something. And there
are other abstractions where, you

159
00:09:22.980 --> 00:09:26.850
know, they fall on your
feet someday. For example, I

160
00:09:26.850 --> 00:09:29.370
dunno. The first example I
could think of right now

161
00:09:29.370 --> 00:09:33.330
is graphical. Get client, you
know, where you sometimes click

162
00:09:33.330 --> 00:09:35.280
around and you want to
merge stuff. And suddenly it

163
00:09:35.280 --> 00:09:38.220
says, you know, merge conflict,
and it drops you back

164
00:09:38.220 --> 00:09:40.860
into your shell or your
text editor and unit, you

165
00:09:40.860 --> 00:09:43.830
know, suddenly presented with the
merge conflict texts. And you

166
00:09:43.830 --> 00:09:47.070
have to fiddle around with
that and the abstraction broke

167
00:09:47.070 --> 00:09:50.070
down. And in that instance,
it's better to know one

168
00:09:50.070 --> 00:09:54.060
level below the one you're
working on, which is kind

169
00:09:54.060 --> 00:09:56.970
of a general rule. I
try to follow. So, you

170
00:09:56.970 --> 00:09:59.880
know, always know one level
of abstraction below the one

171
00:09:59.880 --> 00:10:03.600
you're working on. Meaning if
I work as a web

172
00:10:03.600 --> 00:10:08.250
developer and I've write rap
applications with language X, I

173
00:10:08.250 --> 00:10:11.850
should probably know a little
bit about how this language

174
00:10:11.850 --> 00:10:15.240
works, what kind of memory
model it has, how it's

175
00:10:15.240 --> 00:10:19.170
run in production and how
to deploy it. Because most

176
00:10:19.200 --> 00:10:21.510
things like that are not
just fire and forget, and

177
00:10:21.510 --> 00:10:23.340
you can throw them over
the wall and don't worry

178
00:10:23.340 --> 00:10:27.690
about it, especially nowadays where
you have like a small

179
00:10:27.690 --> 00:10:31.560
agile teams that do a
lot of different things. And

180
00:10:31.560 --> 00:10:34.380
then it's good to always
know which tools you're working

181
00:10:34.380 --> 00:10:36.090
with and how to work
with them and how to

182
00:10:36.090 --> 00:10:38.250
manipulate them and how to
get the most out of

183
00:10:38.250 --> 00:10:41.450
them. Yeah, that really resonates
with me in a lot

184
00:10:41.450 --> 00:10:43.880
of my talks. And when
I'm teaching people, computers, I

185
00:10:43.880 --> 00:10:47.510
always let them know about
that. The abstraction layer, as

186
00:10:47.510 --> 00:10:51.410
you said, one below, right?
For example, I use examples

187
00:10:51.410 --> 00:10:54.710
like, you know, you're driving
a car and when you

188
00:10:54.710 --> 00:10:58.010
turn the wheel, you turn
the steering wheel. Do you

189
00:10:58.010 --> 00:11:02.150
know the relationship between the
steering wheel and the actual

190
00:11:02.150 --> 00:11:05.330
wheels that touch the ground?
And I was trying to

191
00:11:05.330 --> 00:11:09.440
teach a relative recently how
to parallel park. And it

192
00:11:09.440 --> 00:11:11.720
turns out that they thought
when you turn the steering

193
00:11:11.720 --> 00:11:16.670
wheel, all four wheels of
the car turned right. And

194
00:11:16.670 --> 00:11:19.520
when they try to apply
that misunderstanding of that layer

195
00:11:19.520 --> 00:11:22.400
of abstraction to parallel parking,
they were unable to accomplish

196
00:11:22.400 --> 00:11:25.490
that. So we stepped out
of the car, talked about

197
00:11:25.490 --> 00:11:28.220
that one, really that one
layer down in the call

198
00:11:28.220 --> 00:11:31.760
stack, then the light turns
on. They never have to

199
00:11:31.760 --> 00:11:34.160
think about it again. They
just go, go back up

200
00:11:34.160 --> 00:11:38.030
to the higher level of
abstraction. But by peeking underneath

201
00:11:38.030 --> 00:11:40.580
and understanding how the car
works, they suddenly become a

202
00:11:40.580 --> 00:11:42.740
better driver. And it sounds
like you're saying the same

203
00:11:42.740 --> 00:11:45.950
thing, go and write an
interpreter, write your own lecture,

204
00:11:45.950 --> 00:11:48.140
your own parser. And then
you can go back to

205
00:11:48.140 --> 00:11:50.600
writing your web applications, but
you're going to have all

206
00:11:50.600 --> 00:11:54.280
kinds of little Tetris in
your brain that have then

207
00:11:54.280 --> 00:11:57.070
been filled in with the,
the knowledge of what's happening

208
00:11:57.070 --> 00:12:00.960
underneath. Exactly, exactly. That that's
the main point that you

209
00:12:01.290 --> 00:12:03.990
suddenly can make connections in
your mind. The burn there

210
00:12:03.990 --> 00:12:06.990
before that wouldn't even have
been possible to make, because

211
00:12:06.990 --> 00:12:12.600
you were missing essential parts
and actually one of the

212
00:12:12.600 --> 00:12:14.790
blog posts or one of
the things that motivated me

213
00:12:14.790 --> 00:12:17.550
to write this book or
learn about compilers was a

214
00:12:17.550 --> 00:12:21.690
blog post by Steve Yaggie.
It's called rich program of

215
00:12:21.690 --> 00:12:26.340
food. And he essentially says
that you should learn about

216
00:12:26.340 --> 00:12:29.100
compilers. And if you're in
college, you should take the

217
00:12:29.100 --> 00:12:33.240
ComPilot course. It's the most
important course there is. Because

218
00:12:33.270 --> 00:12:36.570
if you learn about competitors,
you learn about all the

219
00:12:36.570 --> 00:12:39.090
things I mentioned before the
abstract syntax street, you learn

220
00:12:39.090 --> 00:12:43.140
about lexing you learn about
parsing. You learn about traversing

221
00:12:43.140 --> 00:12:48.030
grease. You learn about cogeneration
register location, and you know,

222
00:12:48.030 --> 00:12:52.170
all these things, which sound
like you only might use

223
00:12:52.170 --> 00:12:55.740
them in a compiler, but
as it turns out, you

224
00:12:55.740 --> 00:12:58.530
can use them everywhere. You
can apply these concepts in

225
00:12:58.530 --> 00:13:02.670
a lot of different ways.
And the best example I

226
00:13:02.670 --> 00:13:07.650
have is a program called
Mark Bates. He read my book,

227
00:13:07.650 --> 00:13:11.280
he's pretty, he, he wrote
a framework in NGO called

228
00:13:11.280 --> 00:13:15.000
Buffalo. And he actually wrote
the templating language after reading

229
00:13:15.000 --> 00:13:17.460
the book, because suddenly it
clicked in his mind and

230
00:13:17.460 --> 00:13:20.280
he knew how to write
a templating language before. And

231
00:13:20.280 --> 00:13:23.790
that was just, you know,
something far away. How do

232
00:13:23.790 --> 00:13:27.810
you even parse templates? How
do you evaluate different statements

233
00:13:27.810 --> 00:13:31.680
in a template? How do
you evaluate conditions and so

234
00:13:31.680 --> 00:13:34.470
on? And, you know, he
learned about interpreters. He built

235
00:13:34.470 --> 00:13:39.270
the programming language monkey, which
seems fairly unusable in a

236
00:13:39.270 --> 00:13:42.270
day to day job, but
suddenly he built a templating

237
00:13:42.270 --> 00:13:45.990
engine, which is of course,
something usable. Well, is the

238
00:13:46.110 --> 00:13:48.690
monkey program language? The thing
that is that you made

239
00:13:48.690 --> 00:13:50.340
up or is it a
thing? That's a real thing.

240
00:13:51.050 --> 00:13:53.910
It's a, it's a thing
I made up. Yeah. I

241
00:13:54.000 --> 00:13:57.180
originally I wanted to call
it tiger because tigers are

242
00:13:57.180 --> 00:13:59.910
my favorite animal. And then
I looked at one of

243
00:13:59.910 --> 00:14:03.390
the ComPilot books sitting on
my desk and I realized

244
00:14:03.600 --> 00:14:05.820
that there's a tiger on
one of them. And I

245
00:14:05.820 --> 00:14:08.850
opened the book and on
the first page, it says,

246
00:14:09.240 --> 00:14:10.980
the language we're going to
build in this book is

247
00:14:10.980 --> 00:14:14.100
called tiger. And I saw,
alright, so it's not going

248
00:14:14.100 --> 00:14:17.370
to be tiger. And I
like monkeys very much. So

249
00:14:17.640 --> 00:14:21.720
I called it monkey and
it's in my mind, it's

250
00:14:21.720 --> 00:14:24.510
the language that lives in
a book. So there is

251
00:14:24.510 --> 00:14:29.430
no official implementation of monkey.
There are tons of implementation

252
00:14:29.430 --> 00:14:32.730
floating around and get up
because I licensed a code

253
00:14:32.730 --> 00:14:35.310
under the MIT license. So,
you know, if you read

254
00:14:35.310 --> 00:14:38.760
the book, you can build
your own monkey interpreter as

255
00:14:38.760 --> 00:14:40.890
it is in the book
and just share that or

256
00:14:40.890 --> 00:14:45.120
modify it or upload it
on guitar. And so the

257
00:14:45.120 --> 00:14:49.170
original version is doesn't exist.
It only exists in the

258
00:14:49.170 --> 00:14:51.890
book, but there are a
lot of own versions of

259
00:14:51.890 --> 00:14:56.090
readers in different languages. Even
people implemented it in Haskell

260
00:14:56.090 --> 00:15:00.110
and Alex here in dart
in, I think in Java

261
00:15:00.140 --> 00:15:03.440
too. So yeah, it's a,
it's a language with many

262
00:15:03.440 --> 00:15:08.420
faces. It's a small language
and not to, you know,

263
00:15:09.440 --> 00:15:12.230
spoiler secret, but I'm currently
still working on it and

264
00:15:12.230 --> 00:15:14.270
tuning in a bit. And
I want to publish a

265
00:15:14.270 --> 00:15:17.600
few modifications in the future
about how you can make

266
00:15:17.600 --> 00:15:22.360
monkey even more fun. So
let's, let's, let's talk about

267
00:15:22.360 --> 00:15:24.070
this for a second. You've
got monkey, which is a

268
00:15:24.070 --> 00:15:27.400
pretend language. And in this
book, it's not just writing

269
00:15:27.400 --> 00:15:30.190
an interpreter, it's writing an
interpreter in go because of

270
00:15:30.190 --> 00:15:32.560
course you have to choose
some language. You could have

271
00:15:32.560 --> 00:15:35.380
written it in C or
Java or whatever. What if

272
00:15:35.380 --> 00:15:39.290
the people who are listening
are not go programmers? What,

273
00:15:39.430 --> 00:15:42.370
why would they, does it
matter if I'm not a

274
00:15:42.370 --> 00:15:47.740
GoPro? The reason I choose
go is because I think

275
00:15:47.770 --> 00:15:51.670
it's a language that's super
easy to understand, even if

276
00:15:51.670 --> 00:15:54.400
you've never written a line
of go code in your

277
00:15:54.400 --> 00:15:58.960
life, that that's something people
complain about. That goes too

278
00:15:58.960 --> 00:16:02.290
simple. And it doesn't have
all the bells and whistles

279
00:16:02.290 --> 00:16:06.670
of modern programming languages and
elaborate type system or something

280
00:16:06.670 --> 00:16:10.000
like that. And it's essentially
just a modern version of

281
00:16:10.000 --> 00:16:13.420
C and that's exactly why
I chose it for this

282
00:16:13.420 --> 00:16:15.790
book. First of all, I
like programming and go. It's

283
00:16:15.790 --> 00:16:18.040
a, I've been doing it
for a few years now

284
00:16:18.400 --> 00:16:21.670
and it's great language. I
enjoy using it. But I

285
00:16:21.670 --> 00:16:26.050
think as a teaching language,
it's super well-suited because there's

286
00:16:26.050 --> 00:16:30.040
not a lot of stuff
going on. You can't understand

287
00:16:30.040 --> 00:16:32.740
if you've never written go.
And I always compare this

288
00:16:32.740 --> 00:16:36.220
to Ruby, which I use
for quite a long time

289
00:16:36.220 --> 00:16:40.660
now. And if I use
Ruby, which is object oriented

290
00:16:40.660 --> 00:16:45.910
and has met our programming
and has DSL stuff going

291
00:16:45.910 --> 00:16:50.320
on, and it looks like
English. But if you look

292
00:16:50.320 --> 00:16:52.930
at Ruby code some Ruby
code, and you've never written

293
00:16:52.930 --> 00:16:55.090
Ruby in your life, you're
going to have a hard

294
00:16:55.090 --> 00:16:59.170
time understanding it. So there's
a lot of different things

295
00:17:00.250 --> 00:17:03.520
in the way between you
and understanding how the program

296
00:17:03.520 --> 00:17:06.430
works. And if you look
at go code, even if

297
00:17:06.430 --> 00:17:09.820
you're a Java programmer or
your C sharp programmer or

298
00:17:10.270 --> 00:17:13.840
Java script programmer, if you've
ever used the curly braces

299
00:17:13.840 --> 00:17:17.380
language, you're, I think you're
going to have, you're going

300
00:17:17.380 --> 00:17:19.120
to look at, go, and
you're going to understand what's

301
00:17:19.120 --> 00:17:21.940
going on because there is
not a lot going on.

302
00:17:22.000 --> 00:17:24.010
And, and the book I
do not even use, like

303
00:17:24.460 --> 00:17:27.580
concurrency stuff. I don't use
channels. And I don't use

304
00:17:27.580 --> 00:17:31.690
fancy libraries that are no
third party libraries, actually only

305
00:17:31.690 --> 00:17:36.100
the standard library. And I
think, yeah, as I said,

306
00:17:36.100 --> 00:17:38.800
if, you know, JavaScript, for
example, you're going to have

307
00:17:40.000 --> 00:17:42.190
not such a hard time
understanding go code, even if

308
00:17:42.190 --> 00:17:44.680
you've never written goal before.
I mean, there's the hurdle.

309
00:17:44.680 --> 00:17:47.680
If you've never heard of
pointers before, that might trip

310
00:17:47.680 --> 00:17:51.870
you a bit, but honestly,
I don't think that's gonna

311
00:17:51.900 --> 00:17:55.860
stop you from understanding the
code presented, or that's going

312
00:17:55.860 --> 00:17:58.830
to stop you from translating
the code to your favorite

313
00:17:58.830 --> 00:18:01.460
language. So it sounds like
you just, you wanted a

314
00:18:01.460 --> 00:18:03.680
language that would get out
of the way and let

315
00:18:03.680 --> 00:18:06.200
you talk about the concepts
and that, and that that

316
00:18:06.200 --> 00:18:08.300
was go. And the thing
that I think is most

317
00:18:08.300 --> 00:18:10.700
interesting is your choice. As
you've pointed out a few

318
00:18:10.700 --> 00:18:14.720
times, no third party libraries,
you really have the entire

319
00:18:15.290 --> 00:18:18.710
book contains the entire code
of this interpreter. You're going

320
00:18:18.710 --> 00:18:22.130
to learn everything from, from
hello, you know, from hello

321
00:18:22.130 --> 00:18:25.040
world, Maine, all the way
through to your final app.

322
00:18:25.550 --> 00:18:30.860
Exactly. And that's, I'm not
going to brag, but I

323
00:18:30.860 --> 00:18:33.560
have to say that writing
this interpreter for monkey, which

324
00:18:33.830 --> 00:18:37.070
again is just 3000 lines
that has been one of

325
00:18:37.070 --> 00:18:40.370
the most joyful coding experiences
in my life. And that's

326
00:18:40.370 --> 00:18:43.700
not even relevant relevant for
the book because I've wrote

327
00:18:43.700 --> 00:18:47.330
the interpreter before. But I'm
a guy who works with

328
00:18:47.330 --> 00:18:50.030
web applications all day. I
have to start up a

329
00:18:50.030 --> 00:18:52.700
database. When I went to
work, I have to start

330
00:18:52.700 --> 00:18:54.620
up a second database when
I want to work and

331
00:18:54.620 --> 00:18:57.050
I maybe have to start
a message queue and I

332
00:18:57.050 --> 00:18:59.420
have to start a background
job. And I have to

333
00:18:59.420 --> 00:19:04.430
start some JavaScript process that
bundles my front end assets

334
00:19:04.460 --> 00:19:07.430
or something like that. And
I have all this stuff

335
00:19:07.550 --> 00:19:10.280
around and I have third
party libraries, and I have

336
00:19:10.280 --> 00:19:13.160
to go read through documentation
and read me, and I

337
00:19:13.160 --> 00:19:16.100
have to understand how all
these pieces fit together. And

338
00:19:16.100 --> 00:19:19.010
it's perfectly fine in a
production environment. You get paid

339
00:19:19.010 --> 00:19:22.370
to do it and you
need to get results, but

340
00:19:23.030 --> 00:19:27.110
writing misinterpreted without any third
party libraries, that was like

341
00:19:27.170 --> 00:19:29.840
a breath of fresh air,
because you could just run

342
00:19:29.840 --> 00:19:32.600
your tests for the whole
book is written in test

343
00:19:32.600 --> 00:19:36.740
driven development, and you can
run the tests in under

344
00:19:36.750 --> 00:19:39.350
half a second, and you
don't have to read through

345
00:19:39.350 --> 00:19:42.380
any documentation at all. You
can just concentrate on the

346
00:19:42.380 --> 00:19:45.680
one page of code before
you and the test set

347
00:19:46.070 --> 00:19:48.530
says, it's failing and you
can look at your code

348
00:19:48.590 --> 00:19:50.750
and you don't have to
understand anything else. You can

349
00:19:50.750 --> 00:19:53.150
just tweak around with your
own code, run this test

350
00:19:53.150 --> 00:19:55.280
again and see if you
made them pass, tweak around

351
00:19:55.280 --> 00:19:58.130
some more. And they're green.
It's, it's like, you know,

352
00:19:58.160 --> 00:20:03.410
the, what draws most people
to programming, solving little puzzles.

353
00:20:03.440 --> 00:20:06.830
And that's just so refreshing.
And it's so much fun

354
00:20:06.830 --> 00:20:10.610
compared to all right, why
is this failing? It turns

355
00:20:10.610 --> 00:20:13.070
out I used a third
party library the wrong way,

356
00:20:13.070 --> 00:20:15.800
and it accepts, you know,
a timestamp instead of a

357
00:20:15.800 --> 00:20:19.730
data, something like that. And
it's all gone. You just

358
00:20:19.730 --> 00:20:24.020
can concentrate on your code.
And it's super, I don't

359
00:20:24.020 --> 00:20:27.800
know, somebody I've read some
weeks ago that programming is

360
00:20:27.800 --> 00:20:32.570
like playing Lego without gravity.
And yeah, that sounds fun.

361
00:20:32.630 --> 00:20:35.330
And I actually think that's
the most fun part about

362
00:20:35.330 --> 00:20:38.780
programming when you're just, you
know, building some castles in

363
00:20:38.780 --> 00:20:42.020
the sky. And in that
moment, billing an interpreter. Compiler

364
00:20:42.050 --> 00:20:45.230
is kind of like this
strings go in and maybe

365
00:20:45.230 --> 00:20:47.350
something comes out, but you
don't have to depend on

366
00:20:47.350 --> 00:20:50.760
anything else. Yeah. The way
I like to phrase it

367
00:20:50.760 --> 00:20:52.950
is that building things like
this or projects like this

368
00:20:52.950 --> 00:20:55.560
are finite, right? You can
hold it all in your

369
00:20:55.560 --> 00:20:59.520
brain. There's no dependency chain.
Other than the language that

370
00:20:59.520 --> 00:21:03.000
you picked, you actually picked,
go and used only the

371
00:21:03.000 --> 00:21:07.380
go standard libraries and standard
in, you know, data types.

372
00:21:07.380 --> 00:21:10.470
You didn't pull in any
dependencies at all. So you're

373
00:21:10.470 --> 00:21:13.620
you're, you could do this
entirely offline, right? You could

374
00:21:13.710 --> 00:21:16.890
write this on a plane.
There's a joy in a

375
00:21:16.890 --> 00:21:21.720
finite and understandable project like
this. Yeah. That that's, I

376
00:21:21.720 --> 00:21:23.880
don't know that that sums
it up pretty well that

377
00:21:23.880 --> 00:21:26.520
you can write this on
a plane without needing anything

378
00:21:26.520 --> 00:21:28.680
else. You don't even have
to have an internet connection.

379
00:21:29.070 --> 00:21:32.250
And that's, I think everybody
understand what to do A

380
00:21:32.250 --> 00:21:34.020
reminder to people, because I
think some of us will

381
00:21:34.020 --> 00:21:36.780
go and we'll write code
for five years, seven years,

382
00:21:36.780 --> 00:21:41.640
10 years, and get wrapped
up in our IDs and

383
00:21:41.640 --> 00:21:44.550
in our use of stack
overflow and in our third

384
00:21:44.550 --> 00:21:48.450
party libraries, and maybe forget
about these little tiny projects

385
00:21:48.870 --> 00:21:51.180
that might be a couple
hundred or a couple thousand

386
00:21:51.180 --> 00:21:53.580
lines of code that are,
that are finite. And it's

387
00:21:53.580 --> 00:21:57.240
kind of healthy to, to
stretch the muscles and do

388
00:21:57.240 --> 00:22:00.660
these basic exercises. You know,
so many people buy exercise

389
00:22:00.660 --> 00:22:03.870
equipment, and then someone reminds
them, you know, you could

390
00:22:03.870 --> 00:22:06.570
just do squats and bench
press and pull ups. And

391
00:22:06.570 --> 00:22:11.010
that's basically your main exercises,
you know, deadlifts get back

392
00:22:11.010 --> 00:22:12.750
to basics. And it sounds
like you're getting back to

393
00:22:12.750 --> 00:22:15.900
basics with this. One thing
I want to ask though,

394
00:22:15.900 --> 00:22:20.070
is you're building an interpreter,
not a compiler. Maybe you

395
00:22:20.070 --> 00:22:21.780
could talk a little bit
about what that means to

396
00:22:21.780 --> 00:22:26.130
people, Right? The original goal
was to actually show how

397
00:22:26.130 --> 00:22:29.910
to write a compiler, but
with the approach I've chosen

398
00:22:29.940 --> 00:22:32.610
that I show every piece
of code in the book

399
00:22:32.640 --> 00:22:34.920
and that it's all test
driven. And I showed a

400
00:22:34.920 --> 00:22:38.340
test in the book. It
turned out that, you know,

401
00:22:38.820 --> 00:22:41.610
it takes a lot of
pages and it takes a

402
00:22:41.610 --> 00:22:44.370
lot of space to explain
a compiler in full. So

403
00:22:44.370 --> 00:22:49.410
this, this is a reduction
in scope basically. And as

404
00:22:49.410 --> 00:22:52.170
it turned out, you know,
I played with the idea

405
00:22:52.200 --> 00:22:55.320
around, in my head and
I juggled some bullet points

406
00:22:55.320 --> 00:22:58.080
around and made a concept
for the book and how

407
00:22:58.080 --> 00:23:00.780
I could, you know, get
it done. And I think

408
00:23:00.840 --> 00:23:06.390
what I've found is that
this project is a small

409
00:23:06.390 --> 00:23:11.730
interpreter that shows you things
you didn't know before, but

410
00:23:11.880 --> 00:23:14.610
you now know, and you
can learn more about them.

411
00:23:14.640 --> 00:23:17.970
You know, once you've done
this, you haven't written a

412
00:23:17.970 --> 00:23:21.510
compiler, but you suddenly know
what an AST is. And

413
00:23:21.570 --> 00:23:24.240
you're starting to think, all
right, I guess I now

414
00:23:24.240 --> 00:23:27.060
know how a compiler would
walk along this tree and

415
00:23:27.060 --> 00:23:30.630
generate some code of it.
And I think that's very

416
00:23:30.630 --> 00:23:33.480
helpful. And I, I started
to write a compiler after

417
00:23:33.480 --> 00:23:36.030
I finished the book. And
you know, it, wasn't a

418
00:23:36.030 --> 00:23:40.350
lot more steps because the
fundamentals are the same. And

419
00:23:40.350 --> 00:23:43.620
people always say, start with
an interpreter, which is easy

420
00:23:43.620 --> 00:23:46.310
to do, and then try
build stuff on top of

421
00:23:46.310 --> 00:23:48.710
it. And if I would
have done it the other

422
00:23:48.710 --> 00:23:52.280
way around, start with a
compiler or, you know, some

423
00:23:52.280 --> 00:23:56.120
advanced compiler bytecode compiler or
JIT compiler, you would get

424
00:23:56.120 --> 00:23:59.570
lost along the way because
you wouldn't be able to,

425
00:23:59.600 --> 00:24:01.610
as you said, keep the
whole thing in your head.

426
00:24:01.630 --> 00:24:07.480
Yeah. Yeah. So you've said
a three letter acronym or

427
00:24:07.540 --> 00:24:10.690
TLA, a couple of times
you said a S T

428
00:24:10.930 --> 00:24:16.300
write an abstract syntax tree.
So if I understand correctly,

429
00:24:16.510 --> 00:24:21.010
if you're making a compiler,
you take that source code

430
00:24:21.010 --> 00:24:24.340
and you might scan it
once or multiple times if

431
00:24:24.340 --> 00:24:27.070
you need to. And you
make machine language that is

432
00:24:27.070 --> 00:24:30.830
going to be executed by
the, by the, the process

433
00:24:30.850 --> 00:24:33.450
that by the processor. But
when you're making an interpreter,

434
00:24:33.460 --> 00:24:37.540
you take that source code
and are you executing it

435
00:24:37.990 --> 00:24:41.710
line by line? Or are
you making an abstract syntax

436
00:24:41.710 --> 00:24:44.680
tree? And then you're executing
that what's the pipeline look

437
00:24:44.680 --> 00:24:48.580
like? So there is no
generic way to do this,

438
00:24:48.580 --> 00:24:50.830
but the one chosen in
the book, which is the

439
00:24:50.830 --> 00:24:54.640
most, you know, a common
one, I guess, is that

440
00:24:55.330 --> 00:24:58.750
we parsed the source code.
We ALEKS it. That means

441
00:24:58.750 --> 00:25:01.780
we turn it into tokens,
which are just, you know,

442
00:25:01.780 --> 00:25:08.320
small pieces that are not
characters, but say something like

443
00:25:08.860 --> 00:25:12.790
the function keyword or opening
brace or closing price. Those

444
00:25:12.790 --> 00:25:16.120
are tokens. And we get
those from the Lexar. And

445
00:25:16.120 --> 00:25:18.550
then we feed them into
the parser and the Plaza

446
00:25:18.550 --> 00:25:22.390
says, all right, you sent
me the function token, the

447
00:25:22.390 --> 00:25:26.200
function keyword token. What I
expect next is that you're

448
00:25:26.200 --> 00:25:29.530
going to send me an
opening brace because now you're

449
00:25:29.530 --> 00:25:31.750
going to give me the
arguments or the function body,

450
00:25:32.020 --> 00:25:34.630
or you're going to give
me that conditional or whatever.

451
00:25:34.750 --> 00:25:38.140
And the powers of then
accepts these tokens or rejects

452
00:25:38.140 --> 00:25:42.040
them that's deposit error. And
once it has all those

453
00:25:42.040 --> 00:25:45.550
tokens, it starts building an
AST that abstract syntax tree,

454
00:25:45.580 --> 00:25:48.280
which is, you know, an
in memory data structure that

455
00:25:48.280 --> 00:25:52.570
represents your source code as
a tree. And most people

456
00:25:52.570 --> 00:25:57.610
are pretty irritated by a
tree representing the source code,

457
00:25:58.660 --> 00:26:00.490
which I go into a
fair bit in the book,

458
00:26:00.730 --> 00:26:04.150
because if you look at
source code, it doesn't look

459
00:26:04.150 --> 00:26:06.340
like a tree to you.
It looks like code to

460
00:26:06.340 --> 00:26:08.800
you. And if you have
no experience with trees or

461
00:26:08.800 --> 00:26:11.170
abstract syntax trees, you don't
know how to represent it

462
00:26:11.170 --> 00:26:14.710
as a tree. So we
go into debt and we

463
00:26:14.710 --> 00:26:17.320
explain how the powers are,
dust that. And once we

464
00:26:17.320 --> 00:26:21.610
have the tree, we start
interpreting it. And that sounds

465
00:26:21.610 --> 00:26:25.990
like wiseguy answer, but, you
know, interpreting, it means walking

466
00:26:25.990 --> 00:26:30.610
down the nodes of the
tree and actually evaluating them

467
00:26:30.640 --> 00:26:33.790
doing what they're saying. So
you might walk along the

468
00:26:34.060 --> 00:26:38.260
tree and it says, I
have here an infects expression

469
00:26:38.290 --> 00:26:42.220
with two operands and one
operator to operator is the

470
00:26:42.220 --> 00:26:47.580
plus sign, the plus character.
And the operands are the

471
00:26:47.580 --> 00:26:52.080
internal literal five and the
intertribal literal 10. So how

472
00:26:52.080 --> 00:26:54.570
do you go about evaluating
that? You'll look at it

473
00:26:54.570 --> 00:26:57.780
and you look at the,
the operands and you add

474
00:26:57.780 --> 00:27:00.570
them together because the operator
is the plus. And if

475
00:27:00.570 --> 00:27:03.810
the operator minus sign, you're
going to subtract one opera

476
00:27:03.810 --> 00:27:06.000
and from the other, and
then you're going to return

477
00:27:06.000 --> 00:27:09.690
that, and you can do
this in a recursive way,

478
00:27:09.690 --> 00:27:13.050
which is super beautiful. And
it works really well. So

479
00:27:13.050 --> 00:27:15.780
you walk along this tree
and you always pass another

480
00:27:15.780 --> 00:27:18.900
sub note or a child
note of the street to

481
00:27:18.900 --> 00:27:23.820
the same function that evaluated
the upper parent branch. And

482
00:27:23.820 --> 00:27:26.730
so you walk along the
street and evaluate every note

483
00:27:26.730 --> 00:27:30.360
step-by-step. And in the end
you evaluated the whole program,

484
00:27:30.690 --> 00:27:34.230
which means you interpreted the
whole program. And suddenly, you

485
00:27:34.230 --> 00:27:37.110
know, you build a working
interpreter that runs your source

486
00:27:37.110 --> 00:27:41.150
code. And when, when someone
is thinking about an interpreter

487
00:27:41.150 --> 00:27:44.390
versus a compiler, sometimes they
think about speed and they'll

488
00:27:44.390 --> 00:27:46.670
go and say, Oh, well,
this is clearly not as,

489
00:27:46.670 --> 00:27:48.800
not as good. It's because
it's an interpreter, you know,

490
00:27:48.800 --> 00:27:52.040
interpreted is always bad. That's
not fair to say though,

491
00:27:52.040 --> 00:27:56.870
is it that, that interpreter
equals bad In general? No.

492
00:27:56.960 --> 00:28:00.200
Or nowadays, no. You could
say that a tree walking

493
00:28:00.200 --> 00:28:04.940
interpreters actually, without any optimizations
is probably the slowest form

494
00:28:04.940 --> 00:28:09.890
to ride an interpreter. But
that's looking at interpreters from

495
00:28:09.920 --> 00:28:14.930
the perspective of 2017, right?
Because, and this is like

496
00:28:14.930 --> 00:28:18.890
a pet topic of mine,
the line between compilers and

497
00:28:18.890 --> 00:28:23.030
interpreters nowadays, it's so blurry
that you can't even tell

498
00:28:23.030 --> 00:28:27.170
them really apart. So modern
interpreters, what they're doing is

499
00:28:27.170 --> 00:28:30.140
they're not only walking along
the street and interpreting it,

500
00:28:30.500 --> 00:28:35.390
but the intro compiled denote
into machine code just to

501
00:28:35.400 --> 00:28:37.670
this already. And then they
go on to turn this

502
00:28:37.940 --> 00:28:41.300
thing that he evaluated into
native machine code. And the

503
00:28:41.300 --> 00:28:43.760
next time they come across
this note in the tree,

504
00:28:43.970 --> 00:28:46.910
they're just going to execute
the machine code. So what

505
00:28:46.910 --> 00:28:50.660
they did was they compiled
the note into machine code

506
00:28:51.470 --> 00:28:54.320
just in time and then
executed it. And what you

507
00:28:54.320 --> 00:28:59.060
have, there is a JIT
compiler slash Git interpreter because

508
00:28:59.420 --> 00:29:02.840
it interpreted the abstract syntax
tree, but it also compiled

509
00:29:02.840 --> 00:29:06.320
it and ran the resulting
machine code. And then you

510
00:29:06.320 --> 00:29:09.560
have interpreters that walk the
AST and they generate code,

511
00:29:09.590 --> 00:29:13.820
which is some form of
machine code for virtual machine.

512
00:29:14.420 --> 00:29:16.310
And then they pass it
to the virtual machine and

513
00:29:16.310 --> 00:29:20.900
the virtual machine interprets in
quotes the bytecode and runs

514
00:29:20.900 --> 00:29:23.810
it. So now what do
you have, do you have

515
00:29:23.810 --> 00:29:27.740
an interpreter that outputs bytecode
or that evaluates the bytecode

516
00:29:27.740 --> 00:29:30.530
or is it ComPilot? It
outputs bytecode and your virtual

517
00:29:30.530 --> 00:29:34.190
machine isn't that Vox along
those notes, but instead of

518
00:29:34.250 --> 00:29:38.450
evaluating it mean when you
talk about the standard interpreter,

519
00:29:38.450 --> 00:29:40.970
what you mean as a
tree walking, interpreted that just

520
00:29:41.110 --> 00:29:45.460
goes ahead without any optimizations
and evaluates each node in

521
00:29:45.460 --> 00:29:47.080
the tree. And on the
other hand, you have a

522
00:29:47.080 --> 00:29:51.730
compiler that walks along those
notes, but instead of evaluating

523
00:29:51.730 --> 00:29:57.490
it, it produces code that
then executes the code it's

524
00:29:57.490 --> 00:30:01.000
supposed to run. So to
take the example from before

525
00:30:01.000 --> 00:30:04.060
where you had a note
that says, plus five and

526
00:30:04.060 --> 00:30:08.260
10, the interpreter would evaluate
this and output a 15

527
00:30:08.320 --> 00:30:11.530
on the command line or
somewhere else, but to compile

528
00:30:11.530 --> 00:30:15.070
it would actually output machine
code that executes five plus

529
00:30:15.070 --> 00:30:18.970
10. And, you know, just
to, to put one on

530
00:30:18.970 --> 00:30:23.380
top compilers are so optimized
nowadays that it wouldn't even

531
00:30:23.500 --> 00:30:27.280
compile this to machine code,
but it would pre evaluate

532
00:30:27.280 --> 00:30:29.950
this and just put, you
know, the 15 and the

533
00:30:29.950 --> 00:30:32.650
resulting source code. So then
you have a ComPilot, it's

534
00:30:32.650 --> 00:30:36.520
actually interpreting some notes while
it's compiling to machine code.

535
00:30:36.730 --> 00:30:41.080
So I don't think that
distinction is that clear or

536
00:30:41.110 --> 00:30:43.900
that, as you said, it's
fair to say that interpreters

537
00:30:43.930 --> 00:30:48.540
per se are really that
much slower than compilers. So

538
00:30:48.540 --> 00:30:50.880
it seems like if the,
if the thing, if the,

539
00:30:50.880 --> 00:30:54.660
if the work being done
is in any way repetitive,

540
00:30:55.020 --> 00:30:58.230
and the interpreter is smart
about caching, those machine codes

541
00:30:58.230 --> 00:31:01.080
that have been done before
then the interpreter could very,

542
00:31:01.140 --> 00:31:04.560
very much in a tight
loop, be competitive with anything

543
00:31:04.560 --> 00:31:07.920
compiled. But if the interpreter
is doing new and fresh

544
00:31:07.920 --> 00:31:11.670
work for the first time,
every time, then it might

545
00:31:11.670 --> 00:31:13.140
be slower and then it
might be something to worry

546
00:31:13.140 --> 00:31:14.940
about. But for the most
part, it doesn't matter as

547
00:31:14.940 --> 00:31:17.910
much as you'd think it
does. Exactly. Exactly. And then

548
00:31:18.030 --> 00:31:20.640
you also have the use
case, you know, think of

549
00:31:20.640 --> 00:31:24.930
JavaScript interpreters there, they're running
and browsers. So what you

550
00:31:24.930 --> 00:31:27.120
want from a browser is
that you go to a

551
00:31:27.180 --> 00:31:30.810
webpage and it starts executing
a JavaScript code immediately. You

552
00:31:30.810 --> 00:31:35.040
don't want the webpage to
have a ten second compile step,

553
00:31:35.250 --> 00:31:38.010
which compels to JavaScript to
super fast machine code. If

554
00:31:38.010 --> 00:31:40.200
you have to wait 10
seconds for it to actually

555
00:31:40.200 --> 00:31:44.520
run. So you have to
make some optimizations along the

556
00:31:44.520 --> 00:31:46.950
way, and you have to
interpret some code upfront and

557
00:31:46.950 --> 00:31:49.860
then compile it later on
and so on. And as

558
00:31:49.860 --> 00:31:54.660
you said, if you put
in optimizations, caching, layers, remove

559
00:31:54.660 --> 00:31:58.050
redundant code or stuff like
that, you can make interpreters

560
00:31:58.050 --> 00:32:07.290
super fast. Very cool. So
people can check this out@interpreterbook.com.

561
00:32:07.500 --> 00:32:10.710
And from there, they can
check out the ebook, which

562
00:32:10.710 --> 00:32:13.290
includes a Kindle version and
a PDF version, or if

563
00:32:13.290 --> 00:32:15.750
they want, they can buy
a paperback from Amazon and

564
00:32:15.750 --> 00:32:18.060
get the, a full version.
And you're in all the

565
00:32:18.060 --> 00:32:21.180
Amazons all over the, all
over the worlds or any

566
00:32:21.180 --> 00:32:24.690
Amazon, right? Yeah. I think,
I don't think it's available

567
00:32:24.690 --> 00:32:27.690
in India, but it's available
in a lot of Amazon

568
00:32:27.700 --> 00:32:30.870
stores worldwide. Yeah. And they
can buy the ebook if

569
00:32:30.870 --> 00:32:34.230
they want to. Yeah. Brilliant.
Well, thanks so much for

570
00:32:34.230 --> 00:32:37.170
chatting with me today. Thanks
for having me that that's

571
00:32:37.170 --> 00:32:41.180
been a real pleasure talking
about this. Very Cool. This

572
00:32:41.180 --> 00:32:44.240
has been another episode of
Hanselminutes and we'll see you

573
00:32:44.240 --> 00:32:45.140
again next week.


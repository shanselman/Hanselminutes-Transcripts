WEBVTT FILE

1
00:00:12.060 --> 00:00:16.650
From Hanselman it's dot com.
It's Hansel minutes, a weekly

2
00:00:16.650 --> 00:00:20.760
discussion with web developer and
technologist Scott Hanselman hosted by

3
00:00:20.760 --> 00:00:26.190
Carl Franklin. This is Lawrence Ryan announcing
show number one 63. Recorded

4
00:00:26.190 --> 00:00:31.710
live Tuesday, May 26th, 2009. Support for
Hanselman it's just provided by

5
00:00:31.710 --> 00:00:35.670
teller rad controls. The most
comprehensive suite of components for

6
00:00:35.670 --> 00:00:46.350
windows forms and asp.net web
applications. online@wwwdottelerikdotcomandby.net developers journal the

7
00:00:46.350 --> 00:00:52.350
world's leading.net developer magazine online
at www dot <inaudible> dot

8
00:00:52.350 --> 00:00:57.330
com. In this episode, Scott
talks with Patrick Summakia lead

9
00:00:57.330 --> 00:01:02.310
developer at end depen. Hi,
this is Scott Hanselman, and

10
00:01:02.310 --> 00:01:05.280
this is another episode of
Hansel minutes, and I'm making

11
00:01:05.280 --> 00:01:08.580
an international call today talking
to Patrick smock here in

12
00:01:08.580 --> 00:01:11.880
France. We're talking about software
metrics. Patrick is the lead

13
00:01:11.880 --> 00:01:16.470
developer at end depend. Thanks
so much, Patrick, for being

14
00:01:16.470 --> 00:01:22.110
flexible with me and talking
across time zones today. So

15
00:01:22.110 --> 00:01:24.030
I wanted to talk to
you about software metrics because

16
00:01:24.030 --> 00:01:27.990
I'm a big fan of
independence and a lot of

17
00:01:27.990 --> 00:01:32.700
the different metrics that indepen
provides to measure quality and

18
00:01:32.700 --> 00:01:36.750
measure a coupling and all
the different things about software

19
00:01:36.750 --> 00:01:39.150
that people don't measure. And
I knew that you would

20
00:01:39.150 --> 00:01:41.790
be the best guy to
talk to. Cause I think

21
00:01:41.790 --> 00:01:45.870
for a lot of people,
lines of code is the

22
00:01:45.870 --> 00:01:49.020
metric that they start with.
And often the metric that

23
00:01:49.020 --> 00:01:52.500
they, that they end with
is lines of code a

24
00:01:52.510 --> 00:01:56.660
useful metric. Yeah, actually line
of code is representative code

25
00:01:56.660 --> 00:02:00.230
matrix because we are, we
are all working with the

26
00:02:00.290 --> 00:02:02.810
fives and you can view
the line of code in

27
00:02:02.810 --> 00:02:05.930
file. So everybody's thinking in
terms of final code and

28
00:02:05.930 --> 00:02:09.980
maybe number five or so,
but I just bled to

29
00:02:09.980 --> 00:02:14.210
make a point about physical
versus logical line of code,

30
00:02:14.630 --> 00:02:17.060
because if you should just
counting the number of line

31
00:02:17.060 --> 00:02:18.920
of code inside your file,
which is a lot of,

32
00:02:19.370 --> 00:02:21.470
a lot of guys I
think are doing that. I'm

33
00:02:21.470 --> 00:02:24.380
not sure it's a really
relevant metric because it can

34
00:02:24.380 --> 00:02:26.930
be dead by the language
can be gained by the

35
00:02:26.930 --> 00:02:30.770
cost side, the commenting Debbie's
a lot of things, a

36
00:02:30.980 --> 00:02:36.140
convenient side. So what the
tools are doing like can

37
00:02:36.140 --> 00:02:40.370
depend, or usually they are
counting line of code with

38
00:02:40.550 --> 00:02:45.080
what we call PDD scans
points, basically a sequence point,

39
00:02:45.470 --> 00:02:48.500
every developer.net developer know what
is the second sprint it's

40
00:02:48.800 --> 00:02:50.570
when you have a, when
you are tip again, you

41
00:02:50.570 --> 00:02:53.780
code, you could just hit
F nine, okay. To put

42
00:02:53.780 --> 00:02:56.420
your break point and what
is underlined by your X

43
00:02:56.420 --> 00:02:59.560
line. He's a second point.
Okay. And by the seconds

44
00:02:59.560 --> 00:03:03.010
point, we can say that
the chicken sport is the

45
00:03:03.010 --> 00:03:07.570
line of executive or executive
or code. Okay. And so

46
00:03:07.570 --> 00:03:09.280
we can say that the
line of code can be

47
00:03:09.280 --> 00:03:11.050
considered with second point. I
just want you to make

48
00:03:11.470 --> 00:03:15.160
this clear like this. We
have a metric, that's the

49
00:03:15.160 --> 00:03:18.760
language independent, like whether you're
doing vb.net or C sharp

50
00:03:18.760 --> 00:03:22.210
or sharp, or on your
language, you have a metric

51
00:03:22.210 --> 00:03:26.800
that can be comparable across
to engage also independent from

52
00:03:26.800 --> 00:03:29.980
the code style and you
don't get four inside the

53
00:03:29.980 --> 00:03:32.950
metric also. So it's a
perfect metric. It's a logical

54
00:03:32.950 --> 00:03:35.700
metric of a line of
code. Okay. So let me

55
00:03:35.700 --> 00:03:37.770
see if I understand this
though. So I want to

56
00:03:37.770 --> 00:03:39.840
make sure that I've understood
what you said. You're saying

57
00:03:39.840 --> 00:03:42.030
that, that when you just
count the lines of code,

58
00:03:42.030 --> 00:03:44.580
when we do these simple
line of code counters that

59
00:03:44.580 --> 00:03:46.950
we all have done and,
you know, computer science, one

60
00:03:46.950 --> 00:03:49.230
Oh one, and the teacher
says, we're going to build

61
00:03:49.230 --> 00:03:53.250
a program to count lines.
Sometimes we'll put in simple

62
00:03:53.580 --> 00:03:57.630
checks for avoiding things like
counting a, a curly brace

63
00:03:57.630 --> 00:04:00.270
as a line of code.
That would be physical lines

64
00:04:00.270 --> 00:04:03.930
of code. You're saying that
the sequence points, this is

65
00:04:03.930 --> 00:04:07.080
based on the PDB file.
This is based on a

66
00:04:07.080 --> 00:04:10.050
D on the, is, is
the PDB file required to

67
00:04:10.050 --> 00:04:13.000
count the sequence points. Yes,
exactly. Yeah. Yeah. The, the

68
00:04:13.530 --> 00:04:16.690
point of these fine inside
the PDB and usually they're,

69
00:04:17.340 --> 00:04:19.950
they are used by the
debit for the, the beginning

70
00:04:19.950 --> 00:04:23.670
experience to link the code
with the source code. But

71
00:04:23.670 --> 00:04:26.370
what most of the dotnet
tool, whether you are thinking

72
00:04:26.370 --> 00:04:29.580
of <inaudible> and COVID, most
of the donut tool are

73
00:04:29.580 --> 00:04:32.940
working actually the components in
a way or another. And

74
00:04:32.940 --> 00:04:35.280
usually when you are counting
the number of line of

75
00:04:35.280 --> 00:04:38.010
code, you are using the
second voice from DDB and

76
00:04:38.010 --> 00:04:43.890
visual. Interesting. Okay. So if
you can step over it,

77
00:04:44.010 --> 00:04:49.350
then you can count it.
Yeah. Okay. Now, in, in

78
00:04:49.350 --> 00:04:52.980
Steve McConnell's book on software
estimation, it, he says that

79
00:04:52.980 --> 00:04:55.770
lines of code really is
an efficient and efficient way

80
00:04:55.770 --> 00:05:00.540
to compare applications, but only
applications that are developed within

81
00:05:00.540 --> 00:05:03.120
the same context. I mean,
can I compare an iron

82
00:05:03.120 --> 00:05:06.480
Python application and a C
sharp application with lines of

83
00:05:06.480 --> 00:05:09.570
code and get any meaningful
results? I think that that's

84
00:05:09.570 --> 00:05:12.510
a, that's interesting to use
line of code for comparing

85
00:05:12.810 --> 00:05:15.390
a lot of developers. It's
like then of course, because

86
00:05:15.420 --> 00:05:19.260
they see it as a
yardstick to measure productivity. And

87
00:05:19.770 --> 00:05:23.280
I don't think it's relevant
to measure productivity because more

88
00:05:23.280 --> 00:05:26.160
line of code, we all
know that by cookie passcode,

89
00:05:26.460 --> 00:05:28.140
we can have more line
of code and it's a

90
00:05:28.140 --> 00:05:30.660
really bad thing. So line
of code, doesn't meet your

91
00:05:30.660 --> 00:05:33.750
productivity, but it's still very
useful. Indeed. I still, my

92
00:05:33.760 --> 00:05:38.430
Cornell said that to compare
code, because for example, I

93
00:05:38.430 --> 00:05:41.280
just have a few, few
numbers here to give the

94
00:05:41.280 --> 00:05:44.370
donate framework with this definition
as around 2 million, nine of

95
00:05:44.370 --> 00:05:47.730
code. Okay. Like we shopper
half the medial line of

96
00:05:47.730 --> 00:05:53.670
code and it depends, Hey,
2009 as the 35,000. Okay.

97
00:05:53.910 --> 00:05:57.560
ten.net as 45,000. And the
list is very long. And

98
00:05:57.560 --> 00:05:59.900
now you see that with
this number. If I'm talking

99
00:05:59.900 --> 00:06:03.740
like this, you can say
that <inaudible> is really a

100
00:06:03.740 --> 00:06:06.380
big, big, big piece of
code and you can compare

101
00:06:06.380 --> 00:06:09.950
it to the other or
the tool or the software

102
00:06:09.950 --> 00:06:12.170
that, you know, what what's
interesting is that you can

103
00:06:12.170 --> 00:06:15.350
build your, your own software
and like compare a fault

104
00:06:15.680 --> 00:06:18.630
in your software compare with
other, I fought that you

105
00:06:18.920 --> 00:06:22.030
know about, Ah, I think
the thing that surprised me

106
00:06:22.030 --> 00:06:25.390
there was that re ReSharper
was a half million lines

107
00:06:25.390 --> 00:06:28.570
of code, but that's probably
a topic for another day.

108
00:06:28.960 --> 00:06:31.060
I'm not working at ReSharper,
but I think they have

109
00:06:31.060 --> 00:06:33.960
a lots of generic zip
code because, you know, it's

110
00:06:33.970 --> 00:06:37.960
a comp compiler related. And
usually when you develop compiler,

111
00:06:37.960 --> 00:06:40.660
you will regenerate tons of
code. So I say, I

112
00:06:40.690 --> 00:06:44.560
think we shop a lot
of code, but it's also

113
00:06:44.560 --> 00:06:47.800
interesting to use line of
code inside your code bus

114
00:06:47.810 --> 00:06:53.110
to compile feature implementation. Okay.
Like we know that we

115
00:06:53.110 --> 00:06:55.840
have like the 2000 line
of code and future B,

116
00:06:55.840 --> 00:06:59.080
we have the 4,000 and
then maybe you can assess

117
00:06:59.080 --> 00:07:02.320
for the future feature C
you can assess the number

118
00:07:02.320 --> 00:07:03.940
of enough code, and maybe
you can have a good

119
00:07:03.940 --> 00:07:06.400
estimation of the time you're
going to spend on this

120
00:07:06.400 --> 00:07:10.780
feature. Now line of code
though, as a metric doesn't

121
00:07:10.780 --> 00:07:15.040
measure quality, it measures quantity.
So it's just one metric

122
00:07:15.430 --> 00:07:18.460
of, I assume, several dozen
metrics that we might want

123
00:07:18.460 --> 00:07:20.830
to use. What are some
metrics that I can use

124
00:07:20.830 --> 00:07:23.140
to really point at some
code? And it tells me

125
00:07:23.140 --> 00:07:26.440
whether this is good code
or not. First thing of

126
00:07:26.440 --> 00:07:29.740
code can be used for,
for quality, right? Like she

127
00:07:29.740 --> 00:07:32.890
has a very big <inaudible>
with more than let's say

128
00:07:32.890 --> 00:07:36.140
20 line of code begins
to be really hard to

129
00:07:36.220 --> 00:07:40.390
understand. Okay. So for, for
focus, quality for maintenance line

130
00:07:40.390 --> 00:07:42.790
of code can be used
at the third level and

131
00:07:43.030 --> 00:07:47.080
I will save another type
level. But what's really interesting

132
00:07:47.080 --> 00:07:49.540
is end of code is
that it's related to, to

133
00:07:49.570 --> 00:07:52.960
another very popular metric, which
is the ratio of code

134
00:07:52.960 --> 00:07:56.470
COVID by tests and whether
you are using in the

135
00:07:56.470 --> 00:07:59.230
donut world and Kovar, or
whether you are using a

136
00:07:59.230 --> 00:08:04.780
visual studio for coverage. Okay.
Both those tools are relying

137
00:08:05.470 --> 00:08:08.950
on PDC counts points actually
as diagnosis code. And two,

138
00:08:08.950 --> 00:08:11.710
sometimes you get that with
this tools. I actually put,

139
00:08:11.710 --> 00:08:13.900
sometimes you have line of
code. So, so these two

140
00:08:13.900 --> 00:08:20.020
metrics pretty related, and in
my opinion, there was show

141
00:08:20.020 --> 00:08:22.600
of course, covered by tests
is the most important metric

142
00:08:22.870 --> 00:08:28.390
you can have because there's
not related really to maintenance.

143
00:08:28.870 --> 00:08:32.530
Of course you can detect
a regression test, but also

144
00:08:32.590 --> 00:08:38.650
related to correctness, which is
very important on every developer

145
00:08:38.980 --> 00:08:41.650
and do more. You call
this COVID and you can

146
00:08:41.650 --> 00:08:45.460
be sure that the more
likely you are <inaudible>. So

147
00:08:45.580 --> 00:08:49.120
the ratio of lines of
code covered by tests can

148
00:08:49.120 --> 00:08:51.610
tell me whether or not
that code is going to

149
00:08:51.610 --> 00:08:55.500
run as I expect it
to it'll tell that it's

150
00:08:55.530 --> 00:09:01.320
correct. Does it really measure
code quality? I mean, I

151
00:09:01.320 --> 00:09:05.550
could write bad code and
have great coverage, I guess

152
00:09:05.580 --> 00:09:10.050
good or bad is a
usually subjective. Like beauty is

153
00:09:10.050 --> 00:09:14.760
a subjective thing. Is there
a more concrete metric I

154
00:09:14.760 --> 00:09:18.030
can use to decide whether
code is, is well-written or

155
00:09:18.030 --> 00:09:21.650
not? Hold send to quality
of some of the metrics

156
00:09:21.650 --> 00:09:24.440
and more or less we
all know about it. So

157
00:09:24.440 --> 00:09:27.560
there is one very important
metric, which is name psychometric

158
00:09:27.560 --> 00:09:31.310
complexity. So basically the definition
is the number of fastest

159
00:09:31.310 --> 00:09:34.490
thread can take, you know,
metered. So you find four

160
00:09:34.490 --> 00:09:37.820
meter, the concrete method with
the body, but a more

161
00:09:37.820 --> 00:09:43.520
concrete cyclometric complexity, the number
of, for each switch case,

162
00:09:43.520 --> 00:09:47.240
etc statements you have in
the body of humid and

163
00:09:47.240 --> 00:09:51.500
a <inaudible> with the number
of line of code, you

164
00:09:51.500 --> 00:09:54.410
can have pretty clear idea
of that, that won't be

165
00:09:54.410 --> 00:09:58.010
maintainable in the future. Anyway.
So you have also another

166
00:09:58.010 --> 00:10:01.100
border of this metric, which
is the nesting depth, which

167
00:10:01.100 --> 00:10:04.700
is the deepest chelated scopes
inside the body of the

168
00:10:04.760 --> 00:10:09.560
metered. Okay. And so you
can define these metrics. He

169
00:10:09.560 --> 00:10:12.920
really went out there, the
big fat meter that we

170
00:10:12.920 --> 00:10:17.630
will tend to maintain and
to, to develop. And of

171
00:10:17.630 --> 00:10:19.940
course you have a lot
of guys like no, those

172
00:10:20.060 --> 00:10:25.340
parameters and variables, number of
overloads for method, et cetera.

173
00:10:25.820 --> 00:10:28.970
So all these metrics, which
are the definition is pretty

174
00:10:28.980 --> 00:10:32.270
of use from a developer
point of view. All these

175
00:10:32.270 --> 00:10:35.150
metrics can be used with
three souls and it's very

176
00:10:35.150 --> 00:10:40.160
easy. You just stick, shoot.
We sold like a <inaudible>

177
00:10:40.280 --> 00:10:43.400
like, for example, I don't
want more than 10 for

178
00:10:43.400 --> 00:10:45.920
complexity of the metal or
more than 20 line of

179
00:10:45.920 --> 00:10:50.770
code. And then you need
some new continuous integration process.

180
00:10:51.170 --> 00:10:54.690
You can see immediately issue
of new guys that are

181
00:10:56.240 --> 00:11:02.210
not respecting this result. Okay.
So if I have lines

182
00:11:02.210 --> 00:11:07.190
of code in my toolbox,
I have cyclometric complexity and

183
00:11:07.190 --> 00:11:10.370
I have the percentage of
code covered by tests. I

184
00:11:10.370 --> 00:11:11.900
can get a good sense
of whether or not my

185
00:11:11.900 --> 00:11:16.280
code is, is objectively a
good code. I can tell

186
00:11:16.280 --> 00:11:18.830
whether or not it's going
to run as I wish,

187
00:11:19.310 --> 00:11:23.720
but when I start looking
at, you know, specific functions

188
00:11:23.720 --> 00:11:26.510
and I say, this function
is too complicated and I,

189
00:11:26.720 --> 00:11:30.290
and I break it up
into pieces, the complexity of

190
00:11:30.290 --> 00:11:34.370
the business problem is still
there. I've just made it

191
00:11:34.370 --> 00:11:37.580
into, into bite sized chunks.
So I might be able

192
00:11:37.580 --> 00:11:40.880
to look at my application
and say, this is no

193
00:11:40.880 --> 00:11:46.430
longer complex from a method
perspective, but the software itself,

194
00:11:46.580 --> 00:11:49.100
the way that the software
fits together, the way that

195
00:11:49.100 --> 00:11:54.070
it couples with other bits
of code may indicate other

196
00:11:54.070 --> 00:11:57.150
problems. Don't you think? Yeah,
I completely agree with you

197
00:11:57.150 --> 00:12:00.000
because actually we are talking,
we are talking about two

198
00:12:00.000 --> 00:12:04.500
kinds of complexity. The first
one talking about is related

199
00:12:04.530 --> 00:12:07.470
to your software. It's related
to the domain of your

200
00:12:07.470 --> 00:12:11.040
software and other points, you
will reach a point where

201
00:12:11.790 --> 00:12:15.690
the complexity of the software
developing. It cannot be smaller

202
00:12:15.690 --> 00:12:21.630
than what it is now,
but by having <inaudible>, by

203
00:12:21.630 --> 00:12:25.500
having all this very bad
thing, then you are fabricating

204
00:12:25.560 --> 00:12:29.100
even more complexity. So here,
the goal here is to

205
00:12:29.100 --> 00:12:33.940
reduce the fabricated complexity. So
finally, just keep the, the

206
00:12:34.080 --> 00:12:37.440
essential complexity that you will
have any way, because if

207
00:12:37.440 --> 00:12:41.130
you are doing professional software,
it is complex anywhere. So,

208
00:12:41.370 --> 00:12:43.380
so this is a, there
is really two kinds of

209
00:12:43.380 --> 00:12:46.890
complexity and there is one
you cannot really reduce, but

210
00:12:46.890 --> 00:12:49.230
you're the one that we
sold and there are metrics

211
00:12:49.280 --> 00:12:52.500
to try to witness this
one. I've used the independ

212
00:12:52.500 --> 00:12:55.260
over the years. And we
used it at, at a

213
00:12:55.280 --> 00:12:59.130
Kirlian. CheckFree the banking company
that I worked at. And

214
00:12:59.130 --> 00:13:01.380
I always found that it
took me a while to

215
00:13:01.380 --> 00:13:04.740
get my brain around the
way that it displays the

216
00:13:04.740 --> 00:13:07.950
information. It's a, it can
be a little overwhelming when

217
00:13:07.950 --> 00:13:11.130
you try to present such
a large amount of information

218
00:13:11.910 --> 00:13:19.260
over a very, very large
library. I always show people

219
00:13:19.260 --> 00:13:23.910
the.net framework, you know, thousands
of types. And, you know,

220
00:13:23.970 --> 00:13:26.010
it almost feels like I
don't have enough pixels on

221
00:13:26.010 --> 00:13:30.540
the screen to, to present
this. What is the name

222
00:13:30.540 --> 00:13:33.390
of the, the view that
you use to show this?

223
00:13:33.390 --> 00:13:35.760
It's kind of like a
grid and then there's colors

224
00:13:35.760 --> 00:13:39.120
and numbers within the grid
and you can drill in

225
00:13:39.120 --> 00:13:41.280
and out. What is that
call that you're, that you're

226
00:13:41.280 --> 00:13:44.880
using? So basically what we
don't in, in the tool

227
00:13:44.880 --> 00:13:48.000
and Japan is that we
have a four panels and

228
00:13:48.420 --> 00:13:51.900
we try to provide civil
view on new code, whether

229
00:13:51.900 --> 00:13:55.500
is it about dependency or
whether it's about matrix or,

230
00:13:55.790 --> 00:13:59.970
or evolution, but when it
comes to metrics, the, the

231
00:14:00.030 --> 00:14:02.280
view you are talking about,
what's his name team up.

232
00:14:02.940 --> 00:14:07.770
Okay. And basically is just
a usual rectangle. You have

233
00:14:07.770 --> 00:14:10.800
your panel defined as a
rectangles. So this rectangle as

234
00:14:10.800 --> 00:14:13.440
a read as an, a
hate, and it defines us

235
00:14:13.440 --> 00:14:22.930
too fast. Okay. And did,
is that we've caught a

236
00:14:22.940 --> 00:14:27.390
demand Mitch value. So for
example, if you are looking

237
00:14:27.390 --> 00:14:30.450
at the number of plaintiff
code of type inside your

238
00:14:30.450 --> 00:14:34.590
library or inside the net
framework, for example, we can

239
00:14:34.590 --> 00:14:37.650
say that like, there is
like 2 million sign off. We

240
00:14:37.650 --> 00:14:40.290
can say that the first
of the funnel is actually

241
00:14:40.290 --> 00:14:43.230
2 million, nine of God. And
then what we want to

242
00:14:43.530 --> 00:14:48.200
do is to represent each
class inside the.net framework, we

243
00:14:48.900 --> 00:14:52.190
ask for proportional to the,
of fine of code of

244
00:14:52.250 --> 00:14:56.210
the concern class. Okay. So
basically you will get a

245
00:14:56.210 --> 00:14:59.330
rectangle and a lot, a
lot of sub rectangle inside

246
00:14:59.330 --> 00:15:03.140
this rectangle and the big
sub rectangle will be actually

247
00:15:03.140 --> 00:15:06.520
the big type. Hi, it's
Scott here from another place

248
00:15:06.520 --> 00:15:08.440
in time. I hope you're
enjoying the show so far.

249
00:15:08.830 --> 00:15:10.660
I apologize for interrupting it,
but I wanted to let

250
00:15:10.660 --> 00:15:12.880
you know that assembling a
podcast like this every week,

251
00:15:12.880 --> 00:15:16.030
isn't free. Certainly the bandwidth
bill crushes us every month.

252
00:15:16.060 --> 00:15:17.350
So I wanted to let
you know that this show

253
00:15:17.350 --> 00:15:20.170
is sponsored by Tellerik. They
make the show possible and

254
00:15:20.170 --> 00:15:22.870
it makes it pretty cool
products as well. For example,

255
00:15:22.870 --> 00:15:24.850
if you're trying to build
a web 2.0 age, actually

256
00:15:24.850 --> 00:15:27.760
application trying to use the
web 1.0 components, it's kind

257
00:15:27.760 --> 00:15:30.100
of difficult. You got to
get the next gen stuff.

258
00:15:30.100 --> 00:15:32.020
If you want to build
the next gen websites. And

259
00:15:32.020 --> 00:15:34.360
that's exactly what the folks
at Tellerik have got and

260
00:15:34.360 --> 00:15:37.000
their new upcoming product, which
is code named rad controls.

261
00:15:37.000 --> 00:15:40.450
Prometheus's big pack, a web
controls built entirely on top

262
00:15:40.450 --> 00:15:42.970
of the Microsoft ASP net
Ajax stuff that you already

263
00:15:42.970 --> 00:15:45.250
understand. It's going to give
you a lot of performance

264
00:15:45.250 --> 00:15:48.490
interactivity on your next project.
They mirror the ASP net

265
00:15:48.490 --> 00:15:52.380
Ajax API. So the development's
really straightforward client scripture's shared

266
00:15:52.390 --> 00:15:55.030
loading time is pretty fast.
You set a couple of

267
00:15:55.030 --> 00:15:57.250
properties. You can even bind
a web services for really

268
00:15:57.250 --> 00:16:00.730
efficient operation. The new rad
editor for ESPN at Ajax

269
00:16:00.730 --> 00:16:03.310
loads up to four times
faster than before. And the

270
00:16:03.310 --> 00:16:06.520
rad grid will do thousands
of records in milliseconds. But

271
00:16:06.520 --> 00:16:08.410
of course, it's better to
try these things for yourself.

272
00:16:08.410 --> 00:16:11.140
So you can visit <inaudible>
dot com slash ASP, net

273
00:16:11.140 --> 00:16:14.170
Ajax, and download a trial.
Thanks a lot for listening

274
00:16:14.170 --> 00:16:17.860
and we'll get right back
to the show. Okay. So

275
00:16:17.860 --> 00:16:20.980
the size of the rectangle
is an it's something I

276
00:16:20.980 --> 00:16:23.050
can choose. I can say
that this rectangle is going

277
00:16:23.050 --> 00:16:25.690
to be large because of
lines of code or because

278
00:16:25.690 --> 00:16:29.410
of some other metrics. So
the size of the rectangle

279
00:16:29.410 --> 00:16:32.920
is another axis in my,
in my graph that I'm,

280
00:16:33.110 --> 00:16:37.840
I'm trying to make multidimensional
data appear in two dimensions.

281
00:16:38.470 --> 00:16:41.020
Yeah, that's exactly that thing.
What's interesting. So with the

282
00:16:41.050 --> 00:16:44.800
three map view, is that
a, is that the metric

283
00:16:44.800 --> 00:16:48.130
that gives me the class
that are related, like for

284
00:16:48.130 --> 00:16:53.050
example, classes inside the same
name space will be, will

285
00:16:53.050 --> 00:16:58.060
be plastic clubs on the
we'll be located near, inside

286
00:16:58.060 --> 00:17:01.060
the three maps. So you
can see that these namespaces

287
00:17:01.060 --> 00:17:05.290
big, big, or this one
is very small. So not

288
00:17:05.290 --> 00:17:08.710
only gives you a size
four metered side, but also

289
00:17:08.710 --> 00:17:11.200
financial state and as somebody.
So you can see the,

290
00:17:11.490 --> 00:17:14.020
the whole structure of the
code in terms of the

291
00:17:14.020 --> 00:17:16.750
metric you are choosing to
turn, and here is the

292
00:17:16.780 --> 00:17:19.960
number of, And then because
of the grouping, I can

293
00:17:19.960 --> 00:17:23.410
group things are grouped by
namespace and by assembly, I

294
00:17:23.410 --> 00:17:26.560
could look at something kind
of, I could back away

295
00:17:26.560 --> 00:17:29.410
from my large monitor and
I could tell whether one

296
00:17:29.590 --> 00:17:33.970
assembly is a problem based
on the complexity that appears

297
00:17:33.970 --> 00:17:37.660
in one assembly versus versus
another. I could probably use

298
00:17:37.660 --> 00:17:40.840
this also to measure the
complexity of open source applications

299
00:17:40.840 --> 00:17:45.160
that I bring in libraries
that may, you know, may

300
00:17:45.160 --> 00:17:47.980
feel good. But when I
look at the numbers, they

301
00:17:47.980 --> 00:17:51.900
might be trouble in the
She's under the application of

302
00:17:52.140 --> 00:17:55.110
this kind of tool for
measuring quality is good to

303
00:17:55.110 --> 00:17:59.010
measure your own quality. But
for example, when you are,

304
00:17:59.250 --> 00:18:02.160
when you are buying early
library, or when you order

305
00:18:02.160 --> 00:18:06.870
someone to do library for
you, it's interesting to minimal

306
00:18:06.870 --> 00:18:11.720
matrix to, to abide by
insight, insight like that. You,

307
00:18:11.720 --> 00:18:14.040
you can be not really
sure that the quality will

308
00:18:14.040 --> 00:18:16.590
be here, but at least
you can, you can assess

309
00:18:16.630 --> 00:18:19.800
the quality. So I think
this is a new kind

310
00:18:19.800 --> 00:18:23.970
of way to see the
relation between the different actors

311
00:18:24.000 --> 00:18:27.300
in the software development. Because
now you can, you can

312
00:18:27.300 --> 00:18:30.210
say, I want this minimum
of quality, like in any

313
00:18:30.210 --> 00:18:33.360
other industry, when you are
ordering the building or Villa

314
00:18:33.360 --> 00:18:36.240
or house, anything you want
a minimum quality. I need

315
00:18:36.540 --> 00:18:39.990
people with eyes and we,
this kind of tool. Now

316
00:18:39.990 --> 00:18:43.070
you can do it in
software, Right? Yeah. The, the

317
00:18:43.070 --> 00:18:47.060
ability to be able to
stop a build because of

318
00:18:47.060 --> 00:18:49.280
something being wrong has always
been important to me when

319
00:18:49.280 --> 00:18:53.270
I'm doing a CEI, when
I'm doing continuous integration, being

320
00:18:53.270 --> 00:18:57.080
able to say that the
build has failed because of

321
00:18:57.080 --> 00:19:01.790
some syntax error is really
step zero. Being able to

322
00:19:01.790 --> 00:19:04.520
stop the build and declare
that the build is bad

323
00:19:04.520 --> 00:19:07.850
because of a test failure
is important. But the idea

324
00:19:07.850 --> 00:19:11.240
that you could stop a
test based on a design

325
00:19:11.240 --> 00:19:15.110
flaw, I always thought was
a cool, a cool idea

326
00:19:15.110 --> 00:19:17.240
that I could say, this
is just too complex for

327
00:19:17.240 --> 00:19:19.850
any human to understand, and
I want to stop the

328
00:19:19.850 --> 00:19:22.520
build. And, you know, perhaps
I could put in a,

329
00:19:23.330 --> 00:19:27.320
an exception It's I have
a COVID about tail here.

330
00:19:27.470 --> 00:19:30.560
Is that now more and
more, and we keep fall

331
00:19:30.620 --> 00:19:33.230
of COVID actually more and
more. We have a lot

332
00:19:33.230 --> 00:19:36.620
of generated code. Okay. And
actually just two, there is

333
00:19:36.620 --> 00:19:40.700
a new show with Kathleen
dolls about cogeneration. And one

334
00:19:40.700 --> 00:19:44.420
question was about the quality
of generic cheat code. And

335
00:19:44.780 --> 00:19:47.060
what we can see is
that the real from the

336
00:19:47.060 --> 00:19:50.720
quality of the generic is
not here because this code

337
00:19:50.720 --> 00:19:55.010
actually, won't having to be
understood by, by the human.

338
00:19:55.020 --> 00:19:57.140
So you said we did
a good thing, but when

339
00:19:57.140 --> 00:20:02.420
Tula analyzing code at first,
she doesn't make the difference

340
00:20:02.450 --> 00:20:07.430
between generated and a <inaudible>
quested code, right? So you

341
00:20:07.430 --> 00:20:10.550
don't want to AB to,
to, to follow metrics too

342
00:20:10.550 --> 00:20:13.130
much about that. So for
example, in Japan, we are,

343
00:20:13.160 --> 00:20:15.980
we are providing some facility
like you can use some

344
00:20:16.160 --> 00:20:20.450
regular expression, or you can
require that site outside of

345
00:20:20.450 --> 00:20:23.690
the assembly, won't be, won't
be inspected or things like

346
00:20:23.690 --> 00:20:26.630
that, but still you have
this generated code. Maybe you

347
00:20:26.630 --> 00:20:29.650
don't really want to hear
about inside your report. So

348
00:20:31.310 --> 00:20:33.920
this is a good thing
to stop the bill, to

349
00:20:33.920 --> 00:20:37.130
fake the bill because of
quality. But you have to

350
00:20:37.130 --> 00:20:40.010
make sure first that you
have under this, this potential

351
00:20:40.010 --> 00:20:42.530
problem, Right? It sounds like
I'll have a lot of

352
00:20:42.530 --> 00:20:47.290
exceptions. Definitely. Now lines of
code are still, these are

353
00:20:47.290 --> 00:20:50.140
still pretty, pretty basic. We're
kind of moving from the

354
00:20:50.430 --> 00:20:53.440
basic metrics to the more
complex. I think that everyone

355
00:20:53.680 --> 00:20:56.650
has used lines of code.
At some point, people, as

356
00:20:56.650 --> 00:21:00.340
they start getting into a
test driven development and respecting

357
00:21:00.340 --> 00:21:04.420
their tests, they start caring
about code coverage. The things

358
00:21:04.450 --> 00:21:08.410
that I think are the
most interesting metrics are the

359
00:21:08.410 --> 00:21:10.690
ones that I'm afraid to
use a lot of math,

360
00:21:10.720 --> 00:21:13.060
and they use a lot
of charts and graphs to

361
00:21:13.060 --> 00:21:15.520
explain. And then the one
that I found the most

362
00:21:15.520 --> 00:21:18.520
useful when I was working
in, in, in the banking

363
00:21:18.520 --> 00:21:23.920
industry was this notion of
afferent and efferent, coupling afferent,

364
00:21:23.950 --> 00:21:27.190
a F F and efferent
E F F. And I

365
00:21:27.190 --> 00:21:30.160
think they're really horribly named
because I can't quite keep

366
00:21:30.160 --> 00:21:35.920
them, keep them straight. And
the idea is that who

367
00:21:35.920 --> 00:21:40.060
is using me and what
am I using? Is that,

368
00:21:40.060 --> 00:21:41.560
is that a fair way
to put it? And how

369
00:21:41.560 --> 00:21:42.940
do I keep them? How
do I keep track of

370
00:21:42.940 --> 00:21:47.790
which ones afferent, coupling, and
which ones efferent These two,

371
00:21:47.790 --> 00:21:50.640
these two metrics, actually, they
are related to something that

372
00:21:50.640 --> 00:21:54.300
we pop it off for
every architect, which is everybody's

373
00:21:54.630 --> 00:21:56.220
nowadays is they know what
days, and this is a

374
00:21:56.220 --> 00:21:59.340
good thing. Everybody said, I
want low coupling. And I

375
00:21:59.340 --> 00:22:02.490
want high collision inside my
code. And what's interesting is

376
00:22:02.490 --> 00:22:06.600
that we have metric for
that. So Metricon concerning coupling,

377
00:22:06.630 --> 00:22:10.200
as you said, they are
incoming and outgoing or runs

378
00:22:10.200 --> 00:22:14.490
an uncoupling. Okay. And this
metric can be very interesting

379
00:22:14.490 --> 00:22:18.180
because for example, let's take
the, if interferon, uncoupling, what

380
00:22:18.180 --> 00:22:20.340
does it mean? If you
have a high Extron coupling,

381
00:22:20.340 --> 00:22:23.430
let's say for class the
highest run, it means that

382
00:22:23.430 --> 00:22:25.920
you have a class that
is using lots of the

383
00:22:25.920 --> 00:22:30.000
classes. So efferent coupling means
I have a lot of

384
00:22:30.060 --> 00:22:33.840
outgoing references. I'm using a
lot of stuff. Exactly. Yeah.

385
00:22:34.050 --> 00:22:36.000
Imagine you have a friend
that is using a lot

386
00:22:36.000 --> 00:22:39.540
of stuff. Then you can
say almost sure that this

387
00:22:39.540 --> 00:22:43.710
class is breaking the senior
responsibility principle. So imagine a

388
00:22:43.710 --> 00:22:47.580
cloud that is using some,
some WPST things and it's

389
00:22:47.580 --> 00:22:51.300
using some data things, and
maybe some, a threading thing,

390
00:22:51.300 --> 00:22:55.760
like observing your class, like
kind of big fat class

391
00:22:55.970 --> 00:22:58.380
using a lot of things.
Then you can see that

392
00:22:58.380 --> 00:23:01.830
the single responsibility principle that
just stayed that study, that

393
00:23:02.130 --> 00:23:04.890
that class should have just
one reason to change. Or,

394
00:23:05.030 --> 00:23:07.890
or that, I just say
that a class of just

395
00:23:07.890 --> 00:23:11.460
one concern, you can see
that it's broken and actually

396
00:23:12.360 --> 00:23:15.210
stuff called base sheet. There
is a lot of such

397
00:23:15.210 --> 00:23:18.630
classes at discusses. They can
be supported with line of

398
00:23:18.630 --> 00:23:21.240
code for the complexity, but
if someone could bring his

399
00:23:22.050 --> 00:23:29.340
weight, he's a real key
concern class and concerning <inaudible>

400
00:23:29.950 --> 00:23:34.140
the Gaia, the number of
Gaia that use me, imagine

401
00:23:34.140 --> 00:23:36.510
that you have a crowd
that is a pretty popular,

402
00:23:36.510 --> 00:23:39.270
that is pretty used in
Southside you inside your code

403
00:23:39.270 --> 00:23:42.780
bad. What does it mean?
It means that this class

404
00:23:42.780 --> 00:23:45.890
is changing. If we pull
back, we a lot of

405
00:23:45.890 --> 00:23:52.220
other things. So a Cooper
on the class, I think

406
00:23:52.220 --> 00:23:54.950
it's a bad thing to,
and here there is a

407
00:23:54.950 --> 00:23:58.430
tweak. The tweak is to
transform your class inside the

408
00:23:58.520 --> 00:24:03.650
other. You can swap your
implementation to an abstraction. Okay?

409
00:24:03.650 --> 00:24:09.470
If you have the highest
<inaudible>, you cannot avoid it.

410
00:24:09.530 --> 00:24:12.080
There will be some type
that will be very popular

411
00:24:12.110 --> 00:24:15.050
because <inaudible>, but I've seen,
it's a good thing that

412
00:24:15.560 --> 00:24:18.680
these type will be implementation.
Even then you should just

413
00:24:18.680 --> 00:24:21.200
do one NFS for one
class. It's a good thing,

414
00:24:21.200 --> 00:24:23.450
because at least you can
agree on a contract. You

415
00:24:23.450 --> 00:24:26.660
can define your interface as
a contract, and a, at

416
00:24:26.660 --> 00:24:29.600
least you can agree with
all these user that they

417
00:24:29.600 --> 00:24:32.600
should be, that you use
different efforts this way. Maybe

418
00:24:32.600 --> 00:24:35.690
the implementation evolve. It won't
be seen by others, but

419
00:24:35.690 --> 00:24:41.200
by user. So that's a
metric that's in services. And

420
00:24:41.210 --> 00:24:45.410
finally, another usage of <inaudible>.
It's interesting because if you

421
00:24:45.410 --> 00:24:48.110
have zero, it means that
your class is not used

422
00:24:48.110 --> 00:24:51.140
at all. And this is
not always true because of

423
00:24:51.140 --> 00:24:53.420
course you can use it
with reflection. You can see

424
00:24:53.690 --> 00:24:55.970
he's putting more, features, more
things like that. But step

425
00:24:56.110 --> 00:24:58.470
three, you can see for
class is not used. And

426
00:24:59.090 --> 00:25:01.190
in any depend, we are
using the streets through some

427
00:25:01.190 --> 00:25:06.350
key points. That code that's
another usage of interesting usage

428
00:25:06.350 --> 00:25:12.100
of Asteron cooking. Okay. So
afferent coupling the, the incoming

429
00:25:12.340 --> 00:25:16.270
usage. You're saying that having
a lot of people rely

430
00:25:16.270 --> 00:25:19.030
on me, puts a lot
of pressure on me as

431
00:25:19.030 --> 00:25:21.490
a class. It also tells
me whether or not I'm

432
00:25:21.490 --> 00:25:23.290
going to be a problem
if I change. So I

433
00:25:23.290 --> 00:25:26.290
like that afferent coupling is
a good signal that you

434
00:25:26.290 --> 00:25:28.960
should be thinking about interfaces
if you haven't already been.

435
00:25:29.230 --> 00:25:34.750
Yeah. All right. Very cool.
There is another liter of

436
00:25:34.750 --> 00:25:38.710
this metric, which is the
ranking metrics get inspired from

437
00:25:38.710 --> 00:25:41.710
the Google ranking page. I'll
go with them and they're

438
00:25:41.990 --> 00:25:45.480
independent. We implemented this matrix.
So in both type and

439
00:25:45.490 --> 00:25:48.310
a method, or maybe better
said on the graph of

440
00:25:48.310 --> 00:25:51.400
site and the grasp of
third. And so now we

441
00:25:51.400 --> 00:25:54.250
can see with this metric,
which one is very important

442
00:25:54.250 --> 00:25:57.820
insight. So just as an
example, if we apply this

443
00:25:57.820 --> 00:26:02.830
metric on the.net framework immediately,
the top 10 type will,

444
00:26:03.160 --> 00:26:08.560
will be Jake integers, Boolean,
et cetera, or primitive side

445
00:26:08.560 --> 00:26:12.430
that are extremely important and
actually use everywhere. But now,

446
00:26:12.460 --> 00:26:15.310
if we translate this metric
on a, another code base,

447
00:26:15.820 --> 00:26:18.460
it's very interesting because you
shouldn't know a code base,

448
00:26:18.460 --> 00:26:20.680
you should just have a
code base. You just arrive.

449
00:26:21.130 --> 00:26:24.010
Then you can see what's
really important. What's really matter

450
00:26:24.010 --> 00:26:26.680
inside the code base. And
then you can begin to

451
00:26:26.680 --> 00:26:29.090
study this thing and see
how they are related to

452
00:26:29.170 --> 00:26:33.300
component. And this is also
a good metric to, to,

453
00:26:33.490 --> 00:26:36.790
to use, to, to discover
quote base. One of the

454
00:26:36.790 --> 00:26:39.670
things that I think is
exciting about software metrics, it

455
00:26:39.670 --> 00:26:42.160
seems obvious to you, I
think because you work in

456
00:26:42.160 --> 00:26:45.300
this, in this stuff every
day, but the idea that

457
00:26:45.300 --> 00:26:49.050
you could come upon a,
a, a metric, which is

458
00:26:49.050 --> 00:26:52.220
really just an equation, and
you could say, Oh, well,

459
00:26:52.220 --> 00:26:54.750
this would be fun. Let's
see how we can apply

460
00:26:54.750 --> 00:26:58.350
this to, to code. So
the idea that you took

461
00:26:58.590 --> 00:27:02.760
Google page rank as a,
as a popularity and applied

462
00:27:02.760 --> 00:27:05.190
it to code is I
think is a, is a

463
00:27:05.190 --> 00:27:06.870
way I wouldn't have thought.
I think I wouldn't have

464
00:27:06.870 --> 00:27:09.650
thought of It gets pretty
interesting. I'm not sure I'm

465
00:27:09.650 --> 00:27:13.160
the first one that did
that, that, that, that is

466
00:27:13.160 --> 00:27:17.450
pretty interesting results. Well, it
certainly, no, one's the first

467
00:27:17.450 --> 00:27:20.480
one to do anything anymore.
No, I know that <inaudible>

468
00:27:20.510 --> 00:27:23.810
like now, which is now
at Microsoft research on the

469
00:27:23.820 --> 00:27:26.080
text. I know he did
this metric. I think a

470
00:27:26.090 --> 00:27:28.880
bit before me, he did
this metric inside, inside the

471
00:27:28.880 --> 00:27:33.260
network sector, I think. Oh
yeah. One of the metrics

472
00:27:33.260 --> 00:27:35.300
that stood out that I
thought was fun was this

473
00:27:35.300 --> 00:27:39.500
metric called crap, the crap
metric, which stands for change

474
00:27:39.500 --> 00:27:43.340
risk analyzer and predictor. It's
a, it's a Java metric

475
00:27:44.090 --> 00:27:47.840
that basically tells you if
your code is crap. Right?

476
00:27:49.280 --> 00:27:52.280
The problem. So here we
have some other metrics like

477
00:27:52.610 --> 00:27:56.420
that. Actually, they are metric
composition. So now for fall,

478
00:27:56.420 --> 00:27:59.090
we just talk about basic
metrics that can be really

479
00:27:59.750 --> 00:28:02.240
image, at least from the
there. And the idea here

480
00:28:02.240 --> 00:28:04.910
is to put some equation
and to compose this metric.

481
00:28:05.240 --> 00:28:08.900
So for example, the crop
is the psychometric complexity or

482
00:28:08.900 --> 00:28:14.750
squared multiply by one minus
the COVID, right? So you

483
00:28:14.750 --> 00:28:18.300
are the big formula. And
at the end and experience

484
00:28:18.370 --> 00:28:21.930
that you, that you given
by this formula, in this

485
00:28:21.930 --> 00:28:24.080
sponge, it will be very
bad and these ranges would

486
00:28:24.080 --> 00:28:27.320
be acceptable, et cetera. So
you can use metric. You

487
00:28:27.320 --> 00:28:30.260
can compose matrix. There is
another example of a metric

488
00:28:30.260 --> 00:28:34.460
composition in digital. Should you
go, you have the maintainability

489
00:28:34.520 --> 00:28:39.710
index, okay. Which is a
mix of the metric metric

490
00:28:39.710 --> 00:28:43.580
and psychometric complexity line of
code, et cetera. And the

491
00:28:43.580 --> 00:28:46.430
idea is that here you
get a number without dimension.

492
00:28:46.640 --> 00:28:49.550
Okay. When you say a
line of code that you

493
00:28:49.550 --> 00:28:52.520
mentioned is one line of
code, right? Or when you

494
00:28:52.520 --> 00:28:56.810
say <inaudible> is the number
of user, okay. But here

495
00:28:56.810 --> 00:28:59.570
you get to a metric
without dimension that is to

496
00:28:59.570 --> 00:29:02.600
post to give you a
original about what's really bad.

497
00:29:03.020 --> 00:29:05.090
And in my opinion, I
don't really believe in this

498
00:29:05.090 --> 00:29:10.880
metric because I I've never
seen a composed metric because

499
00:29:10.880 --> 00:29:13.700
it's very easy to fake
this metric with a false

500
00:29:13.700 --> 00:29:17.720
positive and a counter example,
then that doesn't show that

501
00:29:17.720 --> 00:29:20.540
it doesn't work all the
time. I think that the

502
00:29:20.720 --> 00:29:24.110
definition of a sweat metric
as to us to stay

503
00:29:24.110 --> 00:29:28.880
pretty, pretty understandable for everybody.
And the minimal requirements is

504
00:29:28.880 --> 00:29:31.100
that you can understand that
you mentioned of the metrics.

505
00:29:32.090 --> 00:29:34.550
Well, the, the thing that
I like about this metric

506
00:29:34.550 --> 00:29:37.370
and why I think the
crap metric is it's fun

507
00:29:37.790 --> 00:29:41.200
and not just fun, but
useful is that in this

508
00:29:41.200 --> 00:29:45.940
instance where we're composing a
metric about complexity, we're composing

509
00:29:45.940 --> 00:29:50.680
a metric using cyclometic complexity
and composing it with coverage.

510
00:29:51.070 --> 00:29:56.020
We're basically saying that this
is complex, but I'm protected

511
00:29:56.020 --> 00:29:59.370
by these tests. I think
you can have a more

512
00:29:59.430 --> 00:30:02.730
linear way to compose metrics.
So for example, the approach

513
00:30:02.730 --> 00:30:05.220
we are taking in independence,
that you can just define

514
00:30:05.220 --> 00:30:08.400
some rule and no, you
cannot, for example, for complex

515
00:30:08.400 --> 00:30:11.670
method that are not COVID
because you can define some

516
00:30:11.670 --> 00:30:14.760
kind of what we call
SQL query. So basically we

517
00:30:14.760 --> 00:30:17.280
are craving the code as
you would query a database.

518
00:30:17.280 --> 00:30:20.700
Okay? And maybe you can
really ask us select method

519
00:30:20.730 --> 00:30:24.450
where the complexity is higher
than maybe 10. And the

520
00:30:24.450 --> 00:30:27.600
percentage per bridge is lower
maybe than 10%. And you

521
00:30:27.600 --> 00:30:29.580
get the effectively the same
thing as what you're saying.

522
00:30:30.210 --> 00:30:34.530
Exactly, but it's more linear
and at least remains understandable.

523
00:30:34.550 --> 00:30:37.900
And if you have a
false book, it will be

524
00:30:37.900 --> 00:30:40.590
very easy to understand why,
why you're here. You have

525
00:30:40.590 --> 00:30:44.490
a problem, but usually by
composing linearly, the metric is

526
00:30:44.490 --> 00:30:47.250
going to be, you can
understand the ratio, which is

527
00:30:47.250 --> 00:30:51.820
really the person essentially. Yeah.
That's a good point that

528
00:30:51.820 --> 00:30:55.200
the crap metric is interesting
because it's squares the complexity

529
00:30:55.200 --> 00:30:58.770
number, and then it cubes
the code coverage number. So

530
00:30:58.770 --> 00:31:02.910
it's putting more weight on,
on one aspect of the,

531
00:31:02.910 --> 00:31:06.300
of the metric than another,
as with all of these

532
00:31:06.300 --> 00:31:07.950
things, they have a reason
for it. But I think

533
00:31:08.100 --> 00:31:10.950
your point is well taken.
You can't really easily look

534
00:31:10.950 --> 00:31:13.560
at the value and say,
here's what I need to

535
00:31:13.560 --> 00:31:17.550
do to pass this metric.
Another composed metric that you

536
00:31:17.550 --> 00:31:21.510
use is this, this vs
maintainability index. This is something

537
00:31:21.510 --> 00:31:26.480
that the FX cop team
uses. It's an index. That's,

538
00:31:26.480 --> 00:31:28.830
that's more linear, but it
is it a, it's not

539
00:31:28.830 --> 00:31:31.170
a percentage, right? It's not
one to a hundred. Is

540
00:31:31.170 --> 00:31:34.590
it? I don't quite understand
the number Because that's exactly

541
00:31:34.590 --> 00:31:36.720
the point. I wasn't. I
was making you, you don't

542
00:31:36.720 --> 00:31:39.090
get the number because there
is no dimension in that

543
00:31:39.090 --> 00:31:43.290
number because it's a mix
between civil matrix, that complexity

544
00:31:43.290 --> 00:31:47.290
line of code. And so
you cannot put a dimension

545
00:31:47.290 --> 00:31:50.550
and each issue don't understand
Microsoft just totally tell you

546
00:31:50.550 --> 00:31:53.610
that you will have a
number between zero and 100,

547
00:31:54.030 --> 00:31:57.660
but maybe if it's a
up to 20, it will

548
00:31:57.660 --> 00:32:01.260
be good. But you just,
you just forced to, to

549
00:32:01.330 --> 00:32:03.660
listen to them because it
should not an extent. You

550
00:32:03.660 --> 00:32:06.750
cannot understand that you mentioned
metric and you cannot do

551
00:32:06.750 --> 00:32:09.240
proper choice by you own.
So this is the world.

552
00:32:09.240 --> 00:32:13.620
Proper fam was the composing
nonlinearly metrics, I think. Yeah,

553
00:32:13.620 --> 00:32:16.920
I agree. It's very confusing.
Now I've been playing with

554
00:32:16.950 --> 00:32:19.530
dotnet for, Oh, and I
know that you have to,

555
00:32:19.590 --> 00:32:22.980
and you've been looking at,
I think you called them

556
00:32:22.980 --> 00:32:27.330
evolutionary metrics or metrics around
how, how things change. So

557
00:32:27.330 --> 00:32:30.780
being able to compare multiple
builds and you had a

558
00:32:30.780 --> 00:32:32.610
blog post a couple of
days ago where you were

559
00:32:32.610 --> 00:32:37.260
looking at dotnet three, five
and.net four and seeing what

560
00:32:37.260 --> 00:32:41.150
was changed and, and what
was added to the diamond

561
00:32:41.150 --> 00:32:45.220
framework. Yeah. I've seen that,
Dave, will you share the

562
00:32:45.220 --> 00:32:49.000
changes inside the code base
is extremely important. And with

563
00:32:49.000 --> 00:32:51.520
the widow you are using
a good frame work, like

564
00:32:51.520 --> 00:32:54.760
the.net framework, and one to
see what's evolving or whether

565
00:32:54.760 --> 00:32:57.880
you are just seeing that
they've already shown on your

566
00:32:57.880 --> 00:33:00.850
own code. I think it's
very important because think about

567
00:33:00.850 --> 00:33:03.730
it when you release there's
some code when the code

568
00:33:03.730 --> 00:33:07.120
is a projection. Okay. If
you have a, if you

569
00:33:08.110 --> 00:33:09.580
don't have bugs or you
are a few bugs, when

570
00:33:09.580 --> 00:33:12.210
the cottage in production, or
at least this is the

571
00:33:12.220 --> 00:33:15.770
goal you want to achieve,
right? So between the release

572
00:33:16.060 --> 00:33:20.500
N minus one and the
next release number N okay.

573
00:33:20.620 --> 00:33:24.100
All the, all the difference
between the two, the two

574
00:33:24.100 --> 00:33:29.980
snapshots codebase can contain Schulberg
that have not been in

575
00:33:29.980 --> 00:33:33.850
production yet. So I think
that the focusing on to

576
00:33:33.880 --> 00:33:39.100
the Delta between two really
diseases, extremely potent, and the

577
00:33:39.940 --> 00:33:44.410
development team are using this
feature, which can be used

578
00:33:44.410 --> 00:33:46.900
actually in Japan. We can,
you can cooperate this, a

579
00:33:46.900 --> 00:33:50.680
feature, we, for example, quality
metrics. So for example, you

580
00:33:50.680 --> 00:33:53.080
can, you can write some
rule and just ask for,

581
00:33:53.890 --> 00:33:57.970
tell me about Smith. That
has been <inaudible> the way

582
00:33:57.970 --> 00:34:00.790
the code was changed. Right?
And I want to know

583
00:34:00.790 --> 00:34:03.790
about this method, and I
want to make sure that

584
00:34:03.820 --> 00:34:07.810
all these methods, other, maybe
a 90% coverage by test,

585
00:34:08.140 --> 00:34:14.080
or even 100%. So maybe
you can require that maybe

586
00:34:14.080 --> 00:34:16.840
like a, a, a complex
city, a lower than 10.

587
00:34:17.170 --> 00:34:21.550
So what is really cool
here is that everybody's dealing

588
00:34:21.550 --> 00:34:23.980
with big assay suppose. Now
you are dealing with a

589
00:34:23.980 --> 00:34:31.420
very huge code base. You
can say from now <inaudible>,

590
00:34:31.450 --> 00:34:36.310
I want them to, to
expect a minimum quantity, from

591
00:34:36.310 --> 00:34:39.370
my perspective, this is the
best feature of the project

592
00:34:40.210 --> 00:34:43.530
to allow you to, to,
to, to, to focus on

593
00:34:43.630 --> 00:34:47.020
to the changes and to,
to, to, to, to some

594
00:34:47.020 --> 00:34:50.320
rules, to, to make the
quality better on the changes.

595
00:34:50.320 --> 00:34:54.460
Because, because now we know
that the code gets refactored,

596
00:34:54.760 --> 00:34:57.280
and we know that in
one year, in two years,

597
00:34:57.280 --> 00:34:59.920
in three years, legacy code
base will be more or

598
00:34:59.920 --> 00:35:05.320
less transformed Portale. So if
you focus on Delta Delta

599
00:35:05.680 --> 00:35:08.620
on the quality with you
are talking about coverage or

600
00:35:08.890 --> 00:35:12.670
psychometric, complexity, et cetera, you
should focus on quality just

601
00:35:12.670 --> 00:35:15.220
on the Denta. You don't
need to say that from

602
00:35:15.220 --> 00:35:18.010
now. We go stop everything
for three months, and we

603
00:35:18.010 --> 00:35:21.730
facto everything to a quality
metric here. The interesting thing

604
00:35:21.730 --> 00:35:24.670
is that just the data
we are purchasing now, since

605
00:35:24.670 --> 00:35:27.670
the last few days, we
want to focus on this

606
00:35:27.670 --> 00:35:31.420
one and you apply this
a very simple principle, maybe

607
00:35:31.420 --> 00:35:33.580
one year in two years,
and each year you will

608
00:35:33.580 --> 00:35:39.030
get a good quote. I
agree. I think that over,

609
00:35:39.030 --> 00:35:41.100
over time, being able to
set a bar and make

610
00:35:41.100 --> 00:35:43.320
sure that you don't regress,
that you don't go back

611
00:35:43.320 --> 00:35:47.220
in time to a time.
That was the quality of

612
00:35:47.220 --> 00:35:49.350
your code was, was, was
lesser, I think is very

613
00:35:49.350 --> 00:35:52.950
important. So the product that
you, that you're selling is

614
00:35:52.950 --> 00:35:56.400
called end depend, and people
can see that if independent.com

615
00:35:56.880 --> 00:36:01.470
and you blog about software
metrics, if code better.com and

616
00:36:01.620 --> 00:36:03.420
people can find your blog
up there, and I'll put

617
00:36:03.420 --> 00:36:06.060
links to all of this
in the, in the show

618
00:36:06.060 --> 00:36:09.390
notes, I really appreciate you
taking the time to come

619
00:36:09.390 --> 00:36:11.580
and chat with me on
the show today, Patrick. Okay.

620
00:36:11.820 --> 00:36:15.210
Can you wake up? All
right. This has been another

621
00:36:15.210 --> 00:36:18.120
episode of Hansel minutes, and
I'll see you again next

622
00:36:18.120 --> 00:36:18.300
week.


WEBVTT FILE

1
00:00:04.890 --> 00:00:21.590
<inaudible> Developer and technologist and
Scott Hanselman. This is Lawrence Ryan

2
00:00:21.600 --> 00:00:32.120
announcing show number two 91,
Thursday, November 3rd, The most comprehensive

3
00:00:32.120 --> 00:00:55.220
suite of components. Hi, this
is Scott Hanselman. This is

4
00:00:55.220 --> 00:00:58.460
another episode of Hanselminutes today.
I'm talking to Damien Edwards.

5
00:00:58.700 --> 00:01:00.830
Damien's got some interesting stuff
he's been doing on the

6
00:01:00.830 --> 00:01:04.400
side with David Fowler. How's it
going, Damien Very well. Thanks.

7
00:01:04.600 --> 00:01:07.190
How are you? I'm getting
there. Do you want a

8
00:01:07.200 --> 00:01:08.900
little bit of a, do
a little bit of work

9
00:01:08.900 --> 00:01:10.880
with this new thing called
signal R I'm going to

10
00:01:10.880 --> 00:01:13.220
be talking at a conference
on a, on Monday about

11
00:01:13.220 --> 00:01:15.050
it, but you did all
the work. Can you tell

12
00:01:15.050 --> 00:01:20.870
me about signaler? That's a
signal is a little library

13
00:01:21.110 --> 00:01:24.770
that David Fowler and myself have
put together over the last

14
00:01:24.770 --> 00:01:31.280
few months that provides a
persistent connection abstraction between the

15
00:01:31.280 --> 00:01:34.970
browser and the web server
that you can code against

16
00:01:34.970 --> 00:01:40.250
as an application developer. Okay.
Persistent connection abstraction. So, you

17
00:01:40.250 --> 00:01:43.460
know, on a reminder might
be obvious, but HTTP is

18
00:01:43.460 --> 00:01:46.310
a stateless protocol. So you
make a call and then

19
00:01:46.310 --> 00:01:49.760
you close that call down.
And then later on you

20
00:01:49.760 --> 00:01:52.220
might call again. It could
be in a minute, it

21
00:01:52.220 --> 00:01:55.220
could be in a year.
You don't know, there may

22
00:01:55.220 --> 00:01:59.390
be some underlying things like
HTTP, 1.1 keep alive and

23
00:01:59.390 --> 00:02:04.610
TCP connections and things that
will, you know, deal with

24
00:02:04.610 --> 00:02:07.400
the efficiencies and inefficiencies of
opening and closing a connection.

25
00:02:07.400 --> 00:02:09.700
But for the most part,
you do a get you

26
00:02:09.710 --> 00:02:13.700
a post and then it's
over. Right? Right. So HTTP

27
00:02:13.700 --> 00:02:16.250
as a protocol is very
much based around this idea

28
00:02:16.250 --> 00:02:19.880
of making a request and
then getting a response and

29
00:02:19.880 --> 00:02:22.790
then making more requests when
the, when the need arises.

30
00:02:23.180 --> 00:02:27.050
But web developers have found
ingenious ways over the years

31
00:02:27.050 --> 00:02:32.270
to mimic persistence in quote,
real time unquote connections between

32
00:02:32.270 --> 00:02:36.290
the browser and the server,
especially since sort of Ajax

33
00:02:36.290 --> 00:02:38.990
became popular. There's been a
few techniques. People have used

34
00:02:39.740 --> 00:02:44.090
to get this type of
logical persistent connection set up

35
00:02:44.090 --> 00:02:47.030
between the browser and the
server. And then more recently

36
00:02:47.030 --> 00:02:51.260
we've had the, the, the,
the appearance of the web

37
00:02:51.260 --> 00:02:54.740
sockets standard, which a lot
of the browsers are now

38
00:02:54.740 --> 00:02:58.370
starting to implement, which actually
gives you a true full

39
00:02:58.370 --> 00:03:02.620
duplex TCP level connection between
the browser and the server.

40
00:03:04.330 --> 00:03:06.700
But it's, it's pretty raw
because it's basically a raw

41
00:03:06.730 --> 00:03:10.480
connection. So signal is something
that sits a layer above

42
00:03:10.870 --> 00:03:13.450
all of those different techniques,
whether it's web sockets or

43
00:03:13.450 --> 00:03:17.020
Ajax long polling or service
center vans. And it sits

44
00:03:17.020 --> 00:03:19.840
above this and you code
against the signaler API, and

45
00:03:19.840 --> 00:03:23.050
then we'll take care of
ensuring that the most appropriate,

46
00:03:23.200 --> 00:03:26.860
the assistant connection transport is
set up and maintained between

47
00:03:26.860 --> 00:03:30.330
the browser and the server.
Okay. So explain each of

48
00:03:30.330 --> 00:03:33.230
the three things you just
said. There's long Pauling there's

49
00:03:33.230 --> 00:03:35.550
service and events, and then
there's, WebSockets what are, how

50
00:03:35.550 --> 00:03:38.160
do each of those work?
So let's start off with

51
00:03:38.160 --> 00:03:40.440
the, the sort of the
lowest common denominator, which is

52
00:03:40.440 --> 00:03:43.800
the Ajax long polling. So
web developers who've used Ajax.

53
00:03:43.800 --> 00:03:46.710
They're probably already familiar with
the idea of, of palling.

54
00:03:46.710 --> 00:03:49.560
So the idea is I
have some information that I

55
00:03:49.560 --> 00:03:51.990
show on my webpage. It
may initially get rendered as

56
00:03:51.990 --> 00:03:55.860
part of the original page
HTML payload. And then I

57
00:03:55.860 --> 00:03:59.160
want that part of the
page to update somewhat frequently

58
00:03:59.160 --> 00:04:01.440
without the user having to
hit the refresh button and

59
00:04:01.440 --> 00:04:03.870
do a full page navigation.
And so what you might

60
00:04:03.870 --> 00:04:06.480
do is use some Java
script to do something like

61
00:04:06.480 --> 00:04:10.590
a set interval, so that
every three or maybe five

62
00:04:10.590 --> 00:04:13.740
seconds, you make an Ajax
call to the server with

63
00:04:13.740 --> 00:04:15.990
some type of ID that
says, you know, this is

64
00:04:15.990 --> 00:04:18.690
the last time I got
data. And then the server

65
00:04:18.690 --> 00:04:21.780
will reply with anything that
happens since that time. And

66
00:04:21.780 --> 00:04:24.030
then when it comes back
to the Ajax request comes

67
00:04:24.030 --> 00:04:26.640
back, you do some processing,
and then it goes to

68
00:04:26.640 --> 00:04:28.950
sleep again for five seconds
or whatever you're pulling into

69
00:04:28.950 --> 00:04:32.040
the layers. So the idea
of long polling is that

70
00:04:32.040 --> 00:04:37.770
rather than us potentially needlessly
hitting the server every three,

71
00:04:37.770 --> 00:04:40.620
five, 10 seconds, whatever our
interval is. And a lot

72
00:04:40.620 --> 00:04:42.480
of the time in these
sorts of applications, there's actually

73
00:04:42.480 --> 00:04:45.410
nothing to show on every
one of the poles, the

74
00:04:45.420 --> 00:04:48.030
hit ratio may be very
low for the number of

75
00:04:48.030 --> 00:04:50.970
poles you're actually making on
the server. So the idea

76
00:04:50.970 --> 00:04:52.770
of long polling is that,
well, let me just make

77
00:04:52.770 --> 00:04:56.040
an Ajax request to the
server that contains some type

78
00:04:56.040 --> 00:04:57.810
of token that says, you
know, this is the last

79
00:04:57.810 --> 00:05:00.300
time I received data from
the server. And then the

80
00:05:00.300 --> 00:05:04.110
server doesn't actually reply to
that polling request until there

81
00:05:04.110 --> 00:05:07.230
is data to satisfy that
request. And so that it

82
00:05:07.230 --> 00:05:09.990
should be connection that Ajax
requests will just stay open

83
00:05:10.560 --> 00:05:12.720
until the server is ready
to return it. And then

84
00:05:12.720 --> 00:05:16.020
once something happens in the
server world to send that,

85
00:05:16.020 --> 00:05:18.510
that would require that data
to go back over the

86
00:05:18.660 --> 00:05:22.230
response to that Ajax request,
it'll complete the ADSL request,

87
00:05:22.230 --> 00:05:24.600
send it back down to
the browser. The browser will

88
00:05:24.600 --> 00:05:27.690
quickly process it and then
immediately send out another Ajax

89
00:05:27.690 --> 00:05:30.630
request asking for the next
lot of data when it

90
00:05:30.630 --> 00:05:33.810
is available. And so we
get this, we get this

91
00:05:33.840 --> 00:05:36.810
illusion of a persistent connection.
And because when things happen

92
00:05:36.810 --> 00:05:39.720
on the server, you instantly
get a response from the

93
00:05:39.720 --> 00:05:42.270
server because you already had
a request open, a pending

94
00:05:42.450 --> 00:05:45.700
long poll requests, open to
them. And then, and there

95
00:05:46.060 --> 00:05:50.100
that's basically long polling. Does
the client think that it's

96
00:05:50.100 --> 00:05:52.350
just a really slow connection?
I mean, are we taking

97
00:05:52.350 --> 00:05:54.870
advantage of the fact that
you can request something and

98
00:05:54.870 --> 00:05:56.130
it might take a second,
or it might take a

99
00:05:56.130 --> 00:06:00.130
minute and the connection fall
down while it waits? Yeah.

100
00:06:00.160 --> 00:06:04.030
I mean, there are issues
around timeout. And so most,

101
00:06:04.060 --> 00:06:06.130
most of the times when
you deal with long polling,

102
00:06:06.130 --> 00:06:09.220
you have to be able
to gracefully handle the situation

103
00:06:09.220 --> 00:06:12.610
where the Ajax request is
terminated for whatever region, whatever

104
00:06:12.610 --> 00:06:16.720
reason. And they have thankfully,
most Ajax libraries like jQuery,

105
00:06:16.960 --> 00:06:19.060
give us a graceful way
of saying, well, when an

106
00:06:19.060 --> 00:06:21.430
error occurs do this. And
so in the case of

107
00:06:21.430 --> 00:06:23.320
long polling, all you're really
doing is setting up a

108
00:06:23.320 --> 00:06:27.120
very tight long pole loop,
which is basically a, a

109
00:06:27.160 --> 00:06:31.060
looped function that just calls
continuously calls is Ajax method.

110
00:06:31.420 --> 00:06:34.570
I'm sorry, I posted this
Ajax end point. And if

111
00:06:34.570 --> 00:06:38.560
an error occurs, it might
perhaps create a delay of

112
00:06:38.560 --> 00:06:40.480
three or four seconds before
it tries again. But then

113
00:06:40.480 --> 00:06:42.730
it'll just start again after
that, when the air conditioning

114
00:06:42.730 --> 00:06:46.360
occurs now, because the internet
is not just browser to

115
00:06:46.360 --> 00:06:49.780
server, it's browser to about
73 other devices before you

116
00:06:49.780 --> 00:06:52.810
actually hit the target server.
One of the issues obviously,

117
00:06:52.810 --> 00:06:54.850
is there any one of
those devices that you happen

118
00:06:54.850 --> 00:06:56.770
to be routed through on
your way to the server,

119
00:06:57.040 --> 00:06:59.410
could at any point in
time decide to just kill

120
00:06:59.410 --> 00:07:04.240
your connection and certainly corporate
firewalls and cloud services front

121
00:07:04.240 --> 00:07:06.970
end proxies, and things like
that have a habit of

122
00:07:06.970 --> 00:07:09.430
identifying connections that have been
open for a long time

123
00:07:09.430 --> 00:07:11.980
with no data being sent
over the end and just

124
00:07:11.980 --> 00:07:15.220
killing them immediately. And usually
these timeouts, et cetera, about

125
00:07:15.220 --> 00:07:18.010
60 to 120 seconds or
one minute to two minutes.

126
00:07:18.820 --> 00:07:20.380
So things like, you know,
signal our, we, we sort

127
00:07:20.380 --> 00:07:24.520
of gracefully handle this. We
have a service side. There's

128
00:07:24.520 --> 00:07:26.620
a, there's a default timeout
for long polling as it

129
00:07:26.620 --> 00:07:29.830
is. So we always, if
nothing happens after two minutes

130
00:07:29.830 --> 00:07:32.410
on a long pole connection,
we just send back a

131
00:07:32.410 --> 00:07:35.170
packet basically that says all
this time out. And then

132
00:07:35.170 --> 00:07:37.870
our client's side lab, he
just knows to reconnect. And

133
00:07:37.870 --> 00:07:41.260
obviously if before that time,
the connection is interrupted. For

134
00:07:41.260 --> 00:07:45.880
whatever reason, the jQuery Ajax
error logic is going to

135
00:07:45.880 --> 00:07:47.590
kick in. And we have
a handle for that, that

136
00:07:47.590 --> 00:07:51.130
says, Oh, an error occurred
at the Ajax transport level.

137
00:07:51.250 --> 00:07:54.310
Let's wait three seconds and
then we'll try again. So

138
00:07:54.310 --> 00:07:56.950
it's a very, very simple
recovery mechanism agent way. And

139
00:07:56.950 --> 00:07:58.870
that's why eight Exxon polling
is sort of the lowest

140
00:07:58.870 --> 00:08:01.060
common denominator for doing this
type of thing. That's actually

141
00:08:01.060 --> 00:08:04.810
really, really good. Okay. So
long polling makes a call

142
00:08:04.810 --> 00:08:07.180
from the client to the
server and says, Hey, I

143
00:08:07.180 --> 00:08:11.680
need some stuff. And then
there's a pause and the

144
00:08:11.680 --> 00:08:13.930
server will respond whenever it
gets around to it, whenever

145
00:08:13.930 --> 00:08:16.810
it's got data and that
pauses, okay, because you've got

146
00:08:16.810 --> 00:08:20.890
other HTTP connections, you can
keep open. And we'll talk

147
00:08:20.890 --> 00:08:24.370
about the scalability ramifications a
little bit later, but that

148
00:08:24.370 --> 00:08:27.160
works everywhere and basically works
through any proxy. And it's

149
00:08:27.160 --> 00:08:30.910
pretty reliable, Right? Because it's
basically just standard Ajax, but

150
00:08:30.910 --> 00:08:33.730
the request just takes a
bit longer than that. Okay,

151
00:08:33.730 --> 00:08:36.790
then, so then what is
service sent events? So service

152
00:08:36.790 --> 00:08:42.010
center events is, was a
protocol. I think it was

153
00:08:42.610 --> 00:08:47.080
suggested by opera back quite
a while ago. If you

154
00:08:47.080 --> 00:08:48.550
use the guy, they introduced
it in some version of

155
00:08:48.550 --> 00:08:52.210
opera, and it's basically the,
it's like a formalization of

156
00:08:52.210 --> 00:08:56.820
long polling. And so it
includes client side object. So

157
00:08:56.820 --> 00:08:59.070
in your browser, you'll be
able to say new event

158
00:08:59.080 --> 00:09:01.680
source, that's a Dom sort
of JavaScript object that you

159
00:09:01.680 --> 00:09:03.930
can create. If you say
new advanced source and you

160
00:09:03.930 --> 00:09:06.360
give it an end point.
And then what happens is

161
00:09:06.360 --> 00:09:09.690
the browser that takes care
of making a request to

162
00:09:09.690 --> 00:09:14.250
this end point and then
keeping this connection open and

163
00:09:14.250 --> 00:09:16.680
then recovering if anything goes
wrong. So, like I said,

164
00:09:16.680 --> 00:09:19.470
it's really a formalization of
the Ajax long polling. The

165
00:09:19.470 --> 00:09:24.570
one difference is that rather
than whenever data is ready

166
00:09:24.570 --> 00:09:27.420
to be sent from the
server to the client, with

167
00:09:27.420 --> 00:09:29.670
an Ajax request, they direct
clone Pauling. The, the Ajax

168
00:09:29.670 --> 00:09:31.860
requests ends, you know, we
send the data back and

169
00:09:31.860 --> 00:09:33.990
that is the end of
that particular Ajax request. And

170
00:09:33.990 --> 00:09:36.510
then we send another one
with service center events. Once

171
00:09:36.510 --> 00:09:40.290
you've established the HDP connection.
The protocol actually says that

172
00:09:40.290 --> 00:09:43.440
the service streams data down
to the client using a

173
00:09:43.440 --> 00:09:48.120
very simple sort of framing
protocol in the standard HTTP

174
00:09:48.120 --> 00:09:51.570
response body. And so the
response actually never ends. So

175
00:09:51.570 --> 00:09:53.820
rather than having an Ajax
long pole where we send

176
00:09:53.820 --> 00:09:56.400
a request, at some point
we get some data that

177
00:09:56.400 --> 00:09:59.130
request comes back and then
we send another request with

178
00:09:59.130 --> 00:10:01.980
service and events. We make
a request with a special

179
00:10:01.980 --> 00:10:04.950
header in it saying, this
is an event source request,

180
00:10:05.160 --> 00:10:08.220
and the server will keep
that request open and then

181
00:10:08.220 --> 00:10:12.330
just stream back little bits
of information over the response

182
00:10:12.330 --> 00:10:15.150
stream as it becomes available.
And then in the client,

183
00:10:15.150 --> 00:10:17.280
that event source object that
we created, it has an

184
00:10:17.280 --> 00:10:20.700
API that sort of raises
events that you can handle

185
00:10:20.700 --> 00:10:23.820
with standard JavaScript functions, so
that when data comes back

186
00:10:23.820 --> 00:10:26.670
over the connection, you can
run your code and do

187
00:10:26.670 --> 00:10:29.330
whatever it is that you
want to do. Okay. So

188
00:10:29.330 --> 00:10:32.360
this is effectively the same
thing, conceptually, as long polling,

189
00:10:32.360 --> 00:10:35.210
except after that, you make
the call, you hold the

190
00:10:35.210 --> 00:10:38.480
connection open. Some data comes
back with long polling. The

191
00:10:38.480 --> 00:10:40.550
data comes back and the
connection ends. And then you

192
00:10:40.550 --> 00:10:43.190
start it over again with
service and events. You keep

193
00:10:43.190 --> 00:10:45.740
that open in order to
send even more data later,

194
00:10:46.490 --> 00:10:51.740
Correct. And currently the, all
the browsers except internet Explorer,

195
00:10:52.070 --> 00:10:55.640
support service intervenes in some
fashion. And it's, it's fairly

196
00:10:55.640 --> 00:10:57.650
easy to implement on the
service side because it doesn't

197
00:10:57.650 --> 00:11:01.550
require any special, extra HTTP
plumbing. It really is just

198
00:11:01.550 --> 00:11:04.070
a custom header that gets
sent up. And then it's

199
00:11:04.070 --> 00:11:08.000
just buffering and not buffering
just immediately, you know, sending

200
00:11:08.000 --> 00:11:10.760
stuff down over the response
and keeping the connection alive.

201
00:11:11.660 --> 00:11:14.360
So that's that's service center
events and that, that works

202
00:11:14.360 --> 00:11:17.300
quite well. We're still building
our server, send events transports

203
00:11:17.300 --> 00:11:21.140
at the moment, but it's
certainly promising the advantage of

204
00:11:21.140 --> 00:11:25.910
that over long polling is
around latency because with long

205
00:11:25.910 --> 00:11:29.570
polling, you have this period
where once a long pole

206
00:11:29.570 --> 00:11:31.970
has come back, you've received
data. This is period we're

207
00:11:31.970 --> 00:11:35.000
in the browser. It's processing
that data before it then

208
00:11:35.000 --> 00:11:38.810
makes another Ajax request with
service and events. Obviously we

209
00:11:38.810 --> 00:11:42.830
don't have this issue because
there's no connection re-establishment going

210
00:11:42.830 --> 00:11:45.320
on. You open a connection
and it stays open most

211
00:11:45.320 --> 00:11:47.810
of the time. You just
keep getting dotted down in

212
00:11:47.810 --> 00:11:50.270
somewhat real time. Now service
the events is a one

213
00:11:50.270 --> 00:11:52.610
way technology only, it's only
served at a client. So

214
00:11:52.620 --> 00:11:54.940
to stuff up to the
server, you just make standard

215
00:11:55.210 --> 00:11:59.520
Ajax posts. Okay. And have
you built that into signal

216
00:11:59.530 --> 00:12:01.170
already or is that something
you should? So we have

217
00:12:01.170 --> 00:12:03.360
a branch in our source
at the moment that has

218
00:12:03.360 --> 00:12:07.140
an experimental service intervention. And
is that, is that tricky

219
00:12:07.140 --> 00:12:08.580
or is it just a
matter of, I mean, how

220
00:12:08.580 --> 00:12:11.670
do you test something like
this A little bit, a

221
00:12:11.670 --> 00:12:14.370
lot of manual testing, basically.
I mean, at the moment,

222
00:12:14.400 --> 00:12:16.590
it's easy to test that
you can get serviced into

223
00:12:16.590 --> 00:12:18.360
events. Working was very easy
just to set up a

224
00:12:18.360 --> 00:12:20.720
handler and spit stuff out
over it. If it, if

225
00:12:20.720 --> 00:12:24.930
it saved a certain header,
what's more tricky is, you

226
00:12:24.930 --> 00:12:27.210
know, figuring out whether the
service and events can actually

227
00:12:27.240 --> 00:12:30.270
take the sort of load
that people expect to be

228
00:12:30.270 --> 00:12:33.000
able to push through something
like signaler. I mean, long

229
00:12:33.000 --> 00:12:35.430
polling for all of its
failings. I mean that, you

230
00:12:35.430 --> 00:12:38.040
know, it's a very low
level, lowest, common denominator denominator

231
00:12:38.040 --> 00:12:40.470
type of thing. You have
this problem of latency and

232
00:12:40.470 --> 00:12:42.600
this problem of this, you
know, there are actually periods

233
00:12:42.600 --> 00:12:44.550
where you're actually not connected
to the server because you're

234
00:12:44.550 --> 00:12:48.150
doing processing for all of
that. We've actually got our

235
00:12:48.150 --> 00:12:51.270
long polling transport really, really
robust. And to the point

236
00:12:51.270 --> 00:12:54.150
that, you know, we've got
demos where we have two

237
00:12:54.150 --> 00:12:56.310
screen, two browsers up and
this sort of doing real

238
00:12:56.310 --> 00:12:59.280
time, moving of Dom elements
from one browser being sent

239
00:12:59.280 --> 00:13:01.050
to the other and that
sort of refreshing in real

240
00:13:01.050 --> 00:13:04.020
time. And that works really,
really well. Even over something

241
00:13:04.020 --> 00:13:06.450
like Ajax long polling at
the moment with server set

242
00:13:06.450 --> 00:13:08.700
events, we're having a few
issues whereby when we start

243
00:13:08.700 --> 00:13:11.940
pushing a lot of sort
of packets over the service

244
00:13:11.940 --> 00:13:15.020
and events, connection, we see
some things being dropped and

245
00:13:15.060 --> 00:13:16.500
we're still sort of trying
to figure out why that's

246
00:13:16.500 --> 00:13:19.920
happening. So that's why it's
still an experimental transport at

247
00:13:19.920 --> 00:13:23.910
the most. Okay. But conceptually
you'll have all three of

248
00:13:23.910 --> 00:13:26.830
these things you'll have long
polling services and events and

249
00:13:26.850 --> 00:13:29.490
websites. It's all working in
the same library. And the

250
00:13:29.490 --> 00:13:31.890
person that writes to that
library me will not have

251
00:13:31.890 --> 00:13:33.660
to think about any of
that stuff. They'll just have

252
00:13:33.660 --> 00:13:37.440
a great experience on any
browser, Correct. That's the idea.

253
00:13:37.440 --> 00:13:38.820
I mean, that sort of
brings us to the last

254
00:13:38.820 --> 00:13:41.430
one, which is web sockets.
And a lot of people

255
00:13:41.670 --> 00:13:44.100
are really excited about the
promise of website because it

256
00:13:44.100 --> 00:13:47.160
gives us this true and
formalized way of doing a

257
00:13:47.160 --> 00:13:51.030
persistent connection, a true sort
of socket level stream connection

258
00:13:51.030 --> 00:13:54.300
between the client, the server
that's full duplex. The problem

259
00:13:54.300 --> 00:13:58.080
is that it's so new.
So if you're a windows

260
00:13:58.080 --> 00:14:00.720
user, I'm using internet Explorer,
you'll have to wait for

261
00:14:00.720 --> 00:14:04.410
internet Explorer, 10 to get
web sockets support in the

262
00:14:04.410 --> 00:14:07.860
client. On the service side,
you need to be running

263
00:14:07.860 --> 00:14:12.030
windows eight server to be
using a web sockets from

264
00:14:12.030 --> 00:14:15.990
within asp.net or WCF. Now,
if you're using other browsers

265
00:14:15.990 --> 00:14:18.810
on the client, then, you
know, Chrome and Firefox and

266
00:14:19.050 --> 00:14:21.600
opera, and those guys, they,
they support. WebSockets just fine

267
00:14:21.600 --> 00:14:23.670
on the client at the
moment, but it's going to

268
00:14:23.670 --> 00:14:28.020
be quite some time until
we can use web sockets

269
00:14:28.170 --> 00:14:31.470
and hit the majority of,
of your audience on a

270
00:14:31.470 --> 00:14:34.830
public facing website, because you
know, internet Explorer is still

271
00:14:34.830 --> 00:14:36.840
has a very high usage
across the world. There's going

272
00:14:36.840 --> 00:14:38.010
to be a long time
before we can just use

273
00:14:38.010 --> 00:14:40.760
website cause everywhere the other
issue with website, cause it's

274
00:14:40.800 --> 00:14:43.410
a very low level API,
it's a socket. And so

275
00:14:43.410 --> 00:14:45.660
if you ever done any
socket programming, you know, there

276
00:14:45.660 --> 00:14:50.130
are framing and buffering. And
if you look@theapiapisthataresortofinasp.net and the

277
00:14:50.130 --> 00:14:52.970
next version, that's going support
this, you're working with a

278
00:14:52.970 --> 00:14:55.340
raised segments of bites and
this type of thing. And

279
00:14:55.340 --> 00:14:57.530
you have to make sure
that you never try and

280
00:14:57.530 --> 00:15:00.920
send anything over a web
socket connection. That's actually closed.

281
00:15:01.370 --> 00:15:02.660
There's all these types of
things that you have to

282
00:15:02.780 --> 00:15:05.510
worry about if you're writing
against the rule WebSocket API.

283
00:15:05.900 --> 00:15:07.640
So the idea of signal
R is that, well, we

284
00:15:07.640 --> 00:15:11.160
just surface a really, really
simple connection API with a

285
00:15:11.180 --> 00:15:13.520
very small amount of events.
Like, you know, someone connected,

286
00:15:13.520 --> 00:15:16.340
someone disconnected, someone sends some
data and you want to,

287
00:15:16.970 --> 00:15:18.830
and, or perhaps you want
to send some data to

288
00:15:18.830 --> 00:15:21.200
someone or broadcast some data
and that's kind of it.

289
00:15:21.200 --> 00:15:22.730
And then everything else is
just built on top of

290
00:15:22.730 --> 00:15:26.120
that. Very, very simple, low
level connection API. And then

291
00:15:26.120 --> 00:15:28.310
underneath that, we have all
these tracks and sports with

292
00:15:28.310 --> 00:15:31.610
the complex logic of maintaining
this illusion of a persistent

293
00:15:31.610 --> 00:15:37.480
connection taken care of This
episode of Hansel minutes is

294
00:15:37.480 --> 00:15:39.820
brought to you by careers
2.0 and our friends at

295
00:15:39.820 --> 00:15:43.210
stack overflow. If you're not
familiar with careers 2.0, it's

296
00:15:43.210 --> 00:15:45.550
a career site dedicated to
advancing your career as a

297
00:15:45.550 --> 00:15:48.280
developer, whether you find that
awesome new company to work

298
00:15:48.280 --> 00:15:51.160
for, or create an online
program or profile, or even

299
00:15:51.160 --> 00:15:54.310
post a job within your
own development team, a programmer

300
00:15:54.310 --> 00:15:57.730
profile at careers 2.0 is
an evolving archive of actual

301
00:15:57.730 --> 00:16:00.490
coding. You've done as well
as your own blog post

302
00:16:00.490 --> 00:16:03.220
your favorite books, it's free.
It's easy to get started.

303
00:16:03.220 --> 00:16:06.820
Just import your LinkedIn profile,
add your favorite stack overflow

304
00:16:06.820 --> 00:16:09.550
answers, and even your open
source contributions to get hub

305
00:16:09.880 --> 00:16:13.330
Bitbucket. And SourceForge even if
you're not currently looking for

306
00:16:13.330 --> 00:16:15.670
a job, a profile on
careers 2.0 is a great

307
00:16:15.670 --> 00:16:19.930
representation of your programming knowledge.
There is one catch profiles

308
00:16:19.930 --> 00:16:22.990
on careers, 2.0 invite only.
They did this to keep

309
00:16:22.990 --> 00:16:26.290
out the spam and create
a high quality environment. Fortunately,

310
00:16:26.320 --> 00:16:28.750
for you as a Hansel
minutes listener, we've hooked you

311
00:16:28.750 --> 00:16:31.090
up. We're going to invite
you to join tens of

312
00:16:31.090 --> 00:16:33.760
thousands of other programmers who
already have a profile head

313
00:16:33.760 --> 00:16:40.150
on over to careers dot
stack overflow.com/h M to accept

314
00:16:40.150 --> 00:16:45.520
your invitation today, once again,
that's careers dot stack overflow.com/h

315
00:16:45.520 --> 00:16:49.510
M the fact that you
can use Jason and you

316
00:16:49.510 --> 00:16:53.110
can use HDP and that
we're high there, they're hiding

317
00:16:53.440 --> 00:16:56.950
the complexities of the underlying
TCP connection that, that none

318
00:16:56.950 --> 00:16:58.900
of us have had to
really worry or think about

319
00:16:58.900 --> 00:17:01.510
TCP in a long time
is something that I think

320
00:17:01.510 --> 00:17:06.430
people should appreciate and realize
that that that's pretty awesome

321
00:17:06.430 --> 00:17:07.990
that you can throw a
string across the wire and

322
00:17:07.990 --> 00:17:09.610
get a string back. And
for the most part, not

323
00:17:09.610 --> 00:17:12.520
think about the little tiny
details that caused that string

324
00:17:12.520 --> 00:17:14.980
to get there. It sounds
like with WebSockets, we'll have

325
00:17:14.980 --> 00:17:17.710
to be thinking about that
again. Yeah. I mean, the

326
00:17:17.710 --> 00:17:19.960
other problem with WebSockets is
because it's a, because it's

327
00:17:19.960 --> 00:17:23.290
an extension to the HDP
protocol and a lot of

328
00:17:23.290 --> 00:17:25.990
ways, a lot of the
hardware of the internet, I

329
00:17:25.990 --> 00:17:28.660
mentioned, you know, the 73
odd devices that are between

330
00:17:28.660 --> 00:17:31.450
your box and the server
you're hitting, they all have

331
00:17:31.450 --> 00:17:34.300
to understand web sockets for
this to really, really work

332
00:17:35.170 --> 00:17:37.000
because the way website has
worked is you make an

333
00:17:37.000 --> 00:17:39.790
initial get requests, a standard
HDB, get requests with a

334
00:17:39.790 --> 00:17:43.330
special header that says, I
want to upgrade this request

335
00:17:43.330 --> 00:17:46.090
to a web sockets connection.
And then at that point,

336
00:17:46.090 --> 00:17:49.530
its server understands that it
sort of switches the from

337
00:17:49.530 --> 00:17:52.440
a normal request or WebSockets
request. And then the original

338
00:17:52.440 --> 00:17:54.810
HDP part of it just
goes away. And then from

339
00:17:54.810 --> 00:17:57.600
that point on, you basically
have a true TCP connection

340
00:17:57.600 --> 00:18:01.770
from client to server. Now
that obviously may cause problems

341
00:18:01.770 --> 00:18:03.810
with the infrastructure of the
internet. When we think about,

342
00:18:03.810 --> 00:18:06.840
you know, really it's been
set up to work with

343
00:18:06.840 --> 00:18:09.660
this idea of a stateless
request response model at the

344
00:18:09.660 --> 00:18:13.020
moment. So it may be
some time before WebSockets become

345
00:18:13.020 --> 00:18:17.160
something that we can reliably
use throughout the internet for

346
00:18:17.160 --> 00:18:19.470
that reason, as well as
the, the re the browser

347
00:18:19.470 --> 00:18:22.460
support. So let's, let's explore
that a little bit more

348
00:18:22.460 --> 00:18:25.580
and make sure that people
really understood that. So HTTP

349
00:18:25.580 --> 00:18:27.680
itself, that protocol that we're
all used to, and we're

350
00:18:27.680 --> 00:18:31.430
all comfortable with in this
case, it's just used as

351
00:18:31.430 --> 00:18:34.280
a rapper for a handshaking
protocol. You go, and you

352
00:18:34.280 --> 00:18:37.310
say, Hey, do you support
WebSockets? Yeah, I do. Which

353
00:18:37.310 --> 00:18:39.440
version, well, I support this
version. Well, that's cool with

354
00:18:39.440 --> 00:18:42.410
me. I also support that
version. Now let's all step

355
00:18:42.410 --> 00:18:47.240
into a parallel universe, start
another connection and HTTP then

356
00:18:47.240 --> 00:18:50.720
stops being used, and it's
not involved in the conversation

357
00:18:50.720 --> 00:18:54.320
anymore. That's right. That's right.
And so, if you think

358
00:18:54.320 --> 00:18:57.980
about how large web servers
are deployed today, we have

359
00:18:57.980 --> 00:19:00.920
this idea of server farms
and some type of front

360
00:19:00.920 --> 00:19:05.810
end infrastructure that knows how
to load balance requests across

361
00:19:05.810 --> 00:19:09.200
a farmer service. And then
anyone who's ever built websites

362
00:19:09.200 --> 00:19:10.940
at any sort of scale
will be familiar with this.

363
00:19:10.940 --> 00:19:13.790
And we have ideas of
things like server affinity or

364
00:19:13.790 --> 00:19:16.760
stateless front ends. The problem
with sockets is they're sort

365
00:19:16.760 --> 00:19:19.220
of Lowes you in this
idea of all things are

366
00:19:19.220 --> 00:19:21.740
still now, but we actually
have this issue. If at

367
00:19:21.770 --> 00:19:23.210
all, if you want to
build anything with scale, we

368
00:19:23.210 --> 00:19:25.070
have to figure out how
we can do, how are

369
00:19:25.070 --> 00:19:30.110
we gonna scale this persistent
connection across using the infrastructure

370
00:19:30.110 --> 00:19:33.230
that we have for doing
this with, you know, request

371
00:19:33.230 --> 00:19:35.570
response, sort of paradigms with
HDP. I have a server

372
00:19:35.570 --> 00:19:38.240
farm. I have a front
end load balancer. Our request

373
00:19:38.240 --> 00:19:41.180
comes in, okay, this is
a web socket request, which

374
00:19:41.180 --> 00:19:43.010
servers are going to go
to. Okay, well, it goes

375
00:19:43.010 --> 00:19:46.130
to seven. Number one, server
number one now has a

376
00:19:46.130 --> 00:19:49.040
hard connection through to this
browser. Okay, well, I'm not

377
00:19:49.040 --> 00:19:51.440
really load balancing very much
now because all that data

378
00:19:51.440 --> 00:19:54.680
is going between that client
and that server, what happens

379
00:19:54.680 --> 00:19:56.840
when that connection goes down?
There's my average in such

380
00:19:56.840 --> 00:19:58.640
a way that if the
web socket connection for that

381
00:19:58.640 --> 00:20:01.460
user suddenly appears at server
two, is it going to

382
00:20:01.460 --> 00:20:04.700
continue to work? So these,
these sort of things that

383
00:20:04.700 --> 00:20:06.410
we have to think about
now when we're using these

384
00:20:06.650 --> 00:20:09.920
protocols, And that's why I
bring up this, this, this

385
00:20:10.700 --> 00:20:14.240
analogy of the, of the
parallel universe, because this means

386
00:20:14.240 --> 00:20:19.250
that your large well-organized server
farm that's completely prepared for

387
00:20:19.250 --> 00:20:23.570
stateless traffic and load balancing
across HTTP might be wholly

388
00:20:23.570 --> 00:20:26.870
and completely inappropriate and unprepared
for real time. So you

389
00:20:26.870 --> 00:20:30.350
might end up with another
whole, another whole network switch

390
00:20:30.350 --> 00:20:32.840
and other whole sub domain
and into their whole farm

391
00:20:32.840 --> 00:20:36.620
to manage that kind of
traffic That's right. So it

392
00:20:36.620 --> 00:20:39.710
is, it's an emerging standard,
you know, the, all the,

393
00:20:39.710 --> 00:20:43.520
all the companies involved in
this working very diligently to,

394
00:20:43.520 --> 00:20:46.520
to get the standard, to
sort of the place where

395
00:20:46.520 --> 00:20:48.880
it can be readily implemented
everywhere, and people can start

396
00:20:48.880 --> 00:20:51.040
trusting it. But I still
think it's going to be

397
00:20:51.040 --> 00:20:53.410
quite some time before this
is something that can be

398
00:20:53.410 --> 00:20:56.500
reliably used for the majority
of internet users. And so

399
00:20:56.500 --> 00:21:00.340
until then, yeah, signal R
I think is, is the

400
00:21:00.940 --> 00:21:04.420
libraries like, it was certainly
not the only one we'll,

401
00:21:04.540 --> 00:21:07.060
you know, really I'm really
required to fill this gap

402
00:21:07.780 --> 00:21:09.550
until such time that we
can say, Hey, web, soccer's

403
00:21:09.570 --> 00:21:11.170
a great, we use it
everywhere. But even when we

404
00:21:11.170 --> 00:21:12.460
get to that point, as
I said, you know, the

405
00:21:12.460 --> 00:21:15.460
website, because API is pretty
low level. So we think

406
00:21:15.460 --> 00:21:17.290
our API is a much
nicer place to be as

407
00:21:17.290 --> 00:21:20.670
an application developer. So who
is your, who's your quote

408
00:21:20.670 --> 00:21:23.130
unquote competition. I mean, there,
there are obviously a lot

409
00:21:23.130 --> 00:21:25.110
of people in real time.
Whenever we think about real

410
00:21:25.110 --> 00:21:27.990
time, we hear about products
like no JS. We hear

411
00:21:27.990 --> 00:21:30.630
about socket IO and there's
different libraries that all claim

412
00:21:30.630 --> 00:21:33.960
to do real time is
yours. They're just the same.

413
00:21:35.250 --> 00:21:36.480
Yeah. In a lot of
ways. I mean, if you

414
00:21:36.480 --> 00:21:39.060
look at, we were inspired
by a couple of things,

415
00:21:39.060 --> 00:21:40.440
I mean, at the end
of it, to make it

416
00:21:40.440 --> 00:21:42.570
very clear about what this
library is, this is, this

417
00:21:42.570 --> 00:21:44.730
is a two part library.
It's a Java, it's a

418
00:21:44.730 --> 00:21:48.240
jQuery plugin for the client
and the.net library for the

419
00:21:48.240 --> 00:21:51.240
server. And it's designed to
run in asp.net. So this

420
00:21:51.240 --> 00:21:55.440
is a very specifically a
persistent connection library for asp.net

421
00:21:55.680 --> 00:21:58.410
developers. Now, if you look
at somebody like Sukkot it

422
00:21:58.410 --> 00:22:00.720
IO, which is sort of
the, probably the most well

423
00:22:00.720 --> 00:22:03.780
known of these libraries after
doing this type of thing.

424
00:22:03.780 --> 00:22:08.160
And it has the same
concept of underlying transports, which

425
00:22:08.160 --> 00:22:11.820
had dynamically switches out and,
and configure it based on,

426
00:22:11.850 --> 00:22:13.380
you know, whatever the client
is and what the server

427
00:22:13.380 --> 00:22:16.050
is <inaudible> was built to
work with. No JS. It

428
00:22:16.050 --> 00:22:17.790
really is a it's a
service side and the client

429
00:22:17.790 --> 00:22:21.180
side library node is JavaScript.
So it's JavaScript on both

430
00:22:21.180 --> 00:22:23.760
ends, which is kind of
nice. And there are other

431
00:22:23.760 --> 00:22:28.080
people who, who have ported
the socket IO protocol, if

432
00:22:28.080 --> 00:22:30.630
you like to other platforms
like PHP and those types

433
00:22:30.630 --> 00:22:34.230
of things. We really, we
looked at socket IO in

434
00:22:34.230 --> 00:22:36.630
the beginning, and we, you
know, we could have taken

435
00:22:36.630 --> 00:22:39.330
the option of trying to
port socket IO to asp.net.

436
00:22:40.020 --> 00:22:41.730
There's a couple of issues
with that one. We felt

437
00:22:41.730 --> 00:22:45.000
the API of socket IO
didn't really wouldn't have been

438
00:22:45.000 --> 00:22:49.440
as comfortable for asp.net developers.
And again, we were trying

439
00:22:49.440 --> 00:22:52.470
to build this for all
asp.net developers, not just the

440
00:22:52.500 --> 00:22:55.410
alpha geek, you know, top
5% of developers. We want

441
00:22:55.410 --> 00:22:58.140
to make this library approachable
for anyone who's ever written

442
00:22:58.140 --> 00:23:01.980
asp.net application. And so we've,
we've sort of structured the

443
00:23:01.980 --> 00:23:04.590
API and the client and
the server to, to sort

444
00:23:04.590 --> 00:23:08.130
of mimic.net where it needs
to, and then B you

445
00:23:08.130 --> 00:23:10.710
know, nicely, Javascripty where it
has to be as well

446
00:23:10.710 --> 00:23:13.380
on the client. And so,
as part of that, we,

447
00:23:13.440 --> 00:23:16.470
you know, we invented our
own protocol. We say invented,

448
00:23:16.500 --> 00:23:19.110
it just emerged as we
built the thing. Really. Now,

449
00:23:19.110 --> 00:23:21.300
when you say protocol though,
you don't mean your own

450
00:23:21.750 --> 00:23:25.290
like HDP protocol, you mean
your own style of programming?

451
00:23:26.280 --> 00:23:29.010
Wow. No, no. I actually
mean our own shape of

452
00:23:29.010 --> 00:23:33.210
the packets that we send
over the wire. So, yeah.

453
00:23:33.240 --> 00:23:35.700
So remember, is this the
client side lobby and a

454
00:23:35.700 --> 00:23:39.330
service side lobby that work
together and in order to

455
00:23:39.330 --> 00:23:41.790
do this in such a
way, and we have to

456
00:23:41.790 --> 00:23:43.650
be able to cater for
the fact that some of

457
00:23:43.650 --> 00:23:46.850
the transports that we use
have floors, and we have

458
00:23:46.850 --> 00:23:50.090
to be able to sort
of backfill over those floors.

459
00:23:50.780 --> 00:23:52.700
You know, there are cracks
in how these things work

460
00:23:52.700 --> 00:23:53.900
and we need to be
able to poly fill those

461
00:23:53.900 --> 00:23:57.080
up so that everything looks
kind of smooth from the

462
00:23:57.080 --> 00:23:59.720
layer that the developer uses.
And so to do that,

463
00:23:59.720 --> 00:24:01.910
when you, when you have
a signal or connection in

464
00:24:01.910 --> 00:24:03.800
the client, and you say,
send some data to the

465
00:24:03.800 --> 00:24:07.580
server, we don't just send
the raw data. We actually

466
00:24:07.580 --> 00:24:11.420
sort of wrap that data
in some Jason other information

467
00:24:11.420 --> 00:24:13.220
and wrap it all into
Jason payload and then send

468
00:24:13.220 --> 00:24:15.440
it to the server. And
then similarly on the service

469
00:24:15.440 --> 00:24:17.870
side, when you say, I
want to broadcast this data

470
00:24:17.870 --> 00:24:20.900
to all the currently connected
clients, we don't just broadcast

471
00:24:20.900 --> 00:24:23.480
the raw data. We have
to sort of broadcast not

472
00:24:23.480 --> 00:24:25.910
just your data, but a
bunch of framing information that

473
00:24:25.910 --> 00:24:28.850
says, well, okay, this data
relates to this connection. This

474
00:24:28.850 --> 00:24:32.480
is message ID number X.
It was sent on transport,

475
00:24:32.480 --> 00:24:34.700
Y blah, blah, blah. So
that once we get once,

476
00:24:34.730 --> 00:24:37.370
once the client side lobby
receives it, it knows how

477
00:24:37.370 --> 00:24:40.640
to process and dispatch that
to the appropriate JavaScript methods

478
00:24:40.730 --> 00:24:42.710
and, you know, events in
the, in the, in the

479
00:24:42.710 --> 00:24:44.810
client side library that we
have. So that's what I'm

480
00:24:44.810 --> 00:24:46.880
talking about when I was
talking about our protocol, like

481
00:24:46.880 --> 00:24:50.960
the actual bites that go
over the, the connection, whether

482
00:24:50.960 --> 00:24:54.050
it's web sockets or long
polling or service at events

483
00:24:54.950 --> 00:24:57.050
is a signal, a packet
in one of the better

484
00:24:57.050 --> 00:25:01.810
word. Okay. Now in the
past, I've, I've done. I

485
00:25:01.810 --> 00:25:03.700
mean, we've all seen, like,
what we would have thought

486
00:25:03.700 --> 00:25:05.560
was real time, like, like
the orig I think the

487
00:25:05.560 --> 00:25:08.800
original, real time experience that
we've all had on the

488
00:25:08.800 --> 00:25:12.970
internet was probably 10 years
ago when we hit expedia.com

489
00:25:12.970 --> 00:25:16.450
for the first time. And
we said, find flights. And

490
00:25:16.450 --> 00:25:19.150
then this animated gift came
up and it said loading,

491
00:25:19.150 --> 00:25:21.490
and it looked like something
was really happening. And then

492
00:25:21.490 --> 00:25:23.880
it would go, the screen
would flash and then we'd

493
00:25:23.880 --> 00:25:26.710
get our results. And that
was using a meta refresh

494
00:25:26.710 --> 00:25:29.020
tag and it was going
get results, got results, got

495
00:25:29.020 --> 00:25:32.200
results, colors, notes. Yep. That
seems like a very obvious

496
00:25:32.200 --> 00:25:35.650
thing to do with, with
signal or like that would

497
00:25:35.650 --> 00:25:37.720
be a swap it in
and out kind of an

498
00:25:37.720 --> 00:25:40.900
experience. Now, when that was
being done, as you pointed

499
00:25:40.900 --> 00:25:43.600
out before, when you talked
about polling, it was basically

500
00:25:43.600 --> 00:25:45.520
going, you hear me now,
do you hear me now?

501
00:25:45.520 --> 00:25:47.440
And it was beating on
the server. It may have

502
00:25:47.440 --> 00:25:49.090
been a lightweight thing, but
it was beating on the

503
00:25:49.090 --> 00:25:52.600
server. I could have probably
opened a connection and tried

504
00:25:52.600 --> 00:25:55.420
to keep it open, but
in the past and asp.net,

505
00:25:55.420 --> 00:25:59.380
at least in kind of
standard, I HTP handler, I

506
00:25:59.380 --> 00:26:03.080
would be holding that request
thread open. I don't think

507
00:26:03.080 --> 00:26:05.350
that asp.net would have scaled
for more than 20 or

508
00:26:05.350 --> 00:26:08.020
30 requests. And it would
have just been holding them

509
00:26:08.020 --> 00:26:10.480
all open. How can I
do that now? How did

510
00:26:10.480 --> 00:26:12.970
you fix that problem? So
there's a couple of things

511
00:26:12.970 --> 00:26:15.040
that have happened in the
last sort of five years

512
00:26:15.040 --> 00:26:18.580
on asp.net that have allowed
us to, to make this,

513
00:26:18.940 --> 00:26:20.920
to do this now. So
the first thing that's probably

514
00:26:20.920 --> 00:26:24.160
worth pointing out is how
AEs coordinate users threads, and

515
00:26:24.160 --> 00:26:27.100
why people perhaps have found
doing this type of thing.

516
00:26:27.100 --> 00:26:29.350
When I just get on
knit hard in the past.

517
00:26:29.980 --> 00:26:34.870
So with acp.net, when the
application starts up, it uses

518
00:26:34.870 --> 00:26:38.140
the.net thread pool. This is
the standard construct in dotnet

519
00:26:38.140 --> 00:26:41.800
applications that sort of manages
the allocation of threads, you

520
00:26:41.800 --> 00:26:44.610
know, threads, being the things
on the CPU that your

521
00:26:44.610 --> 00:26:47.130
code runs on. If you
want to run more than

522
00:26:47.130 --> 00:26:48.720
one thing at a time,
you need to have more

523
00:26:48.720 --> 00:26:51.480
than one thread running. So
it, it, when, when you're

524
00:26:51.480 --> 00:26:53.460
asked to run, the app
spins up, it gets so

525
00:26:53.460 --> 00:26:56.760
many threads added to a
thread pool. That's now running

526
00:26:56.760 --> 00:26:59.670
in your process or running
in your app domain. And

527
00:26:59.670 --> 00:27:01.620
then what will happen is
when a request comes in

528
00:27:01.620 --> 00:27:05.790
via I S and it's
handed off to asp.net, asp.net

529
00:27:05.790 --> 00:27:09.540
will take a thread from
that thread pool and assign

530
00:27:09.540 --> 00:27:11.850
the requests to that thread.
So it can run your

531
00:27:11.850 --> 00:27:16.830
code on that thread. And
in standardized.net programming, that thread

532
00:27:16.830 --> 00:27:19.500
will remain assigned to that
request for the lifetime of

533
00:27:19.500 --> 00:27:25.200
that request. And this model
was really designed to cater

534
00:27:25.200 --> 00:27:27.990
for the scenarios. We request
a very short live, you

535
00:27:27.990 --> 00:27:30.270
know, under a hundred milliseconds,
a request comes in, you

536
00:27:30.270 --> 00:27:32.160
do some processing, and then
you return it very, very

537
00:27:32.160 --> 00:27:35.370
quickly. And the thread pool
is very, very good at

538
00:27:35.370 --> 00:27:37.320
giving us spreads and taking
them back again at that

539
00:27:37.320 --> 00:27:39.150
type of rate. It's certainly
has no problem doing that.

540
00:27:39.750 --> 00:27:43.500
Now, prior to version of
a prior to.net for the

541
00:27:43.500 --> 00:27:46.320
way that we, the default
numbers for the number of

542
00:27:46.320 --> 00:27:49.110
threats that you are allocated
into your Apple for an

543
00:27:49.110 --> 00:27:52.560
ACL net application was actually
very, very low down in

544
00:27:52.560 --> 00:27:54.270
sort of the double digit.
So like, I think it

545
00:27:54.270 --> 00:27:57.150
was something like 10 threads
per CPU or something like

546
00:27:57.150 --> 00:28:00.060
this. So if you had
a four core machine, when

547
00:28:00.060 --> 00:28:01.980
you're able to net application
started up, you would have

548
00:28:01.980 --> 00:28:04.800
less than a hundred threads
perhaps in your ThreadPool by

549
00:28:04.800 --> 00:28:07.410
default, so that you really
couldn't be dealing with any

550
00:28:07.410 --> 00:28:12.350
more than a hundred concurrent
connections. Right. Right. And which

551
00:28:12.350 --> 00:28:16.130
was, which was designed to,
to help throughput women, if

552
00:28:16.130 --> 00:28:18.770
your goal was to serve
as many requests as possible,

553
00:28:18.770 --> 00:28:21.170
you didn't want to spend
too much time thrashing. That

554
00:28:21.170 --> 00:28:23.450
was an appropriate number of
threads per CPU, and was

555
00:28:23.450 --> 00:28:27.560
optimized for horsepower and throughput,
but not for concurrency of,

556
00:28:27.820 --> 00:28:31.520
of persistent connections. Exactly. And
that's what we see is

557
00:28:31.520 --> 00:28:35.300
when we talk about these
concurrency top libraries, these idea

558
00:28:35.300 --> 00:28:38.960
of real time, persistent connection
libraries, the much more important

559
00:28:38.960 --> 00:28:43.370
measure is concurrency the number
of concurrent connections. You can

560
00:28:43.370 --> 00:28:46.460
have open to the server
rather than the throughput of

561
00:28:46.460 --> 00:28:49.520
the server, because generally with
the type of applications you're

562
00:28:49.520 --> 00:28:53.330
building with these type of
abstractions, you're not having an

563
00:28:53.330 --> 00:28:56.150
awful lot of throughput. You're
not sending dozens and dozens

564
00:28:56.180 --> 00:29:00.350
of packets to the clients
per second. What you be

565
00:29:00.350 --> 00:29:02.210
able to do is have
lots and lots of clients

566
00:29:02.240 --> 00:29:06.280
connected. And then when something
happens, push those, push something

567
00:29:06.500 --> 00:29:08.690
out very quickly to those
clients in somewhat close to

568
00:29:08.690 --> 00:29:13.070
real time. And so we
got to.net for, and a

569
00:29:13.070 --> 00:29:16.220
few things happened, first of
all, all those limits were

570
00:29:16.220 --> 00:29:19.490
upped by default. So the
number of threads allocated into

571
00:29:19.490 --> 00:29:22.700
the thread pool per CPU
were drastically increased. There are

572
00:29:22.700 --> 00:29:26.270
other settings in asp.net that
actually govern like hard limits

573
00:29:26.270 --> 00:29:28.910
on how many concurrent connections
can I have before I

574
00:29:28.910 --> 00:29:32.180
just stopped serving requests that
got up to something like

575
00:29:32.180 --> 00:29:35.240
5,000 in dotnet four, by
default, prior to that, it

576
00:29:35.240 --> 00:29:37.550
was much, much, much, much
lower than that. Now these

577
00:29:37.550 --> 00:29:40.850
will always tweakable, but as
you said, they were architected

578
00:29:40.850 --> 00:29:42.520
as this because, you know,
I spit on, it was

579
00:29:42.520 --> 00:29:45.490
really geared. It's serving certain
types of traffic. So what

580
00:29:45.490 --> 00:29:47.350
we have now is this
situation where we can take

581
00:29:47.350 --> 00:29:49.210
a lot more threads, but
we still have this problem.

582
00:29:49.210 --> 00:29:50.830
I mean, you know, I
guess then maybe now I

583
00:29:50.830 --> 00:29:53.020
have a thousand threads available
to me and I can

584
00:29:53.020 --> 00:29:56.820
have handle a high limit
of 5,000 concurrent connections, but

585
00:29:56.820 --> 00:29:58.410
that's still not that many.
Like I'd like to be

586
00:29:58.410 --> 00:30:00.690
able to hold onto a
lot more connections than that.

587
00:30:01.050 --> 00:30:02.850
Well, in order to do
that, we have to look

588
00:30:02.850 --> 00:30:05.160
at, come back to that.
How is broad net deals

589
00:30:05.160 --> 00:30:08.100
with threads requests? And so
I talked about before that,

590
00:30:08.100 --> 00:30:10.080
the default way, what happens
is that when a request

591
00:30:10.080 --> 00:30:11.760
comes in, I just put
on it, assigns it to

592
00:30:11.760 --> 00:30:14.130
a thread, and that thread
lives with it requests for

593
00:30:14.130 --> 00:30:17.280
the life of the request.
But we also have asynchronous

594
00:30:17.280 --> 00:30:22.140
programming model inside of it,
net that lets you basically

595
00:30:22.320 --> 00:30:26.670
keep a request open, but
dissolve all threads associated with

596
00:30:26.670 --> 00:30:29.190
the request until such time
that there is work to

597
00:30:29.190 --> 00:30:31.830
do on the request. So
if you think about a

598
00:30:31.830 --> 00:30:34.410
persistent connection, what's mostly most
of the time what's going

599
00:30:34.410 --> 00:30:36.510
to happen is that the,
the request does open, but

600
00:30:36.510 --> 00:30:39.870
nothing's happening. You're waiting for
some event to take place

601
00:30:39.870 --> 00:30:42.320
on the server. So that
at which point you'll send

602
00:30:42.330 --> 00:30:43.980
out a down sort of
the stuff we've been talking

603
00:30:43.980 --> 00:30:46.770
about all that time, while
nothing's happening on the request,

604
00:30:47.280 --> 00:30:49.560
one, a threat to be
taken up. And so we

605
00:30:49.560 --> 00:30:51.810
need to use the ACE,
but on an asynchronous programming

606
00:30:51.810 --> 00:30:54.660
model to do this. Now,
this has been around for

607
00:30:54.660 --> 00:30:56.010
a while. I mean, I
think I just don't know

608
00:30:56.010 --> 00:30:58.440
there's been around since 1.1,
I think, but it was

609
00:30:58.440 --> 00:31:00.780
very, very difficult because of
the fact that the way

610
00:31:00.780 --> 00:31:05.250
you did@asyncin.net was something called
APM. The asynchronous programming model,

611
00:31:05.610 --> 00:31:07.920
and people will be familiar
with a number of APIs

612
00:31:07.920 --> 00:31:11.610
in asp.net, where we have
like a begin and end

613
00:31:11.640 --> 00:31:15.300
method pair with the begin
method returns and IAA sync

614
00:31:15.300 --> 00:31:19.050
result and takes in as
a parameter. And async Colback

615
00:31:19.290 --> 00:31:21.660
delegate, which is basically the
function that needs to be

616
00:31:21.660 --> 00:31:25.470
called when this async operation
has finished. And then the

617
00:31:25.470 --> 00:31:28.080
calling code will end up
calling the end method, passing

618
00:31:28.080 --> 00:31:30.690
in that IAA sync result
that was returned. That's a

619
00:31:30.810 --> 00:31:34.140
fairly complex coding paradigm to
get around. And while it

620
00:31:34.140 --> 00:31:36.810
may be fairly easy to
get your head around doing

621
00:31:36.810 --> 00:31:38.790
one of those where it
became really difficult is when

622
00:31:38.790 --> 00:31:41.850
you had multiple operations that
were async that you wanted

623
00:31:41.850 --> 00:31:44.400
to chain together, or you
wanted to sort of set

624
00:31:44.400 --> 00:31:46.650
up asynchronous loops where you
did some work and then

625
00:31:46.650 --> 00:31:48.450
sort of went away. And
then at some point in

626
00:31:48.450 --> 00:31:50.370
the future, woke up again
and did some more work.

627
00:31:50.370 --> 00:31:52.290
And that type of coding
was very, very difficult to

628
00:31:52.290 --> 00:31:56.280
do. So we've done there
for the day. Net team

629
00:31:56.280 --> 00:31:59.910
introduces amazing library called the
task parallel library or TPL.

630
00:32:00.270 --> 00:32:03.660
And this is a whole
new set of API inside.net

631
00:32:03.660 --> 00:32:07.230
that make doing this sort
of asynchronous programming much, much

632
00:32:07.260 --> 00:32:09.390
easier. It's it's you don't
have to deal with this

633
00:32:09.390 --> 00:32:12.930
APM, any model anymore. We
have this task-based parallelism model

634
00:32:12.930 --> 00:32:16.260
now. So rather than dealing
with IAA sync results and

635
00:32:16.320 --> 00:32:19.710
method pairs, we now just
deal with things called tasks.

636
00:32:19.800 --> 00:32:22.530
So a method can return
a task, which is a

637
00:32:22.530 --> 00:32:24.960
promise. I mean, other programming
languages, we have these idea

638
00:32:24.960 --> 00:32:26.730
of promises in J crew.
We have the idea of

639
00:32:26.730 --> 00:32:29.640
a deferred object, which is
a promise. So this object

640
00:32:29.640 --> 00:32:33.480
that your method return represents
something, a task that will

641
00:32:33.480 --> 00:32:36.810
run in the future or
maybe running right now. And

642
00:32:36.810 --> 00:32:40.670
then that task will complete
when that has completed. And

643
00:32:40.670 --> 00:32:42.740
then there are API APIs
in the TPL that let

644
00:32:42.740 --> 00:32:45.140
you chain one task to
another. So you can say,

645
00:32:45.140 --> 00:32:47.600
okay, I now have this
task, which represents a database

646
00:32:47.600 --> 00:32:50.210
call. And then when this
task is finished, I want

647
00:32:50.210 --> 00:32:52.610
to go off and do
this other code with the

648
00:32:52.610 --> 00:32:55.520
result of that first task.
And you can continue chatting

649
00:32:55.520 --> 00:32:58.670
these tasks together. And then
the.net will just take care

650
00:32:58.670 --> 00:33:00.980
of scheduling all this work
at the point when it

651
00:33:01.010 --> 00:33:03.260
actually needs to happen based
on that sort of task

652
00:33:03.260 --> 00:33:06.520
hierarchy that you've built up.
And all of that being

653
00:33:06.520 --> 00:33:08.830
hidden from you by signal
are so signal R is

654
00:33:09.040 --> 00:33:12.880
hiding the protocol. That's hiding
some complexities of scale. You

655
00:33:12.880 --> 00:33:14.890
can, and people can use
this today. I mean, we

656
00:33:14.890 --> 00:33:16.960
talked a lot about how
swept sockets is not ready,

657
00:33:16.960 --> 00:33:18.850
but if the listener wants
to go and use signal

658
00:33:18.850 --> 00:33:21.940
or today, even on a
production, what, what, what do

659
00:33:21.940 --> 00:33:24.970
you, what do you recommend
to them? Well, we certainly

660
00:33:24.970 --> 00:33:27.430
have people doing that already.
I mean, from the library

661
00:33:27.430 --> 00:33:29.290
point of view with sort
of still in the fairly

662
00:33:29.290 --> 00:33:33.250
early days, I think versions
like 0.3, something, we have

663
00:33:33.250 --> 00:33:36.670
a sample reference application up
on app Harbor that we

664
00:33:36.670 --> 00:33:38.320
can point to that we
sort of hang out in

665
00:33:38.320 --> 00:33:41.350
as a chat application. So
there's sort of an IRC

666
00:33:41.350 --> 00:33:45.400
clone. It's that chat app
thought app hb.com. And so

667
00:33:45.400 --> 00:33:46.570
you can go up there
and sort of get a

668
00:33:46.570 --> 00:33:49.150
feel for the type of
application you can build with

669
00:33:49.150 --> 00:33:51.040
this. And then I'll get
hub where our sources, we

670
00:33:51.040 --> 00:33:53.470
have a number of other
sample applications as well. Now

671
00:33:53.470 --> 00:33:55.630
we know of people who
have built, Oh, who is

672
00:33:55.630 --> 00:33:58.120
now using signal area and
things like auction sites. So

673
00:33:58.120 --> 00:34:01.960
they can get real time
bid price updates on auction,

674
00:34:01.960 --> 00:34:04.170
lot pages. We have other
people who are looking at

675
00:34:04.180 --> 00:34:06.850
for using on things like
sports sites, so that if

676
00:34:06.850 --> 00:34:08.860
you want to get sports
scores up to date in

677
00:34:08.860 --> 00:34:11.020
real time, they're using looking
at using signal off of

678
00:34:11.020 --> 00:34:12.970
that type of thing. And
then we also have a

679
00:34:12.970 --> 00:34:16.030
scale-out story. So if you
have a large scale site

680
00:34:16.030 --> 00:34:18.520
where your website runs on
more than one server, you

681
00:34:18.520 --> 00:34:21.940
have to be able to
coordinate this at the signal

682
00:34:21.940 --> 00:34:24.910
or messages that go between
the servers. So that if

683
00:34:24.910 --> 00:34:27.370
I have a client connected
to server one who wants

684
00:34:27.370 --> 00:34:29.350
to send a message in
real time to a client

685
00:34:29.350 --> 00:34:32.350
on server two, then you
know, we have a scale-out

686
00:34:32.350 --> 00:34:33.760
story for that as well.
We have a couple of

687
00:34:33.760 --> 00:34:36.880
APIs that you can hook
into to sort of build

688
00:34:36.880 --> 00:34:40.150
in support for whatever scale
that technology that you're using.

689
00:34:40.780 --> 00:34:42.970
So you can certainly try
using it now where, you

690
00:34:42.970 --> 00:34:45.310
know, it's continually being worked
on where we're still refining

691
00:34:45.310 --> 00:34:46.840
a few parts of it,
but we are, the more

692
00:34:46.840 --> 00:34:48.490
people use it, the better
it's going to get. So.

693
00:34:49.690 --> 00:34:51.700
Alright, cool. So are you
going to, you have this

694
00:34:51.790 --> 00:34:54.070
also signal our.net as a
domain that you've been sitting

695
00:34:54.070 --> 00:34:55.300
on for a while, you're
going to hook that up

696
00:34:55.300 --> 00:34:57.070
for me and make it
so it redirects to where

697
00:34:57.070 --> 00:35:00.340
people can get the code.
A really good idea. So

698
00:35:00.340 --> 00:35:01.840
yeah, we do have signal.
I've done that with the

699
00:35:01.840 --> 00:35:03.310
idea of being able to
put a website up there

700
00:35:03.310 --> 00:35:04.870
at some point, but for
now we should probably just

701
00:35:04.870 --> 00:35:07.720
redirect it to the GitHub
repository. I'll go ahead and

702
00:35:07.720 --> 00:35:12.280
do that. Otherwise you can
just go to github.com/which is

703
00:35:12.280 --> 00:35:14.530
the organization, and there's a
bunch of repositories in there

704
00:35:14.530 --> 00:35:16.330
for the various parts of
the library, or you can

705
00:35:16.330 --> 00:35:22.450
just go to install, package
signal. Very cool. Thanks a

706
00:35:22.450 --> 00:35:25.450
lot Damien, for talking to
us about signaler today. Not

707
00:35:25.450 --> 00:35:28.390
a problem. Thanks for that.
This has been another episode

708
00:35:28.390 --> 00:35:30.880
of Hansel minutes. We'll see
you again next week.


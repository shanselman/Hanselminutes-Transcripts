WEBVTT FILE

1
00:00:12.150 --> 00:00:16.620
From Hanselman it's dot com.
It's Hanselman. It's a weekly

2
00:00:16.620 --> 00:00:21.120
discussion with web developer and
technologists. Scott Hanselman hosted by

3
00:00:21.120 --> 00:00:26.190
Carl Franklin. This is Jeff Macio
Lake announcing show number 32

4
00:00:26.490 --> 00:00:32.430
recorded Sunday, September 10th, 2006. Support for
Hansel minutes is provided by

5
00:00:32.430 --> 00:00:36.750
COVID Smith tools, makers of
code Smith, an extensible template

6
00:00:36.750 --> 00:00:40.500
based code generator for dotnet
Hansel and its listeners. Get

7
00:00:40.500 --> 00:00:44.310
$100 off code Smith professional
with coupon code H M

8
00:00:44.400 --> 00:00:52.110
100. online@covidsmithtools.com. Support is also
provided by as PPOs the.net

9
00:00:52.110 --> 00:00:55.890
and Java component publisher Hanselman
its listeners. Get 20% off

10
00:00:55.890 --> 00:00:58.530
the price of any purchase
product or suite with coupon

11
00:00:58.530 --> 00:01:01.920
code H M one two
three four five six seven

12
00:01:01.920 --> 00:01:12.150
eight. online@wwwdotaspose.com. Support is also
provided by.net developers journal the

13
00:01:12.150 --> 00:01:19.020
world's leading.net developer magazine online
at www dot <inaudible> dot

14
00:01:19.020 --> 00:01:22.920
com. In this episode, Scott
talks with Carl about MOC

15
00:01:22.980 --> 00:01:30.180
objects. Hi, this is Carl Franklin
and you're listening to Hanselman

16
00:01:30.180 --> 00:01:32.460
it's. I'm here with Scott
Hanselman as I am every

17
00:01:32.460 --> 00:01:36.060
week. Hi Scott, how are
you sir? Doing fine. I

18
00:01:36.060 --> 00:01:38.460
really enjoyed your DNR TV
last week. That was great.

19
00:01:38.730 --> 00:01:41.460
Well, this week actually. Yeah,
that was pretty cool. Yeah.

20
00:01:42.690 --> 00:01:46.290
And today we're talking about
mock objects. Yeah. You know,

21
00:01:46.290 --> 00:01:50.220
we talked about test driven
development recently and had some

22
00:01:50.220 --> 00:01:53.010
suggestions from a number of
people, including Phil hack, who

23
00:01:53.010 --> 00:01:54.690
I respect very much who
said, well, you've got to

24
00:01:54.690 --> 00:01:57.660
do one on mocks. And
I think that more and

25
00:01:57.660 --> 00:02:00.810
more people are doing test
driven development, or they are

26
00:02:00.810 --> 00:02:03.870
at least doing lots of
tests as we learned last

27
00:02:03.870 --> 00:02:06.900
week, right? Test driven development
and writing lots of tests

28
00:02:06.900 --> 00:02:09.600
or different things, two different
things. Right? One of the

29
00:02:09.600 --> 00:02:12.450
things that I find very
frustrating is trying to test

30
00:02:12.450 --> 00:02:16.080
something when there's a whole
stack of stuff underneath, that

31
00:02:16.080 --> 00:02:19.440
has to be just so
the database set up, or

32
00:02:19.440 --> 00:02:22.830
maybe you need data, you
need web services, connectivity, and

33
00:02:23.160 --> 00:02:25.920
then you end up often
just saying, I won't bother

34
00:02:25.920 --> 00:02:28.590
testing that it's too much
of a hassle. And that's

35
00:02:28.590 --> 00:02:32.550
where mock objects come in.
Mock objects are objects that

36
00:02:32.550 --> 00:02:35.760
have the same interface as
your real objects, but obviously

37
00:02:35.760 --> 00:02:39.180
don't do anything. Right. Right.
That's a good way to

38
00:02:39.180 --> 00:02:42.060
put it. So you could,
of course, just if you

39
00:02:42.060 --> 00:02:44.310
had interfaces for all the
things you wanted to test,

40
00:02:44.520 --> 00:02:47.460
you could just provide an
object that implements that interface.

41
00:02:47.460 --> 00:02:51.510
So you don't need a
mock object framework to do

42
00:02:51.510 --> 00:02:53.520
that, but it takes a
little bit more work on

43
00:02:53.520 --> 00:02:56.970
your effort. Like for, for
my purposes, let's use the

44
00:02:56.970 --> 00:03:00.040
example of DAS blog. So
DAS blog has this very

45
00:03:00.040 --> 00:03:03.850
complicated, very icky interface called
I blog data service. And

46
00:03:03.850 --> 00:03:06.340
right now there's only one
implementation of I blog data

47
00:03:06.340 --> 00:03:09.130
service. This is the thing
for stuff like get entry

48
00:03:09.130 --> 00:03:12.130
and get comments and things
like that. And we've always

49
00:03:12.130 --> 00:03:13.960
said that one day we
would hook it up to

50
00:03:13.960 --> 00:03:17.020
a database. Even though right
now it's talking to XML,

51
00:03:17.560 --> 00:03:20.260
but we do some unit
testing and DAS blog, but

52
00:03:20.260 --> 00:03:23.530
we usually have to have
a folder full of basically

53
00:03:23.530 --> 00:03:27.010
fake blog posts to do
even the most basic testing.

54
00:03:27.130 --> 00:03:30.370
Right. So we could, of
course just write an object

55
00:03:30.370 --> 00:03:33.190
of our own then implements
I've logged data service, and

56
00:03:33.190 --> 00:03:38.290
does basically fakes out the
tests that breaks down when

57
00:03:38.290 --> 00:03:43.120
you start getting into the
object, changing its behavior. So

58
00:03:43.120 --> 00:03:44.770
you call it once it
does this. And then the

59
00:03:44.770 --> 00:03:47.410
second time you call the
same method, it does another

60
00:03:47.410 --> 00:03:50.740
thing. Okay. So the object
has internal state. So then

61
00:03:50.740 --> 00:03:53.110
you end up writing a
lot of code of your

62
00:03:53.110 --> 00:03:56.500
own in this fake object
that implements that interface you

63
00:03:56.500 --> 00:03:59.260
want to test, and that
doesn't necessarily move the ball

64
00:03:59.260 --> 00:04:01.650
forward. I was going to
say, I mean, I mean

65
00:04:01.650 --> 00:04:04.380
this, this whole thing, lock
object thing can only work

66
00:04:04.380 --> 00:04:06.300
if it's easy to implement,
because if you spend more

67
00:04:06.300 --> 00:04:09.690
time writing mock objects than
you, real objects you face,

68
00:04:09.750 --> 00:04:13.860
you're basically wasting time. Right?
Exactly. Now the definition you

69
00:04:13.860 --> 00:04:17.220
said was an object that
implements the same interface as

70
00:04:17.220 --> 00:04:18.690
the one you want to
test. That's a good way

71
00:04:18.690 --> 00:04:21.390
to put it, but a
lot of the newer mock

72
00:04:21.390 --> 00:04:27.900
objects technologies within.net support mocking,
not just interfaces, they actually

73
00:04:27.900 --> 00:04:32.040
mock concrete types. So you
can actually simulate the behavior

74
00:04:32.040 --> 00:04:34.410
of an actual object, you
know, in a test environment,

75
00:04:35.040 --> 00:04:37.530
even if you don't have
an interface. So for example,

76
00:04:37.560 --> 00:04:40.470
maybe you can just Mark
a few methods virtual, and

77
00:04:40.470 --> 00:04:42.780
then you can mock that
object. Or if you use

78
00:04:42.780 --> 00:04:46.140
one of the more advanced
ones, they'll use interception technologies

79
00:04:46.140 --> 00:04:48.660
that will allow you to
mock really anything at all.

80
00:04:49.230 --> 00:04:51.180
And this is really useful
when the thing that you're

81
00:04:51.180 --> 00:04:54.300
trying to test, you know,
has some results that change

82
00:04:54.300 --> 00:04:57.780
a lot, something that's kind
of non-deterministic. So we're talking

83
00:04:57.780 --> 00:05:02.310
about a, what if the
time changes or you're doing

84
00:05:02.310 --> 00:05:06.030
wind speed? You know, just
something that is environmental, even

85
00:05:06.030 --> 00:05:07.530
if you do, you know,
if you do the testing

86
00:05:07.530 --> 00:05:08.850
such that you have to
hook up to a real

87
00:05:08.850 --> 00:05:11.520
device, can you fake that
device? Can you fake that

88
00:05:11.520 --> 00:05:14.610
interface? Sometimes if it's network
connectivity or if you haven't

89
00:05:14.610 --> 00:05:18.030
talked to a, something that's
slow, do a database call

90
00:05:18.030 --> 00:05:22.920
or talk to a web
service. And also sometimes when

91
00:05:22.920 --> 00:05:25.830
you are testing objects, you
have to include information that

92
00:05:25.830 --> 00:05:27.750
you really don't want to
be in the tests, like

93
00:05:28.140 --> 00:05:32.790
a database connection strings that
you'd rather not do. And

94
00:05:32.790 --> 00:05:35.340
you're really not trying to
test the underlying system. You're

95
00:05:35.340 --> 00:05:38.400
trying to test the code
that interacts with that system,

96
00:05:38.430 --> 00:05:41.850
right? So there's a lot
of different frameworks out there.

97
00:05:42.360 --> 00:05:44.730
The ones that everyone keeps
talking about, if you look

98
00:05:44.730 --> 00:05:50.070
around and ask around are
rhino mocks, easy mock, which

99
00:05:50.070 --> 00:05:52.590
is a little older and
a port of a Java

100
00:05:53.580 --> 00:05:56.550
tool, isn't it true that
like every.net tool that's awesome.

101
00:05:56.550 --> 00:05:58.970
As a port, a Java
tool. Yeah. Funny how that

102
00:05:58.970 --> 00:06:04.640
works and mock to type
mock, which is interesting. Cause

103
00:06:04.850 --> 00:06:06.710
there are a lot like
test-driven dot net, they've got

104
00:06:06.710 --> 00:06:09.290
a community version of personal
version and a professional version.

105
00:06:10.640 --> 00:06:13.700
And then there's some other
tools like J flowers, doubler

106
00:06:13.700 --> 00:06:15.940
that we can talk about
it. But, But now the

107
00:06:15.940 --> 00:06:19.000
last time I talked about
mock objects and mock was

108
00:06:19.000 --> 00:06:22.300
really the only game in
town. It's been a while.

109
00:06:22.480 --> 00:06:24.730
A lot of new stuff
has come up there's Yeah.

110
00:06:24.730 --> 00:06:27.400
And then there's end mock
two, which I guess is

111
00:06:27.400 --> 00:06:30.070
now the recommended version. If
you visit the old end

112
00:06:30.070 --> 00:06:33.310
mock site, Let's just talk
about what the goal of

113
00:06:33.310 --> 00:06:36.310
these things is first. You
know, what's the goal of,

114
00:06:36.550 --> 00:06:39.610
of a mock object framework,
I guess it's to take

115
00:06:39.610 --> 00:06:43.720
the grunt work out of
managing mock objects. Right? Well,

116
00:06:43.720 --> 00:06:46.060
yeah. So that's a good
point. So you, if you

117
00:06:46.060 --> 00:06:48.550
run a test, you know,
you go public void test

118
00:06:48.550 --> 00:06:50.530
and you put your test
attribute on the top and

119
00:06:50.530 --> 00:06:52.420
then you right. Click and
you say run test and

120
00:06:52.420 --> 00:06:55.600
you have a bunch of
assertions, right? So you assert

121
00:06:55.630 --> 00:06:57.730
that this will be equal
to that. Or you assert

122
00:06:57.730 --> 00:07:01.930
that whatever's returned from this
function is equal to something,

123
00:07:02.050 --> 00:07:06.550
right? Yeah. But with a
mock you want to not

124
00:07:06.550 --> 00:07:10.780
just have assertions, you have
actually expectations. So you might

125
00:07:10.900 --> 00:07:14.230
have an object called person
and you might expect that

126
00:07:14.230 --> 00:07:17.380
get first name is going
to return Scott, for whatever

127
00:07:17.380 --> 00:07:19.780
reason, maybe it was populated
from the database or whatever,

128
00:07:19.780 --> 00:07:23.320
but you need to know
that that's your expectation. So

129
00:07:23.740 --> 00:07:26.080
you could do what we
did before. We talked about

130
00:07:26.110 --> 00:07:28.630
making something that implements I
person, you have to create

131
00:07:28.630 --> 00:07:33.760
an interface <inaudible> or with
a mock a framework you

132
00:07:33.760 --> 00:07:38.320
could say in your test,
I expect the call to

133
00:07:38.320 --> 00:07:41.410
person dot, get, you know,
get first name to return

134
00:07:41.410 --> 00:07:43.330
Scott. And I expect that
and I'm going to warn

135
00:07:43.330 --> 00:07:47.080
you mr. Test mock object
thing ahead of time. So

136
00:07:47.080 --> 00:07:49.180
then when I turn you
on and actually do the

137
00:07:49.180 --> 00:07:53.020
work, you're going to do
the right faking that's Appropriate.

138
00:07:53.290 --> 00:07:55.540
So it basically is going
to just go ahead and

139
00:07:55.540 --> 00:07:58.120
build an object. That's going
to provide the behavior that

140
00:07:58.120 --> 00:08:01.810
the test expects. And then
once you have that framework,

141
00:08:01.810 --> 00:08:04.780
then you can go in
and change the mock stuff

142
00:08:04.810 --> 00:08:08.440
to real code. Is that
right? Is this like a

143
00:08:08.440 --> 00:08:13.540
prototype? No. So what you're
trying to do is like,

144
00:08:13.590 --> 00:08:17.460
let's say that you've got
some analysis tool that, that

145
00:08:17.830 --> 00:08:20.800
makes a bunch of calls
to an underlying object system

146
00:08:20.980 --> 00:08:24.100
and then perform some analysis.
You're not testing the underlying

147
00:08:24.100 --> 00:08:28.000
system, you're testing the analysis,
right? So you could spend

148
00:08:28.000 --> 00:08:30.310
a whole bunch of time
getting that underlying interface set

149
00:08:30.310 --> 00:08:34.090
up, or you could really
just focus on the results.

150
00:08:34.120 --> 00:08:38.080
I see, you know, that
assuming that my expectations are

151
00:08:38.080 --> 00:08:40.630
correct, but assuming that person
dot first name does in

152
00:08:40.630 --> 00:08:44.770
fact return Scott, which isn't
the point of the test,

153
00:08:45.010 --> 00:08:47.950
it's the point of the
thing that consumes them Value.

154
00:08:48.010 --> 00:08:50.440
I see. So the purpose
is to get tests up

155
00:08:50.440 --> 00:08:56.250
and running quickly, not to
prototype the underlying code. Right?

156
00:08:56.250 --> 00:08:59.250
Right. Now you could, you
could use it that way.

157
00:08:59.250 --> 00:09:01.350
I mean, you could go
and say, I'm not quite

158
00:09:01.350 --> 00:09:03.450
sure how it's going to
get that value. So you

159
00:09:03.450 --> 00:09:06.450
could use mock objects within
the context of test driven

160
00:09:06.450 --> 00:09:08.460
development. So you brought up
an interesting point, which is

161
00:09:08.460 --> 00:09:10.200
a little orthogonal, the way,
the direction that we were

162
00:09:10.200 --> 00:09:13.800
going. But you could say,
I'm going to write my

163
00:09:13.800 --> 00:09:16.530
test as like a specification.
I expect it to work

164
00:09:16.530 --> 00:09:18.810
like this. So you can
basically mock out most of

165
00:09:18.810 --> 00:09:20.460
your system and there's nothing
wrong with that. That's a

166
00:09:20.460 --> 00:09:23.040
really good way to do
it. You could say this

167
00:09:23.040 --> 00:09:24.510
thing, I want to write,
it's going to be really

168
00:09:24.510 --> 00:09:26.340
complicated, but I know when
it comes out, it's going

169
00:09:26.340 --> 00:09:29.880
to say Scott, right? Yeah.
You know, and that's a

170
00:09:29.880 --> 00:09:32.400
really great way to design
a framework, right? If you

171
00:09:32.400 --> 00:09:35.700
don't know how your data
access layer should behave, you

172
00:09:35.700 --> 00:09:38.790
can basically mock up the
whole thing and then fill

173
00:09:38.790 --> 00:09:40.980
in the blanks later. Right.
So that's a great way

174
00:09:40.980 --> 00:09:44.280
to use mocking within the
context of having the test

175
00:09:44.280 --> 00:09:46.290
drive your development. So you've
brought up a really great

176
00:09:46.290 --> 00:09:50.340
point. So let's talk about
like some of the examples,

177
00:09:50.340 --> 00:09:54.300
like for example, and mock
the, the protocol is basically

178
00:09:54.300 --> 00:09:57.090
you make a new mockery,
which is kind of cooling

179
00:09:57.090 --> 00:10:01.020
off what they call. Yeah.
Mockery am equals new mockery.

180
00:10:01.240 --> 00:10:05.770
Okay. And let's say that
you want to mock a,

181
00:10:05.860 --> 00:10:10.080
a person. So you'd go
and say mock.new mock. And

182
00:10:10.080 --> 00:10:12.630
you say type of person,
you say, I want to

183
00:10:12.630 --> 00:10:15.810
mock a person. And then
what's cool is you actually

184
00:10:15.810 --> 00:10:19.140
just say, you know, person
P equals mock.new mock and

185
00:10:19.140 --> 00:10:20.640
you get a person out
of it. And then you

186
00:10:20.640 --> 00:10:26.640
cast because the mock.new mock
returns an object, you have

187
00:10:26.640 --> 00:10:29.490
to cast it to the
object that you're expecting. Okay.

188
00:10:29.520 --> 00:10:31.890
So then you have, you
have a person now, this

189
00:10:31.890 --> 00:10:34.520
is where the syntax gets
really cool. I think so

190
00:10:34.620 --> 00:10:37.440
within mock two, you go
and you say something like

191
00:10:38.100 --> 00:10:44.400
expect dot once on person
dot get property, quote, first

192
00:10:44.400 --> 00:10:50.670
name dot will return a
value of Scott. So it's

193
00:10:50.670 --> 00:10:55.470
really a big, long dot
syntax, but it reads like

194
00:10:55.500 --> 00:11:01.680
English expect once on person
get property, first name will

195
00:11:01.680 --> 00:11:04.260
return Scott. Okay. And it
ends up being a lot

196
00:11:04.260 --> 00:11:08.310
of dots and parentheses. So
you basically prepare your expectations.

197
00:11:08.970 --> 00:11:11.040
So here's a good example.
I'll just use one from

198
00:11:11.070 --> 00:11:14.190
a, a, a blog post
that I read about, about

199
00:11:14.190 --> 00:11:18.060
an MOC at shrink stir
slash <inaudible>. And in this

200
00:11:18.060 --> 00:11:20.520
example, they had items that
are going in a shopping

201
00:11:20.520 --> 00:11:23.220
cart. It's not the items
we're trying to test. It's

202
00:11:23.220 --> 00:11:26.250
the shopping cart. Okay. So
the shopping cart is going

203
00:11:26.250 --> 00:11:29.340
to compute the total of
the items. So we'll mock

204
00:11:29.610 --> 00:11:33.390
two items. We'll fake out
two items. Okay. And we'll

205
00:11:33.600 --> 00:11:36.780
add them to the shopping
cart, the items aren't real,

206
00:11:36.780 --> 00:11:39.990
but the shopping cart doesn't
care. Then we call shopping

207
00:11:39.990 --> 00:11:43.920
cart, compute total. We've told
the items ahead of time.

208
00:11:43.920 --> 00:11:47.100
If anyone calls price on
you, here are the values

209
00:11:47.100 --> 00:11:51.000
we, you should return those
values. Those lies that we've

210
00:11:51.160 --> 00:11:53.530
set up. Those expectations. We've
set up, have been set

211
00:11:53.530 --> 00:11:55.630
up in the test. We
didn't have to create any

212
00:11:55.630 --> 00:11:58.090
phony objects to do it.
We test the shopping cart.

213
00:11:58.090 --> 00:12:01.900
We say compute total. And
then the assertion that the

214
00:12:01.900 --> 00:12:05.620
total equals a certain amount
lives in the same function

215
00:12:05.620 --> 00:12:08.830
that the expectations lived. So
the test data and the

216
00:12:08.830 --> 00:12:11.980
assertion live in the same
place, which makes the management

217
00:12:11.980 --> 00:12:14.470
of your tests a lot
easier. Yeah. So in here

218
00:12:14.470 --> 00:12:17.320
we are testing a shopping
cart, passing it, real items

219
00:12:17.320 --> 00:12:22.270
that aren't implementing an interface
that it understands. Now, one

220
00:12:22.270 --> 00:12:25.060
of the interesting things about
N mock and most of

221
00:12:25.060 --> 00:12:27.670
the mock things that I've
seen are that a lot

222
00:12:27.670 --> 00:12:30.730
of them use strings and
kind of reflection type stuff.

223
00:12:30.730 --> 00:12:34.270
So in this example, you
would say, you know, expect

224
00:12:34.270 --> 00:12:36.700
on item dot, get property.
And then you put in

225
00:12:36.700 --> 00:12:38.860
quotes the name of the
property that you're going to

226
00:12:38.860 --> 00:12:41.590
be calling. Okay. So in
this case, I might say

227
00:12:41.590 --> 00:12:45.160
item, I put, put in
quotes price, we don't get

228
00:12:45.160 --> 00:12:48.790
compiler support there. We don't
know that price is really

229
00:12:49.520 --> 00:12:53.920
an on the item. If
we misspell it, because we've

230
00:12:53.950 --> 00:12:55.720
put the name of the
property and quotes, it's a

231
00:12:55.720 --> 00:12:58.660
string it's being tunneled. We
don't have that kind of

232
00:12:58.660 --> 00:13:03.100
IntelliSense support for this fake
object. Now I ND Raheen

233
00:13:03.100 --> 00:13:06.220
AKA or an any rights
rhino mocks. And what he's

234
00:13:06.220 --> 00:13:08.410
done is he said, you
know, I really didn't like

235
00:13:08.950 --> 00:13:11.260
that. I have to pass
in these quotes. I want

236
00:13:11.260 --> 00:13:14.680
the pro the, I want
the syntax to be cleaner.

237
00:13:14.680 --> 00:13:18.910
I want IntelliSense for my
mock objects. So his syntax

238
00:13:18.910 --> 00:13:23.500
is you make a mock
repository and you say repository,

239
00:13:23.500 --> 00:13:25.930
create mock type of person.
You do same kind of

240
00:13:25.930 --> 00:13:28.990
thing. And then in your
expectations, you would actually say,

241
00:13:29.290 --> 00:13:33.340
expect.call. And then you put
in princesses and then you

242
00:13:33.340 --> 00:13:38.680
actually call the fake function.
Okay. So you'd say, expect.call

243
00:13:39.010 --> 00:13:42.220
parentheses. And then you'd say,
you know, person dot, whatever,

244
00:13:42.670 --> 00:13:45.460
put that in parentheses and
say dot return. So in

245
00:13:45.460 --> 00:13:49.360
that case, you're getting IntelliSense
because you're actually passing in

246
00:13:49.360 --> 00:13:52.600
a fake call and he's
intercepting that call. That's interesting.

247
00:13:52.600 --> 00:13:55.360
When you're done setting up
your expectations, you say, okay,

248
00:13:55.360 --> 00:13:59.470
repository replay, and then you
do your tests. That's an

249
00:13:59.470 --> 00:14:01.860
interesting Way to do it.
I would, I would, I

250
00:14:01.860 --> 00:14:04.560
would die without, until, since.
So that's, that's a great

251
00:14:04.560 --> 00:14:08.220
way to do it. Rhino
mocks has some limitations in

252
00:14:08.220 --> 00:14:10.440
that. The things that you
want to mock have to

253
00:14:10.440 --> 00:14:13.710
be marked virtual. Cause what
he's doing internally is he's

254
00:14:13.710 --> 00:14:18.870
basically making a derived class
of the thing that you

255
00:14:18.870 --> 00:14:21.690
want to mock returning you
like. So if sample, I'm

256
00:14:21.690 --> 00:14:25.110
saying mock, a person he's
going to make secret internal

257
00:14:25.110 --> 00:14:27.810
derived person and then pass
it back and you'll cast

258
00:14:27.810 --> 00:14:30.210
it to a person and
you don't care. And then

259
00:14:30.390 --> 00:14:33.300
when you make the call
because you marked it virtual

260
00:14:33.330 --> 00:14:35.790
indicating you want to change
it, that lets him basically

261
00:14:35.790 --> 00:14:38.490
get in. Isn't that a
little dangerous though? I mean,

262
00:14:38.490 --> 00:14:40.320
what if your app is
doing a lot of casting

263
00:14:40.320 --> 00:14:43.800
and, and, and, you know,
dealing with times a big,

264
00:14:44.130 --> 00:14:47.280
You have a big object
hierarchy and, and marking something

265
00:14:47.310 --> 00:14:50.790
virtual. Isn't what you want
to do. Because basically when

266
00:14:50.790 --> 00:14:53.780
you Mark virtual, you're saying,
I intend someone to extend

267
00:14:53.780 --> 00:14:56.480
this in the future. And
if you're trying to use

268
00:14:56.480 --> 00:14:59.360
a tool like rhino mocks
on a series of objects

269
00:14:59.360 --> 00:15:01.160
that have not been marked
virtual, you can't do it.

270
00:15:01.790 --> 00:15:03.170
Then you got to get
into some of the more

271
00:15:03.170 --> 00:15:08.350
advanced mocking technologies, like Type
mock. So how does that,

272
00:15:08.440 --> 00:15:11.350
how does the word virtual
translate to VB programmers? Just

273
00:15:11.350 --> 00:15:15.610
curiously. I think it's over
rideable in VB. Okay. So,

274
00:15:16.240 --> 00:15:20.530
And C-sharp is, must inherit
in VB and virtual is

275
00:15:20.530 --> 00:15:25.480
over rideable. Okay. Not must
override, but over rideable. Right?

276
00:15:25.510 --> 00:15:28.060
Got it. So you're basically,
you're saying I will in

277
00:15:28.060 --> 00:15:30.730
the future extend this object
and I want to open

278
00:15:30.730 --> 00:15:33.250
it up for that. So
then people talk about virtual

279
00:15:33.250 --> 00:15:36.370
calls being slower, because if
I hand you a person

280
00:15:36.370 --> 00:15:39.850
object, you don't know if
it's really a person object

281
00:15:39.850 --> 00:15:43.510
or if it's actually a
really tall person object that

282
00:15:43.510 --> 00:15:45.970
derives from person. Yeah. Cause
when you go on call

283
00:15:45.970 --> 00:15:51.160
person dot height, you're really
calling the derived class, override

284
00:15:51.280 --> 00:15:57.130
overwritten, rather implementation of height.
So what, what I ND

285
00:15:57.130 --> 00:16:00.550
is doing, that's very clever
is using that virtual ness

286
00:16:00.550 --> 00:16:04.180
as an opportunity to, to
build up his, his fake

287
00:16:04.300 --> 00:16:07.330
versions of the same objects,
which is pretty cool. Yeah.

288
00:16:07.330 --> 00:16:10.240
That's cool. So other than
rhino mocks, what are some

289
00:16:10.240 --> 00:16:13.150
of the other things Tools
out there? So From what

290
00:16:13.150 --> 00:16:15.610
I'm seeing, I have not
personally used type mock, but

291
00:16:15.610 --> 00:16:19.030
I'm understanding and reading their
documentation, which is very good

292
00:16:19.030 --> 00:16:23.020
documentation. I've been impressed reading
their documentation type market shrinks

293
00:16:23.020 --> 00:16:27.480
to S slash <inaudible>. This
seems to be the, the

294
00:16:27.480 --> 00:16:29.950
big stuff. This is the
heavy guns. I was reading

295
00:16:29.950 --> 00:16:34.060
an article by Roy <inaudible>.
I think it was at

296
00:16:34.060 --> 00:16:37.060
shrink stir slash <inaudible>. And
he was saying that, you

297
00:16:37.060 --> 00:16:39.160
know, when you can't get
your mocking done with one

298
00:16:39.160 --> 00:16:41.320
thing, you bring in the
big guns and it's it's

299
00:16:41.320 --> 00:16:45.700
type mock type mock has
got this thing called natural

300
00:16:45.700 --> 00:16:49.450
type mocks, which basically you
set up a scope, you

301
00:16:49.450 --> 00:16:53.020
say using, and you have
a using block and you

302
00:16:53.020 --> 00:16:57.220
say, record expectations, start recording.
And then everything in the

303
00:16:57.220 --> 00:17:02.410
block is being mocked TiVo
for your mock objects. Okay.

304
00:17:02.620 --> 00:17:05.260
Everything's being mocked. So you
basically mock it and you

305
00:17:05.260 --> 00:17:07.900
just call the methods and
then it just fakes it

306
00:17:07.900 --> 00:17:11.650
all and intercepts it. Wow.
Then you do your assertions.

307
00:17:11.680 --> 00:17:13.180
And then at the very
end, you say, okay, well

308
00:17:13.180 --> 00:17:17.650
now verify mock manager verify
that all of our expectations

309
00:17:17.650 --> 00:17:22.030
were met. So it's, it's
a very powerful, very natural

310
00:17:22.030 --> 00:17:25.120
way to do things. Now,
those guys have got a

311
00:17:25.330 --> 00:17:31.930
community version and they've got
a, a professional and enterprise

312
00:17:31.990 --> 00:17:36.400
additions. I'm looking online here
with the prices are, looks

313
00:17:36.400 --> 00:17:38.890
like, Oh, and you get
test-driven dot net. So it's

314
00:17:38.890 --> 00:17:44.470
like, it's 300 bucks enterprise
personal and, and they've got

315
00:17:44.470 --> 00:17:47.350
their community edition and they've
got a series of what

316
00:17:47.350 --> 00:17:51.720
features are available in what
and what versions, all of

317
00:17:51.720 --> 00:17:54.420
their stuff is very kind
of intercepted everything's on the

318
00:17:54.420 --> 00:17:59.610
fly. Right? They'll let you
do a lot more advanced

319
00:17:59.640 --> 00:18:04.530
type stuff from, from reading
their documentation. They've got ms.

320
00:18:04.530 --> 00:18:07.110
Build tasks for mocking Nat
tasks. I mean, this is

321
00:18:07.110 --> 00:18:11.970
a complete mock they're serious
about it. Yeah. Now, one

322
00:18:11.970 --> 00:18:13.650
of the things that I
like about rhino mocks, not

323
00:18:13.650 --> 00:18:16.440
to come back to the
free product, but why Namoks

324
00:18:16.440 --> 00:18:19.920
has a dotnet one, one
version. And I always like

325
00:18:19.920 --> 00:18:22.350
it when people have both.
And I think it's great

326
00:18:22.350 --> 00:18:24.660
that, that he respects one,
one, and realizes that useful

327
00:18:24.660 --> 00:18:27.450
work is happening on, on
one shore and especially the

328
00:18:27.450 --> 00:18:29.730
version of tools that, that
are going to be used

329
00:18:29.730 --> 00:18:32.190
by people on one, one,
two Oh and whatever else.

330
00:18:32.850 --> 00:18:36.570
Yeah, totally. I'm using his,
a vinyl max, 2.9 to

331
00:18:36.570 --> 00:18:41.220
do some, some one, one
mocking his stuff is pretty

332
00:18:41.220 --> 00:18:43.350
cool. The only limitation of
course, is that virtual thing.

333
00:18:43.350 --> 00:18:45.270
That is a little, a
little frustrating, but you know,

334
00:18:45.270 --> 00:18:47.340
you can, you can work,
work your way around and

335
00:18:47.340 --> 00:18:50.790
things like that. I know
that Phil hack uses that.

336
00:18:50.790 --> 00:18:53.010
I think in subtext for
a lot of his marketing

337
00:18:53.790 --> 00:18:58.650
now there's also like a,
an end unit itself has

338
00:18:58.650 --> 00:19:01.920
some, has some mock technology
built into it with end

339
00:19:01.930 --> 00:19:05.910
unit to there's a discussion
of that at a shrink

340
00:19:05.910 --> 00:19:11.850
stir slash <inaudible> E. And
it seems to be kind

341
00:19:11.850 --> 00:19:15.030
of interface based. It's kind
of the, the standard mock

342
00:19:15.030 --> 00:19:17.490
object stuff is I want
to mock something that implements

343
00:19:17.490 --> 00:19:20.010
a certain interface, and that
makes things really easy because

344
00:19:20.010 --> 00:19:23.760
the interface is just a
contract. So then you can

345
00:19:23.760 --> 00:19:25.440
just say, well, go ahead
and fake this out for

346
00:19:25.440 --> 00:19:29.610
me, say new dynamic mock,
and then mock this interface.

347
00:19:29.610 --> 00:19:32.100
And then go ahead and
give me a fake instance.

348
00:19:32.610 --> 00:19:35.310
And then you use kind
of reflection, style string stuff

349
00:19:35.310 --> 00:19:37.950
to say, well, I expect
this to happen when you

350
00:19:37.950 --> 00:19:41.670
call this. So just to
make sure that we're clear,

351
00:19:41.670 --> 00:19:44.010
because this is a little
confusing because everything starts with

352
00:19:44.010 --> 00:19:47.340
an right. So this is
actually mock objects within an

353
00:19:47.340 --> 00:19:50.190
unit. So there's an MOC,
which is a little older,

354
00:19:50.490 --> 00:19:54.060
and that has been subsumed
by end MOC two. Okay.

355
00:19:54.060 --> 00:19:55.500
So an mock two is
the one we were talking

356
00:19:55.500 --> 00:20:00.240
about before then there's rhino
mock there's type mock, which

357
00:20:00.240 --> 00:20:03.690
is the big, expensive, most
powerful one. And then there's

358
00:20:03.690 --> 00:20:06.510
some lightweight kind of mock
object stuff in end unit

359
00:20:06.510 --> 00:20:13.860
two that lets you mock
interfaces, very cleanly. And it's

360
00:20:13.890 --> 00:20:15.960
already built into the end
unit that you're already using.

361
00:20:15.960 --> 00:20:18.330
So you already go and
say using end unit dot

362
00:20:18.330 --> 00:20:20.220
framework here, you just go
and say, using any unit

363
00:20:20.220 --> 00:20:23.810
dot marks, you can go
and say, I expect exceptions.

364
00:20:24.050 --> 00:20:26.150
So you can say, when
this MOC gets called on

365
00:20:26.150 --> 00:20:29.390
this function, throw a new
exception that ties in nicely

366
00:20:29.390 --> 00:20:32.660
with the expected exception attributes
that are built into a

367
00:20:32.990 --> 00:20:39.350
10 unit. So you don't
have to pick one and

368
00:20:39.350 --> 00:20:41.420
just go with that. You
can pick the one that

369
00:20:41.420 --> 00:20:44.420
feels the most natural. Sometimes
you'll use rhino mock for

370
00:20:44.420 --> 00:20:46.400
your, for most of your
mocking. And then you'll pull

371
00:20:46.400 --> 00:20:49.300
out a type mock for,
you know, for the, for

372
00:20:49.300 --> 00:20:52.380
the big guns for doing
the really complicated stuff. Scott,

373
00:20:52.380 --> 00:20:56.010
what about Microsoft visual studio
team system? Is there anything

374
00:20:56.010 --> 00:20:58.980
in team system for doing
mock objects? Well, there's a

375
00:20:58.980 --> 00:21:01.260
lot, It's a unit testing,
you know, in team system,

376
00:21:01.260 --> 00:21:03.420
but there doesn't appear to
be anything that explicitly calls

377
00:21:03.420 --> 00:21:05.610
out mock objects. Okay. So
they're not going to do

378
00:21:05.610 --> 00:21:08.070
it for you and you
can certainly use mocks within

379
00:21:08.070 --> 00:21:09.780
team system. Sure. One of
the courses you can use

380
00:21:09.780 --> 00:21:12.690
any of these tools because
it's visual studio, Right. But

381
00:21:12.690 --> 00:21:17.820
team's system doesn't include a,
their own view of mock

382
00:21:17.820 --> 00:21:20.310
objects. Okay. Probably a good
thing. Cause there's a lot

383
00:21:20.310 --> 00:21:22.740
of people who've already put
thought into that and I

384
00:21:22.740 --> 00:21:25.110
don't think we need another
thing invented. I meant it

385
00:21:25.110 --> 00:21:27.420
over again. All right, Scott,
you were telling me about

386
00:21:27.420 --> 00:21:30.870
an article you read from
IBM about, about MOC objects,

387
00:21:32.130 --> 00:21:34.080
A little bit of an
older article, but I thought

388
00:21:34.080 --> 00:21:37.380
it was useful. It was,
it shrinks or slash <inaudible>

389
00:21:37.710 --> 00:21:40.470
talks about, you know, just
kind of the concepts behind

390
00:21:40.470 --> 00:21:42.870
mock objects. It speaks a
little bit of a Java

391
00:21:42.870 --> 00:21:45.870
speak, but it explains the
idea of, you know, the

392
00:21:45.870 --> 00:21:49.440
mock object being that, that,
that middleman, that opportunity to

393
00:21:49.440 --> 00:21:52.680
do the interception and, and
some of the, the theory

394
00:21:52.680 --> 00:21:54.930
behind that when you would
make the decisions to mock

395
00:21:54.930 --> 00:21:58.440
something and when you wouldn't.
Okay. That's a good question.

396
00:21:58.440 --> 00:22:01.020
When would you, I mean,
you know, we've given a

397
00:22:01.020 --> 00:22:04.050
lot of information about MOC
objects and about tools, but

398
00:22:04.710 --> 00:22:06.750
when do you need mock
objects? What are the, what

399
00:22:06.750 --> 00:22:10.260
are your criteria for saying,
you know, this would be

400
00:22:10.590 --> 00:22:13.920
markable. So That's a very,
it's a very, very good

401
00:22:13.920 --> 00:22:16.920
question. So I'll give you
a couple of concrete, examples

402
00:22:16.920 --> 00:22:18.660
of times when I've, you
know, I've needed to use

403
00:22:18.660 --> 00:22:21.570
it. Like recently I was
working on a, an article

404
00:22:21.570 --> 00:22:24.690
for coding for fun, and
I was using a barcode

405
00:22:24.690 --> 00:22:28.050
scanner and, you know, I
had these unit tests that

406
00:22:28.050 --> 00:22:31.770
needed that raw data. And
I had an eye bar

407
00:22:31.770 --> 00:22:34.050
code scanner interface, and I
was going back and forth

408
00:22:34.050 --> 00:22:36.450
and I kept having to
pause things and then do

409
00:22:36.450 --> 00:22:40.050
manual scanning. So here was
an example of some external

410
00:22:40.050 --> 00:22:43.080
thing in this case, a
barcode and I really needed

411
00:22:43.080 --> 00:22:46.680
to, to capture its data.
Now I could have just,

412
00:22:46.860 --> 00:22:49.920
you know, captured its data
and pasted it directly into

413
00:22:49.920 --> 00:22:54.690
the test and bypass the
exercising of its of its

414
00:22:54.690 --> 00:22:56.970
interface. But because I'd gone
to the effort to abstract

415
00:22:56.970 --> 00:22:59.670
the way that, that bit
of hardware, it was useful

416
00:22:59.670 --> 00:23:03.480
to go and make a
mock barcode scanner that would

417
00:23:03.480 --> 00:23:08.010
return kind of, you know,
TiVo data. So Something that

418
00:23:08.010 --> 00:23:11.880
has that returns non-deterministic results,
maybe it would be great.

419
00:23:12.120 --> 00:23:15.660
I kept, I kept scanning
this over and over again,

420
00:23:15.660 --> 00:23:17.730
but it was, it was
a, in this case I

421
00:23:17.730 --> 00:23:19.650
kept scanning the same three
books. And I wanted to

422
00:23:19.800 --> 00:23:22.950
take a look at not
just the, the interaction between

423
00:23:23.400 --> 00:23:25.950
my test and the barcode
scanner, but to make sure

424
00:23:25.950 --> 00:23:28.230
that I wasn't corrupting some
internal data structures as I

425
00:23:28.230 --> 00:23:31.350
went and scan those books.
So I kept scanning these

426
00:23:31.350 --> 00:23:33.180
books manually and I was
like, Oh, this is ridiculous.

427
00:23:33.180 --> 00:23:36.600
I'll just go and use
an ordered rhino mock and

428
00:23:36.600 --> 00:23:38.970
say that this is what
I'm expecting to get back

429
00:23:39.330 --> 00:23:41.700
the next three times that
I do the scanning. You

430
00:23:41.700 --> 00:23:44.670
know, that was an example
where I really should've thought

431
00:23:44.670 --> 00:23:47.720
about mock right off the
bat, because like you had

432
00:23:47.720 --> 00:23:50.840
mentioned the very, the very
beginning of us talking, knowing

433
00:23:50.840 --> 00:23:52.700
about mock objects ahead of
time can allow you to

434
00:23:52.700 --> 00:23:57.620
actually design with mocks in
mind. Right. And make the

435
00:23:57.620 --> 00:23:59.840
interface that you're gonna end
up using a lot cleaner.

436
00:24:00.530 --> 00:24:02.750
Yeah. I think also another
good example would be to

437
00:24:02.780 --> 00:24:05.600
anytime you've got a, a
web service that provides data

438
00:24:06.530 --> 00:24:08.960
or any kind of data
service or data access layer

439
00:24:09.320 --> 00:24:12.100
that being able to do
mocking when, when, when the,

440
00:24:12.100 --> 00:24:14.540
the testing of the data
access layer, isn't the point,

441
00:24:14.570 --> 00:24:17.690
but it's those things that
consume it, do analysis on

442
00:24:17.690 --> 00:24:19.880
it, that you're gonna be
doing the testing on the

443
00:24:19.880 --> 00:24:23.270
Scott. One other thing you
said, if you want to

444
00:24:23.270 --> 00:24:25.820
start get started with mock
objects, you know, probably download

445
00:24:26.090 --> 00:24:30.200
and mock two and download
a easy mock or rhino

446
00:24:30.200 --> 00:24:32.540
mocks. Why not, if you're
serious about this and you've

447
00:24:32.540 --> 00:24:35.600
got the money just go
right to something like type

448
00:24:35.600 --> 00:24:38.300
mock and use that all
the time. Well, you know,

449
00:24:38.480 --> 00:24:41.780
if I were a guy
working by myself, if I

450
00:24:41.780 --> 00:24:45.830
were a one man shop,
I would probably eventually end

451
00:24:45.830 --> 00:24:48.680
up buying type mock.net. You
know what I mean? It

452
00:24:48.750 --> 00:24:51.620
is the most advanced that
I've seen. It has a

453
00:24:51.620 --> 00:24:56.750
very, very nice syntax. It's
got, you know, all sorts

454
00:24:56.750 --> 00:24:59.610
of support for little bits
of fluff that only a

455
00:24:59.610 --> 00:25:03.740
Polish application has like automatic
updating and 64 bits, you

456
00:25:03.740 --> 00:25:07.070
know, and static instructors and
stuff. But, you know, for

457
00:25:07.070 --> 00:25:09.500
the most part, you're going
to get what you need

458
00:25:09.500 --> 00:25:13.010
out of an mock two
and or rhino mock. Okay.

459
00:25:13.210 --> 00:25:15.260
For some of the basic
stuff you're doing. So, you

460
00:25:15.260 --> 00:25:17.900
know, I don't know. I
don't think that I would

461
00:25:18.290 --> 00:25:20.990
standardize on an entire enterprise
when there's such a great

462
00:25:21.260 --> 00:25:24.380
open source story out there.
I see, you know, I

463
00:25:24.380 --> 00:25:26.360
mean, I, again, I don't
know the guys at type

464
00:25:26.360 --> 00:25:29.450
mocks, but I was able
to go in and start

465
00:25:29.450 --> 00:25:33.230
mocking my stuff with rhino
mocks very quickly. I mean,

466
00:25:33.230 --> 00:25:36.740
it was so obvious. And
then within an MOC, the,

467
00:25:37.430 --> 00:25:40.610
the syntax is so intuitive.
These basically you're building up

468
00:25:40.610 --> 00:25:43.250
these sentences to say, I
expect all this to go

469
00:25:43.250 --> 00:25:46.520
down the way it goes
down, you know, it's so

470
00:25:46.520 --> 00:25:49.130
it's, so it's so intuitive.
Like in the context of

471
00:25:49.130 --> 00:25:51.770
I'm doing banking, right? We
do a lot of online

472
00:25:51.770 --> 00:25:54.350
banking at my company being
able to go and say,

473
00:25:54.590 --> 00:25:57.560
I expect this value of
this, you know, this account

474
00:25:57.560 --> 00:25:59.120
to have this much money
in this account to have

475
00:25:59.120 --> 00:26:01.250
that much, I'm going to
transfer some money. And then

476
00:26:01.250 --> 00:26:04.250
now I expect these values
to be this way, and

477
00:26:04.250 --> 00:26:07.790
then to have a mocked
out the entire backend for

478
00:26:07.790 --> 00:26:10.880
our banking system to be
so easy in, in, in

479
00:26:10.880 --> 00:26:14.840
Denmark. So between mock and
rhino mock, it covers the

480
00:26:14.840 --> 00:26:18.920
80, 90% case, but it's
good to know the tight

481
00:26:18.920 --> 00:26:23.060
box out there to, to
test existing systems. Right? Sometimes

482
00:26:23.060 --> 00:26:24.710
you might have a test
that system that you can't

483
00:26:24.710 --> 00:26:28.310
design, you can't Mark this
virtual, or you can't redesign

484
00:26:28.310 --> 00:26:30.680
that. That's when you bring
in the, the intercepting stuff,

485
00:26:30.680 --> 00:26:33.140
like type model. All right.
Great. Well, that's the show,

486
00:26:33.140 --> 00:26:36.410
Scott. Thanks very much. And
I'm sure that the listeners

487
00:26:36.410 --> 00:26:40.160
appreciate your analysis of mock
objects. Thanks. And we'll talk

488
00:26:40.160 --> 00:26:41.630
to you next week on
handsome.


WEBVTT FILE

1
00:00:12.030 --> 00:00:17.460
From Hansel minutes.com. It's Hanselman.
It's a weekly discussion with

2
00:00:17.460 --> 00:00:22.200
web developer and technologist and
Scott Hanselman. This is Lawrence Ryan

3
00:00:22.260 --> 00:00:27.270
announcing. Sure. Number one 93.
He recorded live Thursday, January 7th, 2010.

4
00:00:28.440 --> 00:00:31.290
Support for Hanselman it's just
provided by teller at RB

5
00:00:31.290 --> 00:00:34.920
controls. The most comprehensive suite
of components for windows forms

6
00:00:34.920 --> 00:00:44.250
and asp.net web applications online@wwwdottelerik.com.
In this episode, Scott talks

7
00:00:44.250 --> 00:00:50.550
with Nicholas Gustafson about the
incubation project. Axel. Hi, this

8
00:00:50.550 --> 00:00:52.920
is Scott Hanselman and this
is another episode of Hansel

9
00:00:52.920 --> 00:00:55.260
minutes. And today I have
the pleasure of speaking with

10
00:00:55.290 --> 00:00:59.520
Nicholas Gustafson, a principal architect
on the parallel computing team.

11
00:00:59.520 --> 00:01:01.910
How are you, sir? Oh,
hi Scott. How are you?

12
00:01:03.420 --> 00:01:05.330
I'm pretty well. So I'm
glad that you took the

13
00:01:05.330 --> 00:01:06.800
time to sit down and
chat with me about this.

14
00:01:06.800 --> 00:01:09.770
Cause we've got an interesting
topic today. We're talking about

15
00:01:10.250 --> 00:01:14.900
ACSM formerly called Maestro, and
this is something that was

16
00:01:15.770 --> 00:01:19.190
part of a labs incubation.
This isn't a product yet,

17
00:01:19.190 --> 00:01:23.930
right? Yeah, that's correct. So,
so I think it's important

18
00:01:23.930 --> 00:01:26.990
to, to explain perhaps then
what, what incubation means at

19
00:01:26.990 --> 00:01:31.970
Microsoft there, oftentimes when, you
know, based on just market

20
00:01:31.970 --> 00:01:35.660
research and, and understanding our
customers, you know, through decades

21
00:01:35.660 --> 00:01:39.410
of, of having relationships with
developers, we just sort of

22
00:01:39.620 --> 00:01:42.200
understand exactly what's what the
right thing to do in

23
00:01:42.200 --> 00:01:45.860
a, in a product, in
a product cycle. But often

24
00:01:46.160 --> 00:01:49.130
it's also the case that
we, and particularly for perhaps

25
00:01:49.130 --> 00:01:54.260
more advanced quote unquote advanced
projects or, or things that

26
00:01:54.260 --> 00:01:59.450
we may have some doubts
about. It's not always clear

27
00:01:59.450 --> 00:02:01.550
exactly what it is that
we need to put to

28
00:02:01.550 --> 00:02:05.690
produce. And this is where
incubation or whether even things

29
00:02:05.690 --> 00:02:08.510
are feasible to do. And
this is where incubation fits

30
00:02:08.510 --> 00:02:11.180
in. It's not research in
the sense of trying to

31
00:02:11.180 --> 00:02:14.660
advance the state of what
is known if you will,

32
00:02:14.660 --> 00:02:17.930
but it's really trying to
advance with how things are

33
00:02:17.930 --> 00:02:21.710
applied and what technologies that
are already established are feasible

34
00:02:21.710 --> 00:02:25.310
to produce as Microsoft products.
And this is where Axiom

35
00:02:25.310 --> 00:02:27.830
comes in. Also, it's a,
it's an incubation project at

36
00:02:27.830 --> 00:02:32.300
Microsoft within the developer division.
So did, did it come

37
00:02:32.300 --> 00:02:36.440
from research? I mean, what
is the process from someone

38
00:02:36.440 --> 00:02:40.340
has a thought to someone
in Microsoft research has a

39
00:02:40.340 --> 00:02:44.030
thought versus someone spins up
an incubation project within the

40
00:02:44.030 --> 00:02:47.810
development division itself. Yeah. So
I would say that it's

41
00:02:47.810 --> 00:02:51.080
inspired by research, but not
just by research within Microsoft

42
00:02:51.080 --> 00:02:53.990
and not just by research
either. It's also inspired by

43
00:02:53.990 --> 00:02:58.190
other other products that are,
that are out there. You

44
00:02:58.190 --> 00:03:00.640
start with a problem that
you see not being solved

45
00:03:00.640 --> 00:03:06.700
adequately and in, in current
products and a customer need.

46
00:03:08.560 --> 00:03:12.400
And, and that customer meeting,
they need may not be

47
00:03:13.060 --> 00:03:15.730
so immediate that you can
find it, or it's sort

48
00:03:15.730 --> 00:03:19.510
of evaluated through just through
sort of a market analysis

49
00:03:19.520 --> 00:03:22.570
or research. From that perspective,
you have to sort of

50
00:03:22.570 --> 00:03:27.310
develop a technology prototype and
you have to, you have

51
00:03:27.310 --> 00:03:30.460
to try it with customers.
And this is sort of

52
00:03:30.460 --> 00:03:32.770
the approach we took with
ax and we it's inspired

53
00:03:32.770 --> 00:03:37.300
by what's commonly referred to
as actor based or actor

54
00:03:37.300 --> 00:03:43.390
oriented programming. It's also called
agent oriented programming. And the

55
00:03:43.390 --> 00:03:49.000
idea there is that instead
of relying on shared memory

56
00:03:49.030 --> 00:03:53.230
access to shared memory or
shared state and coordinating that

57
00:03:53.230 --> 00:03:58.510
access through locks and other
forms of synchronization primitives, you

58
00:03:58.990 --> 00:04:04.090
isolate state within agents and
you use message passing between

59
00:04:04.090 --> 00:04:08.980
the agents to, to synchronize
and exchange information. But each

60
00:04:09.010 --> 00:04:11.920
piece of data is at
any given point in time

61
00:04:11.920 --> 00:04:16.390
in the program owned by
only one single threaded entity.

62
00:04:18.220 --> 00:04:22.870
And there are, there are
other languages that do exactly

63
00:04:22.870 --> 00:04:26.330
this Earline is an example
of a functional, you know,

64
00:04:26.380 --> 00:04:31.630
pure functional language that, that
takes this approach. There are

65
00:04:31.840 --> 00:04:37.150
elements of actor oriented programming
in, in languages like Scala

66
00:04:37.210 --> 00:04:41.080
and F sharp, but accent
really tries to take it

67
00:04:41.110 --> 00:04:46.480
one step further and really
be pretty rigid about the

68
00:04:46.480 --> 00:04:49.810
isolation of forcement, neither scholar,
nor F sharp alien forces,

69
00:04:50.590 --> 00:04:53.410
the isolation it's just sort
of suggests that it's a

70
00:04:53.410 --> 00:04:57.130
good thing. They take the
pattern, but don't quite enforce

71
00:04:57.130 --> 00:04:59.500
all the constraints that are
necessary to make the pattern

72
00:04:59.830 --> 00:05:04.360
completely, completely safe. So one
of the questions for us,

73
00:05:04.810 --> 00:05:07.180
and this is why, you
know, you want to test

74
00:05:07.180 --> 00:05:11.920
this is, you know, how,
how critical is that enforcement?

75
00:05:11.920 --> 00:05:14.710
How critical is it to
go beyond what you can

76
00:05:14.710 --> 00:05:20.650
just do in libraries and
really implement this model, this

77
00:05:20.650 --> 00:05:24.690
pattern in a language? Well,
that was my, that was

78
00:05:24.690 --> 00:05:27.300
my next question is that,
you know, F sharp and

79
00:05:27.300 --> 00:05:32.080
functional languages make the decision
to be functional. They, they,

80
00:05:32.740 --> 00:05:35.460
they, they exist to be
functional and you get the

81
00:05:35.460 --> 00:05:39.330
benefits of being functional with
a, you know, not having

82
00:05:39.330 --> 00:05:42.450
shared state, but they don't
necessarily exist to be parallel.

83
00:05:43.020 --> 00:05:45.600
Or are you saying that
that ACSM, you know, puts

84
00:05:45.600 --> 00:05:48.030
a stake in the ground
and says we exist for

85
00:05:48.030 --> 00:05:50.430
the purpose of being parallel
rather than just to be

86
00:05:50.430 --> 00:05:55.320
functional? Yes. And, and, and
those are, those are not

87
00:05:55.410 --> 00:06:01.340
necessarily coupled to each other,
a functional programming language need

88
00:06:01.340 --> 00:06:05.540
not be a need not
be parallel or Lang as

89
00:06:05.540 --> 00:06:08.090
an example of a, of
a functional language that is

90
00:06:08.090 --> 00:06:12.200
designed to be parallel as
well as functional ACSM is

91
00:06:12.200 --> 00:06:16.370
not, it's not a functional
language. It has more to

92
00:06:16.370 --> 00:06:18.290
do. It has more in
common with C sharp, and

93
00:06:18.290 --> 00:06:21.740
it does with F sharp.
And one thing to keep

94
00:06:21.740 --> 00:06:25.190
in mind about F sharp
and Scalise is that there

95
00:06:25.820 --> 00:06:30.530
they're both functional languages and
object oriented languages. So there's

96
00:06:30.530 --> 00:06:36.530
sort of a, a mix
of the two and, and,

97
00:06:36.650 --> 00:06:40.220
you know, any object oriented
language will be dependent on,

98
00:06:40.340 --> 00:06:44.630
on shared state and shared
memory. Now, what we're trying

99
00:06:44.630 --> 00:06:46.820
to do with Axiom is
to take an object oriented

100
00:06:47.540 --> 00:06:51.140
context rather than a functional
context, and provide some isolation

101
00:06:51.140 --> 00:06:55.790
around a state with an
actor model actor onto the

102
00:06:55.790 --> 00:07:00.590
Mount model. That's, that's sitting
on top of a object

103
00:07:00.590 --> 00:07:03.170
oriented environment rather than what
Erlynne does is to do

104
00:07:03.170 --> 00:07:07.510
it on top of the
functional. Now, why wouldn't you

105
00:07:07.510 --> 00:07:12.070
take an existing, an existing
language like Erlang or Scala

106
00:07:12.070 --> 00:07:14.470
and make a dotnet version
of that? Why create a

107
00:07:14.470 --> 00:07:19.750
new syntax? Well, let's talk
about Erlang this co Scott.

108
00:07:19.770 --> 00:07:21.520
I think that this really
is, I mean, the F

109
00:07:21.520 --> 00:07:25.430
sharp is, is to.net. What's
Scalise to the, to the

110
00:07:25.450 --> 00:07:29.140
Java virtual machine. But if
you look at, if you

111
00:07:29.140 --> 00:07:32.650
look at Erline, it's a
pure functional language, it's not,

112
00:07:32.830 --> 00:07:37.810
it wouldn't be very straightforward
to take a language like

113
00:07:37.810 --> 00:07:43.390
that and put it on.net
without giving up a lot

114
00:07:43.390 --> 00:07:49.690
of what.net offers. So, for
example, most of the dotnet

115
00:07:49.690 --> 00:07:54.760
class libraries are built on
the assumption that you're really

116
00:07:54.760 --> 00:07:58.630
going to be using them
from an object oriented language.

117
00:07:58.930 --> 00:08:03.700
They're really very, you know,
quite stateful class libraries. They

118
00:08:03.700 --> 00:08:07.750
are, they really operate on
the idea that you're, that

119
00:08:07.750 --> 00:08:13.960
you're manipulating and modifying objects,
and so built to build

120
00:08:13.960 --> 00:08:16.450
something like our language, which
has a data model that

121
00:08:16.450 --> 00:08:20.920
is first of all, completed
dynamically typed and is built

122
00:08:20.920 --> 00:08:23.950
on the further built on
the idea that Allstate is

123
00:08:23.980 --> 00:08:28.780
immutable or data is immutable,
and that you mutate by

124
00:08:29.260 --> 00:08:33.370
or mutate the state by
building new copies of the

125
00:08:33.370 --> 00:08:37.180
data that rather than changing
that you create new coffees.

126
00:08:37.600 --> 00:08:39.460
So it's a completely different
model. You wouldn't be able

127
00:08:39.460 --> 00:08:42.040
to leverage a lot of
dots with.net has to offer

128
00:08:42.040 --> 00:08:44.950
in terms of a built
in types and class libraries.

129
00:08:44.980 --> 00:08:46.660
If you try to build
our line on top of

130
00:08:46.660 --> 00:08:49.270
it. So what Axiom is,
is trying to accomplish is

131
00:08:49.270 --> 00:08:52.900
to build a model that
works well with.net and leveraged

132
00:08:52.900 --> 00:08:54.850
has all of that net
and where you, in your

133
00:08:55.220 --> 00:08:57.390
program, you have access to
all of that math and

134
00:08:57.390 --> 00:09:02.160
can use it productively, but
add some form of some

135
00:09:02.220 --> 00:09:04.350
measure of isolation on top
of that as a, some

136
00:09:04.350 --> 00:09:07.160
measure of safety on top
of that, And this was

137
00:09:07.160 --> 00:09:10.010
something that needed to be
another language, as opposed to

138
00:09:10.010 --> 00:09:13.340
being some kind of extension,
or like the way that,

139
00:09:13.730 --> 00:09:17.600
you know, you could, you
could have, could you not

140
00:09:17.600 --> 00:09:21.320
have created some, you know,
basically spot welded something onto

141
00:09:21.320 --> 00:09:25.580
C-sharp itself? Well, we could.
And absolutely. And this is

142
00:09:25.580 --> 00:09:27.710
one of the questions, you
know, when you go from

143
00:09:27.710 --> 00:09:30.860
incubation to product to station,
what is the right strategy

144
00:09:30.860 --> 00:09:35.120
to take there? What we,
what we wanted to do

145
00:09:35.120 --> 00:09:39.770
was we wanted to have
some, we want to have

146
00:09:39.770 --> 00:09:42.680
more degrees of freedom if
you will, in our experimentation.

147
00:09:42.680 --> 00:09:45.260
That's what incubation is about
after all this experimentation and

148
00:09:45.260 --> 00:09:49.070
finding the right solution without
being in the artist stages

149
00:09:49.070 --> 00:09:53.990
of, of your development being
too strictly tied to some

150
00:09:53.990 --> 00:09:57.740
existing set of constraints that
may not really have to

151
00:09:57.740 --> 00:10:00.740
anything to do with the
problem that you're trying to,

152
00:10:01.400 --> 00:10:06.080
to experiment with. So doing
it as a, as a

153
00:10:06.080 --> 00:10:10.700
separate language gives you a
lot more freedom to, to

154
00:10:10.700 --> 00:10:15.080
experiment That that is actually
a very good explanation. That

155
00:10:15.080 --> 00:10:17.120
makes a lot of sense.
Cause I think that sometimes

156
00:10:17.120 --> 00:10:19.700
people look at these things
from outside and they just

157
00:10:19.700 --> 00:10:22.550
go, what is going on
inside of Microsoft? They're inventing

158
00:10:22.550 --> 00:10:25.130
new languages. There's, you know,
there's, these problems are solved,

159
00:10:25.160 --> 00:10:28.820
but you're right from a,
from a skunkworks perspective, it's

160
00:10:28.820 --> 00:10:32.180
much more freeing for you
to explore the space with

161
00:10:32.180 --> 00:10:35.870
a fresh language and a
separate compiler than it would

162
00:10:35.870 --> 00:10:38.690
be to try to shoehorn
an existing thing on top

163
00:10:38.690 --> 00:10:42.980
of the, the CLR That's
that's right. And so, so,

164
00:10:42.980 --> 00:10:47.390
so that's, that's the primary
reason for doing an essay

165
00:10:47.390 --> 00:10:50.570
separate language during the incubation
phase. Now that leads to

166
00:10:50.570 --> 00:10:53.510
the question of what, how
would you really productize something

167
00:10:53.510 --> 00:10:56.870
like this and, and what
would it look like? And

168
00:10:56.870 --> 00:11:00.470
those are questions that were,
you know, there, we're thinking

169
00:11:00.470 --> 00:11:03.740
about, you know, right now,
and is in a, you

170
00:11:03.740 --> 00:11:07.010
know, as a next step
and, and whether it's all

171
00:11:07.010 --> 00:11:09.470
of it that makes it
into, you could wind up

172
00:11:09.470 --> 00:11:12.740
with a solution where you
certain aspects of a language

173
00:11:12.740 --> 00:11:16.700
like this, make it into
certain, you know, into some

174
00:11:16.700 --> 00:11:18.950
languages and other aspects of
it, make it into other

175
00:11:18.950 --> 00:11:24.500
languages. It's all sort of
unclear at this point, what

176
00:11:24.500 --> 00:11:26.930
the right solution is. And
it may actually be that

177
00:11:26.930 --> 00:11:28.640
the right solution is to
have what I call a

178
00:11:28.640 --> 00:11:32.180
special purpose language, which is
what we sort of build

179
00:11:32.180 --> 00:11:36.290
acts mass one, where you
would expect users to write

180
00:11:36.290 --> 00:11:39.680
only pieces of your application
in that special purpose language.

181
00:11:40.190 --> 00:11:43.340
And then most of the
majority of your, your application

182
00:11:43.340 --> 00:11:45.890
would probably be written in
a general purpose language, such

183
00:11:45.890 --> 00:11:49.490
as C sharp or visual
basic doesn't that that's something

184
00:11:49.490 --> 00:11:52.610
we're struggling with right now,
but, but it's not part

185
00:11:52.610 --> 00:11:57.220
of the problem domain, if
you will. What is the,

186
00:11:58.060 --> 00:12:01.770
the contract between you and
the people who are involved

187
00:12:01.770 --> 00:12:04.020
in an incubation? If someone
decides to build their business

188
00:12:04.020 --> 00:12:06.990
around an incubation project, is,
are they sound like they're

189
00:12:06.990 --> 00:12:09.210
taking a pretty big chance?
Is that pretty clear up

190
00:12:09.210 --> 00:12:11.610
front and be like, what
is your obligation to them

191
00:12:11.670 --> 00:12:16.470
to support this thing that
is not supported? So one

192
00:12:16.470 --> 00:12:20.880
of the obligations is to
be very upfront about what

193
00:12:20.880 --> 00:12:24.540
our commitments are to a
project like this and, and

194
00:12:26.010 --> 00:12:29.430
being very honest and direct
about what we mean by

195
00:12:29.430 --> 00:12:33.990
incubation and, and the fact
that this is something that

196
00:12:33.990 --> 00:12:40.440
is intended to inspire thoughts,
and I inspire ideas and

197
00:12:40.440 --> 00:12:43.560
inspire you as a, as
a user of it. Or

198
00:12:43.560 --> 00:12:47.850
some somebody picks it up
and experiments with it to

199
00:12:47.880 --> 00:12:51.780
rethink maybe how you're doing,
how you're looking at problems

200
00:12:51.780 --> 00:12:57.960
and, and maybe just expand
your, the way that you

201
00:12:57.960 --> 00:13:02.460
look at the future of,
of parallel programming. It's not,

202
00:13:02.490 --> 00:13:05.580
and we've, you know, been
very clear about this throughout,

203
00:13:05.580 --> 00:13:08.550
and I want to reiterate
it now, we're not committing

204
00:13:08.550 --> 00:13:13.530
to shipping this in this
form at all. We're hoping

205
00:13:13.530 --> 00:13:16.800
to, but we're not saying
to anybody that this is

206
00:13:16.800 --> 00:13:20.790
a, this is a for
sure thing. So, you know,

207
00:13:20.790 --> 00:13:23.550
we certainly don't recommend anybody
to build a business around

208
00:13:23.550 --> 00:13:27.800
it that would be taking
a huge risk. But what

209
00:13:27.800 --> 00:13:32.250
we do encourage anybody to
do is to get it

210
00:13:32.250 --> 00:13:34.980
out of the dev labs,
try it out and, and

211
00:13:35.400 --> 00:13:39.840
contribute thinking to this problem.
And if it's this, the

212
00:13:39.840 --> 00:13:42.360
right solution, are there things
missing? Is there too much

213
00:13:42.360 --> 00:13:45.990
in it? One of our
concerns is that Axiom is

214
00:13:46.170 --> 00:13:50.970
a lot bigger than perhaps
is it feasible to try

215
00:13:50.970 --> 00:13:56.010
to try to introduce in,
in, in.net right now, or

216
00:13:56.010 --> 00:13:58.050
in the, in, in sort
of the, the market right

217
00:13:58.050 --> 00:14:03.050
now, what is the minimalist
approach to this problem? What,

218
00:14:03.050 --> 00:14:05.760
what can we yank out
of accent method is defined

219
00:14:05.760 --> 00:14:10.680
right now and wind up
with something that is mostly

220
00:14:10.680 --> 00:14:14.940
as powerful as, as what
we've defined. Do you know

221
00:14:14.940 --> 00:14:17.670
how to make the possible
out of the impossible? Well,

222
00:14:17.670 --> 00:14:20.370
the dotnet ninjas at Telerik
do they just released a

223
00:14:20.370 --> 00:14:22.680
huge pack of web controls,
all built on top of

224
00:14:22.680 --> 00:14:26.490
ESPN at Ajax, that'll help
you build impossibly fast and

225
00:14:26.490 --> 00:14:29.580
interactive applications in no time
at all. They've made the

226
00:14:29.580 --> 00:14:33.690
impossible possible and desktop development.
If you think you can't

227
00:14:33.690 --> 00:14:36.330
have a carousel component and
wind forms, well, you can.

228
00:14:36.660 --> 00:14:39.630
They're windows forms, suite features
a super powerful grid, view

229
00:14:39.630 --> 00:14:42.480
control, and 32 other crazy
desktop components. That'll give you

230
00:14:42.480 --> 00:14:47.190
a dazzling WPF like features,
but in wind farms, they

231
00:14:47.190 --> 00:14:49.020
do the same thing in
reporting solutions with a new

232
00:14:49.020 --> 00:14:51.800
design service, like nothing else
looks just like graph paper

233
00:14:52.160 --> 00:14:55.730
gives you advanced page layout
capabilities. It makes it feel

234
00:14:55.730 --> 00:14:58.250
more like a graphic design
software than a reporting solution.

235
00:14:58.670 --> 00:15:05.390
Go check them out@telerikdotcomandbeat.net Ninja.
Thanks for listening. Now, I

236
00:15:05.390 --> 00:15:08.000
know that everyone is thinking
about parallelism at Microsoft right

237
00:15:08.000 --> 00:15:12.830
now, and I've talked to
various folks about how to

238
00:15:12.830 --> 00:15:17.180
make parallel accessible parallelism accessible
to the masses. And I

239
00:15:17.180 --> 00:15:20.900
just literally last night put
together a very inexpensive machine

240
00:15:20.900 --> 00:15:23.300
with a friend of mine
that had eight cores. I

241
00:15:23.300 --> 00:15:25.580
feel like, you know, we're
going to blink and there's

242
00:15:25.580 --> 00:15:27.680
going to be 16 cores
on the desktop, you know,

243
00:15:27.680 --> 00:15:32.750
within, within a year, this
is part of that larger

244
00:15:32.750 --> 00:15:37.450
kind of push towards making
parallelism accessible to people. Yeah.

245
00:15:37.480 --> 00:15:40.420
So, so I think, I
think that's absolutely right. What,

246
00:15:40.990 --> 00:15:45.720
one of the major problems
with the tools and the

247
00:15:45.730 --> 00:15:49.240
PR and what we have
platforms that we have available

248
00:15:49.240 --> 00:15:53.980
today is that they were
built for, for concurrency, where

249
00:15:54.130 --> 00:16:01.690
you have limited needs to,
to run things in parallel.

250
00:16:01.690 --> 00:16:06.200
And they're typically driven by,
you know, either the need

251
00:16:06.640 --> 00:16:08.860
when you had it. It
was either because you were

252
00:16:08.860 --> 00:16:11.650
trying to unblock a gooey
spread for example, or you

253
00:16:11.650 --> 00:16:14.650
were trying to leverage latency
in terms of, you know,

254
00:16:15.010 --> 00:16:17.170
while you were doing this
guy or a network, I

255
00:16:17.200 --> 00:16:21.280
were doing other things so
that the overall application responsiveness

256
00:16:21.280 --> 00:16:25.660
would be higher with all
this, all this power, while

257
00:16:25.660 --> 00:16:27.640
you have eight course, you
know, I have an eight

258
00:16:27.640 --> 00:16:32.980
core box at home and,
you know, of course, 99%

259
00:16:32.980 --> 00:16:36.310
of the time it's, it's,
you know, completely idle. And

260
00:16:36.760 --> 00:16:40.060
a little bit of the
time it runs maybe, you

261
00:16:40.060 --> 00:16:43.180
know, five or 10% of
its of its capacity. And

262
00:16:43.180 --> 00:16:46.690
very rarely does it actually
use all of its capacity

263
00:16:46.690 --> 00:16:51.460
because there's applications just aren't
written for it. And now

264
00:16:51.460 --> 00:16:54.430
we have all this capacity
capacity. We can use it

265
00:16:55.060 --> 00:16:57.820
for parallelism, where you're actually
trying to take an algorithm

266
00:16:58.300 --> 00:17:01.930
and run even just the
computation, not just overlapping it

267
00:17:01.930 --> 00:17:08.410
with IO, but run the
computation computations inside the application

268
00:17:08.410 --> 00:17:13.780
in parallel and speed up
how quickly computations finish that

269
00:17:14.020 --> 00:17:19.060
will give us just completely
new opportunities for new, new

270
00:17:19.180 --> 00:17:23.350
user experiences and new quicker,
more in depth analysis of

271
00:17:23.350 --> 00:17:26.380
data and so on and
so forth. But it's hard.

272
00:17:26.380 --> 00:17:30.490
It's hard because we have,
haven't built it for that

273
00:17:30.490 --> 00:17:33.130
type of, we haven't built
the platforms for that type

274
00:17:33.130 --> 00:17:38.440
of, of usage by, by
sort of the developer masses.

275
00:17:38.440 --> 00:17:43.360
And even for the very
advanced developers, it's tricky accessing

276
00:17:44.200 --> 00:17:46.390
memory cells, if you will.
I mean, the kind of

277
00:17:46.390 --> 00:17:48.460
model we have is that
you have memory cells and

278
00:17:48.460 --> 00:17:51.060
you have threads and the
threads are accessing the memory

279
00:17:51.060 --> 00:17:55.740
cells, incompletely without any coordination
and all, any coordination by

280
00:17:55.740 --> 00:17:58.920
the system that is, and
all the coordination is responsibility

281
00:17:58.920 --> 00:18:00.900
is put on the programmer.
And so we have a

282
00:18:00.900 --> 00:18:05.460
model that's extremely random, if
you will, non-deterministic and its

283
00:18:05.460 --> 00:18:09.750
execution behavior. And we're asking
developers to reign in that

284
00:18:09.750 --> 00:18:13.370
non determinism Right now, this
is really interesting. I think

285
00:18:13.430 --> 00:18:16.460
that you kind of, there's
almost a throwaway statement in

286
00:18:16.460 --> 00:18:19.100
there, but I think that
really, for me crystallizes the

287
00:18:19.100 --> 00:18:21.950
whole idea that we're at
we're, we're running around and

288
00:18:21.950 --> 00:18:27.170
we're accessing memory in a,
in a fairly ad hoc

289
00:18:27.170 --> 00:18:30.800
way. And the responsibility is
on the programmer on how

290
00:18:30.800 --> 00:18:33.920
to manage these shared resources.
And there's a really great

291
00:18:34.550 --> 00:18:37.760
blog posts up on the
MSDN at the, the older

292
00:18:37.850 --> 00:18:41.840
site called Maestro team back
when action was called my

293
00:18:41.840 --> 00:18:44.630
show that has some visualizations
that really explain that. So

294
00:18:44.630 --> 00:18:46.580
maybe we can change gears
a little bit and talk

295
00:18:46.580 --> 00:18:49.280
about this because this really
crystallized it for me. Like

296
00:18:49.730 --> 00:18:51.350
we've been talking for a
while here and there may

297
00:18:51.350 --> 00:18:53.150
be some folks that have
felt we've geeked out a

298
00:18:53.150 --> 00:18:55.550
little too much and forgotten
to talk about like, what

299
00:18:55.550 --> 00:18:58.550
exactly is this thing? And
you give an example of

300
00:18:58.880 --> 00:19:03.050
a multithreaded application where we're
gonna run through a list

301
00:19:03.050 --> 00:19:07.370
of items that are in
some shared state and sort

302
00:19:07.370 --> 00:19:10.120
them and put them back
together. So it's, it's a

303
00:19:10.220 --> 00:19:14.600
very contentious application and there's
this wonderful visualization that shows

304
00:19:15.410 --> 00:19:18.770
how much waiting for locks
is going on. You've got

305
00:19:18.770 --> 00:19:23.720
all this parallelism and the
worker threads, the parts of

306
00:19:23.720 --> 00:19:26.750
the application that are doing
the work. They go work,

307
00:19:26.750 --> 00:19:28.820
work, work, all right, I'm
done. Now, I'm going to

308
00:19:28.820 --> 00:19:32.120
get in line to tell
you about the work. And

309
00:19:32.120 --> 00:19:33.830
then they wait for a
while and then they work,

310
00:19:33.830 --> 00:19:35.720
work, work, and then they
get in line to tell

311
00:19:35.720 --> 00:19:40.340
you about the work. But
then when you introduce a,

312
00:19:41.330 --> 00:19:44.840
a message passing algorithm, you've
got one thread that's doing

313
00:19:44.840 --> 00:19:47.270
the updating of the data
structure while the worker threads

314
00:19:47.300 --> 00:19:50.600
actually work. And it really
got me thinking that I

315
00:19:50.600 --> 00:19:53.210
think most of my worker
threads aren't working at all

316
00:19:54.560 --> 00:19:59.480
Right. And that's correct. I
mean, you're, you're spending so

317
00:19:59.480 --> 00:20:05.030
much time synchronizing and, and
worrying. And to some degree

318
00:20:05.030 --> 00:20:09.350
it's a performance issue, right?
To some degree it's a

319
00:20:09.740 --> 00:20:14.450
productivity issue because the amount
of time you spend debugging

320
00:20:14.450 --> 00:20:20.060
your ad hoc methodology for
synchronization is, is tremendous. I

321
00:20:20.060 --> 00:20:23.030
mean, we have, we have
lots of data that supports

322
00:20:23.060 --> 00:20:27.500
this, that, that developing concurrent
applications is many times less

323
00:20:27.680 --> 00:20:32.510
productive than developing a sequential
application because of the ad

324
00:20:32.510 --> 00:20:35.900
hoc methodologies that are available
now. So what Axiom is

325
00:20:35.900 --> 00:20:38.480
trying to do there, so
it's, it's trying to put

326
00:20:38.480 --> 00:20:41.690
some constraints on this, and
this is another reason why

327
00:20:41.690 --> 00:20:46.430
languages are necessary because frameworks
are good at enabling not

328
00:20:46.430 --> 00:20:48.910
constraining. And what you really
need to do here is

329
00:20:48.910 --> 00:20:52.300
you need to constrain the
patterns that people can use

330
00:20:53.080 --> 00:20:57.120
for powerless, Right? So you're
setting them up for success

331
00:20:57.810 --> 00:21:00.840
in parallelism, by following the
rules in the framework that

332
00:21:00.840 --> 00:21:03.930
you've laid out, parallelism will
just happen. That's correct. And

333
00:21:03.930 --> 00:21:07.080
you won't even think about
it. So the idea is

334
00:21:07.080 --> 00:21:09.870
correct by construction. In other
words, that if you write

335
00:21:09.870 --> 00:21:13.770
your parallel application in Axiom,
it will enforce a pattern

336
00:21:13.770 --> 00:21:18.360
for your application that is
safe, inherently safe from data

337
00:21:18.360 --> 00:21:23.610
racist. That is these, the,
the accidental reordering of access

338
00:21:23.610 --> 00:21:28.440
to, to, to memory cells.
There are other hazards in

339
00:21:28.440 --> 00:21:32.820
parallel programming, like deadlocks that
ask them does not necessarily

340
00:21:32.820 --> 00:21:35.760
deal with, Well, that's an
interesting question then what, what

341
00:21:35.760 --> 00:21:39.660
doesn't Axiom deal with? Well,
So, so deadlocks is the,

342
00:21:39.660 --> 00:21:45.660
it's the primary one. Now
deadlocks, fortunately, is among the

343
00:21:45.990 --> 00:21:50.610
problems that are hard to
debug in, in parallel programming

344
00:21:50.790 --> 00:21:54.330
data. Racist is by far
the, the, you know, the

345
00:21:54.330 --> 00:21:58.830
most common first and then
also extremely hard given the

346
00:21:58.830 --> 00:22:02.610
tools that we have today.
Deadlocks are fortunately, I mean,

347
00:22:02.640 --> 00:22:07.110
sometimes they are quite intricate,
but you usually hang and

348
00:22:07.110 --> 00:22:09.960
you know that you have
it, there's this, the signs

349
00:22:09.960 --> 00:22:11.940
are, are there for you.
You, you know that you

350
00:22:11.940 --> 00:22:14.400
have it, they erase, this
can be extremely hard to

351
00:22:14.400 --> 00:22:21.540
detect because they're the side
effects of databases are sometimes

352
00:22:21.540 --> 00:22:26.100
benign and sometimes not. And
it's, they're very intermittent deadlocks.

353
00:22:26.310 --> 00:22:29.040
You're you just break into
the program with a debugger

354
00:22:29.040 --> 00:22:32.160
and look at where all
the threads are fixing the

355
00:22:32.160 --> 00:22:35.070
problem. Cause there'll be a
challenge, but at least you

356
00:22:35.070 --> 00:22:37.650
can detect it much easier.
So, so one of the

357
00:22:37.650 --> 00:22:39.870
things that we're doing in
accident, and we have this

358
00:22:39.870 --> 00:22:43.800
thing called a protocol where
we define between agents. We

359
00:22:43.800 --> 00:22:47.850
define a communication channels. This
is where the messages are

360
00:22:47.850 --> 00:22:51.630
being passed between agents. And
we actually add formal protocols

361
00:22:51.630 --> 00:22:55.350
to those channels. And once
you have the formality of,

362
00:22:55.560 --> 00:22:59.460
so the protocols express the
order of messages that can

363
00:22:59.460 --> 00:23:02.100
go between agents and because
we're not allowing you to

364
00:23:02.100 --> 00:23:06.150
take locks in accent, agents
cannot synchronize their actions of

365
00:23:06.150 --> 00:23:09.270
using locks. You can't have
any deadlocks through locks. All

366
00:23:09.270 --> 00:23:14.160
your deadlocks can only happen
through, through messaging where you're

367
00:23:14.160 --> 00:23:19.170
trying to access you. You're
doing things you're expecting some

368
00:23:19.170 --> 00:23:21.120
value from me, and I'm
not going to be sending

369
00:23:21.120 --> 00:23:22.890
it to you because I'm
expecting a value from you.

370
00:23:22.890 --> 00:23:25.470
That's kind of the message
passing deadlock, if you will,

371
00:23:26.640 --> 00:23:29.250
but by defining formal protocols
for how you and I,

372
00:23:29.400 --> 00:23:31.140
you know, if you and
I are agents in this

373
00:23:31.140 --> 00:23:34.740
program, how we interact, we
can get rid of a

374
00:23:34.740 --> 00:23:38.010
lot of deadlock situations. If
we also add some more

375
00:23:38.010 --> 00:23:42.510
advanced analysis tools, static analysis
tools that compare the code.

376
00:23:42.510 --> 00:23:45.680
I write in my agent
against the protocol for the

377
00:23:45.710 --> 00:23:48.740
communication channel and see what
are really following and living

378
00:23:48.740 --> 00:23:50.810
up to that protocol or
not. And this is not

379
00:23:50.810 --> 00:23:54.350
something that still remains to
be incubated, but it's something

380
00:23:54.350 --> 00:23:58.970
that theoretically should be straightforward
to do. And that's something

381
00:23:58.970 --> 00:24:02.810
we've experimented within Microsoft, not
I wasn't involved, but Microsoft

382
00:24:02.810 --> 00:24:07.310
has experimented with another research
project. So, so we have

383
00:24:07.310 --> 00:24:10.340
a theoretical solution to that.
We haven't applied it, but

384
00:24:10.340 --> 00:24:12.730
on the data race side,
we have applied as an

385
00:24:12.740 --> 00:24:15.020
ACSM. You know, an accent
program should be free of

386
00:24:15.020 --> 00:24:18.230
data racist. If you use
accent sort of at the

387
00:24:18.230 --> 00:24:22.070
top of your application architecture,
which is where it's designed

388
00:24:22.070 --> 00:24:25.870
to be or intended to
be used. So if someone,

389
00:24:25.900 --> 00:24:27.760
if someone sits down for
this for the first time

390
00:24:27.760 --> 00:24:30.370
and they download this, they're
there, they're bringing what onto

391
00:24:30.370 --> 00:24:32.410
their machine. Sometimes when I'm
going to put something on

392
00:24:32.410 --> 00:24:35.470
my machine from Microsoft, I'm
concerned that it's going to

393
00:24:35.500 --> 00:24:38.020
mess up projects that I'm
existing, you know, I'm working

394
00:24:38.020 --> 00:24:40.780
on. So what are the
options for getting involved and

395
00:24:40.780 --> 00:24:43.930
getting started with ACSM? Right?
So actually it's just a,

396
00:24:44.470 --> 00:24:49.060
the download is an MSI,
just a regular installation image.

397
00:24:49.810 --> 00:24:53.770
It builds on top of
doc. That's 3.5 and visual

398
00:24:53.770 --> 00:24:57.250
studio 2008 is expected. We
can, you can use just

399
00:24:57.250 --> 00:24:59.950
to command line version also,
but we certainly recommend that

400
00:24:59.950 --> 00:25:05.080
visual studio 2008 is, is
your environment for it. And

401
00:25:05.110 --> 00:25:09.310
there's, you know, there's nothing
special about it. It's just

402
00:25:09.310 --> 00:25:12.940
a salsa, no other language
service into visual studio and

403
00:25:13.270 --> 00:25:20.230
adds a few libraries to
your.net environment and a few

404
00:25:20.230 --> 00:25:24.670
samples. And that's pretty much
it there's, there's nothing, nothing

405
00:25:24.670 --> 00:25:31.570
special about it. It's just
another couple of libraries and,

406
00:25:31.750 --> 00:25:34.780
and the computer. Okay. So
this is, it's not gonna,

407
00:25:34.780 --> 00:25:36.520
it's not going to put
things in my gack, they're

408
00:25:36.520 --> 00:25:40.390
going to make existing projects
break. No, it's not replacing

409
00:25:40.390 --> 00:25:44.080
anything. It's not patching anything.
So it should be completely

410
00:25:44.440 --> 00:25:48.400
safe from that perspective. And
the uninstaller, as far as

411
00:25:48.400 --> 00:25:50.890
our testing goes, it seems
to be working just fine.

412
00:25:51.430 --> 00:25:55.840
So cleaning out fill machine
afterwards is, is, is supported

413
00:25:55.840 --> 00:26:00.040
also. So then the ACSM
light is these is the

414
00:26:00.190 --> 00:26:02.320
command line compiler. If I
just want to do things

415
00:26:02.320 --> 00:26:04.510
like in an EMIS build
situation, or if I really

416
00:26:04.510 --> 00:26:07.360
want to keep things isolated,
but I really should use

417
00:26:07.360 --> 00:26:11.050
the visual studio addition. And
w what does that add

418
00:26:11.050 --> 00:26:15.040
to visual studio? It has
another language. So if you're

419
00:26:15.160 --> 00:26:18.280
familiar with sort of the,
the visual studio environment, right,

420
00:26:18.280 --> 00:26:21.670
you have, if you install
a, not just one language,

421
00:26:21.670 --> 00:26:25.720
but you know, the whole
visual studio installation, you know,

422
00:26:25.720 --> 00:26:28.900
with pro or something like
that, you get visual C

423
00:26:28.900 --> 00:26:31.960
plus, plus you get a
C sharp, you get VB.

424
00:26:32.320 --> 00:26:36.220
So Axiom just shows up
as another language and with

425
00:26:36.220 --> 00:26:40.390
a couple of project templates
and item templates and visual

426
00:26:40.390 --> 00:26:45.470
studio and a sample, that's
pretty much it. So then

427
00:26:45.470 --> 00:26:47.900
I w I could just
take an existing application and

428
00:26:47.900 --> 00:26:50.030
add a new library. So
it just be like having

429
00:26:50.090 --> 00:26:53.060
a solution with multiple languages.
So I could have C-sharp

430
00:26:53.060 --> 00:26:55.940
Phoebe and ACSM. Yep. That's
right. Okay. Now, can I

431
00:26:55.940 --> 00:26:59.360
use ACSM within an existing
application, or because we can't

432
00:26:59.360 --> 00:27:02.990
have mixed language at assemblies
in visual studio, we'd have

433
00:27:02.990 --> 00:27:05.270
to do that a different
way. Right. So, so that's

434
00:27:05.270 --> 00:27:09.740
the visual studio limitation in
that you can't mix ACSM

435
00:27:09.860 --> 00:27:13.490
and VB, for example, or,
and VB in the same

436
00:27:14.030 --> 00:27:15.860
project, but you kind of
have them in the same

437
00:27:15.860 --> 00:27:20.750
solution. Of course. All right.
Very cool. And one thing

438
00:27:20.750 --> 00:27:22.700
I'm curious about, and this
is just a little bit

439
00:27:22.700 --> 00:27:26.180
of an obscure question, but
I'm a, an Afro file.

440
00:27:26.210 --> 00:27:29.390
And I noticed that Maestro
makes sense as a name.

441
00:27:29.390 --> 00:27:31.430
This was the previous code
name, cause the Maestro is

442
00:27:31.430 --> 00:27:34.370
a conductor and it's, you
know, it's, it's, it's an

443
00:27:34.370 --> 00:27:38.600
evocative name, but, but ACSM
is a province in Ethiopia.

444
00:27:38.630 --> 00:27:41.330
And I can't think about
it. I'm trying to figure

445
00:27:41.330 --> 00:27:44.090
out why you would name
the product ACSM. The thing

446
00:27:44.090 --> 00:27:48.590
that's significant about ACSM in,
in mythology is that they

447
00:27:48.590 --> 00:27:52.310
say that the, the 10
commandments exist in a church

448
00:27:52.310 --> 00:27:55.460
in Aksum in Ethiopia. But
I, I can't tell if

449
00:27:55.460 --> 00:28:00.110
that means anything about parallelism.
So, so the tradition at

450
00:28:00.110 --> 00:28:03.530
Microsoft is that code names
that are, are made public

451
00:28:03.530 --> 00:28:09.170
should be based on geographical
locations. And so, so we

452
00:28:09.170 --> 00:28:11.960
just, we just had to
pick something and we wanted

453
00:28:11.960 --> 00:28:14.720
to pick something that was
a little bit obscure and

454
00:28:14.720 --> 00:28:21.600
not just something common. And,
you know, I, you know,

455
00:28:21.610 --> 00:28:26.780
I I'm, I'm a, I'm
personally I'm Swedish, but I

456
00:28:26.780 --> 00:28:30.770
have some, some connections to
Ethiopia. And I just decided

457
00:28:30.800 --> 00:28:33.170
that, Hey, that's, that would
be a cool name to

458
00:28:33.170 --> 00:28:37.360
have. And, but really the
obscurity of it was, was

459
00:28:37.400 --> 00:28:40.370
part of the charm of,
of picking a name like

460
00:28:40.370 --> 00:28:43.580
that. I think that's great.
I was, I was thinking

461
00:28:43.580 --> 00:28:45.680
before the interview, I'm like,
okay, let me think. Well,

462
00:28:45.980 --> 00:28:47.840
the thing that's significant about
ACSM is that the 10

463
00:28:47.840 --> 00:28:50.330
commandments are there and everyone
wants them to be released,

464
00:28:50.330 --> 00:28:52.910
but no one's seen them.
Maybe if Axiom get, gets

465
00:28:52.910 --> 00:28:57.350
released from Microsoft, that'll say
something about the 10 commandments

466
00:28:57.350 --> 00:29:01.040
being released from Ethiopia. No,
I just, I just, I

467
00:29:01.040 --> 00:29:03.410
just wanted people to, when
they heard the name, I

468
00:29:03.410 --> 00:29:05.630
thought it would be cool
if people actually had to

469
00:29:05.630 --> 00:29:10.520
research what that was rather
than just, you know, Well,

470
00:29:10.520 --> 00:29:13.340
we have mission accomplished. I
knew immediately. I said, Oh,

471
00:29:13.340 --> 00:29:16.820
wow, okay. That's a cool,
that's a cool name. So

472
00:29:16.820 --> 00:29:20.150
the, the, the blog used
to is called Maestro team,

473
00:29:20.180 --> 00:29:22.520
has that moved in fact,
because you can find information

474
00:29:22.520 --> 00:29:26.630
about Axiom. I was Googling
with being, and I found

475
00:29:27.350 --> 00:29:31.190
ACSM information in multiple locations
where where's the primary place

476
00:29:31.190 --> 00:29:34.370
to find the, the latest
on ACSM. So I, I,

477
00:29:34.370 --> 00:29:38.990
there are two places, one
on MSDN dev labs. And

478
00:29:38.990 --> 00:29:41.310
the other one is that
my store team blog, it

479
00:29:41.380 --> 00:29:45.070
turned out that it was
while changing. The code name

480
00:29:45.070 --> 00:29:48.790
was quite straightforward, particularly because
we did it before we

481
00:29:48.790 --> 00:29:53.440
released it, changing, changing the
blog address and so on

482
00:29:53.440 --> 00:29:55.750
and so forth because we
had lots of links everywhere.

483
00:29:55.990 --> 00:29:58.330
We just didn't want to
go through that. So, so

484
00:29:58.330 --> 00:30:03.400
the blog is actually still
blogs that msdn.com/my strongest core

485
00:30:03.400 --> 00:30:08.680
team. And, but that is
the official ACSM blog. It's

486
00:30:08.680 --> 00:30:11.080
been a little bit inactive
in the last couple of

487
00:30:11.080 --> 00:30:14.860
months because we have really,
haven't had anything public to,

488
00:30:15.110 --> 00:30:21.820
to talk about, about accents
lately, but, but there's tons

489
00:30:21.820 --> 00:30:24.730
of information on there. There's
a forum on dev labs

490
00:30:26.050 --> 00:30:28.270
also been a little bit
inactive lately because we haven't

491
00:30:28.270 --> 00:30:32.770
had anything public to release
there. We haven't updated the

492
00:30:32.770 --> 00:30:37.660
verse, the accent release in,
in, in some time, but

493
00:30:38.320 --> 00:30:42.280
there's, there's lots of information
there. Lots of things to

494
00:30:42.280 --> 00:30:47.260
go through and look at
it is alive. And the

495
00:30:47.260 --> 00:30:50.170
download is there at dev
labs, <inaudible> dot com slash

496
00:30:50.170 --> 00:30:54.610
dev labs. And it has
great samples. And those samples

497
00:30:54.610 --> 00:30:57.340
are a lot of what
the forum discussions are about,

498
00:30:57.850 --> 00:31:01.300
are about samples and questions
around it and elaborations on

499
00:31:01.300 --> 00:31:03.690
those things. So that might,
it might help to do

500
00:31:03.720 --> 00:31:08.010
the download and before looking
at the forum. Okay. Very,

501
00:31:08.010 --> 00:31:09.690
very cool. I'll put the
links for that up on

502
00:31:09.690 --> 00:31:13.200
the show site, that's msdn.com/dev
labs, and there's a lot

503
00:31:13.200 --> 00:31:16.110
of different projects up there.
One of which is ACSM

504
00:31:16.320 --> 00:31:19.710
and then blogs that understand.com/maestro
team. And of course, if

505
00:31:19.710 --> 00:31:22.830
you just search on the
web for Axiom, a X,

506
00:31:22.830 --> 00:31:26.040
U M programming, I was
able to find all of

507
00:31:26.040 --> 00:31:29.250
these things as well as
some interesting presentations videos at,

508
00:31:29.480 --> 00:31:33.000
at various conferences on this
topic. But thanks so much,

509
00:31:33.030 --> 00:31:35.640
Nicholas. I really appreciate your
time. Okay. Well, thank you

510
00:31:35.640 --> 00:31:38.250
Scott, for having me. This
has been another episode of

511
00:31:38.280 --> 00:31:40.470
Hansel minutes, and we'll see
you again next week.


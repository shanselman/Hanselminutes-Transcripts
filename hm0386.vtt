WEBVTT FILE

1
00:00:12.060 --> 00:00:17.640
From hanselminutes.com. It's Hansel minutes,
all weekly discussion with web

2
00:00:17.640 --> 00:00:21.990
developer and technologists and Scott
Hanselman. This is Lawrence Ryan announced

3
00:00:21.990 --> 00:00:28.950
some show number three 85
recorded live Thursday, August 8th, 2013. Support

4
00:00:28.950 --> 00:00:32.340
for Hansel minutes is provided
by Teluride offering the best

5
00:00:32.340 --> 00:00:41.010
in developer tools and support
online@telerikdotcomandbyfranklin.net makers of gesture pack

6
00:00:41.430 --> 00:00:45.180
a powerful gesture, recording and
recognition system for Microsoft connect

7
00:00:45.180 --> 00:00:50.640
for windows developers details. Add
gesture, PA k.com. In this

8
00:00:50.640 --> 00:00:54.480
episode, Scott talks with open
source developer, John Linaro about

9
00:00:54.480 --> 00:00:59.330
the no SQL movement and
couch DB. Hi, this is

10
00:00:59.330 --> 00:01:01.730
Scott Hanselman. This is another
episode of Hansel minutes and

11
00:01:01.730 --> 00:01:03.830
on the Skype right now,
I've got Yon, lean art

12
00:01:03.860 --> 00:01:06.710
from Berlin, Germany. How are
you? Hey, I'm fine. How

13
00:01:06.710 --> 00:01:09.140
are you? I'm very well.
Thanks for waking up with

14
00:01:09.140 --> 00:01:11.060
me this morning. I'm up
at midnight and you're up

15
00:01:11.060 --> 00:01:14.660
at eight. That's lovely. That's
not my time, but I'm

16
00:01:14.660 --> 00:01:17.780
happy to be on the
show. That's great. You're known

17
00:01:17.780 --> 00:01:21.620
in open source spaces. You've
done a mustache and a

18
00:01:21.830 --> 00:01:23.870
couch DB, which is what
I'm interested in talking to

19
00:01:23.870 --> 00:01:28.880
you about. Yep. So no
SQL. This is like the

20
00:01:28.880 --> 00:01:31.850
hot thing that everyone talks
about, but I think people

21
00:01:31.850 --> 00:01:34.010
who are listening to the
show and myself included are

22
00:01:34.010 --> 00:01:37.760
used to like kind of
classic SQL databases, entity, relationship

23
00:01:37.760 --> 00:01:42.020
diagrams, spending lots of time
looking at looking at designing

24
00:01:42.020 --> 00:01:45.290
schema. This is a whole
different way of thinking about

25
00:01:45.290 --> 00:01:49.190
it. It's the exact opposite.
Isn't it of a relational

26
00:01:49.310 --> 00:01:53.970
database, the aspect you mentioned
with no SQL, definitely that

27
00:01:53.970 --> 00:01:58.100
that people can be freer
and doing software rather than

28
00:01:58.100 --> 00:02:00.400
planning it. Then, then maybe
doing it later when the

29
00:02:00.440 --> 00:02:05.000
plan got approved or whatever,
depending on a specific attribute

30
00:02:05.000 --> 00:02:07.040
to know, SQL tends to
be very hard. So it

31
00:02:07.040 --> 00:02:11.890
can be about scaling, about
ease of use about the

32
00:02:11.900 --> 00:02:14.030
schema business that you mentioned.
And there's all sorts of

33
00:02:14.030 --> 00:02:16.460
other stuff that knows SQL
is known for. It's kind

34
00:02:16.460 --> 00:02:21.080
of like a big hodgepodge
of things, but yeah, the,

35
00:02:21.890 --> 00:02:25.100
it requires some rethinking of
what you may have learned

36
00:02:25.400 --> 00:02:29.210
in university or on the
job. Is it a, is

37
00:02:29.210 --> 00:02:31.580
it a matter of taking
characteristics that we think of

38
00:02:31.580 --> 00:02:35.480
in a classic SQL or
relational database and just doing

39
00:02:35.480 --> 00:02:38.750
the opposite or what are
some characteristics of no SQL

40
00:02:38.750 --> 00:02:43.760
databases? It's more like going
back to the fundamentals of

41
00:02:43.760 --> 00:02:47.270
data storage. So all, all
major databases work the same

42
00:02:47.270 --> 00:02:50.510
way that some tree data
structure, you like data structure

43
00:02:50.510 --> 00:02:53.030
for main data storage and
indexes, and then some, maybe

44
00:02:53.030 --> 00:02:58.400
some hashes for specific purposes.
And then, then those skills

45
00:02:58.430 --> 00:03:02.530
database on SQL databases just
take the same underlying technology

46
00:03:02.530 --> 00:03:06.220
and put it together in
different ways. So there, there

47
00:03:06.220 --> 00:03:11.490
isn't anything new and no
SQL maybe, but, but the,

48
00:03:11.490 --> 00:03:13.630
the putting things together in
a, in a more specific

49
00:03:13.630 --> 00:03:16.540
way, and maybe introducing a
bit of distributed systems thinking

50
00:03:16.540 --> 00:03:20.530
into how to larger, larger
databases that then fit in

51
00:03:20.530 --> 00:03:23.770
the single machine, but the
underlying technologies is basically the

52
00:03:23.770 --> 00:03:28.300
same. So it's not all
too different for me, but

53
00:03:28.450 --> 00:03:30.010
like I've been at it
for a couple of years

54
00:03:30.010 --> 00:03:32.820
now. Well, when you say
that the underlying technology is

55
00:03:32.820 --> 00:03:36.090
the same, you're saying that
things like indexes and record

56
00:03:36.090 --> 00:03:41.160
retrieval, that those concepts are
still fundamentally there. Yeah. So,

57
00:03:41.160 --> 00:03:42.990
I mean, I'm, I'm pushing
data to it. I'm doing

58
00:03:42.990 --> 00:03:46.260
inserts. I'm, I've got indexes.
I have views, you know,

59
00:03:46.290 --> 00:03:48.990
data is still data. Four
loops are still four loops,

60
00:03:48.990 --> 00:03:52.410
of course. Right? Yeah. That,
that is, that is basically

61
00:03:52.410 --> 00:03:56.280
it. And then the, the
difference is that maybe on

62
00:03:56.280 --> 00:03:59.640
the, on the insertion, in
this, in the SQL databases,

63
00:03:59.640 --> 00:04:03.240
this, the SQL database will
look up the table structure

64
00:04:03.240 --> 00:04:06.450
and then enforce the particular
schema and a NoSQL database

65
00:04:06.450 --> 00:04:08.220
may just take the data
you have and store it

66
00:04:08.220 --> 00:04:11.100
as adjacent block, but that's
not, not any different from

67
00:04:11.100 --> 00:04:13.740
storing and change and evolve
into a large data structure

68
00:04:14.460 --> 00:04:17.610
in the regular database. Right.
But if I took a

69
00:04:17.610 --> 00:04:20.400
Jason blob and threw it
into a column in a

70
00:04:20.400 --> 00:04:24.090
standard SQL database, I wouldn't
be able to query what's

71
00:04:24.090 --> 00:04:27.030
inside that, you know, it
would become this opaque bunch

72
00:04:27.030 --> 00:04:30.390
of bytes. Right. And then
SQL databases. Don't like doing

73
00:04:30.390 --> 00:04:33.120
that too, because it's Unbound
and its size and SQL

74
00:04:33.120 --> 00:04:36.970
databases seem to like their
slices nicely paid. Yeah, that

75
00:04:36.970 --> 00:04:39.930
was correct. And yeah, there's,
there's a bunch of like

76
00:04:39.930 --> 00:04:42.570
optimizations that if you're you're
you can do, if you

77
00:04:42.570 --> 00:04:47.040
have very, very sliced, very
I'm very record oriented. And

78
00:04:47.040 --> 00:04:50.280
then there's the orthogonal version,
like the verticals of the

79
00:04:50.280 --> 00:04:52.830
world, which are the common
databases, which slice just the

80
00:04:52.830 --> 00:04:55.110
other way, which is probably
a fallen or something. And

81
00:04:55.110 --> 00:04:59.310
then, and the notes equal.
Well, we tend to not

82
00:04:59.310 --> 00:05:03.300
worry too much about that
because if you introduce this

83
00:05:03.300 --> 00:05:08.400
idea of scale, the individual
single query performance may, may

84
00:05:08.400 --> 00:05:12.750
matter less than the overall
system throughput. So if you

85
00:05:12.750 --> 00:05:15.390
have a thousand machines running
a single database, making sure

86
00:05:15.390 --> 00:05:18.570
that they all respond to
the request in a reasonable

87
00:05:18.570 --> 00:05:20.550
amount of time, that's still
fast enough for the user.

88
00:05:20.580 --> 00:05:23.550
That's good enough then squeezing
the loss microseconds out of

89
00:05:23.550 --> 00:05:27.060
a single query. That's Interesting
because I, I know that

90
00:05:27.090 --> 00:05:30.330
when dealing with classic kind
of SQL server and I

91
00:05:30.330 --> 00:05:32.640
come from the Microsoft SQL
server world, but I've also

92
00:05:32.640 --> 00:05:35.580
done work on DB too.
And I've done work on

93
00:05:36.750 --> 00:05:40.770
Oracle databases, scaling up is
always easy. You know, going

94
00:05:40.770 --> 00:05:43.410
from one to four to
eight to 16 processors is

95
00:05:43.410 --> 00:05:46.770
what SQL databases and SQL
database administrators like to do,

96
00:05:46.770 --> 00:05:49.260
throw a memory at it,
throw a processor at it.

97
00:05:49.860 --> 00:05:52.260
But you're saying that in
the no SQL world, that

98
00:05:52.560 --> 00:05:55.590
chopping things up and scaling
out rather than up is

99
00:05:55.590 --> 00:05:59.900
more appropriate. Yeah. There's definitely
A bunch of databases in

100
00:05:59.900 --> 00:06:02.840
the no SQL wealth fed
are based around the idea

101
00:06:02.840 --> 00:06:05.150
that you can just throw
more hardware in terms of

102
00:06:05.150 --> 00:06:08.800
more machines at the problem.
So if I were going

103
00:06:08.800 --> 00:06:10.810
to do the kind of
the standard, make a table

104
00:06:10.810 --> 00:06:13.570
of people, how do I
store people? Do I create

105
00:06:13.570 --> 00:06:15.760
a table and create columns
and give those columns data

106
00:06:15.760 --> 00:06:18.580
to, Okay. And that, that,
that one. Now we need

107
00:06:18.580 --> 00:06:21.580
to look at what specific
NoSQL database you're looking at.

108
00:06:22.540 --> 00:06:26.020
The there are different versions,
the one I'm working on

109
00:06:26.020 --> 00:06:28.720
the couch, and then other
ones have the same idea.

110
00:06:28.720 --> 00:06:32.170
You just have a record
just to do some blog.

111
00:06:32.200 --> 00:06:33.880
That is the contents of
the data that you want

112
00:06:33.880 --> 00:06:37.180
to store. That is name
first name, last name, age

113
00:06:37.180 --> 00:06:39.070
address, or whatever you want.
And you just saw that

114
00:06:39.070 --> 00:06:41.140
into the database. And that
may or may not be

115
00:06:41.140 --> 00:06:45.010
schema enforcement there. If you
have other databases say like,

116
00:06:45.040 --> 00:06:47.170
cause I know you want
to have some ideas about

117
00:06:47.170 --> 00:06:49.360
the types you're going to
be storing cause the system's

118
00:06:49.360 --> 00:06:52.600
going to do stuff with
them. So this is where

119
00:06:52.600 --> 00:06:54.760
the term knows Guild breaks
up a little bit. You

120
00:06:54.760 --> 00:06:57.190
need to look at the
specific database you're storing data

121
00:06:57.190 --> 00:07:00.850
with. Okay. So let's talk
about couch DB. Can I

122
00:07:00.850 --> 00:07:03.250
just throw it some Jason,
it looks like a person

123
00:07:03.250 --> 00:07:05.110
and it'll just say, all
right, well, that's a person

124
00:07:05.110 --> 00:07:07.990
I'll hang onto this for
you for later Comes to

125
00:07:07.990 --> 00:07:09.430
be a little extra to
just say, Oh, that looks

126
00:07:09.430 --> 00:07:11.920
like Villa Jason. I'll hang
on to that for you.

127
00:07:12.010 --> 00:07:14.140
And it'll give you a
key back and then you

128
00:07:14.140 --> 00:07:17.290
can use that key later
for retrieval. And then on

129
00:07:17.290 --> 00:07:19.600
top of that, you can
also create indexes for the

130
00:07:19.990 --> 00:07:23.830
specific, specific properties of that
Jason block. So if you

131
00:07:23.830 --> 00:07:25.900
want to look up people
by first name or last

132
00:07:25.900 --> 00:07:28.000
name or age or something
like that, you can create

133
00:07:28.000 --> 00:07:31.480
secondary indexes to retrieve that
data as well in a

134
00:07:31.510 --> 00:07:34.960
more query, like way Now,
when I'm doing things to

135
00:07:34.960 --> 00:07:37.450
two SQL servers or Oracles
and things like that, they

136
00:07:37.450 --> 00:07:39.640
all have a, a, a
socket that they open and

137
00:07:39.640 --> 00:07:42.610
they have some magical binary
format. Am I speaking some

138
00:07:42.610 --> 00:07:45.280
secret format or am I
just posting Jason to an

139
00:07:45.280 --> 00:07:48.850
HTTPS? That is exactly it.
Couch TV is all built

140
00:07:48.880 --> 00:07:51.430
around the web and web
standards. So it speaks all

141
00:07:51.430 --> 00:07:54.580
HTP Andrei song. And you
don't need any special software

142
00:07:54.580 --> 00:07:57.400
to use it like curl
or browser will do. Like

143
00:07:57.400 --> 00:07:59.620
in fact, the, the admin
interface of couch TV is

144
00:07:59.630 --> 00:08:01.960
just like a web app
that uses XHR to talk

145
00:08:01.960 --> 00:08:04.480
to catch DB. There isn't
any middleware that does anything

146
00:08:04.480 --> 00:08:07.510
fancy. Hmm. So I could
write my own if I

147
00:08:07.510 --> 00:08:09.670
wanted to. I mean, it's
just, it's just a web

148
00:08:09.670 --> 00:08:12.520
service out there in the
world. Yeah. That's, that's one

149
00:08:12.520 --> 00:08:15.010
of the pains of coach
Jimmy's existence. We kind of

150
00:08:15.010 --> 00:08:17.680
decided not to write client
libraries because you don't actually

151
00:08:17.680 --> 00:08:19.930
need client libraries. So the
first thing everyone does is

152
00:08:19.930 --> 00:08:22.000
try to catch the client
library for their needs. So

153
00:08:22.000 --> 00:08:24.520
there are a million of
them that just do that

154
00:08:24.640 --> 00:08:27.370
thing they need, but none
of them do everything everyone

155
00:08:27.370 --> 00:08:30.160
needs and that's kind of
an issue, but it's also

156
00:08:30.160 --> 00:08:32.170
fun that people just write
the client libraries because it's

157
00:08:32.170 --> 00:08:35.710
so damn easy. Interesting. That's
actually the next question was

158
00:08:35.710 --> 00:08:38.080
like, okay, I'm a, like,
I'm a.net programmer. And I'm

159
00:08:38.080 --> 00:08:40.510
thinking I want to start
doing work in, in couch

160
00:08:40.510 --> 00:08:42.760
DB. Should I go on
hunt? I mean, I would

161
00:08:42.760 --> 00:08:46.540
naturally go hunting for the
official.net client library and it

162
00:08:46.540 --> 00:08:50.110
just doesn't exist. Well, there
there's like, I'm going to

163
00:08:50.110 --> 00:08:52.150
say we can, everybody's going
to hate me because these

164
00:08:52.150 --> 00:08:55.380
are awful, but we're collecting
these. And then a bit

165
00:08:55.380 --> 00:08:57.270
of a natural selection going
on. Then the better ones

166
00:08:57.270 --> 00:08:59.040
tend to pop up to
be on the top of

167
00:08:59.040 --> 00:09:01.350
the list on the Wiki.
So that was some hunting

168
00:09:01.350 --> 00:09:03.480
that you can do and
reuse of code. You can

169
00:09:03.480 --> 00:09:06.840
just get into for easiness,
but then like there, if

170
00:09:06.840 --> 00:09:09.810
they're good, they're really thin
layer on top of couch

171
00:09:09.810 --> 00:09:12.710
anyway. So if you want
to learn couch, it's probably

172
00:09:12.750 --> 00:09:15.270
easiest to just ride your
own and just keep going

173
00:09:15.270 --> 00:09:17.070
with it. But if you
just want to get stuff

174
00:09:17.070 --> 00:09:18.840
done, you skip that and
take one of the existing

175
00:09:18.840 --> 00:09:22.610
ones. Sorry. It's definitely a
database where I need to

176
00:09:22.610 --> 00:09:26.540
love the web. Yeah. But
you should love the web

177
00:09:26.540 --> 00:09:32.600
anyway. Okay. So I've got
my person and my first

178
00:09:32.600 --> 00:09:34.400
name and my age and
all those kinds of things.

179
00:09:35.030 --> 00:09:36.440
How do I go and
say, well, give me all

180
00:09:36.440 --> 00:09:39.050
the people with the first
name that starts with S

181
00:09:39.740 --> 00:09:41.720
All right. So here's, here's
the thing. That's, that's the

182
00:09:41.720 --> 00:09:43.730
most tricky to explain the
couch to the, I guess

183
00:09:44.430 --> 00:09:48.440
the, the way we do
querying is a bit obscure,

184
00:09:48.530 --> 00:09:52.820
but it, it works quite
nicely. We're using a procedure

185
00:09:52.820 --> 00:09:57.740
called MapReduce and now everybody
runs away screaming again, which

186
00:09:57.800 --> 00:09:59.780
requires you to write some
Java script, which if you're

187
00:09:59.790 --> 00:10:02.180
done that programmer, it's probably
not your favorite thing to

188
00:10:02.180 --> 00:10:05.180
do, but you can still
do. And then manage. Usually

189
00:10:05.180 --> 00:10:08.450
the code required to be
written as really tiny, just

190
00:10:08.450 --> 00:10:10.460
a couple of lines of
code. So basically all you

191
00:10:10.460 --> 00:10:12.590
do is write a function
that gets applied to all

192
00:10:12.590 --> 00:10:15.080
your records. And all it
needs to do is admit

193
00:10:15.080 --> 00:10:18.230
or return the data that
you want to be in

194
00:10:18.230 --> 00:10:21.470
the index. So for, if
you want to have the

195
00:10:22.280 --> 00:10:24.320
first, the first character you
said with the last name,

196
00:10:24.320 --> 00:10:28.160
right? So, so you just
met or returned the last

197
00:10:28.160 --> 00:10:30.650
name from that function. And
then you get an index

198
00:10:30.650 --> 00:10:32.930
by last name, and then
you can do a sub

199
00:10:32.930 --> 00:10:35.060
query on that, on that
query time was just like,

200
00:10:35.060 --> 00:10:38.180
give me everyone that starts
with a T. So I

201
00:10:38.180 --> 00:10:40.580
would make a function that
takes a doc and I

202
00:10:40.580 --> 00:10:42.800
would do whatever I want
to within there in this

203
00:10:42.800 --> 00:10:45.620
case say, you know, if,
and then go off looking

204
00:10:45.620 --> 00:10:49.010
at index of, Oh, so
you wouldn't in the, in

205
00:10:49.010 --> 00:10:52.310
the map function, you wouldn't
look for you wouldn't program

206
00:10:52.400 --> 00:10:56.870
your query details as like
extract the first character of

207
00:10:56.870 --> 00:10:58.850
it, maybe, but maybe you
want to have an index

208
00:10:58.850 --> 00:11:02.600
by last name. And then
there is like indexing time

209
00:11:02.600 --> 00:11:05.730
of the query time. So
at query time we created

210
00:11:05.760 --> 00:11:07.040
it and I was sorry
at the next time to

211
00:11:07.040 --> 00:11:10.100
create an index. So we
put all the last names

212
00:11:10.100 --> 00:11:12.500
into a data structure that's
really efficient to look at.

213
00:11:12.560 --> 00:11:15.020
And then at query time,
we can say within that

214
00:11:15.020 --> 00:11:17.520
data structure, give me a
subset of the, of the

215
00:11:17.540 --> 00:11:19.460
rows there. And then you
can say, just give me

216
00:11:19.460 --> 00:11:21.770
everything that starts with a
T, but everything that's in

217
00:11:21.770 --> 00:11:24.350
between starting with a T
and starting with S excluding

218
00:11:24.350 --> 00:11:26.450
the ones that stopped with
an S. So that's everything

219
00:11:26.450 --> 00:11:29.090
with a T, but at
the same index can also

220
00:11:29.090 --> 00:11:31.910
answer it. Just give me
everything by last name. I

221
00:11:31.910 --> 00:11:35.900
see. So if I understand
correctly, hence it's MapReduce first,

222
00:11:35.900 --> 00:11:37.520
I decide what are the
records? I want to map

223
00:11:37.940 --> 00:11:41.180
this on top of, and
then I reduced the results.

224
00:11:41.180 --> 00:11:43.130
So I would go in
almost like I'm getting a

225
00:11:43.130 --> 00:11:45.830
view model, not the actual
data, but have a view

226
00:11:45.830 --> 00:11:50.180
on that data. Yeah. Of
last names. That's one function,

227
00:11:50.180 --> 00:11:53.030
the map function. Right. Ignore,
reduce for now, I think

228
00:11:53.200 --> 00:11:55.380
too much for a half
hour. Okay. But then I

229
00:11:55.380 --> 00:12:00.060
query that resulting. Yeah, exactly.
And these mechanisms called views

230
00:12:00.060 --> 00:12:02.970
and country V so that's
very fitting. Hmm. And would

231
00:12:02.970 --> 00:12:05.490
that be familiar to MVC
people or is that just

232
00:12:05.490 --> 00:12:10.020
a coincidence that it's called
a view? That's a different

233
00:12:10.020 --> 00:12:13.620
kind of view. Okay. Yeah.
Okay. And so this, this

234
00:12:13.620 --> 00:12:16.230
emit function, this is a,
this is a fundamental built

235
00:12:16.230 --> 00:12:20.550
in function that takes this
key value pair. Yeah. And

236
00:12:20.550 --> 00:12:22.830
the key is, is some
arbitrary key, or is it

237
00:12:22.830 --> 00:12:26.310
a meaningful, Natural key? It
is whatever you want it

238
00:12:26.310 --> 00:12:30.390
to be. We usually use,
at least for the secondary

239
00:12:30.390 --> 00:12:32.850
nexus use some natural data,
like the last name, the

240
00:12:32.850 --> 00:12:36.720
age, the street, or whatever
you need to be unique.

241
00:12:37.580 --> 00:12:40.110
It does not have to
be unique. In fact, there

242
00:12:40.110 --> 00:12:43.260
is no unique constraint even
possible on the secondary nexus,

243
00:12:43.260 --> 00:12:45.780
which is a bit of
a limit, but yeah, we'll

244
00:12:45.780 --> 00:12:48.420
maybe have to fix that
some time later. Well, actually,

245
00:12:48.420 --> 00:12:51.660
speaking of limits, one of
the things that you say,

246
00:12:51.660 --> 00:12:54.270
it just a couple of
chapters into one of the,

247
00:12:54.930 --> 00:12:58.080
you know, what's the deal
with couch DB wikis is

248
00:12:58.350 --> 00:13:01.710
that there are some limits
that will initially make newcomers

249
00:13:01.710 --> 00:13:06.390
feel that it's inflexible, but
then after some, some work

250
00:13:06.390 --> 00:13:08.040
you go, ah, I see
why you did that. That's

251
00:13:08.040 --> 00:13:10.710
a useful limit. So what
is something that would turn

252
00:13:10.710 --> 00:13:12.480
me off and immediately make
me think this is so

253
00:13:12.480 --> 00:13:16.890
inflexible, but it makes it
possible, Right? So the, this

254
00:13:16.890 --> 00:13:18.750
is what we maybe talk
about the reduce a little

255
00:13:18.750 --> 00:13:23.670
bit. If you want to
get score somebody like you

256
00:13:23.670 --> 00:13:25.830
have games and people have
scores, and then you want

257
00:13:25.830 --> 00:13:27.750
to find out who has
got the highest score, right?

258
00:13:28.200 --> 00:13:29.880
So you can use the
map and the reduced to

259
00:13:29.880 --> 00:13:33.150
compute the score of everyone,
but you can't sort by

260
00:13:33.180 --> 00:13:35.820
the score anymore. That will
be a chain men produce.

261
00:13:35.820 --> 00:13:39.870
And we currently don't support
that because very fast access

262
00:13:39.870 --> 00:13:42.480
to a change map produce
like an OLT piece that

263
00:13:42.480 --> 00:13:45.660
access to chain MapReduce isn't
really possible because you need

264
00:13:45.660 --> 00:13:51.330
a tabled skin style computation
of, of that results. So

265
00:13:51.330 --> 00:13:52.860
what types of it gives
you is a list of

266
00:13:52.860 --> 00:13:55.200
all the scores, but you
need to sort them in

267
00:13:55.200 --> 00:13:58.110
whichever way you need on
the client application, which may

268
00:13:58.110 --> 00:14:01.710
seem very inflexible and very
silly, but it allows countries

269
00:14:01.710 --> 00:14:04.830
to be, to be deployed
on multiple machines and guarantee

270
00:14:04.850 --> 00:14:09.330
fast response times at all
times. Whereas with other systems,

271
00:14:09.330 --> 00:14:10.980
you will get into a
situation. If there's a lot

272
00:14:10.980 --> 00:14:13.440
of data on that kind
of query, you need to

273
00:14:13.470 --> 00:14:16.260
bump some buffer or run
into some other, other like

274
00:14:16.260 --> 00:14:19.110
memory issues and country, but
just give them it. Doesn't

275
00:14:19.110 --> 00:14:21.570
give you that feature to
like, should just shoot yourself

276
00:14:21.570 --> 00:14:24.060
in the foot. So in
a, in a kind of

277
00:14:24.060 --> 00:14:28.890
a classic SQL database, you,
you would find out later

278
00:14:29.160 --> 00:14:31.920
that something was a table
scan, you'd do some profiling

279
00:14:31.920 --> 00:14:33.810
and you'd go, wow. Why,
why is that so slow?

280
00:14:33.840 --> 00:14:36.360
Oh, that turned in that
query turned into a table

281
00:14:36.360 --> 00:14:38.430
scan, and then you have
to go off and figure

282
00:14:38.430 --> 00:14:40.920
out why that reduced into
a table scan. You're saying

283
00:14:40.920 --> 00:14:43.470
that couch CP simply won't
allow you to, to get

284
00:14:43.470 --> 00:14:46.440
yourself in that situation. Right?
Yeah. I think we, for

285
00:14:46.440 --> 00:14:48.330
the most part, all the
features in country B are

286
00:14:48.330 --> 00:14:52.930
built in a way that
don't come haunting later. But

287
00:14:52.930 --> 00:14:55.720
then that means that the
logical operation may need to

288
00:14:55.720 --> 00:14:59.260
be split in its responsibilities
between this, you know, some

289
00:14:59.260 --> 00:15:02.050
middleware that might do some
additional filtering filtering or some

290
00:15:02.050 --> 00:15:07.060
additional sorting. Yeah, that's correct.
And we're kind of, we,

291
00:15:07.060 --> 00:15:09.370
we're very Heartline as part
of the development team to

292
00:15:09.370 --> 00:15:12.130
not ever have features that
are like that. We're kind

293
00:15:12.130 --> 00:15:15.850
of like switching the whole
like development code structure to

294
00:15:15.850 --> 00:15:18.310
a like small core and
many plugins kind of thing,

295
00:15:19.510 --> 00:15:21.280
because we, we found that
people really want to have

296
00:15:21.280 --> 00:15:24.880
the problem solved rather than
not being told they need

297
00:15:24.880 --> 00:15:27.850
to solve the problems differently.
So maybe we'll have a,

298
00:15:27.880 --> 00:15:30.420
we'll have a plugin that
allows you to sort by

299
00:15:30.460 --> 00:15:33.910
reduced value with the caveat
that it may break later.

300
00:15:33.940 --> 00:15:36.490
But if you make the
conscious decision of like, okay,

301
00:15:36.490 --> 00:15:38.380
I'm using the feature now
that I know might break,

302
00:15:38.410 --> 00:15:40.450
but I'm never going to
be in the position where

303
00:15:40.450 --> 00:15:42.580
it actually is going to
break. I I'm able to

304
00:15:42.580 --> 00:15:45.670
use that. So we're kind
of starting to turn it

305
00:15:45.670 --> 00:15:48.940
around on this one. No.
If I was going to

306
00:15:48.940 --> 00:15:52.690
have some values that are,
that are dates or something,

307
00:15:52.690 --> 00:15:55.300
that's a little bit more
formal than a string, and

308
00:15:55.300 --> 00:15:58.780
I've got a bunch of
people, but instead of sending

309
00:15:58.780 --> 00:16:00.400
in birthday, let's say one
of the records, I just

310
00:16:00.400 --> 00:16:02.740
put in some nonsense, Lang
you know, something, that's not

311
00:16:02.740 --> 00:16:06.610
a date. So I've got
birthdate equals Fu what is

312
00:16:06.610 --> 00:16:08.350
the database going to do
with that? Is it going

313
00:16:08.350 --> 00:16:09.520
to reject it? Or is
it just going to say,

314
00:16:09.520 --> 00:16:13.210
Hey, I'm, I'm relaxed. I'm
chill. Yeah. I catch the

315
00:16:13.210 --> 00:16:15.940
be is definitely relaxed. As
soon as it's, as long

316
00:16:15.940 --> 00:16:18.520
as it's valid, Jason, it
will just accept it and

317
00:16:18.520 --> 00:16:21.700
store it, stay. Now whether
the data makes sense in

318
00:16:21.700 --> 00:16:24.700
your view definitions later, or
like say you're accessing a

319
00:16:24.700 --> 00:16:27.040
field in a map function
that doesn't exist that may

320
00:16:27.040 --> 00:16:31.780
throw an error or your
client side code Oreo, middleware,

321
00:16:31.810 --> 00:16:35.020
Kurt, Lola expecting expect that
kind of data is different

322
00:16:35.020 --> 00:16:38.410
matter, but then there's a
mode. I'm not a mode,

323
00:16:38.500 --> 00:16:40.300
but a way in country
to be, to enforce schema

324
00:16:40.300 --> 00:16:43.390
as well, which may sound
counterintuitive is one of the

325
00:16:44.320 --> 00:16:47.650
whole idea of no SQL,
nothing being schema lists at

326
00:16:47.650 --> 00:16:51.850
all. But you can tell
the catcher if he wants

327
00:16:51.850 --> 00:16:53.980
you to figure it out,
what your data's going to

328
00:16:53.980 --> 00:16:56.020
look like to reject data
that doesn't look like the

329
00:16:56.020 --> 00:17:01.400
one that you've defined. So
it's kinda like my, I

330
00:17:01.450 --> 00:17:02.860
love to think about it.
I'd like to think about

331
00:17:02.860 --> 00:17:06.280
it as like static typing
versus dynamic typing, and then

332
00:17:06.310 --> 00:17:08.380
COVID should be also allows
you to add type pins

333
00:17:08.380 --> 00:17:12.490
basically. Right. Okay. That type
annotations, like I think about

334
00:17:13.030 --> 00:17:16.240
when I explain TypeScript to
people, they immediately kind of

335
00:17:16.240 --> 00:17:18.220
recoil and fear, like what
have you done to my

336
00:17:18.220 --> 00:17:20.740
JavaScript? But then you explain,
well, it's thrown away. It's

337
00:17:20.740 --> 00:17:23.150
not really used. It's just
there as a, as a,

338
00:17:23.150 --> 00:17:27.490
a sifting filter to prevent
you from hurting yourself. And

339
00:17:27.490 --> 00:17:30.970
then the only difference there
is that, that, that filter

340
00:17:30.970 --> 00:17:33.400
in veterinary, it's a heart
filter. If you're a few

341
00:17:33.400 --> 00:17:35.740
stories trying to store some
data that doesn't conform to

342
00:17:35.740 --> 00:17:39.400
your specification will not get
stories. So it's a filter

343
00:17:39.400 --> 00:17:43.390
on the way in. Yeah.
And if you've already got

344
00:17:43.420 --> 00:17:45.700
data that's bad on the
way in, and you want

345
00:17:45.700 --> 00:17:47.920
to clean it up, you
would want to pull it

346
00:17:47.920 --> 00:17:50.810
back out and then put
it back in again, The

347
00:17:50.810 --> 00:17:53.000
client will look at a
rejection and say, Hey, this

348
00:17:53.000 --> 00:17:54.980
doesn't look right. And then
you can like, look at

349
00:17:55.010 --> 00:17:58.100
the definition and change, change,
whatever needs And fix it.

350
00:17:58.820 --> 00:18:02.360
So it's no, the term
knows SQL. It means that

351
00:18:02.360 --> 00:18:05.600
it means like there is
no structured query language. There

352
00:18:05.600 --> 00:18:09.110
is JavaScript. I'm using Jason
for my storage, but is

353
00:18:09.110 --> 00:18:11.360
it really Jason, like on
the disc or is it

354
00:18:11.360 --> 00:18:16.340
some magic sauce that is
not Jason For all intents

355
00:18:16.340 --> 00:18:19.730
and purposes? It is Jason
on the disc, but then

356
00:18:19.730 --> 00:18:23.060
it is the earning representation
of Jason cause casually he's

357
00:18:23.060 --> 00:18:25.310
written in our line and
we're doing a type conversion

358
00:18:25.310 --> 00:18:28.250
internally for various reasons that
pollute me at the moment.

359
00:18:28.250 --> 00:18:33.170
And we make, get rid
of that eventually. But we're

360
00:18:33.170 --> 00:18:35.390
storing the raw data just
on, on disc as this.

361
00:18:35.990 --> 00:18:39.320
So if I have a
database, a couch DB database

362
00:18:39.320 --> 00:18:41.390
of all the people in
the world, which is going

363
00:18:41.390 --> 00:18:43.460
to be quite large, let's
say it takes, you know,

364
00:18:43.490 --> 00:18:46.970
10 computers. Am I chopping
it up? Like the yellow

365
00:18:46.970 --> 00:18:50.000
pages where I have a
through F on this computer

366
00:18:50.000 --> 00:18:52.460
and L through Z on
that computer, or how is

367
00:18:52.460 --> 00:18:55.640
that across multiple? How do
I do that? How do

368
00:18:55.640 --> 00:18:59.300
I do something so big?
So again, it depends events.

369
00:19:00.980 --> 00:19:02.630
I'd also like to think
of Crutchfield as like a

370
00:19:02.630 --> 00:19:05.780
toolkit to build your own
distributed database, which is only

371
00:19:05.780 --> 00:19:09.320
interesting to people who like
building distributed databases. So you

372
00:19:09.320 --> 00:19:11.510
can, you can think up
your own petitioning scheme if

373
00:19:11.510 --> 00:19:14.750
you want, like by my
name and then your, your

374
00:19:14.750 --> 00:19:16.820
box for the letter S
needs to be really big

375
00:19:16.820 --> 00:19:23.420
in certain groups of people.
But there, there, the other

376
00:19:23.420 --> 00:19:26.270
way around is just lending
lending software to do the

377
00:19:26.270 --> 00:19:30.800
job. There is a quite
famous dynamo paper by Amazon.

378
00:19:30.920 --> 00:19:33.680
And there is an implementation
off that paper as kind

379
00:19:33.680 --> 00:19:36.320
of an add on to
couch DB that allows you

380
00:19:36.320 --> 00:19:39.320
to just specify, I'll say
like this time computers now

381
00:19:39.320 --> 00:19:41.210
behave like the single couch
TV, and we'll do the

382
00:19:41.210 --> 00:19:45.560
partitioning for you. And we're
in the process of merging

383
00:19:45.560 --> 00:19:48.500
that plugin back into couch
to be proper towards the

384
00:19:48.500 --> 00:19:50.180
end of the year, I
guess, where I'll be done

385
00:19:50.180 --> 00:19:51.770
with that and have that
release. So you don't actually

386
00:19:51.770 --> 00:19:53.450
have to worry about anything.
You're just stuck at another

387
00:19:53.450 --> 00:19:57.230
machine. And then things go.
So then if who am

388
00:19:57.230 --> 00:20:00.110
I asking, am I asking
some load balanced endpoint over

389
00:20:00.110 --> 00:20:03.260
HTTP? Give me all of
the people who are over

390
00:20:03.260 --> 00:20:06.380
20 years old In that
case, all the nodes in

391
00:20:06.380 --> 00:20:09.680
that database will act as
a proxy. So if you

392
00:20:09.740 --> 00:20:11.630
can ask any one node
in the K, give me,

393
00:20:11.630 --> 00:20:13.640
give me that record. And
if it is that record

394
00:20:13.640 --> 00:20:15.440
locally, it'll just return it.
And if it doesn't have

395
00:20:15.440 --> 00:20:17.360
a proxy, the request to
the note that does have

396
00:20:17.360 --> 00:20:19.610
it, because every, every node
knows where every other key

397
00:20:19.610 --> 00:20:24.260
lives. Ah, interesting. Okay. So
then how does that relate

398
00:20:24.260 --> 00:20:26.810
to something like a Reddis
or a memcache D it

399
00:20:26.810 --> 00:20:30.050
feels like we're blurring the
lines a little bit. So

400
00:20:30.050 --> 00:20:35.420
for, for mem cache, D
both resume Castillo, fundamentally single

401
00:20:35.480 --> 00:20:40.640
single machine databases are programs.
And then there's some like

402
00:20:40.640 --> 00:20:44.030
best practices around memcache D
how to like, get to

403
00:20:44.060 --> 00:20:47.440
sharding, like Festus, like every
try and find has the

404
00:20:47.440 --> 00:20:50.590
sharp key kind of thing.
So you can have three

405
00:20:50.590 --> 00:20:52.330
machines that every amount of
cash. And then whenever you

406
00:20:52.330 --> 00:20:55.480
have to add a mem
cash machine, you'd have to

407
00:20:55.660 --> 00:20:58.060
rechart everything, because you need
a new key that distributes

408
00:20:58.060 --> 00:20:59.500
it over four and so
on. So that's a bit

409
00:20:59.500 --> 00:21:02.800
annoying. Red is, are working
on a cluster feature that

410
00:21:02.800 --> 00:21:10.660
I haven't looked into very
detailed yet. So the, the

411
00:21:10.660 --> 00:21:13.090
storage engine took coach to
be that is fundamentally single,

412
00:21:13.090 --> 00:21:15.910
sober, but then the layer
on top can do the

413
00:21:16.070 --> 00:21:24.300
distribution for you. Okay. And
were trying to think about

414
00:21:24.360 --> 00:21:28.140
how I want to phrase
this. Do, do you think

415
00:21:28.140 --> 00:21:31.680
that there is increased legitimacy
in the, in the kind

416
00:21:31.680 --> 00:21:34.410
of the classic enterprise of
no SQL because of the

417
00:21:34.410 --> 00:21:37.890
success of things like, like
Netflix or, I mean, is

418
00:21:37.890 --> 00:21:42.960
couch to relaxed for a
big enterprise, like some boring

419
00:21:42.960 --> 00:21:47.280
insurance company somewhere. So COVID
is used in the enterprise

420
00:21:47.340 --> 00:21:50.340
and boring media companies, at
least that I know of,

421
00:21:50.400 --> 00:21:52.080
like the BBC is using
it. And one of the

422
00:21:52.080 --> 00:21:54.270
bigger German broad cultures is
using it and a bunch

423
00:21:54.270 --> 00:21:56.850
of others. So there's definitely
a big names using the

424
00:21:56.850 --> 00:22:03.270
software. And I think the
question in here is, does,

425
00:22:03.330 --> 00:22:06.360
does it solve a particular
problem better than existing solutions?

426
00:22:06.390 --> 00:22:08.700
And does it have a
low risk profile? That's the

427
00:22:08.700 --> 00:22:12.630
biggest thing for the enterprise?
I guess coach to me

428
00:22:12.630 --> 00:22:15.540
in particular is an Apache
project, which a lot of

429
00:22:15.540 --> 00:22:17.370
people think of kind of
as a place where open

430
00:22:17.370 --> 00:22:20.850
source projects go to die,
but that's kind of not

431
00:22:20.850 --> 00:22:23.010
the right thing to think
about it. I think of

432
00:22:23.010 --> 00:22:25.350
it as a place where
they go for legitimacy. Yeah,

433
00:22:25.380 --> 00:22:30.950
exactly. That's more, more like
it, the Apache puts, puts

434
00:22:30.950 --> 00:22:34.020
us the community around the
project first and visibility into

435
00:22:34.020 --> 00:22:39.570
that community first. So a
big enterprise we'll know way

436
00:22:39.570 --> 00:22:42.090
in advance. If something big
disruptive is going to happen

437
00:22:42.090 --> 00:22:44.190
for the project, if development
is going to slow down

438
00:22:44.190 --> 00:22:46.230
or a big changes are
coming, there's, everything's in the

439
00:22:46.230 --> 00:22:48.240
public and guaranteed to be
in the public. There's not

440
00:22:48.240 --> 00:22:50.820
one single company that ha
that is behind the development

441
00:22:50.820 --> 00:22:53.640
that then suddenly says, Hey,
we're doing something different today.

442
00:22:53.640 --> 00:22:56.580
Or version four breaks all
backwards compatibility. It could look

443
00:22:56.610 --> 00:22:59.520
and supports for the other
one stops right now. That

444
00:22:59.520 --> 00:23:04.210
kind of thing that said
though, the proper support and

445
00:23:05.970 --> 00:23:08.400
the support contracts and services
kind of thing needs to

446
00:23:08.400 --> 00:23:11.850
be built on top of
that by other people. So

447
00:23:11.850 --> 00:23:14.310
there, there isn't that package
that you can buy as

448
00:23:14.310 --> 00:23:18.810
an enterprise, but there's some
folks that, that provide that

449
00:23:18.810 --> 00:23:22.980
service. So let's talk about,
about performance. One of the

450
00:23:22.980 --> 00:23:26.430
things that it's kind of
touted as is it'll slow

451
00:23:26.430 --> 00:23:28.410
down, but it won't fall
over. Like, you know, if

452
00:23:28.410 --> 00:23:31.380
you start throwing a lot
of work at couch DB,

453
00:23:31.380 --> 00:23:33.360
it will just maybe take
a little bit longer, but

454
00:23:33.360 --> 00:23:36.770
it, it doesn't tip over.
Is that true? Yeah. That's

455
00:23:36.870 --> 00:23:39.510
about it. My friend max
often phrases it like you

456
00:23:39.720 --> 00:23:42.720
pay all the hurt with
cash should be upfront about

457
00:23:42.720 --> 00:23:45.210
that. It never gets any
worse. Whereas with other databases,

458
00:23:45.230 --> 00:23:46.820
they are really fast in
the beginning and then they

459
00:23:46.820 --> 00:23:50.750
get slower over time. Kind
of like they were basically

460
00:23:50.810 --> 00:23:54.440
operating at worst case scenario
at all times. Why is

461
00:23:54.440 --> 00:23:57.860
that? Is that because of
Earl Lang just does well

462
00:23:57.860 --> 00:24:02.810
on multiple cores, there's multiple,
multiple things that attribute to

463
00:24:02.810 --> 00:24:05.060
it, or I think that's
definitely one part of it.

464
00:24:05.150 --> 00:24:08.840
It does it doesn't optimize
for the single request performance,

465
00:24:08.840 --> 00:24:12.920
like I mentioned earlier, but
for overall system throughput and

466
00:24:12.920 --> 00:24:15.710
making sure you have always
like saturated IO and be

467
00:24:15.710 --> 00:24:18.410
able to accept all the
incoming requests as sockets and

468
00:24:18.410 --> 00:24:20.840
that kind of stuff. And
if everything takes a little

469
00:24:20.840 --> 00:24:23.330
longer, that's no problem. But
then if there's like a

470
00:24:23.330 --> 00:24:26.300
spike of 10,000 requests coming
in, it'll just handle that

471
00:24:26.300 --> 00:24:30.140
gracefully. And it's really hard
to build that into other

472
00:24:30.140 --> 00:24:34.630
languages to deal with these
spikes really easily. Don't big

473
00:24:34.630 --> 00:24:37.600
databases fall over when it
comes to things like contention

474
00:24:37.600 --> 00:24:39.400
where, you know, everyone's trying
to get to the same

475
00:24:39.400 --> 00:24:42.130
page at the same time.
And that's, that's a computer

476
00:24:42.130 --> 00:24:46.420
science problem, not necessarily a
language or programming language problem.

477
00:24:46.480 --> 00:24:50.020
Why has custody be different?
Well, so in the, in

478
00:24:50.020 --> 00:24:52.390
the getting to the same
record kind of scenario would

479
00:24:52.390 --> 00:24:54.610
do the proper computer science
thing and then leave it

480
00:24:54.610 --> 00:24:56.230
to a caching system that
will be in front of

481
00:24:56.230 --> 00:24:58.630
catcher, which is one of
the beauties of using HTTP

482
00:24:58.630 --> 00:25:00.730
as a protocol. We can
just use any of the

483
00:25:01.660 --> 00:25:03.460
proxies that are available for
that. And they all work

484
00:25:03.460 --> 00:25:07.750
really nicely. So we just
don't solve the problem. No,

485
00:25:07.750 --> 00:25:10.570
that's interesting. Let me interrupt
you before you forget before

486
00:25:10.570 --> 00:25:13.600
I forget. So you're saying
that because HTTP is the

487
00:25:13.600 --> 00:25:17.020
transport, you, you're not just
using the URL style, you're

488
00:25:17.020 --> 00:25:20.290
not just using HTTP verbs,
but other things he tags

489
00:25:20.290 --> 00:25:22.960
and not modified and things
like that. That's meaningful. Well,

490
00:25:23.110 --> 00:25:26.530
yeah, that's correct. Okay. That's
a really important point for

491
00:25:26.530 --> 00:25:30.070
people to understand. Yeah. And
there's one of the neat

492
00:25:30.100 --> 00:25:32.560
neater features of catch TV
as a, as a real

493
00:25:32.560 --> 00:25:35.200
time feed of stuff that
happens in the database. So

494
00:25:35.200 --> 00:25:38.410
we can have like a
live update of Cassius invalidate

495
00:25:38.410 --> 00:25:41.080
that key right now, because
it's not valid anymore. So

496
00:25:41.080 --> 00:25:44.140
we can for hot data,
we can preemptively updated for

497
00:25:44.140 --> 00:25:46.270
the cash, or just at
least tell the calf she

498
00:25:46.270 --> 00:25:52.600
can evict that particular keynote.
What about like big bulk

499
00:25:52.600 --> 00:25:55.090
document inserts? Is this something
that's just for little records

500
00:25:55.090 --> 00:25:56.560
and stuff, or if I
was going to go and

501
00:25:56.890 --> 00:26:00.130
do, you know, big bunches
of information, or maybe throw

502
00:26:00.130 --> 00:26:02.740
in some binaries and pictures
and some PDFs and things

503
00:26:02.740 --> 00:26:06.130
like that. All right, cool.
That's two questions. One, the

504
00:26:06.160 --> 00:26:09.130
bulk insertion is a feature
we have just like a

505
00:26:09.130 --> 00:26:12.370
post endpoint that just takes
a specific piece structured, Jason,

506
00:26:12.430 --> 00:26:14.980
that isn't standard or anything,
but it's very trivial. It's

507
00:26:14.980 --> 00:26:17.800
just a list of documents
basically. And you can throw

508
00:26:17.800 --> 00:26:19.240
it at couch to me
and we'll just start in

509
00:26:19.240 --> 00:26:21.580
bulk. And then we'll be
faster than like starting every

510
00:26:22.120 --> 00:26:28.030
one, every single one on
their own. And the other

511
00:26:28.030 --> 00:26:31.360
question was binary data catch
to be, has this idea

512
00:26:31.360 --> 00:26:34.270
of attachments. And if you've
ever done that attachments and

513
00:26:34.270 --> 00:26:36.640
email, which everybody has, you
already know how it works.

514
00:26:36.640 --> 00:26:39.520
And so the list of
keys or key value pairs

515
00:26:40.440 --> 00:26:43.110
attached to a document that
is just a name and

516
00:26:43.110 --> 00:26:46.620
some typing involved, and you
can have as many of

517
00:26:46.620 --> 00:26:51.800
you as you, as you
like, There's, there's some other

518
00:26:51.800 --> 00:26:54.530
databases in the world that
also have the name couch.

519
00:26:55.160 --> 00:26:59.060
And I don't understand you.
There was, there was one

520
00:26:59.060 --> 00:27:01.970
couch DB, and then there's
couch base. These are different

521
00:27:01.970 --> 00:27:04.550
things. Is that Right? That
is correct. And it's a

522
00:27:04.550 --> 00:27:10.760
bit of an unfortunate history,
but let me explain. Couchbase

523
00:27:10.940 --> 00:27:14.270
came out of a merger
for a company that was

524
00:27:14.270 --> 00:27:17.420
doing catch to be development
called <inaudible> and the company

525
00:27:17.420 --> 00:27:21.350
that was doing memcache Membase,
he kind of things called

526
00:27:21.350 --> 00:27:23.840
Membase and they merged into
a thing called church base

527
00:27:23.840 --> 00:27:26.930
and the name of the
company and the, the product

528
00:27:26.930 --> 00:27:30.530
after it. And members is
actually, we talked about memcache

529
00:27:30.530 --> 00:27:34.880
earlier is the codifications of
best practices for memcache servers.

530
00:27:35.000 --> 00:27:38.150
So it just implements a
sharding, a scenario where you

531
00:27:38.150 --> 00:27:40.160
don't have to recharge every
time you add a new

532
00:27:40.160 --> 00:27:43.220
system, or can you machine
to the whole cluster. And

533
00:27:43.220 --> 00:27:45.530
it does that very well.
It also adds persistence. So

534
00:27:45.530 --> 00:27:48.020
when you lose a machine
and then it restarts, maybe

535
00:27:48.020 --> 00:27:50.150
you don't have to load
the data from all the

536
00:27:50.150 --> 00:27:53.390
other machines. A memory is
if you're in a failure

537
00:27:53.390 --> 00:27:55.790
scenario, that's a lot of
arrows going on. You don't

538
00:27:55.790 --> 00:27:58.250
want to have extra load
repopulating in your notes. So

539
00:27:58.250 --> 00:28:00.230
you can just read from
this and it's it's online

540
00:28:00.230 --> 00:28:02.300
again. And it also allows
you to store more data

541
00:28:02.720 --> 00:28:07.760
than you have a memory
available for. And at some

542
00:28:07.760 --> 00:28:11.240
point they were using SQL
Lite as the backend storage,

543
00:28:11.300 --> 00:28:13.730
and they thought that's not
very flexible because they couldn't,

544
00:28:13.970 --> 00:28:15.710
it was working very well
as a key value store,

545
00:28:15.710 --> 00:28:17.990
but not for dynamic queries
on the things that we're

546
00:28:17.990 --> 00:28:20.060
doing. And they thought <inaudible>
was the better backend for

547
00:28:20.060 --> 00:28:25.340
it. So these companies merged
the products. How should it

548
00:28:25.340 --> 00:28:29.480
be like to think ology
is now behind Couchbase, but

549
00:28:29.480 --> 00:28:32.000
the thing that are defining
for, for coach to be

550
00:28:32.150 --> 00:28:38.900
the, the HTTP storage and
the multi-master replication feature, which

551
00:28:38.900 --> 00:28:40.550
I'd like to talk about
a bit in a second

552
00:28:41.450 --> 00:28:45.260
are, are part of Couchbase
as is, which is, which

553
00:28:45.410 --> 00:28:50.540
adds to the confusion to,
well, to save their, save

554
00:28:50.540 --> 00:28:54.470
their owner. Couchbase did plan
to make it look like

555
00:28:54.470 --> 00:28:57.320
a couch to, but engineering
reality made it not work

556
00:28:57.320 --> 00:28:59.120
out that way. So they
focused on the thing that

557
00:28:59.120 --> 00:29:01.610
they could ship in time
to make the customers happy,

558
00:29:01.970 --> 00:29:03.920
which is catching me in
the backend Membase in the

559
00:29:03.920 --> 00:29:07.850
front, but they don't share
any code. There's some code

560
00:29:07.850 --> 00:29:11.570
that like Couchbase is also
can online and see hybrid

561
00:29:11.630 --> 00:29:13.640
all data's done and see
an old management is done

562
00:29:13.640 --> 00:29:16.370
an airline. So that's some
code that is shared. And,

563
00:29:17.210 --> 00:29:19.610
but ultimately there are different
systems. I see. And they

564
00:29:19.610 --> 00:29:22.790
just, they're both named couch
and that's unfortunate, but there

565
00:29:22.790 --> 00:29:26.780
are different things. Yeah. That's
a historic historic accident. And

566
00:29:26.780 --> 00:29:27.830
then what was the other
thing that you said that

567
00:29:27.830 --> 00:29:30.770
you wanted to make sure
we touched on The replication

568
00:29:30.770 --> 00:29:34.970
feature? If there's there's it's
if people ask what's the

569
00:29:34.970 --> 00:29:37.130
one, like, why would you
use couch? And there's the

570
00:29:37.160 --> 00:29:40.070
one defining feature that everybody
agrees is the one thing

571
00:29:40.070 --> 00:29:42.880
that is cut to be
is for, we called it

572
00:29:42.880 --> 00:29:45.880
replication. Other people know the
same thing as sync and

573
00:29:46.450 --> 00:29:49.090
well, you know, database replication
from other databases, but ours

574
00:29:49.090 --> 00:29:53.470
is a little bit different
than I kinda think of

575
00:29:53.470 --> 00:29:56.380
it as like the, the
get the databases does what

576
00:29:56.500 --> 00:29:59.920
it does for your application
data. And not in the

577
00:29:59.920 --> 00:30:02.500
sense that you have like
a lot of diffing going

578
00:30:02.500 --> 00:30:05.200
on and merging stuff, but
more, I have a local

579
00:30:05.200 --> 00:30:07.660
copy of my data, and
I want to show you

580
00:30:07.660 --> 00:30:09.220
what I have, and then
I can replicate it to

581
00:30:09.220 --> 00:30:10.660
you. And now you have
the full set of data

582
00:30:10.660 --> 00:30:11.830
as well, and you can
look at it and you'll

583
00:30:11.830 --> 00:30:13.180
find a bunch of issues
with it and you can

584
00:30:13.180 --> 00:30:16.570
fix it. And then I
replicated your changes back, but

585
00:30:16.570 --> 00:30:18.550
you also showed it to
your friend and they found

586
00:30:18.550 --> 00:30:20.020
a bunch of issues or
edit a bit of data

587
00:30:20.020 --> 00:30:22.750
and they can get both
your stuff back into my

588
00:30:22.840 --> 00:30:24.820
copy. And we think it's
all good. I can push

589
00:30:24.820 --> 00:30:27.670
it to a live server.
And then my continued continuous

590
00:30:27.670 --> 00:30:29.380
integration will pick it up
and check all the data

591
00:30:29.380 --> 00:30:33.100
again, without all our automated
tests. And when that's all,

592
00:30:33.100 --> 00:30:35.680
okay, push it to the
production system. Like kind of

593
00:30:35.680 --> 00:30:38.320
how you're thinking about doing
code deployment with get, but

594
00:30:38.320 --> 00:30:41.470
for your application, data can
live everywhere and that's pretty

595
00:30:41.470 --> 00:30:46.880
cool and fairly unique to,
to catch DV. That is

596
00:30:46.880 --> 00:30:50.640
his automatic kind of imposed
workflow versus is, are those

597
00:30:50.640 --> 00:30:52.500
methods that I call or
how do I make that

598
00:30:52.500 --> 00:30:57.990
happen? Oh, so the fundamental
procedure, as you have very

599
00:30:57.990 --> 00:31:01.740
limited, it's just replicate this
database to another database and

600
00:31:01.740 --> 00:31:04.350
this database can be a
local or remote one, or

601
00:31:04.470 --> 00:31:06.660
the targeted one can also
be local or remote one.

602
00:31:06.700 --> 00:31:09.750
So it can go either
way, whichever way you want,

603
00:31:10.170 --> 00:31:13.410
and then whatever management you
want on top of like

604
00:31:13.410 --> 00:31:16.560
automation automatically puts everything. There's
some, some hooks for that,

605
00:31:16.560 --> 00:31:19.140
but usually you script that
yourself And do I just

606
00:31:19.140 --> 00:31:21.600
declare one authoritative? Cause I
feel like it, like, you

607
00:31:21.600 --> 00:31:25.230
know, Linus owns this, get
one, get repository. Cause he's

608
00:31:25.230 --> 00:31:28.020
Linus. Cause we said so.
Or is there a formalization

609
00:31:28.020 --> 00:31:30.990
of who's on top? Nope.
There is that's ad hoc.

610
00:31:30.990 --> 00:31:33.240
Like whatever you want to
be the master at semester

611
00:31:33.300 --> 00:31:36.540
or there's no master, if
you want that. Very cool.

612
00:31:36.900 --> 00:31:39.930
Right. So people can go
up to guide dot couch,

613
00:31:39.930 --> 00:31:43.860
db.org. And is the whole
book up there, the definitive

614
00:31:43.860 --> 00:31:46.710
guide. Yeah. That was a
very sweet deal that really

615
00:31:46.710 --> 00:31:49.950
allowed us to do. We
were writing the, to documentation

616
00:31:49.950 --> 00:31:51.690
anyway, and we told them
like, we're not coming right

617
00:31:51.690 --> 00:31:53.760
at twice, so you better
let us opensource it. And

618
00:31:53.760 --> 00:31:55.080
they're like, yeah, that's cool.
And we're like, Oh my

619
00:31:55.080 --> 00:31:57.300
God, it works cool. So
we, the book is open

620
00:31:57.300 --> 00:32:01.170
source, the whole book. It's
a, it's a work in

621
00:32:01.170 --> 00:32:04.200
progress. You've got English, German,
French, Spanish. You've got an

622
00:32:04.200 --> 00:32:06.750
English draft that's being worked
on and people can submit

623
00:32:06.750 --> 00:32:09.360
corrections as well. If they
find any problems. Yeah. It's

624
00:32:09.360 --> 00:32:11.730
all good help. You can
forget. It's going to be

625
00:32:11.730 --> 00:32:14.010
part of the official catch
to be documentation too. So

626
00:32:14.010 --> 00:32:15.750
a lot more people can
look at it as well.

627
00:32:15.810 --> 00:32:21.930
And then some new new
ideas or error corrections. And

628
00:32:21.930 --> 00:32:25.410
then every like every major,
what version, Alrighty, we'll just

629
00:32:25.410 --> 00:32:27.780
take a cut, then print
a book or promote an

630
00:32:27.780 --> 00:32:30.750
ebook that they can sell
them. And a lot of

631
00:32:30.930 --> 00:32:33.480
the people who are listening
to the show are.net people

632
00:32:33.480 --> 00:32:37.380
or windows people. Can we
use couch DB on windows?

633
00:32:37.830 --> 00:32:41.600
Yeah, of course. RN support
for windows is very, very

634
00:32:41.600 --> 00:32:44.060
good and can be supported
as well. So we ship

635
00:32:44.180 --> 00:32:47.150
windows binary with every release.
You can just, don't like,

636
00:32:47.150 --> 00:32:49.340
it's an installer thing and
you can just double click

637
00:32:49.340 --> 00:32:52.180
and install. It just runs
as a windows service and

638
00:32:52.180 --> 00:32:54.880
does its thing. Yeah. Or
you can be in there's

639
00:32:54.880 --> 00:32:57.280
some configuration there, but I
think the minimum thing I

640
00:32:57.280 --> 00:32:59.320
want to do is run
it as a service. I

641
00:32:59.320 --> 00:33:01.450
see. Very cool. And it
looks like there's lots of

642
00:33:02.620 --> 00:33:05.110
public C-sharp libraries. If I,
if I don't want to

643
00:33:05.290 --> 00:33:07.990
just talk to it myself,
there's relax and there's sharp

644
00:33:07.990 --> 00:33:11.080
couch and things like that.
But like you said, I

645
00:33:11.080 --> 00:33:13.360
can just talk to this
with an HTTP client and

646
00:33:13.360 --> 00:33:16.960
build my own wrappers, whatever
it looks like my data.

647
00:33:17.740 --> 00:33:20.440
Okay. Very cool. Well, thanks
so much for chatting with

648
00:33:20.440 --> 00:33:22.750
me today. I really Well,
thanks for having me. This

649
00:33:22.750 --> 00:33:25.510
was fun. I'll put up
all of the links to

650
00:33:25.540 --> 00:33:28.390
couch DB and the guide
up on the show notes.

651
00:33:28.810 --> 00:33:31.690
This has been another episode
of Hanselminutes and we'll see

652
00:33:31.690 --> 00:33:32.590
you again next week.


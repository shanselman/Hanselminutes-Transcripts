WEBVTT FILE

1
00:00:04.380 --> 00:00:17.540
<inaudible> From Hansel minutes.com. It's
Hansel minutes, a weekly discussion

2
00:00:17.540 --> 00:00:21.290
with web developer and technologist
is Scott Hanselman. This is

3
00:00:21.290 --> 00:00:26.870
Lawrence Ryan announcing show number one
91 reported live Thursday, December 3rd, 2009.

4
00:00:27.590 --> 00:00:31.160
Support for Hanselman. This is
provided by Tellerik rad controls,

5
00:00:31.580 --> 00:00:34.610
the most comprehensive suite of
components for windows forms and

6
00:00:34.610 --> 00:00:44.210
asp.net web applications online@wwwdottelerik.com. In
this episode, Scott talks with

7
00:00:44.300 --> 00:00:50.570
Nathan Brooksy is with the
solver foundation team Scott Hanselman.

8
00:00:50.570 --> 00:00:52.220
And this is another episode
of Hansel minutes, and I'm

9
00:00:52.220 --> 00:00:55.490
on campus at Microsoft here
in Redmond, Washington, wandering around

10
00:00:55.490 --> 00:00:57.740
the halls and talking to
lots of interesting people. And

11
00:00:57.950 --> 00:01:00.170
I'm actually sitting down here
with Nathan bricks. He is

12
00:01:00.170 --> 00:01:03.320
with the solver foundation team.
That sounds like a really

13
00:01:03.530 --> 00:01:08.000
complicated team, the solver foundation
team. What is the solver

14
00:01:08.000 --> 00:01:11.390
finishing team? So the, the
solid foundation team has been

15
00:01:11.390 --> 00:01:13.400
around for a few years
and we had our first

16
00:01:13.400 --> 00:01:17.120
release last year. What we
are is a basically a.net

17
00:01:17.840 --> 00:01:23.360
platform for modeling and solving
like planning, scheduling, and optimization

18
00:01:23.360 --> 00:01:27.710
problems. So we build a
library that.net programmers can use

19
00:01:28.160 --> 00:01:32.060
to model and solve optimization
problems. Okay. So what is

20
00:01:32.060 --> 00:01:35.060
an optimization problem? Well, there
you find them all over

21
00:01:35.060 --> 00:01:39.890
the place. Actually. There's lots
of interesting examples. For example,

22
00:01:39.890 --> 00:01:45.680
suppose you are an investor
and you're trying to take

23
00:01:45.680 --> 00:01:49.070
your, take your money and
spread it across some different

24
00:01:49.070 --> 00:01:51.800
investments in a way that
will give you a nice

25
00:01:51.800 --> 00:01:55.040
return, but not be too
risky. That's an example of

26
00:01:55.040 --> 00:01:58.010
an optimization problem. You have
a goal in mind, but

27
00:01:58.010 --> 00:02:00.920
you also have some, some
constraints that you're operating other

28
00:02:00.980 --> 00:02:05.390
under another one might be
maybe you're a scheduling a

29
00:02:05.390 --> 00:02:09.110
conference, or maybe you're scheduling
your classes at school. That's

30
00:02:09.110 --> 00:02:12.080
another example. You have some,
some goals in mind, maybe

31
00:02:12.080 --> 00:02:14.060
not to get up too
early or to have your

32
00:02:14.060 --> 00:02:18.050
classes run consecutively. And also
some constraints like you can't

33
00:02:18.050 --> 00:02:20.120
go to two classes at
the same time, for example.

34
00:02:20.600 --> 00:02:26.330
So you find optimization problems
in finance and scheduling. Like

35
00:02:26.360 --> 00:02:30.140
there are many supply chain
problems. For example, you're trying

36
00:02:30.140 --> 00:02:33.080
to get products from, from
place to place at low

37
00:02:33.080 --> 00:02:36.650
cost. And so on. Is
the travelers the classic traveling

38
00:02:36.650 --> 00:02:41.990
salesman problem, a optimization problem?
Absolutely. It's, that's a classic

39
00:02:41.990 --> 00:02:46.460
example of a actually a
difficult optimization problem. There's there's

40
00:02:46.460 --> 00:02:51.830
many different kinds. Some optimization
problems are solved pretty easily,

41
00:02:51.830 --> 00:02:55.250
and there are others like
the traveling salesman problem where

42
00:02:55.250 --> 00:03:01.990
the number of possible solutions
blows up exponentially with the

43
00:03:01.990 --> 00:03:04.630
number of cities in, in
the problem. And so you

44
00:03:04.630 --> 00:03:08.920
have to resort to some
pretty heavy duty techniques to

45
00:03:08.980 --> 00:03:12.390
find solutions to those sorts
of problems. So w with

46
00:03:12.390 --> 00:03:15.150
all due respect to your
team, it's probably fair to

47
00:03:15.150 --> 00:03:18.390
say that the, the chances
of the listener having heard

48
00:03:18.390 --> 00:03:21.900
of this library is probably
a low, would you say

49
00:03:21.900 --> 00:03:25.290
that this is not a
mainstream, like bump into a.net

50
00:03:25.290 --> 00:03:27.030
developer on the street? Hey,
yeah. You're checking out the

51
00:03:27.030 --> 00:03:30.630
solver foundation stuff. Oh yeah,
Totally. Yeah, exactly. It's a,

52
00:03:30.630 --> 00:03:33.570
we're, we're a new team
where up and coming, and

53
00:03:33.570 --> 00:03:38.790
it is something that traditionally
in the past is optimization

54
00:03:38.790 --> 00:03:42.240
has kind of been hidden
away from, from the general

55
00:03:42.240 --> 00:03:46.980
public in part, because it's,
it's been pretty, pretty hard

56
00:03:46.980 --> 00:03:50.160
to get your hands on
and pretty difficult to actually

57
00:03:50.520 --> 00:03:54.810
use in a real live
production applications. One of our

58
00:03:54.810 --> 00:03:56.730
goals that it's trying to
make it more accessible for

59
00:03:56.730 --> 00:03:59.340
people, Then I would take
it. So if I would

60
00:03:59.340 --> 00:04:01.320
take even farther to say,
is it fair to say

61
00:04:01.320 --> 00:04:05.700
that the average dominant developer
doesn't know about your library

62
00:04:05.700 --> 00:04:07.860
and your group, but they
very likely have one of

63
00:04:07.860 --> 00:04:10.680
these problems and they may
not even realize it. Absolutely.

64
00:04:10.680 --> 00:04:12.120
They may have been solving.
It was just a series

65
00:04:12.120 --> 00:04:17.820
of four loops and magic.
Absolutely, absolutely. Yeah. Programmers come

66
00:04:17.820 --> 00:04:20.730
up with, come across these
problems all the time. And

67
00:04:20.730 --> 00:04:22.680
as you say, many times,
what you do is maybe

68
00:04:22.680 --> 00:04:26.400
you will just dream up
something on the spot or

69
00:04:26.400 --> 00:04:28.950
more you'll, you'll do a
little, do a little search

70
00:04:28.950 --> 00:04:31.440
or maybe a, you know,
you'll crack open your, one

71
00:04:31.440 --> 00:04:34.110
of your textbooks from college,
one of your algorithms textbooks

72
00:04:34.110 --> 00:04:38.550
or something, and dig in
there. But of course that's

73
00:04:38.550 --> 00:04:40.860
not what we do for
many other tasks that we

74
00:04:40.860 --> 00:04:43.950
have as programmers like sorting,
you know, most of us,

75
00:04:44.100 --> 00:04:46.920
hopefully if we need to
sort some numbers or we're

76
00:04:46.920 --> 00:04:48.300
not going to go and
try to write our own

77
00:04:48.300 --> 00:04:50.730
sorting algorithm, we're going to
go, we're going to understand

78
00:04:50.730 --> 00:04:52.290
that there are libraries out
there that help us to

79
00:04:52.290 --> 00:04:54.790
do that. And they've been
well tested. And so on.

80
00:04:54.820 --> 00:04:56.220
We go to that. So
what our goal is to

81
00:04:56.220 --> 00:05:00.330
try to try to make
this, these really powerful tools

82
00:05:00.330 --> 00:05:04.560
accessible to people. And it
does take, it takes time

83
00:05:04.560 --> 00:05:08.010
to sort of build up,
you know, education about what

84
00:05:08.010 --> 00:05:09.450
it is that we're doing,
and also to help people

85
00:05:09.450 --> 00:05:12.090
to understand the ways in
which this could be used.

86
00:05:12.090 --> 00:05:15.660
Cause it is very broadly
applicable. Okay. Okay. So this

87
00:05:15.660 --> 00:05:17.730
is something that I download
and it's a series of

88
00:05:17.760 --> 00:05:20.790
improv DLS. That's right. In
fact, it's one. So you

89
00:05:20.790 --> 00:05:26.550
can go to solver, foundation.com
and there's an ex free

90
00:05:26.640 --> 00:05:31.140
express edition, which has all
the functionality that so you

91
00:05:31.140 --> 00:05:34.320
can download it. It's a
managed code DLL. So for

92
00:05:34.320 --> 00:05:37.230
example, if you're a, a
C sharp programmer, you can

93
00:05:37.230 --> 00:05:40.500
add a reference to this,
all our foundation DLL into

94
00:05:40.500 --> 00:05:44.220
your project. And then you
can follow along with the,

95
00:05:44.880 --> 00:05:46.950
you know, the samples that
get downloaded as well, and

96
00:05:46.950 --> 00:05:50.820
then start, you know, trying
it out, building some models

97
00:05:50.820 --> 00:05:53.370
and solving them. Okay. So
building some models and sergeants,

98
00:05:53.370 --> 00:05:55.920
that was kind of my
next question. Like, like this

99
00:05:55.920 --> 00:06:00.050
is a group that creates
this with this one, this

100
00:06:00.050 --> 00:06:02.780
one DLL. So it must
be complicated. I mean, it

101
00:06:02.780 --> 00:06:03.890
must be a lot of
magic in there and it

102
00:06:03.890 --> 00:06:07.820
must scale from very small,
basic samples up to pretty

103
00:06:08.120 --> 00:06:14.350
intense. Could you even multi
machine? So That's actually a

104
00:06:14.350 --> 00:06:19.210
great question right now. You
can't do multi machine solves.

105
00:06:19.480 --> 00:06:22.240
I mean, we won't do
it for it. You'd have

106
00:06:22.240 --> 00:06:23.800
to chop it up yourself.
You have to chop it

107
00:06:23.800 --> 00:06:27.460
up yourself. But we, what
we do do right now

108
00:06:27.460 --> 00:06:31.120
is use all of the
cores, all the processors on

109
00:06:31.120 --> 00:06:35.230
your machine. So if you
have a problem, which is

110
00:06:35.910 --> 00:06:41.860
particularly difficult, based on solar
foundation, we'll do an analysis

111
00:06:41.860 --> 00:06:44.170
of the problem and chop
it up into pieces and

112
00:06:44.170 --> 00:06:47.200
use all of the processes
on your machine to solve

113
00:06:47.200 --> 00:06:51.250
it. And that's something that
even someone who maybe knows

114
00:06:51.250 --> 00:06:54.850
a lot about the algorithms
and the solution techniques, they

115
00:06:54.850 --> 00:06:58.480
might not know how to
do that analysis and make

116
00:06:58.480 --> 00:07:00.940
use of all the computational
power on the machine, as

117
00:07:00.940 --> 00:07:04.900
you know, these days, pretty
much any machine that you'll

118
00:07:04.900 --> 00:07:08.410
pick up these days has
several cores. I mean, it's,

119
00:07:08.430 --> 00:07:11.470
it's, it's fairly trivial to
spin up a background thread,

120
00:07:11.470 --> 00:07:14.110
right. And when people think
about multiprocessing, they might think,

121
00:07:14.110 --> 00:07:15.910
well, yeah, I've got this
and I've got my background

122
00:07:15.910 --> 00:07:19.180
thread, but even with something
like the new parallel extensions

123
00:07:19.180 --> 00:07:21.040
and the stuff that, you
know, Steven Tobin, those guys

124
00:07:21.040 --> 00:07:24.310
are doing around the PFX
still too, even if I

125
00:07:24.310 --> 00:07:26.800
knew the algorithm and I
understood parallel extensions, it would

126
00:07:26.810 --> 00:07:31.930
still be nontrivial, right. A
multi proc multi-core solver. Exactly.

127
00:07:32.110 --> 00:07:34.360
Exactly. So what kind of
data structures am I creating?

128
00:07:34.360 --> 00:07:36.550
Is this a, is this
a declarative model where I

129
00:07:36.550 --> 00:07:38.860
described the problem in a
series of data structures and

130
00:07:38.860 --> 00:07:42.040
then hand it to you?
That's, that's exactly right. It's

131
00:07:42.730 --> 00:07:47.200
our focus, what we want
users of solid foundation to

132
00:07:47.200 --> 00:07:52.030
be able to do is
just think about what their

133
00:07:52.030 --> 00:07:55.240
problem is rather than how
to solve it. So it

134
00:07:55.240 --> 00:08:02.830
is a declarative, a declarative
framework. And so the representation

135
00:08:02.830 --> 00:08:05.890
of the problem that you
want to solve in solid

136
00:08:05.890 --> 00:08:09.940
foundation is called a model.
And so the model has

137
00:08:11.230 --> 00:08:13.870
just a few building blocks.
So it has, for example,

138
00:08:14.170 --> 00:08:20.260
a goal, like describe some
goals earlier, for example, find

139
00:08:20.260 --> 00:08:24.010
a minimum risk investment portfolio.
I think that's a good

140
00:08:24.010 --> 00:08:27.070
example we can use to
walk people through this. So

141
00:08:27.370 --> 00:08:29.980
there's, there's an example of
a goal and that's the

142
00:08:29.980 --> 00:08:32.500
thing your, it could be
a business objective. How do

143
00:08:32.500 --> 00:08:34.090
I describe that? I mean,
it's easy to say in

144
00:08:34.090 --> 00:08:36.550
pros, but how do I
describe a goal like minimum

145
00:08:36.550 --> 00:08:41.860
risks In code? Got it.
Well, what solver foundation offers

146
00:08:41.860 --> 00:08:46.450
is a, basically a toolbox
and expression language that lets

147
00:08:46.450 --> 00:08:52.480
you define these. So define
these goals essentially, you know,

148
00:08:52.480 --> 00:08:57.390
mathematically or algebraically. So you,
in this example, we're talking

149
00:08:57.390 --> 00:09:02.430
about if it's a minimum
risk portfolio, I might want

150
00:09:02.460 --> 00:09:12.030
to look at the, the
risk associated, the correlation between

151
00:09:12.720 --> 00:09:17.160
two different types of investments.
So like stocks and bonds,

152
00:09:17.730 --> 00:09:21.450
and I might want to
multiply those sort of risk

153
00:09:21.450 --> 00:09:25.470
factors with the amount of
money that I have decided

154
00:09:25.470 --> 00:09:29.460
to allocate to a particular
investment category. And so if

155
00:09:29.460 --> 00:09:34.620
I like, for example, 30%,
30% of my money, I

156
00:09:34.680 --> 00:09:38.730
might want to allocate to
bonds. And so I multiply

157
00:09:38.730 --> 00:09:41.430
that with these risk factors
and I add them all

158
00:09:41.430 --> 00:09:45.000
up and that gives me
a, an expression which represents

159
00:09:45.000 --> 00:09:48.810
the total amount of risk
in the portfolio. So solver

160
00:09:48.810 --> 00:09:54.390
foundation has it lets you
use this, you know, standard

161
00:09:54.390 --> 00:09:57.090
like plus and minus and
times and those sorts of

162
00:09:57.090 --> 00:10:00.270
things. And it will as
well as adding some additional

163
00:10:01.120 --> 00:10:06.930
constructs that let you combine
these building blocks into goals.

164
00:10:07.530 --> 00:10:10.160
So thinking, and forgive me
if I'm speaking to you

165
00:10:10.160 --> 00:10:12.350
as I'm a more like
a four year old or

166
00:10:12.350 --> 00:10:14.510
five-year-old here, but you know,
trying to get the, get

167
00:10:14.510 --> 00:10:17.300
down to the basics of
this is this like a,

168
00:10:17.300 --> 00:10:20.600
when I was doing algebra
and doing multivariable solving where

169
00:10:20.600 --> 00:10:22.670
it's like, yeah, it's easy
to solve for X now

170
00:10:22.670 --> 00:10:24.830
solve for X, Y, and
Z where you're trying to

171
00:10:24.830 --> 00:10:28.730
minimize Z. Right. Whereas is
that an example? That is

172
00:10:28.730 --> 00:10:33.260
definitely that's an example. And
yeah, So I've got a

173
00:10:33.260 --> 00:10:36.420
series of goals that I
want to meet. And then

174
00:10:36.440 --> 00:10:38.900
like in the, my X,
Y Z example, I really

175
00:10:38.900 --> 00:10:41.870
want to solve for something
that meets a goal with

176
00:10:41.870 --> 00:10:44.120
some constraints. So it's not
just about finding a goal,

177
00:10:44.120 --> 00:10:46.280
but it's about finding the
goal within the constraints. And

178
00:10:46.280 --> 00:10:49.250
is it those constraints that
make the problem difficult? Cause

179
00:10:49.250 --> 00:10:51.380
I want the listener to
understand like the ones that

180
00:10:51.380 --> 00:10:54.860
are still awake at this
point, because we're talking math,

181
00:10:54.860 --> 00:10:59.780
right. That this is, this
is hard because to find

182
00:10:59.780 --> 00:11:03.560
the optimum, That's the goal
that's right. That there are

183
00:11:05.390 --> 00:11:09.950
it's it's, it's, it's extremely
complicated, but that's absolutely, it's

184
00:11:09.950 --> 00:11:13.790
true to say that when
you combine the goals with

185
00:11:13.970 --> 00:11:17.810
having to, you know, meet
some of these constraints, you

186
00:11:17.810 --> 00:11:21.230
have a, you can oftentimes
have a very difficult problem.

187
00:11:21.710 --> 00:11:24.350
I mean, we can, if
we get to go back

188
00:11:24.350 --> 00:11:29.600
to the traveling salesman example,
Let me look for the

189
00:11:29.630 --> 00:11:31.640
listeners who may not be
familiar with that problem. Explain

190
00:11:31.640 --> 00:11:35.360
the basics of the traveler.
The idea is that there's

191
00:11:35.360 --> 00:11:40.130
a salesman who is going
out selling products in different

192
00:11:40.130 --> 00:11:43.310
cities. Like let's say five
cities and the salesman wants

193
00:11:43.310 --> 00:11:46.160
to drive around to the
visit each of the five

194
00:11:46.640 --> 00:11:52.400
cities, but he or she
wants to do so visit

195
00:11:52.400 --> 00:11:56.320
each one of the cities
once, but minimize the amount

196
00:11:56.320 --> 00:11:58.560
of distance that they're driving.
Right? So they want to

197
00:11:58.560 --> 00:12:00.330
hit every city. Cause they're
a salesman. They don't want

198
00:12:00.330 --> 00:12:02.250
to visit cities twice because
that's a waste of gas.

199
00:12:03.600 --> 00:12:05.880
And then they've got multiple
ways to get to a

200
00:12:05.880 --> 00:12:08.790
city because there's multiple roads,
right? How do you find,

201
00:12:08.830 --> 00:12:12.420
how do you visit every
single city minimizing the space

202
00:12:12.420 --> 00:12:14.700
and the number of trips
per city, right? So if

203
00:12:14.700 --> 00:12:17.880
you break it down, right,
the goal is minimize the

204
00:12:17.940 --> 00:12:21.630
travel distance and a constraint.
We just listen. We just

205
00:12:22.230 --> 00:12:24.690
to visit a city twice,
can't visit a city twice,

206
00:12:24.970 --> 00:12:29.550
need to visit every city
at once. Seems simple, seems

207
00:12:29.550 --> 00:12:33.330
simple, simple. And you can
basically, if you write down

208
00:12:33.330 --> 00:12:35.730
that prose description of the
problem, you can sort of

209
00:12:35.730 --> 00:12:37.770
underline, Oh, here's a constraint,
here's a goal. And so

210
00:12:37.770 --> 00:12:41.130
on each one of those
components is not too difficult

211
00:12:41.130 --> 00:12:44.280
to understand right now you
put it all together and

212
00:12:44.280 --> 00:12:47.340
you try to say now,
okay, now what's the optimal

213
00:12:47.460 --> 00:12:50.850
right to, or what's the
best tour sequence of cities

214
00:12:50.850 --> 00:12:54.030
to visit. That is an
extremely complicated problem. And that's

215
00:12:54.030 --> 00:12:57.510
an interesting example because that's
a case where coming up

216
00:12:57.510 --> 00:13:01.350
with a, a solution that
meets all of the constraints

217
00:13:01.440 --> 00:13:04.380
is really easy, right? I
mean, if I say the,

218
00:13:04.960 --> 00:13:09.540
the cities are Atlanta, Boston,
Chicago, Dallas, you can just

219
00:13:09.540 --> 00:13:11.520
eyeball it. You can come
up with all sorts of

220
00:13:11.520 --> 00:13:14.820
solutions, Right. But now take
the traveling sales problem, traveling

221
00:13:14.820 --> 00:13:19.110
salesman problem, and make it
a multi-city 20, 30 cities

222
00:13:19.110 --> 00:13:22.710
situation where you've got a
truck of produce and you've

223
00:13:22.710 --> 00:13:25.170
got to get the apples
to Dallas before they rot.

224
00:13:25.290 --> 00:13:28.800
Exactly. Then things get a
little more interesting. Exactly. Okay.

225
00:13:28.800 --> 00:13:30.120
That was that the kind
of thing that you're trying

226
00:13:30.120 --> 00:13:33.990
to solve. Absolutely. And so
the way I think the

227
00:13:33.990 --> 00:13:38.580
beauty of what we're offering
with solver foundation is you

228
00:13:38.580 --> 00:13:42.240
can say you start with
a traveling salesman problem when

229
00:13:42.240 --> 00:13:44.790
you're able to list out
the goals and the constraints

230
00:13:44.790 --> 00:13:48.330
and so on. Well, now
you can add, now you

231
00:13:48.330 --> 00:13:52.650
can add more constraints to
the problem, for example, the

232
00:13:52.650 --> 00:13:55.440
produce. Okay. So once you've
described the model correctly, so

233
00:13:55.440 --> 00:13:58.110
if I understand correctly, the
model I would describe would

234
00:13:58.110 --> 00:14:01.290
be the graph of all
the potential connections between these

235
00:14:01.290 --> 00:14:04.380
different cities, right? That's the
declaration of the, the, the

236
00:14:04.380 --> 00:14:07.080
map in this case, a
graph of paths and then

237
00:14:07.080 --> 00:14:11.340
the weights of those paths
indicating a travel distance and

238
00:14:11.340 --> 00:14:14.220
things like that. And then
the constraints are the rules

239
00:14:14.220 --> 00:14:17.040
that we just described. I
can add on my own

240
00:14:17.040 --> 00:14:20.310
custom rules later, I can
run the problem multiple times

241
00:14:20.310 --> 00:14:24.210
with different rules. It's all
right. With different rules or

242
00:14:24.210 --> 00:14:27.870
with different data, because the
way you would describe the

243
00:14:27.870 --> 00:14:31.020
traveling salesman problem and solve
our foundation, say that we

244
00:14:31.020 --> 00:14:35.070
started with five cities, a
simple problem. Well, you in

245
00:14:35.160 --> 00:14:38.040
solar foundation, there is a,
for each expression. So you

246
00:14:38.040 --> 00:14:41.400
could say for each city
and then an expression, which

247
00:14:41.400 --> 00:14:45.930
says visit the city exactly
once. Right? So that, that

248
00:14:45.930 --> 00:14:48.960
doesn't depend that expression doesn't
depend on there being five

249
00:14:48.960 --> 00:14:52.760
cities, right? So I can
scale up the problem size.

250
00:14:52.790 --> 00:14:56.000
You use different data, larger
data sets. For example, in

251
00:14:56.000 --> 00:14:59.690
my model, doesn't change. And
just as you said, I

252
00:14:59.690 --> 00:15:03.650
can now add new constraints
or change the constraints or

253
00:15:03.650 --> 00:15:07.970
change my goal. And I
don't have to, it's a

254
00:15:07.970 --> 00:15:12.290
much simpler process. I don't
have to start from scratch.

255
00:15:13.420 --> 00:15:15.520
Hey everybody, this is Scott
coming at you from another

256
00:15:15.520 --> 00:15:18.460
place in time. No doubt.
You'll probably bump into testing

257
00:15:18.460 --> 00:15:21.100
tasks now, and then, and
your work and, you know,

258
00:15:21.100 --> 00:15:23.590
writing functional tests is probably
not your favorite thing. It's

259
00:15:23.590 --> 00:15:25.660
kind of difficult. It takes
time and the results can

260
00:15:25.660 --> 00:15:28.900
be dubious. Well, get ready
to start liking tests. Thanks

261
00:15:28.900 --> 00:15:32.860
to Tellerik with the, the
new whereby testing framework building

262
00:15:32.860 --> 00:15:36.220
web automation test is a
breeze. You've got code automation

263
00:15:36.220 --> 00:15:39.340
with advanced asp.net Ajax, and
several applications. You can write

264
00:15:39.340 --> 00:15:42.610
a single test, have it
executed against multiple browsers at

265
00:15:42.610 --> 00:15:46.030
once. You'd benefit from a
rich API there's link support

266
00:15:46.060 --> 00:15:49.540
integration with visual studio unit
testing, also in unit X

267
00:15:49.540 --> 00:15:52.810
unit and MB unit, not
to mention the free rappers

268
00:15:52.810 --> 00:15:55.600
for Telerik rad controls for
ESPN and Ajax, and several

269
00:15:55.600 --> 00:15:59.470
light, all shipping with Telerik's
new testing tool. One of

270
00:15:59.470 --> 00:16:02.650
the best features, the webinar
testing framework, which is developed

271
00:16:02.650 --> 00:16:06.550
by art of test is
it's absolutely free. Freddie got

272
00:16:06.610 --> 00:16:09.370
hooked on web testing framework,
start using it right away,

273
00:16:09.700 --> 00:16:14.140
go to tellerik.com for more
info. Thanks a lot. Okay.

274
00:16:14.140 --> 00:16:16.480
So, so three questions just
popped into my head and

275
00:16:16.480 --> 00:16:18.340
they'll kind of all make
sense because they're all related

276
00:16:18.700 --> 00:16:22.930
with solver foundation at the
hub. I'm visualizing data coming

277
00:16:22.930 --> 00:16:26.020
in, data, going out and
then data in the form

278
00:16:26.020 --> 00:16:28.090
of constraints, kind of coming
in the middle. And I'm

279
00:16:28.090 --> 00:16:31.420
wondering in what formats can
I bring this data in?

280
00:16:31.420 --> 00:16:33.190
And how am I doing
that? Like if I've got,

281
00:16:34.480 --> 00:16:36.580
you know, a million records
of something that's in a

282
00:16:36.580 --> 00:16:39.940
database that represents some model,
and then I've got, I

283
00:16:39.940 --> 00:16:42.220
want to make this accessible
to my business users. So

284
00:16:42.220 --> 00:16:44.380
I want to plug them
into maybe Excel or some

285
00:16:44.380 --> 00:16:46.990
UI of some kind. They're
going to describe some constraints.

286
00:16:47.530 --> 00:16:49.060
And then I want the
result to come out as

287
00:16:49.060 --> 00:16:53.830
a PDF, right? How far
does pro foundation solver foundation

288
00:16:53.920 --> 00:16:57.790
stretch in each of these
directions versus just letting.net and

289
00:16:57.790 --> 00:17:00.100
the various libraries that I
have available do that work.

290
00:17:00.850 --> 00:17:04.360
Got it. So at the
very top, I said, solid

291
00:17:04.360 --> 00:17:08.820
foundation was a platform. And
I said that word first

292
00:17:08.820 --> 00:17:11.050
single deal. That's a big
word for a single DLL.

293
00:17:11.380 --> 00:17:15.040
What we want to do
is let.net do what it

294
00:17:15.040 --> 00:17:17.710
does well, and we are
not in the, we're not

295
00:17:17.710 --> 00:17:21.010
in the business. For example,
of writing out PDF files

296
00:17:21.010 --> 00:17:23.530
or reading from databases, what
we want to use. We

297
00:17:23.530 --> 00:17:25.570
want to take advantage of
all the other good stuff

298
00:17:25.570 --> 00:17:29.140
within.net to do that. So
what we do in solid

299
00:17:29.140 --> 00:17:33.610
foundation is we have a
set of data, binding APIs

300
00:17:33.610 --> 00:17:37.450
and interfaces that you can
use. So for example, if

301
00:17:37.450 --> 00:17:39.310
you have a database that
you want to read your

302
00:17:39.310 --> 00:17:42.940
data from, you can use
whatever technique you like and.net,

303
00:17:42.940 --> 00:17:47.500
for example, you know, you
could use some link expressions

304
00:17:47.500 --> 00:17:50.460
to bring down the data
and find it directly. I

305
00:17:50.460 --> 00:17:52.230
asked the question a little
bit, selfishly, because I used

306
00:17:52.230 --> 00:17:54.090
to, before I worked at
Microsoft, I work in banking.

307
00:17:54.150 --> 00:17:56.610
Yeah. All of our data
lived in mainframes and we

308
00:17:56.610 --> 00:17:58.620
would do bill payment things.
And we had a thing

309
00:17:58.620 --> 00:18:01.740
that was called least cost
routing, which I'm starting to

310
00:18:01.740 --> 00:18:04.050
realize that we solved a
problem that would have, we

311
00:18:04.050 --> 00:18:06.450
could have actually kind of
done a little coding by

312
00:18:06.450 --> 00:18:09.240
subtraction, which would mean deleting
our stuff and using your

313
00:18:09.240 --> 00:18:11.700
stuff. At least cost routing
is I've got a bunch

314
00:18:11.700 --> 00:18:13.260
of banks and I've got
a bunch of payments and

315
00:18:13.260 --> 00:18:14.220
a bunch of people want
to pay a bunch of

316
00:18:14.220 --> 00:18:18.180
other people. I have relationships
with some banks. It costs

317
00:18:18.180 --> 00:18:20.640
me this much to pay
that guy via you or

318
00:18:20.640 --> 00:18:24.300
via you or via Swift.
This least cost routing is

319
00:18:24.300 --> 00:18:26.880
the act of pay of,
of paying all of the

320
00:18:26.880 --> 00:18:29.040
different bills to all the
different people, via all the

321
00:18:29.040 --> 00:18:31.830
different banks, given all their
different prices in the way

322
00:18:31.830 --> 00:18:34.530
that would cost people, the
least amount of money. And

323
00:18:34.530 --> 00:18:39.120
we charged people, but Jillian's,
that's the official term of

324
00:18:39.120 --> 00:18:41.820
dollars for the feature that
is least cost routing. And

325
00:18:41.820 --> 00:18:45.000
that is, sounds like a
classic silver foundation problem. It

326
00:18:45.000 --> 00:18:48.260
is Absolutely a classic problem.
And I had to call

327
00:18:48.260 --> 00:18:51.920
those guys because I don't
work there anymore. Well, and

328
00:18:51.920 --> 00:18:55.970
it's funny because you find
this over and over again

329
00:18:56.030 --> 00:18:59.180
in many different industries. I
didn't recognize it though. Yeah,

330
00:18:59.180 --> 00:19:06.740
exactly. And that's the, the,
the pro and the con

331
00:19:06.740 --> 00:19:08.750
of, of working on a
team like software foundation is

332
00:19:08.750 --> 00:19:12.260
we are building something which
is very general purpose. And

333
00:19:12.260 --> 00:19:14.180
so one of the challenges
that we have as a

334
00:19:14.180 --> 00:19:19.100
team is to really have
good examples and good case

335
00:19:19.100 --> 00:19:22.520
studies and things of that
that give people the inspiration,

336
00:19:23.050 --> 00:19:25.430
help people understand all the
different ways that this could

337
00:19:25.430 --> 00:19:27.890
be used. How do you
get the word out though?

338
00:19:27.890 --> 00:19:31.340
I mean, there's not a
foundation solver solver foundation, rather

339
00:19:31.340 --> 00:19:35.060
a evangelist. No, I guess
I'm as close as you

340
00:19:35.060 --> 00:19:38.780
get, right. You're a dev,
right? Yeah. I write code.

341
00:19:39.080 --> 00:19:42.830
I'm passionate about, you know,
optimization in this stuff. And

342
00:19:43.130 --> 00:19:45.410
I do want to see
people using it. We don't

343
00:19:45.410 --> 00:19:48.710
have a TV ads. We
don't do, do you charge

344
00:19:48.710 --> 00:19:51.770
for it? We do. There's
a, there's an express version.

345
00:19:51.770 --> 00:19:55.280
There's a standard version and
there's an enterprise version. And

346
00:19:56.240 --> 00:20:00.620
the difference between the three
is, and that express version,

347
00:20:00.620 --> 00:20:03.380
which is free, we do
cap the problem size. So

348
00:20:03.380 --> 00:20:06.950
you wouldn't be able to
put Amelion constraints. Right. I

349
00:20:06.950 --> 00:20:08.660
wouldn't be able to solve
my bill payment thing without

350
00:20:08.660 --> 00:20:12.080
paying somebody. Exactly. Nor would
you be able to redistribute

351
00:20:12.080 --> 00:20:16.400
it in an application? Because
like we said, talked about

352
00:20:16.400 --> 00:20:19.250
before, it's just a DLL.
And so you could imagine

353
00:20:19.250 --> 00:20:22.940
this working in an asp.net
application or a silver light

354
00:20:22.940 --> 00:20:27.050
application or a, Oh, wait
a second. So I can

355
00:20:27.050 --> 00:20:31.010
run this in silver Lake.
You cannot well not, Excuse

356
00:20:31.010 --> 00:20:32.990
me now. Well, you can,
what you could do is

357
00:20:32.990 --> 00:20:36.260
write a backing WCF web
service. Okay. But this runs

358
00:20:36.260 --> 00:20:38.270
on the two that runs
on the desktop CLR. Correct.

359
00:20:38.300 --> 00:20:40.580
So I can run it
in asp.net or WinForms or

360
00:20:40.580 --> 00:20:43.580
WPF or whatever, you know,
what's actually brings up a

361
00:20:43.580 --> 00:20:46.340
very interesting question all this
time. We're sitting here talking

362
00:20:46.340 --> 00:20:51.730
about managed code, but isn't
optimization problems. And these kinds

363
00:20:51.730 --> 00:20:55.320
of solutions typically solved in
C plus plus Typically they

364
00:20:55.320 --> 00:20:58.980
have been that's right. That's
right. And a solver foundation

365
00:20:58.980 --> 00:21:07.100
is the first purely managed
code.net solution for these, these

366
00:21:07.100 --> 00:21:10.230
sorts of problems. So no
one's really ever tried that

367
00:21:10.230 --> 00:21:15.420
before. And there were some
doubts as to whether the

368
00:21:15.420 --> 00:21:18.690
performance would be The right.
Well, surely, surely it must

369
00:21:18.690 --> 00:21:24.600
be slower. It is quite
competitive actually. Yeah. So competitive

370
00:21:24.600 --> 00:21:27.120
is, I'm not speaking for
these, all of our foundation

371
00:21:27.120 --> 00:21:30.150
team, but competitive is code
and Microsoft, for sure. Not

372
00:21:30.150 --> 00:21:34.440
slower. So I have to
be careful about it just

373
00:21:34.440 --> 00:21:38.370
because we don't benchmark and
so on, but, but it's

374
00:21:38.370 --> 00:21:41.220
not like 10 times slower.
No, no, no. We, we

375
00:21:41.220 --> 00:21:46.260
are solving really large scale
industrial strength. Can you give

376
00:21:46.280 --> 00:21:48.270
a sense of how big
the data sets that you

377
00:21:48.270 --> 00:21:52.440
can work with us? The,
I threw the term million

378
00:21:52.440 --> 00:21:54.960
constraints around, Oh, you weren't
just saying I wasn't kidding.

379
00:21:55.680 --> 00:22:00.450
There are real problems that
our foundation is solving right

380
00:22:00.450 --> 00:22:03.450
now that involve millions of
constraints. And do I need,

381
00:22:03.690 --> 00:22:06.780
do I need millions of
processors and millions of megabytes

382
00:22:06.780 --> 00:22:10.230
of memory? You don't need
millions. You need a, I

383
00:22:10.230 --> 00:22:12.510
mean, I need a beefy
machine, need a beefy machine,

384
00:22:12.510 --> 00:22:17.040
but we're talking about a
single multi-pronged machine with a

385
00:22:17.040 --> 00:22:20.940
lot of memory, but Like,
like a 64 bit like

386
00:22:20.970 --> 00:22:23.370
eight gigs kind of a
thing. Yeah. Is this typically

387
00:22:23.370 --> 00:22:24.750
a thing I would want
to do with a 64

388
00:22:24.750 --> 00:22:27.390
bit with, you know, a,
a.net app that has compiled

389
00:22:27.390 --> 00:22:32.280
for 60? No, I need
more than two gigs. No,

390
00:22:32.280 --> 00:22:35.220
you don't. I mean, I,
of course it depends on

391
00:22:35.220 --> 00:22:38.700
the size of the problem,
but you know, I routinely,

392
00:22:38.790 --> 00:22:40.860
you know, I have my,
my laptop, which is, it's

393
00:22:40.860 --> 00:22:44.100
a nice laptop, but it's
nothing too special and I

394
00:22:44.310 --> 00:22:48.450
have no problems running, running
models on, on that. So,

395
00:22:48.450 --> 00:22:50.640
so back to the point
about C plus plus and

396
00:22:50.640 --> 00:22:53.190
C sharp, I mean, as
I understand it, you've been

397
00:22:53.190 --> 00:22:55.620
in this space of optimization
problems for a number of

398
00:22:55.620 --> 00:22:59.520
years. You probably must've coded
these before.net in what languages

399
00:22:59.520 --> 00:23:02.010
did you use before? Yeah.
Yeah. Well, this is what

400
00:23:02.010 --> 00:23:06.030
I did before I came
to Microsoft and I was

401
00:23:06.030 --> 00:23:08.370
a, a Unix guy and
a Linux guy did a

402
00:23:08.370 --> 00:23:12.660
lot of coding on Solaris
and HP machines and in

403
00:23:12.660 --> 00:23:17.790
a bit of Linux and,
you know, the languages of

404
00:23:17.790 --> 00:23:23.820
choice were Fortran C and
C plus plus. And so

405
00:23:25.650 --> 00:23:30.060
writing I'd written solvers before
I came to Microsoft. And

406
00:23:30.060 --> 00:23:32.100
then once I came on
the software foundation team, it

407
00:23:32.100 --> 00:23:34.860
was, you know, switching over
to C sharp. And so

408
00:23:34.860 --> 00:23:38.880
I've had quite a bit
of experience trying to solve

409
00:23:38.880 --> 00:23:41.850
the same sorts of problems,
but using different, different languages.

410
00:23:42.750 --> 00:23:46.280
And does the language, does
the language getting your way

411
00:23:46.280 --> 00:23:47.690
or is this because all
of these are kind of

412
00:23:47.690 --> 00:23:49.850
C style languages, do you
think about that? I mean,

413
00:23:49.850 --> 00:23:51.450
there's a lot of talk
about things like Earl Lang

414
00:23:51.450 --> 00:23:54.890
and different, different languages that
are not classic CS titles,

415
00:23:55.010 --> 00:23:57.020
style languages. I mean, have
you, can you, can I

416
00:23:57.020 --> 00:24:01.550
use F sharp in the,
Yeah, absolutely. In fact, a

417
00:24:01.600 --> 00:24:03.790
couple of things. One is
that there's a lot of

418
00:24:03.790 --> 00:24:08.680
people in the financial industry,
like quantitative analysts and so

419
00:24:08.680 --> 00:24:12.640
on who really love F
sharp. And we're finding a

420
00:24:12.640 --> 00:24:15.850
lot of interest from people
who want to use F

421
00:24:15.850 --> 00:24:19.420
sharp and solid foundation. And
so in fact, one of

422
00:24:19.420 --> 00:24:22.840
the samples that we ship
is an F sharp sample.

423
00:24:23.590 --> 00:24:26.590
Cool. So it's totally appropriate
to do that. Oh, absolutely.

424
00:24:26.620 --> 00:24:27.760
And I don't have to
feel, I don't have to

425
00:24:27.760 --> 00:24:29.860
see any C-sharp to do
it, I guess. No, no.

426
00:24:29.890 --> 00:24:32.860
You can use the dotnet
language of your choice. And

427
00:24:32.860 --> 00:24:37.810
there are plenty of F
sharp samples, vb.net samples and

428
00:24:37.810 --> 00:24:39.640
so on. So, so what
are kind of some of

429
00:24:39.640 --> 00:24:42.640
the pros and cons that
you've found in writing silver

430
00:24:42.640 --> 00:24:45.580
foundation in C-sharp versus writing
it in C, C plus

431
00:24:45.580 --> 00:24:48.100
plus, cause I kind of
feel like in an old

432
00:24:48.100 --> 00:24:50.320
school, Microsoft, maybe a couple
of years ago, they might've

433
00:24:50.320 --> 00:24:51.850
forced you to write it
in C plus plus and

434
00:24:51.850 --> 00:24:54.700
done an interrupt layer. Right,
right. But it sounds like

435
00:24:54.700 --> 00:24:56.560
you, you know, there was
some kind of a tiny

436
00:24:56.560 --> 00:25:00.100
victory or big victory maybe
when you, when you guys

437
00:25:00.100 --> 00:25:02.950
convinced the powers that be
to do this thing managed

438
00:25:02.950 --> 00:25:06.160
and Right. Right. Is that
true? Absolute that's though. That

439
00:25:06.160 --> 00:25:10.090
is true. And it's really
been the conventional wisdom within

440
00:25:10.120 --> 00:25:13.210
this has been a, actually
a long running argument that

441
00:25:13.210 --> 00:25:17.470
even predates C-sharp. So if
you go back 20 years

442
00:25:17.470 --> 00:25:20.470
ago, there were people who
were saying C plus plus

443
00:25:20.470 --> 00:25:22.390
is too slow. You need
to, you need to do

444
00:25:22.390 --> 00:25:25.900
it in Fortran because of
the way you can because

445
00:25:25.900 --> 00:25:28.030
of array, access and so
on and so forth. So

446
00:25:28.900 --> 00:25:32.740
as time goes on, there's
always the same sorts of

447
00:25:32.740 --> 00:25:38.140
arguments, but the languages change
a C-sharp. I mean, I

448
00:25:38.140 --> 00:25:43.150
have to say, I love
writing solid foundation code in

449
00:25:43.390 --> 00:25:49.930
C sharp. The, the argument
that you will get is

450
00:25:49.930 --> 00:25:55.690
really the performance argument. People
will say with, with managed

451
00:25:55.690 --> 00:26:00.370
code with C sharp because
of, you know, compiling it

452
00:26:00.370 --> 00:26:03.940
into IUL because of the
garbage collection, because of the

453
00:26:03.940 --> 00:26:06.370
fact that you're not coding
as close to the machine,

454
00:26:06.400 --> 00:26:09.670
as you are in C
plus plus that you will

455
00:26:09.670 --> 00:26:15.280
never be able to have
an acceptable level of performance

456
00:26:15.280 --> 00:26:17.290
or you'll never be fast
enough. I mean, that's, that's

457
00:26:17.290 --> 00:26:24.700
the primary, you know, argument
that is made and, you

458
00:26:24.700 --> 00:26:28.930
know, there is an essential,
I mean, there's an essential

459
00:26:28.930 --> 00:26:31.240
truth to that. I mean,
there is more stuff going

460
00:26:31.240 --> 00:26:34.270
on. Yeah. There are, for
example, there are array, array,

461
00:26:34.270 --> 00:26:38.920
bounds checks that happen and
all sorts automatically, automatically that

462
00:26:38.920 --> 00:26:43.890
you have no control over
in C-sharp, which you don't

463
00:26:44.220 --> 00:26:46.860
need to do well, if
you know how big your

464
00:26:46.860 --> 00:26:48.930
array is, if you know
how big your is, and

465
00:26:48.930 --> 00:26:51.210
you do everything correctly, you
don't need to do. And,

466
00:26:51.750 --> 00:26:55.140
and C plus plus, and,
you know, with the type

467
00:26:55.140 --> 00:27:00.270
of code that I'm writing,
it is very computationally intense.

468
00:27:00.270 --> 00:27:04.110
There are lots of tight,
four loops where you're doing,

469
00:27:05.130 --> 00:27:08.670
you know, you're adding, multiplying,
dividing numbers. And so on,

470
00:27:09.980 --> 00:27:12.620
You're floating up at this
higher layer of abstraction. I

471
00:27:12.620 --> 00:27:14.900
mean, even though C-sharp and
CNC plus supposed to look

472
00:27:14.900 --> 00:27:18.740
like similar languages, fundamentally, there's
several layers between you and

473
00:27:18.740 --> 00:27:23.630
the metal. That's right. And
you're effectively a business logic

474
00:27:23.630 --> 00:27:26.840
programmer, right. Even though you're
doing intense computational stuff. Yeah.

475
00:27:27.050 --> 00:27:31.190
And, and the CLR is
there to provide you comfort.

476
00:27:31.550 --> 00:27:34.490
And the comfort it provides
you is via, you know,

477
00:27:34.520 --> 00:27:39.680
silent bounce checking and automatic
garbage collection. And when you're

478
00:27:39.680 --> 00:27:42.260
in a tight loop or
deepen a series of tight

479
00:27:42.260 --> 00:27:45.230
loops, wouldn't you wish that
you could just turn it

480
00:27:45.230 --> 00:27:47.630
off, like it wouldn't you
want to put a block

481
00:27:47.690 --> 00:27:51.080
like the unsafe block or
something, and just say, don't

482
00:27:51.080 --> 00:27:53.330
worry about it. I got
this for a minute and

483
00:27:53.360 --> 00:27:56.000
eke out that extra 3%
or that extra 4% of

484
00:27:56.840 --> 00:27:58.610
a performance, or do you
just not worry about that

485
00:27:58.610 --> 00:28:01.400
kind of stuff? Well, it's,
I guess what I'm trying

486
00:28:01.400 --> 00:28:05.540
to understand if your philosophy
around micro optimization, My philosophy

487
00:28:05.540 --> 00:28:10.370
is that you really need
to take a more holistic

488
00:28:10.370 --> 00:28:14.900
view, a more top level
view of the problem, because

489
00:28:16.610 --> 00:28:19.330
there, yeah, there are sections
of the code where there

490
00:28:19.330 --> 00:28:23.510
are these tight four loops.
And in those particular section,

491
00:28:23.900 --> 00:28:25.850
as you're writing them, you
might say to yourself, ah,

492
00:28:25.960 --> 00:28:29.540
I wish I could just
go unsafe and skip these

493
00:28:30.050 --> 00:28:32.570
length checks and so on,
but what you need to,

494
00:28:33.350 --> 00:28:35.090
you need to take a
step back and think about

495
00:28:36.590 --> 00:28:40.310
how users are using this
code. Like we were just

496
00:28:40.460 --> 00:28:43.040
a couple minutes ago, we
were talking about expressing these

497
00:28:43.790 --> 00:28:46.400
constraints and these goals and
so on and the declarative

498
00:28:46.400 --> 00:28:48.890
language and so on. And
there's a lot of steps

499
00:28:48.890 --> 00:28:52.040
that need to occur to
solve a problem, right? So

500
00:28:52.040 --> 00:28:54.140
you need to, you need
to get the data, you

501
00:28:54.140 --> 00:28:58.040
need to do some preprocessing
and analysis of the problem.

502
00:28:58.040 --> 00:29:01.700
And then, so these, these
loops that you're staring at

503
00:29:01.700 --> 00:29:05.450
when you're writing code, they
may seem extremely important at

504
00:29:05.450 --> 00:29:07.100
the time, but will you
re what you really need

505
00:29:07.100 --> 00:29:11.150
to do is go back
and measure and, and see

506
00:29:11.150 --> 00:29:15.170
what the real impact is.
And what we have found

507
00:29:15.170 --> 00:29:19.370
is that if you are,
if you write good, solid,

508
00:29:20.240 --> 00:29:24.950
careful managed code, and you're
thinking about performance as you're

509
00:29:24.950 --> 00:29:31.700
writing the C sharp code,
the, the differences, not generally

510
00:29:31.700 --> 00:29:35.120
speaking, not that great in
the, yeah, you need, you

511
00:29:35.120 --> 00:29:37.280
need to look at the
total system performance. I think

512
00:29:37.280 --> 00:29:40.940
the trick is that programmer
type I'll make a generalization

513
00:29:40.940 --> 00:29:44.140
here, the kind of personality
that makes an excellent programmer

514
00:29:44.140 --> 00:29:47.350
is the, almost sometimes the
kind that overthinks things. So

515
00:29:47.350 --> 00:29:50.320
like you just said, and
if you think carefully about

516
00:29:50.320 --> 00:29:53.050
performance, and I thought to
myself, and if you overthink

517
00:29:53.410 --> 00:29:55.540
appropriately about performance, you know,
it's like, when do you

518
00:29:55.540 --> 00:29:57.790
stop? At what point do
you back off? And I

519
00:29:57.790 --> 00:30:01.150
think you've made points to
me before the idea that

520
00:30:01.510 --> 00:30:04.720
you could fight for that
last 2% and then lose

521
00:30:04.720 --> 00:30:08.430
it on a single disc,
right? Yes. Yeah. That's absolutely

522
00:30:08.430 --> 00:30:13.050
the case. It's hundreds of
times more, I don't know

523
00:30:13.050 --> 00:30:15.360
the exact numbers, but it's
hundreds of times billions and

524
00:30:15.360 --> 00:30:18.720
billions, billions and billions. Yeah.
Yeah. It's a big deal.

525
00:30:18.720 --> 00:30:20.430
I mean, we're talking about
you, you fight for that

526
00:30:20.460 --> 00:30:24.330
a hundred milliseconds and you
lose it because somebody swapped

527
00:30:24.330 --> 00:30:27.330
you to a different core
or Whatever. Right. So I

528
00:30:27.330 --> 00:30:33.600
think a key is to
understand how this piece of

529
00:30:33.600 --> 00:30:38.880
code is functioning in the
larger system and measure and

530
00:30:38.880 --> 00:30:42.510
measure and measure on the,
on the scenarios that, that

531
00:30:42.510 --> 00:30:45.570
matter. And do you need
to have some goals in

532
00:30:45.570 --> 00:30:48.150
mind? How fast does it
need to be, right. Yeah,

533
00:30:48.150 --> 00:30:52.320
exactly. If you stop, when,
if you don't have a

534
00:30:52.320 --> 00:30:55.920
goal and your goal is
just make it faster, we'll

535
00:30:55.920 --> 00:30:58.710
then you'll never be done.
Right. And we all want

536
00:30:58.710 --> 00:31:01.230
our code to run as
fast as possible, if nothing

537
00:31:01.230 --> 00:31:05.430
else, just as a point
of pride. Right. But we

538
00:31:05.430 --> 00:31:09.030
don't have, there's only so
many hours in the day

539
00:31:09.090 --> 00:31:12.300
and you need to just
establish some goals of like,

540
00:31:12.510 --> 00:31:14.700
well, how fast to this
does this need to be?

541
00:31:15.300 --> 00:31:19.200
Otherwise you'll never be, you'll
never get any, Is profiling

542
00:31:19.200 --> 00:31:20.970
a big part of what
you guys do. I mean,

543
00:31:20.970 --> 00:31:22.860
is that like fundamental to
the way you guys write

544
00:31:22.860 --> 00:31:26.190
code? It is. I mean,
there's like, there's a couple

545
00:31:26.190 --> 00:31:28.500
of things we do. And
so the first thing is

546
00:31:28.500 --> 00:31:30.780
we think about what our
goals are. We think about

547
00:31:30.780 --> 00:31:35.700
the scenarios and we regularly
just measure the performance, like

548
00:31:35.880 --> 00:31:39.210
stop, watch time without a
profiler, just to make sure.

549
00:31:39.240 --> 00:31:43.170
Cause sometimes very innocent little
things can, Oh really? So

550
00:31:43.170 --> 00:31:44.940
when you say stop, watch
your time. You're not kidding.

551
00:31:44.940 --> 00:31:47.340
You're like saying, you know,
this, this a series of

552
00:31:47.340 --> 00:31:49.740
tests should run in two
seconds and then suddenly we

553
00:31:49.740 --> 00:31:51.570
made a change. It runs
in four. Yeah. So you're

554
00:31:51.570 --> 00:31:54.630
saying you're actually measuring that.
Do you have like constraints

555
00:31:54.630 --> 00:31:56.610
set up in a continuous
integration system such that it

556
00:31:56.610 --> 00:31:59.730
would fail and you would
be alerted? Yes. Every night,

557
00:32:01.080 --> 00:32:04.740
every night, actually our testing
team is fantastic every night,

558
00:32:05.220 --> 00:32:09.420
thousands of models and test
cases run and we measure

559
00:32:09.600 --> 00:32:12.030
the performance and when you
compare it to a baseline

560
00:32:12.720 --> 00:32:17.190
and these red flags pop
up, if the performance degrades

561
00:32:17.370 --> 00:32:19.950
too much. Okay. So he'll
performance regression is a real

562
00:32:19.950 --> 00:32:22.590
problem in some that you're,
you have quality Gates to

563
00:32:22.590 --> 00:32:25.260
figure that stuff out. Yes.
Yes. You would think that

564
00:32:25.260 --> 00:32:29.580
in the solver foundation would
be the classic test driven

565
00:32:29.580 --> 00:32:32.850
development example. Yeah. Do you
guys practice that here? Do

566
00:32:32.850 --> 00:32:35.370
you like write models and
say, I know the solution

567
00:32:35.370 --> 00:32:38.370
to this. Yes. Oh, absolutely.
So red, you know, red,

568
00:32:38.370 --> 00:32:41.170
green testing, you know, red,
green refactor. And I think

569
00:32:42.910 --> 00:32:45.640
it's so easy to want
to jump ahead because you're

570
00:32:45.640 --> 00:32:48.910
so eager, but many times
what, what I will do

571
00:32:48.910 --> 00:32:50.350
and other people on the
team will do is we'll

572
00:32:50.350 --> 00:32:54.820
actually take a very small
problem and write it down

573
00:32:54.820 --> 00:33:01.250
on paper and actually solve
it out, native wood. It,

574
00:33:01.250 --> 00:33:06.310
you just work out the
numbers and, and, and that's,

575
00:33:06.310 --> 00:33:08.710
that can be a very
first test case. Yeah. You

576
00:33:08.710 --> 00:33:11.680
know, and then you can,
you know, build up slightly

577
00:33:11.680 --> 00:33:14.410
larger examples and so on,
just start very simple and

578
00:33:14.410 --> 00:33:17.770
then say, and in general,
I would say when you're

579
00:33:18.310 --> 00:33:22.840
thinking about performance or trying
to evaluate whether I should

580
00:33:22.840 --> 00:33:25.210
be using C plus plus
or C sharp or something,

581
00:33:25.510 --> 00:33:27.460
it's good to just get
in the habit of writing,

582
00:33:28.060 --> 00:33:33.790
very small, simple test programs
that, you know, sort of

583
00:33:33.790 --> 00:33:35.800
be a scientist to try
to come up with a

584
00:33:35.800 --> 00:33:39.070
hypothesis, But they've gotta be
valid tests because I think

585
00:33:39.070 --> 00:33:41.680
that sometimes you always see
those, those examples that get

586
00:33:41.680 --> 00:33:43.420
thrown around the blogs every
once in a while someone

587
00:33:43.420 --> 00:33:45.100
takes your language and they
take another language and they

588
00:33:45.100 --> 00:33:47.830
say, and I spun it
on million loops. And I,

589
00:33:47.830 --> 00:33:50.230
you know, for, I equals
one, do a million and

590
00:33:50.230 --> 00:33:53.530
that's completely inappropriate. I mean,
it doesn't make any sense

591
00:33:53.530 --> 00:33:54.790
at all. I tell it
tells you that it can

592
00:33:54.790 --> 00:33:59.530
do Exactly. So the key
is nobody knows more about

593
00:33:59.560 --> 00:34:03.010
the, the scenario that you're
trying to address with your

594
00:34:03.010 --> 00:34:08.260
code in you, the programmer.
So get, you know, learn

595
00:34:08.260 --> 00:34:11.920
to learn to sort of
distill the essence of what

596
00:34:11.920 --> 00:34:16.660
you're trying to do and
write a, a small set,

597
00:34:16.680 --> 00:34:21.760
you know, representative program that,
that makes sense for you

598
00:34:21.790 --> 00:34:25.240
for the particular project that
you're working on. Just sketch

599
00:34:25.240 --> 00:34:27.280
it out, Right. Solve it
once and then solve it

600
00:34:27.280 --> 00:34:33.610
in times. Yeah. Yeah. I
mean, and don't rely on

601
00:34:33.610 --> 00:34:38.310
someone else's well, someone else
else's measurement measurement. Right. Do

602
00:34:38.320 --> 00:34:41.140
do your own measurement. They're
measuring may not, don't rely

603
00:34:41.140 --> 00:34:44.470
on anyone else's rule ruler.
Yeah. Measure it. Measure twice

604
00:34:44.470 --> 00:34:49.780
code once. Absolutely. You know,
it's, it's much easier to

605
00:34:50.500 --> 00:34:54.360
write that kind of basically
throw away code. It's just

606
00:34:54.360 --> 00:34:56.830
sketch it out. There's so
many fewer things you need

607
00:34:56.830 --> 00:34:59.080
to worry about. You know,
you just need to get

608
00:34:59.080 --> 00:35:02.260
the right, the right pieces
in there and get it

609
00:35:02.260 --> 00:35:04.510
working and get a sense.
You know, it doesn't need

610
00:35:04.510 --> 00:35:07.750
to be down to the,
you know, down to the

611
00:35:07.750 --> 00:35:10.600
millisecond. Exactly. Reflective of how
it will be in your

612
00:35:10.600 --> 00:35:14.140
real production code. It needs
to be fair and close,

613
00:35:14.170 --> 00:35:16.300
you know, Where can people
go again? You said it

614
00:35:16.300 --> 00:35:19.750
was a solver foundation.com and
that'll redirect to somewhere Or

615
00:35:19.750 --> 00:35:24.280
foundation.com. There's a little front
door website, and there's a

616
00:35:24.280 --> 00:35:26.860
download link that will take
you to our MSDN site

617
00:35:27.730 --> 00:35:31.840
where you can go and
grab. Very cool. Well, thank

618
00:35:31.840 --> 00:35:34.210
you so much, Nathan Brooks for
chatting with me today about

619
00:35:34.210 --> 00:35:37.560
salvia foundation and optimization. Yeah.
Thank you. My pleasure. This

620
00:35:37.560 --> 00:35:40.200
has been another Episode of
Hansel minutes and we'll see

621
00:35:40.200 --> 00:35:41.220
you again next week.


WEBVTT FILE

1
00:00:14.520 --> 00:00:18.570
From Hanselman it's dot com.
It's Hansel minutes, a weekly

2
00:00:18.570 --> 00:00:22.740
discussion with web developer and
technologist Scott Hanselman and hosted

3
00:00:22.740 --> 00:00:27.780
by Carl Franklin. This is Lawrence Ryan
announcing show number seven recorded

4
00:00:27.780 --> 00:00:33.510
Monday, February 20th, 2006. Support for handsome,
and it's just provided by

5
00:00:33.510 --> 00:00:37.950
automated QA makers of test
complete providing automatic testing of

6
00:00:37.950 --> 00:00:48.180
windows.net framework, Java and web
applications online@wwwdotautomatedqa.com. And by Peter

7
00:00:48.180 --> 00:00:57.450
bloom.com start with better controls
finish with better sites online@peterblum.com.

8
00:00:58.410 --> 00:01:01.680
Support is also provided by
Dutton and developers journal. The

9
00:01:01.680 --> 00:01:07.560
world's leading dotnet developer magazine
online at www dot <inaudible>

10
00:01:07.650 --> 00:01:12.480
dot com. In this episode,
Scott covers tools and technologies

11
00:01:12.510 --> 00:01:20.700
around XML. Hi, this is
Carl Franklin. You're listening to Hansel

12
00:01:20.700 --> 00:01:23.910
minutes and Scott, before we
get going, we want to

13
00:01:23.910 --> 00:01:25.230
give a shout out to
our friends over at the

14
00:01:25.230 --> 00:01:29.820
polymorphic podcast, polymorphic podcasts.com who
are just celebrating their one

15
00:01:29.820 --> 00:01:32.600
year anniversary. Yeah, I really
admire the stuff that Craig's

16
00:01:32.600 --> 00:01:35.480
been doing over there at
a polymorphic podcast. We even

17
00:01:35.480 --> 00:01:38.510
stole one of his JavaScript
rollovers recently, put it up

18
00:01:38.510 --> 00:01:40.400
on Hansel minutes and we're
trying to get that tweaked.

19
00:01:40.940 --> 00:01:42.980
Craig's put together a really
solid show for quite a

20
00:01:42.980 --> 00:01:45.410
while now, and we really
appreciate his support of Hansel

21
00:01:45.410 --> 00:01:47.120
minutes and we wanted to
give him a shout out.

22
00:01:47.630 --> 00:01:50.210
So the topic today is
XML. It's a kind of

23
00:01:50.210 --> 00:01:52.880
a big topic. You've sort
of narrowed it down into

24
00:01:52.880 --> 00:01:55.880
a few, a few, a
choice subtopics. What are those

25
00:01:55.880 --> 00:01:58.010
going to be? XML is
a big topic. And for

26
00:01:58.010 --> 00:02:00.440
a lot of people, they
really are just angle bracket,

27
00:02:00.440 --> 00:02:05.930
delimited files, even in large
companies, you'll find people parsing

28
00:02:05.930 --> 00:02:09.230
XML in ways that maybe
aren't as effective as, as

29
00:02:09.320 --> 00:02:12.050
they could be. And at,
at my company, we often

30
00:02:12.050 --> 00:02:14.510
deal with really large XML
files. We'll deal with a

31
00:02:14.510 --> 00:02:16.940
file that might be dropped
in with a list of

32
00:02:17.270 --> 00:02:19.880
bills that need to be
paid. That might be a,

33
00:02:19.880 --> 00:02:22.010
you know, a half gigabyte
or a gigabyte in size

34
00:02:22.010 --> 00:02:24.380
with, you know, tens or
hundreds of thousands of records.

35
00:02:24.740 --> 00:02:27.380
And there are many different
ways to deal with XML.

36
00:02:27.770 --> 00:02:32.120
And ever since ms. XML
was introduced around the VB

37
00:02:32.120 --> 00:02:36.230
five, he'd be six days.
There was a class of

38
00:02:36.470 --> 00:02:38.900
solution that I called the
select single node solution that

39
00:02:38.900 --> 00:02:41.690
people are still using today,
right? This is load XML

40
00:02:41.690 --> 00:02:44.870
up and Adom, right? And
say select nodes or select

41
00:02:44.870 --> 00:02:47.060
single node and poke out
that value that you want.

42
00:02:47.060 --> 00:02:48.410
I mean, we've all done
that. I'm sure you've done

43
00:02:48.410 --> 00:02:50.780
that. Sure. When you load
XML up into a Dom,

44
00:02:51.020 --> 00:02:53.480
you're using up a lot
of memory, you're having to

45
00:02:53.480 --> 00:02:57.980
do a big, complete thorough
parsing of that XML document.

46
00:02:58.430 --> 00:03:01.420
And often people are loading
stuff into a Dom either

47
00:03:01.420 --> 00:03:04.300
just to extract one little
bit of information or more

48
00:03:04.300 --> 00:03:08.260
often to translate that document
into a different format, right?

49
00:03:08.260 --> 00:03:11.320
So maybe if I have
a 10 megabyte XML document,

50
00:03:11.320 --> 00:03:13.540
it might get loaded up
and take 30 megs of,

51
00:03:13.700 --> 00:03:16.540
of memory. And that can
be a real problem. One

52
00:03:16.540 --> 00:03:19.150
of the things that I
like to avoid is what

53
00:03:19.150 --> 00:03:23.830
I call Caterpillar style, XML
management. So this is when,

54
00:03:23.830 --> 00:03:27.040
if you imagine a Caterpillar,
when the, the back legs

55
00:03:27.040 --> 00:03:29.510
of the Caterpillar start walking
up towards the front and

56
00:03:29.740 --> 00:03:32.050
the back of the Caterpillar
gets really, really tall. It's

57
00:03:32.050 --> 00:03:34.480
like loading up all this
stuff and the XML document,

58
00:03:34.480 --> 00:03:35.950
and it gets big, big,
big, big, big, and then

59
00:03:35.950 --> 00:03:37.990
it sits there for a
second. And then you hold

60
00:03:37.990 --> 00:03:40.660
this thing in memory for
a moment. And then you

61
00:03:40.660 --> 00:03:43.120
use are walking away and
then you pull your information

62
00:03:43.120 --> 00:03:47.080
out of the XML document
and for a really effective

63
00:03:47.080 --> 00:03:50.740
XML transformation, or whether that,
and I don't mean XSLT,

64
00:03:50.740 --> 00:03:53.680
but I mean, literally transformation
of XML to another, another

65
00:03:53.680 --> 00:03:56.740
format using anything you want
to avoid that kind of

66
00:03:56.740 --> 00:04:00.280
Caterpillar style development, where you
load something up, hold it

67
00:04:00.280 --> 00:04:02.200
for a second and then
spit it back out again.

68
00:04:02.860 --> 00:04:05.260
And using XML readers next
to my writers can help

69
00:04:05.260 --> 00:04:08.140
you do that. All right.
So XML reader and XML

70
00:04:08.140 --> 00:04:11.950
writer are classes in the
framework that, that work in

71
00:04:11.950 --> 00:04:15.000
this space. What, how do
you use these things? They,

72
00:04:15.000 --> 00:04:18.040
they, they sound like streams
to me. Are they streams?

73
00:04:18.370 --> 00:04:20.260
They sit on, they can
sit on top of streams.

74
00:04:20.260 --> 00:04:24.280
Exactly. So streams are, are
like byte arrays. Yeah. This

75
00:04:24.280 --> 00:04:25.870
is an interesting thing that
you brought up. The concept

76
00:04:25.870 --> 00:04:29.230
of streams is something that
that.net is introduced to make

77
00:04:29.230 --> 00:04:30.580
the idea of buying a
raise and a raise the

78
00:04:30.580 --> 00:04:33.130
information a lot, a lot
simpler. I was working with

79
00:04:33.130 --> 00:04:36.310
some guys at, at Kirlian
recently doing some pair programming.

80
00:04:36.700 --> 00:04:40.510
And I realized that amongst
dotnet programmers, in my opinion,

81
00:04:40.780 --> 00:04:43.870
particularly in my case C
sharp programmers, there are two

82
00:04:43.870 --> 00:04:46.720
types of folks. There are
the folks that lean hard

83
00:04:46.720 --> 00:04:49.210
on the language, and there
are the folks that lean

84
00:04:49.210 --> 00:04:52.870
hard on the library. And
I was doing compare programming

85
00:04:52.870 --> 00:04:55.510
with a fellow who was
a expert C plus plus

86
00:04:55.540 --> 00:04:58.840
programmer. And he was doing
some manipulation of, of some

87
00:04:58.840 --> 00:05:03.190
byte array data in its
raw form and was writing

88
00:05:04.030 --> 00:05:07.150
C sharp as if it
were C plus plus, because

89
00:05:07.150 --> 00:05:08.530
you can, you can write
any, you know, you can

90
00:05:08.530 --> 00:05:10.930
write C plus plus in
any language, you could be

91
00:05:10.930 --> 00:05:13.300
a very C plus plus
EVB programmer. Right? Right. We

92
00:05:13.310 --> 00:05:15.820
come upon vb.net code that's
been written, and you can

93
00:05:15.820 --> 00:05:17.590
just look at it. And
the variable names you say,

94
00:05:18.070 --> 00:05:20.140
there's been a C plus
plus person in this code.

95
00:05:20.140 --> 00:05:25.360
I can smell it. S
the Z, exactly. LPSC STR.

96
00:05:25.960 --> 00:05:30.490
So this individual leaned on
the language very hard while

97
00:05:30.490 --> 00:05:33.940
I lean on the base
class library, but have less

98
00:05:33.940 --> 00:05:36.190
deep knowledge about the right
things to do as far

99
00:05:36.190 --> 00:05:38.530
as keywords within the language.
So between us, we were

100
00:05:38.530 --> 00:05:41.950
very well well-placed. He was
poking around inside of a

101
00:05:41.950 --> 00:05:45.550
byte array. When in fact,
a stream reader kind of

102
00:05:45.550 --> 00:05:49.480
a forward only view of
a byte array within the.net

103
00:05:49.810 --> 00:05:52.150
base class library would have
been the more appropriate thing

104
00:05:52.150 --> 00:05:53.950
to do for him to
manipulate this data the way

105
00:05:53.950 --> 00:05:56.350
that want it to right.
I learned something, he learned

106
00:05:56.350 --> 00:05:59.120
something, but it really underscored
the fact that the base

107
00:05:59.120 --> 00:06:01.850
class library has been thought
about at such a depth

108
00:06:02.600 --> 00:06:05.390
that it's so much more
about the libraries. And it

109
00:06:05.390 --> 00:06:07.490
is about the language for
a lot of different problems.

110
00:06:07.630 --> 00:06:10.060
It's been a standard theme
on dotnet rocks. It's about,

111
00:06:10.090 --> 00:06:12.340
you know, reinventing the wheel
when you really should have

112
00:06:12.340 --> 00:06:15.700
cracked, cracked the help file.
Well, it's so difficult though,

113
00:06:15.700 --> 00:06:17.830
because the base class library
is so complicated. And I

114
00:06:17.830 --> 00:06:20.050
think that system dot XML
is one of those places

115
00:06:20.050 --> 00:06:22.690
where you could just live
there. It's, there's so much

116
00:06:22.690 --> 00:06:26.200
going on. So an XML
reader, like the XML text

117
00:06:26.200 --> 00:06:29.320
reader and validating reader are
forward only views on some

118
00:06:29.320 --> 00:06:32.620
XML while the Dom loads
that XML up and holds

119
00:06:32.620 --> 00:06:34.600
it in memory a lot,
like back in the day

120
00:06:34.600 --> 00:06:36.760
and VB five and VB
six, we had forward only

121
00:06:36.760 --> 00:06:39.190
record sets and static record
sets. Right? So you know

122
00:06:39.190 --> 00:06:41.890
more about that than anybody.
Yeah, Sure. A static being

123
00:06:41.890 --> 00:06:45.190
a that, that never changes
underneath, whereas they also had

124
00:06:45.190 --> 00:06:48.400
dynamic key sets, which would
change the data would change

125
00:06:49.120 --> 00:06:53.890
on you. Exactly. And when,
when beginner developers started using

126
00:06:53.920 --> 00:06:56.710
visual basic, they always went
for the static stuff. Cause

127
00:06:56.710 --> 00:06:58.390
that seemed to be the
most logical way to do

128
00:06:58.390 --> 00:07:01.210
things. And one of the
tips that was constantly passed

129
00:07:01.210 --> 00:07:03.250
around was only use of
forward. Only if you don't

130
00:07:03.250 --> 00:07:05.680
need to go back and
forth over the data, spin

131
00:07:05.680 --> 00:07:08.890
through at once, use the
use the forward only stuff.

132
00:07:09.220 --> 00:07:12.370
The XML text reader is,
is one of those examples

133
00:07:12.370 --> 00:07:14.170
where if you're going to
be running through an XML

134
00:07:14.170 --> 00:07:17.080
document and you really don't
want to load it up

135
00:07:17.080 --> 00:07:19.060
into memory, if you're gonna
be doing something a lot,

136
00:07:19.630 --> 00:07:22.000
if you're gonna have a
very fast XML access to

137
00:07:22.000 --> 00:07:23.830
data, and you want the
memory footprint to be very

138
00:07:23.830 --> 00:07:26.500
flat, you don't want that
entire document to get loaded

139
00:07:26.500 --> 00:07:29.650
up into memory. The text
reader is the most efficient

140
00:07:29.650 --> 00:07:31.960
way to do things it's
forward only. And it's read

141
00:07:31.960 --> 00:07:34.630
only. So It does some
memory management where it loads

142
00:07:34.630 --> 00:07:37.240
data up in chunks and
in cursors through it. Is

143
00:07:37.240 --> 00:07:40.060
that how, how it works?
Yeah. It's actually loading it

144
00:07:40.060 --> 00:07:42.940
as it goes. It's walking
through that stream, whatever you

145
00:07:42.940 --> 00:07:45.310
pass it, as it goes.
And it never actually loads

146
00:07:45.310 --> 00:07:48.460
the entire document. It's just
looking a few kind of

147
00:07:48.460 --> 00:07:51.970
few nodes ahead. Okay. And
as, and if you've heard

148
00:07:51.970 --> 00:07:56.770
of sax S XXX, the
sack style parsing is a

149
00:07:57.040 --> 00:08:01.330
kind of push style parsing
where you start parsing XML

150
00:08:01.360 --> 00:08:04.690
and the sax engine starts
to announce, Hey, I found

151
00:08:04.690 --> 00:08:06.640
an element, Hey, I found
an attribute, Hey, I found

152
00:08:06.640 --> 00:08:09.130
an end element. It's hollering
at you all the time.

153
00:08:09.580 --> 00:08:11.680
XML, text reader, and the
XML reader style of things

154
00:08:11.680 --> 00:08:13.630
is the reverse of that.
It is a pull style

155
00:08:13.630 --> 00:08:18.310
where you are saying while
reader.read, and then each, this

156
00:08:18.310 --> 00:08:22.450
is an interesting thing. Each
little piece, each little part,

157
00:08:22.690 --> 00:08:25.810
each atom of an XML
document, including white space. If

158
00:08:25.810 --> 00:08:28.780
you've told the XML reader
to care about white space

159
00:08:29.440 --> 00:08:32.950
is a node. I was
parsing some OFX recently, it's

160
00:08:32.950 --> 00:08:36.910
an open financial exchange format
and they, they have some

161
00:08:36.940 --> 00:08:41.150
text nodes within the document
just floating around. And, and

162
00:08:41.150 --> 00:08:43.270
I had to decide whether
I cared about those or

163
00:08:43.270 --> 00:08:46.300
not. Whether the white space
was in fact significant. So

164
00:08:46.300 --> 00:08:49.630
as you go next, next,
next, and you say pulling

165
00:08:49.630 --> 00:08:53.260
through this reader, going read,
read, read. Each note is

166
00:08:53.260 --> 00:08:56.430
a type, everything from the
comments like you'll actually see

167
00:08:56.430 --> 00:08:59.310
comments go by when you're
using an XML text reader,

168
00:08:59.550 --> 00:09:02.760
it is the absolutely most
efficient use of memory, but

169
00:09:02.760 --> 00:09:05.910
it is read only. And
by itself, the XML texture

170
00:09:05.910 --> 00:09:08.880
doesn't do any validation. It
won't validate your XML against

171
00:09:09.600 --> 00:09:12.390
an XSD, which is why
folks then use the XML

172
00:09:12.420 --> 00:09:15.630
validating reader. So this is
a reader that is a

173
00:09:15.840 --> 00:09:18.180
pretty fast compared to the
Dom, but it, and it

174
00:09:18.180 --> 00:09:21.480
does automatic validation, but it's
two to three times slower

175
00:09:21.480 --> 00:09:24.360
than the XML text reader.
Okay. Things get real slow,

176
00:09:24.360 --> 00:09:28.830
real fast. Now, comparatively the
Dom the XML document that

177
00:09:28.830 --> 00:09:31.800
we're all familiar with is
another two or three times

178
00:09:31.800 --> 00:09:35.460
slower than the XML text
trader. So we can, we're

179
00:09:35.460 --> 00:09:38.940
looking at potentially six to
nine, maybe 10 times slower

180
00:09:38.940 --> 00:09:41.040
when you start using a
Dom. Now we're talking about

181
00:09:41.040 --> 00:09:43.830
memory issues. We're talking about
a dotnet to, Oh, here,

182
00:09:44.520 --> 00:09:47.190
because there isn't really any
version of.net. Okay. Cause I

183
00:09:47.190 --> 00:09:49.470
do remember you, or do
you recall you talking about

184
00:09:49.470 --> 00:09:52.440
a, a version of an
XML component that was much

185
00:09:52.440 --> 00:09:57.450
faster into, Oh, the XSLT
transform in dotnet two. Oh,

186
00:09:57.480 --> 00:10:02.020
the XSL compiled transform is
who? Hey, faster. Okay. And

187
00:10:02.020 --> 00:10:04.710
then what the rest of
these are typically about the

188
00:10:04.710 --> 00:10:08.190
same speed. I believe that
almost everything in Dutton at

189
00:10:08.190 --> 00:10:11.010
two O has received a
speed boost, but for the

190
00:10:11.010 --> 00:10:13.710
most part, the relationship between
them is the same. The

191
00:10:13.710 --> 00:10:16.890
Dom will almost always, always.
I mean, when I say

192
00:10:16.890 --> 00:10:19.110
will almost just in case
someone writes and says, no,

193
00:10:19.110 --> 00:10:21.510
in this one instance, it
is right, but the Xbox

194
00:10:22.260 --> 00:10:25.440
is the fastest way full
stop to get some information.

195
00:10:25.440 --> 00:10:27.720
Now, now you pay for
that though, because you're having

196
00:10:27.720 --> 00:10:30.120
to go read or.read, and
you're poking around at a

197
00:10:30.120 --> 00:10:33.570
very low level, right? You
don't get the luxury of

198
00:10:33.570 --> 00:10:37.170
backing up with an XML,
text reader and Scott, I

199
00:10:37.170 --> 00:10:39.240
just want to remind the
listeners at this time that

200
00:10:39.240 --> 00:10:42.300
I'm Hanselman it's would not
be possible without the generous

201
00:10:42.300 --> 00:10:45.750
support from our sponsors. And
one of those sponsors is

202
00:10:45.750 --> 00:10:49.440
automated QA, and they make
a product called test complete,

203
00:10:49.440 --> 00:10:54.450
which is just a complete
solution for testing in.net. And

204
00:10:54.450 --> 00:10:56.670
it's great stuff. We love
it. And that's why they're

205
00:10:56.670 --> 00:10:59.130
a sponsor. And so if
you please do us a

206
00:10:59.130 --> 00:11:04.350
favor and check out their
site@automatedqa.com and also let them

207
00:11:04.350 --> 00:11:06.780
know that you heard about
them on Hansel minutes, that

208
00:11:06.780 --> 00:11:09.270
will help believe it or
not keep this show on

209
00:11:09.270 --> 00:11:18.350
the air. I recently wrote
some code where I used

210
00:11:18.350 --> 00:11:21.920
an XML text reader to,
or an XML reader. Rather,

211
00:11:22.220 --> 00:11:24.710
you pass it a URL
to an RSS feed. And

212
00:11:24.710 --> 00:11:27.950
then you use that reader
on the, on a dataset,

213
00:11:28.340 --> 00:11:31.250
read XML, pass it the
reader. And you basically have

214
00:11:31.250 --> 00:11:34.010
loaded RSS data into a
dataset where he, you know,

215
00:11:34.010 --> 00:11:36.620
he can mess around with
it using the XML reader

216
00:11:36.620 --> 00:11:38.600
as a parameter to other
things is a really nice

217
00:11:38.600 --> 00:11:41.330
way of doing things. You
can pay passing data from

218
00:11:41.330 --> 00:11:43.430
back, back and forth. You're
really not passing the data.

219
00:11:43.430 --> 00:11:45.650
As you are passing the
cursor at a certain location,

220
00:11:45.890 --> 00:11:48.680
right? Passing a Dom around
means passing this chunk of

221
00:11:48.680 --> 00:11:50.570
memory of the handle to
this chunk of memory around

222
00:11:50.870 --> 00:11:52.880
causing a reader at a
particular point is a really

223
00:11:52.880 --> 00:11:56.380
nice to plug things in
and out of the, the

224
00:11:56.380 --> 00:11:59.950
dominant framework. I like doing
what are called XML reader,

225
00:11:59.950 --> 00:12:03.820
writer, pipelines, where I'll have
an interface like, you know,

226
00:12:03.850 --> 00:12:07.120
I, my, my XML handler,
I have some interface that

227
00:12:07.330 --> 00:12:10.660
takes a reader and a
writer. So I'll read out,

228
00:12:10.660 --> 00:12:11.950
I'd like to say, I
read out of the left

229
00:12:11.950 --> 00:12:14.410
hand and I'll write into
the, the right the right

230
00:12:14.410 --> 00:12:18.130
hand. So if someone wants
to pass me a reader

231
00:12:18.130 --> 00:12:20.470
and I'm going to do
some big transformation, and I

232
00:12:20.470 --> 00:12:23.350
don't mean an XSLT transformation,
but maybe I've got a

233
00:12:23.380 --> 00:12:25.420
gigabyte file. And I want
to turn all of my

234
00:12:25.420 --> 00:12:30.160
attributes into elements, writing that
giant XML export file into

235
00:12:30.640 --> 00:12:33.610
the Dom is unreasonable and
probably not possible depending on

236
00:12:33.610 --> 00:12:36.430
how much memory you have,
but I can read that

237
00:12:36.430 --> 00:12:38.920
up with the text reader
and I can make fundamental

238
00:12:38.920 --> 00:12:40.990
changes to what's going on
in my document. I can

239
00:12:41.230 --> 00:12:44.320
convert attributes to elements. I
can strip out comments. I

240
00:12:44.320 --> 00:12:47.860
can clean things up. A
really common question is how

241
00:12:47.860 --> 00:12:51.130
do I get automatic in
denting in my document? Someone's

242
00:12:51.130 --> 00:12:52.960
going to give me an
XML document and it's got

243
00:12:53.380 --> 00:12:55.360
no white space, but I
like my documents to be

244
00:12:55.360 --> 00:12:59.080
tidy for maybe debugging purposes.
I can read that information

245
00:12:59.080 --> 00:13:01.750
in with a reader and
then with an XML text

246
00:13:01.750 --> 00:13:04.900
writer, which is the inverse
of the XML text reader,

247
00:13:05.200 --> 00:13:07.720
I can then say XML
formatting is going to be

248
00:13:07.720 --> 00:13:10.420
indented and then just read
through and write out and

249
00:13:10.420 --> 00:13:12.730
I'll get free and denting.
And, and of course that's

250
00:13:12.730 --> 00:13:17.500
still is nicely tight on
the memory. So very exactly

251
00:13:17.500 --> 00:13:19.900
because you're not loading that
entire document up, but you

252
00:13:19.900 --> 00:13:22.330
do have to curse it
through the whole thing. Well,

253
00:13:22.330 --> 00:13:25.030
you do what you do
anyway, in that case. Yeah.

254
00:13:25.080 --> 00:13:26.800
Yeah. Well, you're dealing with
this in a very, very

255
00:13:26.800 --> 00:13:29.410
small chunks of information at
a time. Yeah. And of

256
00:13:29.410 --> 00:13:33.010
course the XML document that
we're used to using is

257
00:13:33.010 --> 00:13:35.290
using a reader underlying in
any way. This is the

258
00:13:35.290 --> 00:13:36.880
neat thing about readers is
that these are really the

259
00:13:36.880 --> 00:13:40.390
lowest level chunks of information.
They hide the angle brackets

260
00:13:40.390 --> 00:13:43.090
from you. Now the XML
document is different from the

261
00:13:43.090 --> 00:13:46.660
Dom, right? No, the XML
document is the Dawn. Dawn

262
00:13:46.660 --> 00:13:50.230
is an implementation. The W3C
said, you know, there is

263
00:13:50.230 --> 00:13:53.470
this thing called the document
object model that we want

264
00:13:53.470 --> 00:13:57.610
to view of some XML
and the XML information set.

265
00:13:57.940 --> 00:14:00.910
The XML document is dot
and its implementation of the

266
00:14:00.910 --> 00:14:03.440
thumb. All right. Now the,
the, the thing that keeps

267
00:14:03.440 --> 00:14:06.250
saying that we haven't talked
about is the XML information

268
00:14:06.250 --> 00:14:10.180
set. The idea that if
you look at the angle

269
00:14:10.180 --> 00:14:12.370
brackets in the text and
try to do like a

270
00:14:12.370 --> 00:14:14.950
diff like doing a diff
with a tool like beyond

271
00:14:14.950 --> 00:14:19.150
compare on an XML document,
doesn't really help you because

272
00:14:19.330 --> 00:14:21.850
the XML document might be
different from a bite. You

273
00:14:21.850 --> 00:14:24.850
know, bites bites provides might
be different, but what it's

274
00:14:24.850 --> 00:14:28.330
trying to express the information
set within that document is

275
00:14:28.330 --> 00:14:31.540
the same. So if I
had a document that had

276
00:14:31.540 --> 00:14:36.580
like books and the XML
prefix, right, the shortcut before

277
00:14:36.580 --> 00:14:40.210
the element might be like
a colon books, where a,

278
00:14:40.240 --> 00:14:43.870
is the namespace for Amazon.
And I have another document

279
00:14:44.020 --> 00:14:47.260
where they just chose B
as the namespace prefix, the

280
00:14:47.260 --> 00:14:50.380
documents might express the exact
same XML information set. But

281
00:14:50.380 --> 00:14:51.680
if I did a diff
it would come out as

282
00:14:51.680 --> 00:14:54.970
radically different. Hmm. So when
you're doing XML dif you

283
00:14:54.970 --> 00:14:57.340
need to ask yourself, am
I doing a low level?

284
00:14:57.490 --> 00:14:59.530
Is this the same bytes?
Or is this the same

285
00:14:59.530 --> 00:15:02.640
information? Another example would be
empty elements if I've got

286
00:15:02.650 --> 00:15:06.070
a start Fu and then
an end Fu, or I've

287
00:15:06.070 --> 00:15:09.520
got a single food that's,
pre-close like less than food

288
00:15:09.540 --> 00:15:13.150
slash greater than yeah. Those
express the same thing and

289
00:15:13.150 --> 00:15:16.600
empty element, except one is
short-circuited closed and one is

290
00:15:16.600 --> 00:15:19.360
not, but they're expressing the
same kind of a thing.

291
00:15:19.660 --> 00:15:21.940
The Dom tries to hide
that and give you a,

292
00:15:22.210 --> 00:15:25.090
a pretty clear abstraction on
top of that. So you

293
00:15:25.090 --> 00:15:28.750
get the same information set.
So once you have these

294
00:15:28.750 --> 00:15:30.760
kinds of underlying pieces and
you can start to become

295
00:15:30.760 --> 00:15:32.890
familiar with it, I suggest
that everyone really try to

296
00:15:33.220 --> 00:15:36.190
deal with XML, text reader
and validating reader, and think

297
00:15:36.190 --> 00:15:38.680
about what you can do.
You don't have to live

298
00:15:38.680 --> 00:15:41.380
at that really low level
all the time. You can

299
00:15:41.710 --> 00:15:45.370
run through to a point
within a, an XML reader,

300
00:15:45.460 --> 00:15:49.570
find something you recognize, and
then maybe use the node,

301
00:15:49.600 --> 00:15:53.290
use an XML node reader,
or use XML, sterilization, XML,

302
00:15:53.290 --> 00:15:55.780
sterilization. One of my favorite
things. So what you have,

303
00:15:56.620 --> 00:15:58.630
that's when you can Mark
up, okay. Class, like I

304
00:15:58.630 --> 00:16:01.570
could say public classes book,
and then I can put

305
00:16:01.570 --> 00:16:04.630
attributes on it. Dotnet attributes
that say, when I serialize

306
00:16:04.630 --> 00:16:06.910
a book, when I save
a book as XML, I

307
00:16:06.910 --> 00:16:10.270
want it to have these
elements in these, in these

308
00:16:10.270 --> 00:16:13.900
places. So it's the automatic
kind of marshaling of data

309
00:16:13.900 --> 00:16:16.630
from the angle bracket world
into the dotnet CLR type

310
00:16:16.630 --> 00:16:22.310
world. And in m.net. One,
one, you can say, you

311
00:16:22.310 --> 00:16:24.550
get to a point within
an XML reader and say,

312
00:16:24.550 --> 00:16:28.510
read inner XML. And then
deserialize a document. And I've

313
00:16:28.510 --> 00:16:32.440
got an example of reading
and saving XML fragments@shrinks.com slash

314
00:16:32.650 --> 00:16:36.580
<inaudible>. Okay. And I'm in
dotnet two. Oh, you can

315
00:16:36.580 --> 00:16:39.250
say like read subtree and
you can add a certain

316
00:16:39.250 --> 00:16:42.280
point within a document, kind
of break off that reader

317
00:16:42.280 --> 00:16:44.950
and take a chunk out
of it. The best of

318
00:16:44.950 --> 00:16:48.730
both worlds, you don't have
to build an XML serialization

319
00:16:48.760 --> 00:16:51.370
tree over the entire document,
but you don't have to

320
00:16:51.370 --> 00:16:53.590
keep poking around at the
low level with the XML

321
00:16:54.010 --> 00:16:57.520
reader. Cool. So you can
walk forward, grab a piece

322
00:16:57.520 --> 00:17:00.100
and then keep, keep moving.
Great. But one of the

323
00:17:00.100 --> 00:17:03.190
really exciting things about the
XML reader is that it

324
00:17:03.190 --> 00:17:05.830
is an abstract base class,
the XML X street, and

325
00:17:05.830 --> 00:17:09.220
the validating reader are examples,
you know, concrete instances of

326
00:17:09.220 --> 00:17:13.150
that, but we can build
our own XML readers using

327
00:17:13.150 --> 00:17:17.890
the same model dare Obasanjo
and Howard Howe wrote a

328
00:17:18.100 --> 00:17:22.180
X path reader X path,
is that right? Kind of

329
00:17:22.210 --> 00:17:25.180
tight language that you can
say, things like, give me

330
00:17:25.180 --> 00:17:27.220
all the books that have
an author equal to this.

331
00:17:27.220 --> 00:17:31.060
You can go like backslash
backslash books, open square bracket,

332
00:17:31.060 --> 00:17:34.270
author, yada yada yada. And
you build a whole expression

333
00:17:34.660 --> 00:17:38.870
sorta like SQL for XML.
Yeah. Query query language for,

334
00:17:39.190 --> 00:17:42.430
for XML nodes. Yeah. But
typically you have to load

335
00:17:42.430 --> 00:17:46.060
these things up into an
X path document, a faster,

336
00:17:46.060 --> 00:17:50.070
more optimized XML document that's
optimized X path and for

337
00:17:50.400 --> 00:17:54.800
X, And Have to then
query from there. So how

338
00:17:54.800 --> 00:17:57.560
do I get the convenience
of an X path query

339
00:17:57.860 --> 00:18:00.200
without all the memory usage
that I would get from

340
00:18:00.200 --> 00:18:03.380
an X path document or
an XML document? And Darryl

341
00:18:03.380 --> 00:18:05.870
was Sandro has got an
X path reader. So it

342
00:18:05.870 --> 00:18:11.450
shrinks stir.com/c eight w dare.
And Howard's example is up

343
00:18:11.450 --> 00:18:14.390
there. And I've actually linked
to another, a really smart

344
00:18:14.390 --> 00:18:17.540
XML guy named Oliver Chenko
and all leg to Chenko.

345
00:18:17.540 --> 00:18:20.060
His blog is at <inaudible>
dot com slash see eight

346
00:18:20.060 --> 00:18:24.590
V and he's a, an
XML, a pundit. Another great

347
00:18:24.590 --> 00:18:29.360
guy is Daniel catalino@shrinks.com slash
C eight U. These are

348
00:18:29.360 --> 00:18:31.910
folks that I really keep
an eye on when it

349
00:18:31.910 --> 00:18:34.340
comes to what's really interesting
and going on within the

350
00:18:34.340 --> 00:18:37.670
XML space, the X path
reader that dare and Howard

351
00:18:37.670 --> 00:18:40.580
have got, has a subset
of X path. It lets

352
00:18:40.580 --> 00:18:43.220
you do those X paths.
That would make sense within

353
00:18:43.220 --> 00:18:47.570
a forward only context. So
you can ask questions of

354
00:18:47.600 --> 00:18:51.470
the X path reader and
actually build up an X

355
00:18:51.470 --> 00:18:53.960
path collection. And you could
say, well, here are three

356
00:18:53.960 --> 00:18:57.020
different queries that I want
you to watch mr. X

357
00:18:57.020 --> 00:19:00.710
path reader. And I could
say rather than reader.read, I

358
00:19:00.710 --> 00:19:04.790
would say reader.read on tell,
match, nice, and then ask

359
00:19:04.790 --> 00:19:07.220
it, which match it found.
So I would get the

360
00:19:07.220 --> 00:19:10.190
benefits of X path and
the speed and the convenience

361
00:19:10.190 --> 00:19:13.310
of an XML text reader.
That's shiny to quote you.

362
00:19:13.400 --> 00:19:16.160
It is shiny. Another really
shiny one. It was written

363
00:19:16.160 --> 00:19:20.930
by a fantastically brilliant woman
named Helena coupe Cova. And

364
00:19:21.020 --> 00:19:25.040
she actually wrote, I think,
called fast XML at shrink.com/c

365
00:19:25.040 --> 00:19:29.270
a Z, an XML processor
and parser that is eight,

366
00:19:29.300 --> 00:19:32.150
10, 20 times faster than
the ones that came from

367
00:19:32.150 --> 00:19:35.090
Microsoft. She did it as
her, I think our master's

368
00:19:35.090 --> 00:19:38.150
thesis or her PhD thesis.
And she has written an

369
00:19:38.150 --> 00:19:41.450
XML bookmark reader. Remember how
I said that? XML readers

370
00:19:41.450 --> 00:19:46.070
are forward only. Yeah, well,
she's got one at shrinks.com/c

371
00:19:46.070 --> 00:19:50.060
eight Y that would let
you Mark a point within

372
00:19:50.060 --> 00:19:54.110
an XML reader, continue to
move forward and play around

373
00:19:54.140 --> 00:19:57.560
and then say return and
remove bookmark and actually hop

374
00:19:57.560 --> 00:20:00.080
back to where you were
and then keep going. Awesome.

375
00:20:00.590 --> 00:20:02.870
So it's kinda like TiVo
for XML readers. I don't

376
00:20:02.870 --> 00:20:05.510
mean to overuse the TiVo
reference too much, but I

377
00:20:05.510 --> 00:20:08.030
absolutely love this thing because
a lot of times when

378
00:20:08.030 --> 00:20:11.780
you're doing an XML, a
pipeline like this XML reader

379
00:20:11.780 --> 00:20:14.960
writer, pipeline, where you're passing
in readers and writers, you

380
00:20:14.960 --> 00:20:17.780
can be concerned that your
implementation is going to misuse

381
00:20:17.780 --> 00:20:20.510
the reader. Someone might read
one step too far or

382
00:20:20.510 --> 00:20:23.630
not far enough, and kind
of mess things up with

383
00:20:23.630 --> 00:20:27.620
the bookmark reader. Your outer
pipeline can return back to

384
00:20:27.620 --> 00:20:30.710
a known point and continue
on. That's often someone who

385
00:20:30.710 --> 00:20:34.460
wrote a malformed or well
poorly behaved chunk of that

386
00:20:34.460 --> 00:20:38.330
pipeline can, can have themselves
saved by this bookmarking reader.

387
00:20:38.390 --> 00:20:40.790
Wow. That's that's fabulous, man.
Well, some other cool things

388
00:20:40.790 --> 00:20:42.710
that you can do with
XML readers are you can,

389
00:20:42.980 --> 00:20:44.930
and this is this'll blow
your mind. I hope it

390
00:20:44.930 --> 00:20:50.560
does. You can make XML
reader implementations over things that

391
00:20:50.560 --> 00:20:55.150
aren't themselves XML. Huh? So
I'll pause for effect there.

392
00:20:55.150 --> 00:20:57.450
And you can just drink
that. Yeah. So like a

393
00:20:57.510 --> 00:21:00.570
comma separated value file or
in any file or something

394
00:21:00.570 --> 00:21:04.770
like that and how absolutely
You've done your research@trickster.com slash

395
00:21:04.800 --> 00:21:09.330
<inaudible>. They've got an XML
reader that reads CSV files.

396
00:21:09.360 --> 00:21:12.450
So what it's doing is
remember that the XML reader,

397
00:21:12.690 --> 00:21:16.620
when you say reader.read, it
sets a number of variables

398
00:21:16.620 --> 00:21:20.490
and properties like node type
saying, what kind of note

399
00:21:20.490 --> 00:21:22.080
am I on? Am I
on an element? Am I

400
00:21:22.080 --> 00:21:24.810
on an attribute and my
own an end element. So

401
00:21:24.810 --> 00:21:26.610
if you want it to
provide a view over a

402
00:21:26.610 --> 00:21:29.160
CSV document, you could decide,
what does that mean to

403
00:21:29.160 --> 00:21:32.040
you? Is that, is it
the comma on, you know,

404
00:21:32.280 --> 00:21:33.840
that that is the XML
element? Or is that the,

405
00:21:33.840 --> 00:21:36.600
is it the quote within
a CSV document, right? You

406
00:21:36.600 --> 00:21:38.700
get to decide. And as
long as you return the

407
00:21:38.700 --> 00:21:42.270
right answer so that the
consumer thinks it's XML, the

408
00:21:42.270 --> 00:21:46.470
fact that your underlying not
reading XML doesn't matter because

409
00:21:46.470 --> 00:21:48.720
the XML reader doesn't care
about angle brackets. It cares

410
00:21:48.720 --> 00:21:53.100
about this information set. So
the XML CSV reader makes

411
00:21:53.610 --> 00:21:57.450
CSV files look like XML.
That's what really is cool

412
00:21:57.450 --> 00:22:00.300
about that is you could
then run an XSLT transform

413
00:22:01.170 --> 00:22:04.590
on a CSV file. You
can actually write an XSLT

414
00:22:04.590 --> 00:22:07.170
and, you know, an XML
style sheet transformation over the

415
00:22:07.170 --> 00:22:10.680
top of an XML CSV
reader. So literally going directly

416
00:22:10.680 --> 00:22:15.120
from comma separated values to
HTML or XML or something

417
00:22:15.120 --> 00:22:19.320
else without having to do
intermediate steps. Cause typically you

418
00:22:19.320 --> 00:22:21.660
would want to just read
that CSV file on yourself.

419
00:22:21.660 --> 00:22:23.310
Maybe save it to a
dataset or put it in

420
00:22:23.310 --> 00:22:26.000
a temporary file and then
transform from there. Have you

421
00:22:26.000 --> 00:22:29.850
had, Do you use this
yourself at work? Yeah. Anytime

422
00:22:29.850 --> 00:22:32.310
I can do a streaming
transformation over any kind of

423
00:22:32.310 --> 00:22:35.910
thing, rather than loading it
up into memory. I love

424
00:22:35.910 --> 00:22:37.770
doing that kind of stuff.
Yeah. The ability to make

425
00:22:37.770 --> 00:22:40.470
an XML reader over the
top of something that isn't

426
00:22:40.770 --> 00:22:43.560
XML, that's a really powerful
thing. The any reader is

427
00:22:43.560 --> 00:22:47.430
pretty cool. He XML any
reader by Ralph westfall@shrinks.com slash

428
00:22:47.430 --> 00:22:51.570
<inaudible> makes regular old INI
files like any files from

429
00:22:51.570 --> 00:22:54.450
back in the day, look
like XML. But what's interesting

430
00:22:54.450 --> 00:22:56.730
about that article is it
gives you the tools to

431
00:22:56.730 --> 00:22:59.430
do this yourself with maybe
flat files you have. Now,

432
00:22:59.730 --> 00:23:01.650
if you're a company that
has got flat files that

433
00:23:01.650 --> 00:23:03.660
you wish were XML, or
I know that you're going

434
00:23:03.660 --> 00:23:07.050
to move them to XML,
you could start now by

435
00:23:07.050 --> 00:23:09.510
making that information set available.
And then when you eventually

436
00:23:09.510 --> 00:23:13.140
do change them into XML,
your consumers wouldn't, wouldn't actually

437
00:23:13.140 --> 00:23:18.030
care. Sweet. Another great one
is by Aaron scanner, actually@shrinks.com

438
00:23:18.030 --> 00:23:21.360
slash C nine zero. Who's
got a file system navigator.

439
00:23:21.720 --> 00:23:25.140
Basically he's taken the interface
of X path node iterator,

440
00:23:25.590 --> 00:23:28.320
and he's made it over
the file system. So you

441
00:23:28.320 --> 00:23:31.320
could run X path queries
over your hard drive. Wow.

442
00:23:31.440 --> 00:23:35.490
Again, all of this is
about implementing interfaces or making

443
00:23:35.490 --> 00:23:39.060
classes that derive from abstract
based classes that as long

444
00:23:39.060 --> 00:23:41.400
as you follow the contract,
as long as you answer

445
00:23:41.400 --> 00:23:45.230
the questions and produce the
right information, the fact you're

446
00:23:45.230 --> 00:24:05.980
not reading underlying XML is
an implementation detail. Okay, Scott,

447
00:24:06.160 --> 00:24:07.960
Very cool. What else are
we going to talk about

448
00:24:07.960 --> 00:24:11.740
today? Well, so we've been
talking about IX. I'm extending

449
00:24:11.740 --> 00:24:15.370
some of the inner interfaces
that Microsoft gives, you know,

450
00:24:15.370 --> 00:24:19.180
like the XML reader, but
there are other extension points

451
00:24:19.180 --> 00:24:22.990
within kind of the, the
XML ethos that that can

452
00:24:22.990 --> 00:24:28.240
be exploited. The XML MVP
group, a bunch of MVPs

453
00:24:28.240 --> 00:24:31.570
have gotten together and they've
added things to system dot

454
00:24:31.570 --> 00:24:36.100
XML, the XML namespace that
they wish Microsoft would have

455
00:24:36.100 --> 00:24:39.190
done. Maybe Microsoft didn't have
time, or it was an

456
00:24:39.190 --> 00:24:42.670
esoteric thing that they didn't
feel was necessary and up

457
00:24:42.670 --> 00:24:47.200
at XML, mvp.org, they've added
a couple of classes that

458
00:24:47.200 --> 00:24:50.080
you can just download their
BSD license. There's one for

459
00:24:50.080 --> 00:24:54.340
dotnet two. Oh, and there's
one for.net, a one.one. And

460
00:24:54.420 --> 00:24:59.080
an interesting one is an
an XSL reader. So this

461
00:24:59.080 --> 00:25:03.550
is a, a transformation we
know oftentimes we'll do XSLT

462
00:25:03.550 --> 00:25:07.360
transformations where you'll take a
Dom and a apply a

463
00:25:07.360 --> 00:25:11.200
style sheet to it, a
tree transformation language. And typically

464
00:25:11.200 --> 00:25:15.040
that gets transformed into another
Dom. They've got an ex

465
00:25:15.070 --> 00:25:18.280
an XSL reader that lets
you read the results of

466
00:25:18.280 --> 00:25:21.470
that transformation as if it
were an XML reader that

467
00:25:21.470 --> 00:25:24.760
what's significant about. This is
if you were stringing lots

468
00:25:24.760 --> 00:25:28.480
of things together, making a
pipeline of readers into readers,

469
00:25:28.480 --> 00:25:32.140
into writers, into readers, then
you could take something like

470
00:25:32.140 --> 00:25:33.970
this and you could say,
I'm going to take the

471
00:25:33.990 --> 00:25:37.360
CSV file and read it
with the CSV reader, do

472
00:25:37.360 --> 00:25:40.840
an XSL transform with some
XSLT and the results will

473
00:25:40.840 --> 00:25:43.990
go straight into an XSL
reader. And this is important

474
00:25:43.990 --> 00:25:47.350
because in dotnet to, Oh,
the XSL compiled transform. Remember

475
00:25:47.350 --> 00:25:49.780
how we said that they
have a new class in.net

476
00:25:49.780 --> 00:25:53.050
that has compiled transforms, right?
Well, because of the way

477
00:25:53.050 --> 00:25:56.860
it's doing that compilation, they've
thrown away the ability to

478
00:25:56.860 --> 00:26:01.060
transform into an excess an
XML reader. So this team

479
00:26:01.060 --> 00:26:04.810
has basically put that functionality
back and they're making it

480
00:26:04.810 --> 00:26:08.410
available. And those other great
features that they've added to

481
00:26:08.410 --> 00:26:10.370
XML that you might want
to take a look at

482
00:26:10.370 --> 00:26:14.410
an XML, mvp.org. Another thing
that they've added is what's

483
00:26:14.410 --> 00:26:20.320
called E XSLT. And you
can learn about that@exslt.org. These

484
00:26:20.320 --> 00:26:25.240
are kind of formalized extensions
to XSLT when you're writing

485
00:26:25.240 --> 00:26:28.660
this XSLT transformation language and
you, you hit a wall.

486
00:26:28.930 --> 00:26:31.060
Microsoft lets you throw script
in there. You know, and

487
00:26:31.060 --> 00:26:33.940
a lot of people have
with ms. XML and back

488
00:26:33.940 --> 00:26:36.130
in the calm days and
the VB days, you'd you'd

489
00:26:36.130 --> 00:26:41.140
throw JavaScript or VB script
inside of your XSLT transformation.

490
00:26:41.680 --> 00:26:43.620
And when you did the
transform, they fire up the

491
00:26:43.620 --> 00:26:45.840
scripting language and you'd have
a little opportunities to poke

492
00:26:45.840 --> 00:26:51.960
around in there, but they've
actually formalized this, this XSLT

493
00:26:51.960 --> 00:26:56.760
series of libraries E xslt.org,
and they've built support for

494
00:26:56.760 --> 00:27:02.970
these libraries into a.net and
the MVP XML library. What's

495
00:27:02.970 --> 00:27:06.030
cool about that is that
before, when you wrote Java

496
00:27:06.030 --> 00:27:09.270
script and VB script, you
were pretty much stuck with

497
00:27:09.270 --> 00:27:12.660
whatever XSLT transformer you were
using. You're pretty much stuck

498
00:27:12.660 --> 00:27:17.460
on Microsoft, but now E
XSLT, these libraries are described

499
00:27:17.460 --> 00:27:19.770
in a way that is
more about the interface and

500
00:27:19.770 --> 00:27:23.670
less about the implementation. So
they've got a.net implementation of

501
00:27:23.670 --> 00:27:26.850
XSLT, which means I could
actually run it on different

502
00:27:26.850 --> 00:27:30.270
implementations of an XSL transformer.
I could take an XSLT

503
00:27:30.270 --> 00:27:32.790
that maybe a Linux user
was using against a Java

504
00:27:33.530 --> 00:27:36.750
XML library and transforming on
a Linux machine. But he

505
00:27:36.750 --> 00:27:40.950
used these libraries, these methods
that are available via XSLT

506
00:27:41.250 --> 00:27:44.070
and they'd still work on.net.
So it's almost like saying

507
00:27:44.100 --> 00:27:49.230
cross-platform XSLT XSLT at its
purest sense is something that

508
00:27:49.230 --> 00:27:51.540
if you just write pure
XSLT, for the most part,

509
00:27:51.780 --> 00:27:53.610
if they follow the spec,
you can use any number

510
00:27:53.610 --> 00:27:57.540
of transforming engines. But as
soon as you start extending

511
00:27:57.540 --> 00:27:59.280
it and putting in script
of your own, you're pretty

512
00:27:59.280 --> 00:28:03.810
much stuck. And it had
have basically written Microsoft specific

513
00:28:03.870 --> 00:28:07.740
XSLT. This E XSLT has
become enough of a standard

514
00:28:07.740 --> 00:28:09.540
now that there are a
lot of choices for people

515
00:28:09.540 --> 00:28:12.090
who are writing these style
sheets, smoking, it is pretty

516
00:28:12.090 --> 00:28:14.790
sweet. Yeah. You've been writing
a lot about XML this

517
00:28:14.790 --> 00:28:18.210
week. What are some posts
that you want to point

518
00:28:18.210 --> 00:28:22.380
us to? I did some
XSLT stuff a while back

519
00:28:22.380 --> 00:28:26.820
on@ashrinkstir.com slash B F zero.
Talking about how, when you

520
00:28:26.820 --> 00:28:29.580
do XSLT, you've really got
to just test, test, test,

521
00:28:29.580 --> 00:28:32.640
test, test. And we actually
got to interact with some

522
00:28:32.640 --> 00:28:35.250
of the guys at the
XML perf team at Microsoft.

523
00:28:35.250 --> 00:28:39.060
And they said that even
though you can write XSLT

524
00:28:39.060 --> 00:28:42.780
and most often everything that
you write is portable. If

525
00:28:42.780 --> 00:28:45.780
you're really serious about performance,
you need to tweak it

526
00:28:45.780 --> 00:28:48.870
for the quirks of the
particular partial that you're using

527
00:28:49.650 --> 00:28:55.350
some performance testing on the
comm based MSX SL for

528
00:28:55.350 --> 00:28:58.170
MSML six, we use done
at one Oh two Oh

529
00:28:58.560 --> 00:29:03.360
and learn some techniques that
can make XML transformations more,

530
00:29:03.390 --> 00:29:07.530
more powerful and more efficient.
Okay. Another one is some

531
00:29:07.680 --> 00:29:10.800
fragment writing. A lot of
times people want to write

532
00:29:10.800 --> 00:29:15.150
out an XML document from
an object, but they don't

533
00:29:15.150 --> 00:29:19.920
want all the namespaces. Maybe
they want some backward compatibility.

534
00:29:19.920 --> 00:29:21.690
They don't really want an
XML document. They want an

535
00:29:21.690 --> 00:29:25.080
XML fragment. We've got an
XML fragment writer up at

536
00:29:25.080 --> 00:29:30.180
shrinks.com/ <inaudible>. And then as
I mentioned before, I'm reading

537
00:29:30.180 --> 00:29:34.800
those fragments back in with
the serializer@shrinks.com slash <inaudible>. Okay.

538
00:29:34.800 --> 00:29:37.980
What are some XML sites
that you visit regularly? Well,

539
00:29:37.980 --> 00:29:41.830
so blogs that I read
of folks that are into

540
00:29:41.830 --> 00:29:47.800
XML deeply, like I'd mentioned
Olay kotanko@shrinks.com slash C eight

541
00:29:47.800 --> 00:29:51.910
V is amazing. I just
love reading his stuff. Daniel

542
00:29:51.910 --> 00:29:56.200
catalino@shrinker.com slash C eight U
has got a whole series

543
00:29:56.200 --> 00:30:00.370
on XML performance. I love
reading stuff by Daryl Obasanjo.

544
00:30:00.370 --> 00:30:04.540
I love reading stuff by
Aaron Skynard anything up on

545
00:30:04.540 --> 00:30:08.380
MSD, antibiotics, AML. They really
have some brilliant stuff. Anytime

546
00:30:08.380 --> 00:30:11.290
you can read an article
by Halena cook Cova whose

547
00:30:11.290 --> 00:30:13.300
blog I have been unable
to find, but she is

548
00:30:13.300 --> 00:30:16.690
absolutely brilliant. And reading the
code inside of the XML,

549
00:30:16.690 --> 00:30:20.020
bookmark reader is pretty amazing
grant, actually, a link that

550
00:30:20.020 --> 00:30:22.090
I forgot to, to put
up, but I think you

551
00:30:22.090 --> 00:30:25.570
could probably find it up
on my blog is a

552
00:30:25.570 --> 00:30:30.130
thing called an SGML reader.
You know how HTML is

553
00:30:30.130 --> 00:30:33.190
not well formed. There's no
rule that says that you

554
00:30:33.190 --> 00:30:36.040
absolutely have to have a
closing tag, right? When you

555
00:30:36.040 --> 00:30:38.530
open a tag like the
BR tags, real common tag,

556
00:30:38.530 --> 00:30:42.370
that people don't close you
can't open up an regular

557
00:30:42.370 --> 00:30:46.420
old HTML document as an
XML file as an XML

558
00:30:46.420 --> 00:30:49.270
document, because if it's not
well formed and it's not

559
00:30:49.270 --> 00:30:52.390
XML well, Chris love it
wrote a thing called the

560
00:30:52.390 --> 00:30:54.700
SGML reader. And you can
Google for this. It'll be

561
00:30:54.700 --> 00:30:58.840
the first hit. The SGML
reader is an XML reader,

562
00:30:58.870 --> 00:31:01.300
right? So he's derived from
XML reader. And what he

563
00:31:01.300 --> 00:31:05.020
does is he actually auto
closes tags. So if he

564
00:31:05.020 --> 00:31:07.660
sees that there's a tag
that's been opened and then

565
00:31:07.660 --> 00:31:10.000
he gets farther along into
the document and notices that

566
00:31:10.210 --> 00:31:13.180
if I read the next
element, that this is going

567
00:31:13.180 --> 00:31:16.090
to be an invalid document,
he will go back and

568
00:31:16.120 --> 00:31:19.720
automatically close elements that need
to be closed. So that

569
00:31:20.020 --> 00:31:23.230
a poorly formed document, like
whether it be Oh, effects

570
00:31:23.230 --> 00:31:25.540
in my case, the financial
exchange format, or whether it's

571
00:31:25.540 --> 00:31:29.800
HTML, you'll get valid XML.
So if you have some

572
00:31:29.800 --> 00:31:32.110
HTML you want to clean
up or you need to

573
00:31:32.110 --> 00:31:36.100
parse some XML, that's not
necessarily well-formed the SGML reader

574
00:31:36.100 --> 00:31:37.990
is a really great way
to do that. This is

575
00:31:37.990 --> 00:31:39.970
a lot of information in
a really short period of

576
00:31:39.970 --> 00:31:42.370
time. And XML is one
of those things that, you

577
00:31:42.370 --> 00:31:44.500
know, you could get really
deeply into. And there are

578
00:31:44.500 --> 00:31:47.890
people who spend their entire
career focused on XML. But

579
00:31:47.890 --> 00:31:50.020
the, the thing that, that
I want to get across

580
00:31:50.020 --> 00:31:52.660
to folks is that a,
if you don't want to

581
00:31:52.660 --> 00:31:55.630
see angle brackets, you don't
have to, there are so

582
00:31:55.630 --> 00:31:58.750
many things that allow you
to look at XML without

583
00:31:58.750 --> 00:32:01.090
ever seeing an angle bracket.
It's really about the information

584
00:32:01.090 --> 00:32:03.510
set, not the brackets. And
that said, you know, it's

585
00:32:03.510 --> 00:32:05.970
always a good idea to
have at least one or

586
00:32:05.970 --> 00:32:09.540
two really hot shot XML
guys on your, on your

587
00:32:09.540 --> 00:32:14.400
staff, in your development team.
Yeah. And it's probably good

588
00:32:14.460 --> 00:32:16.830
if it was you. One
of the things that my

589
00:32:16.830 --> 00:32:20.190
boss says is that Every
problem in computer science can

590
00:32:20.190 --> 00:32:23.970
be solved by one additional
layer of abstraction. Yeah. That's

591
00:32:24.270 --> 00:32:26.820
dealing with XML having these
nice clean interfaces and then

592
00:32:26.820 --> 00:32:29.610
having just a little layer
of abstraction around them gives

593
00:32:29.610 --> 00:32:33.090
you a lot of flexibility,
whether you're parsing RSS or

594
00:32:33.450 --> 00:32:36.180
pulling information out of a
CSV file, those layers of

595
00:32:36.180 --> 00:32:40.430
distraction and a nice clean
library, the Dunnet base Class

596
00:32:40.430 --> 00:32:42.440
library and system dot XML
and make life a lot

597
00:32:42.440 --> 00:32:45.710
easier. And that's a show
everything else wanted to know

598
00:32:45.710 --> 00:32:48.920
about XML. Thank you, Scott.
Thank you, Carl. Thank you

599
00:32:48.920 --> 00:32:52.190
listeners. And we'll see you
next week on Hansel minutes.


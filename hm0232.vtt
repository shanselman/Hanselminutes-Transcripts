WEBVTT FILE

1
00:00:12.120 --> 00:00:17.610
From hanselminutes.com. It's Hansel minutes,
a weekly discussion with web

2
00:00:17.610 --> 00:00:22.170
developer and technologists. Scott Hanselman.
This is Lawrence Ryan announcing show

3
00:00:22.170 --> 00:00:28.050
number two 32 recorded live
Thursday, September 9th, 2010. Support for Hanselman

4
00:00:28.070 --> 00:00:31.110
is provided by teller R
a D controls the most

5
00:00:31.110 --> 00:00:34.740
comprehensive suite of components for
windows forms and asp.net web

6
00:00:34.740 --> 00:00:43.770
applications. online@wwwdottelerik.com. In this episode,
Scott talks with Colin Miller

7
00:00:43.800 --> 00:00:49.260
about the.net micro framework. Hi,
this is Scott Hanselman, and

8
00:00:49.260 --> 00:00:51.810
this is another episode of
Hansel minutes. Today. I've got

9
00:00:52.170 --> 00:00:56.010
Colin Miller, that product unit
manager for the dotnet micro

10
00:00:56.010 --> 00:01:00.180
framework, tiny, tiny, tiny framework.
Thank you Colin for taking

11
00:01:00.180 --> 00:01:04.720
a second to chat with
me today. Thank you. I'm

12
00:01:04.720 --> 00:01:07.530
I'm looking at my spot
watch. I've got a spot

13
00:01:07.530 --> 00:01:10.830
watch spot was a smart,
personal object technology. And I

14
00:01:10.830 --> 00:01:12.630
remember that this thing came
out. It came out in

15
00:01:12.630 --> 00:01:16.380
2004 and I loved this
thing. It was tiny and

16
00:01:16.380 --> 00:01:20.010
they always told me that
I could write.net code on

17
00:01:20.010 --> 00:01:21.540
this. I can write C
sharp and we talked and

18
00:01:21.540 --> 00:01:25.110
I never got around to
writing C sharp code, but

19
00:01:25.250 --> 00:01:30.800
did this watch really run.net?
It did actually. Unfortunately you

20
00:01:30.800 --> 00:01:33.530
probably would have been disappointed
to try and write C-sharp

21
00:01:33.530 --> 00:01:35.690
code. Cause one thing we
didn't do at the time

22
00:01:35.690 --> 00:01:40.280
was actually expose the ability
to, to download your own

23
00:01:40.280 --> 00:01:45.080
applications on it. So it
did support downloading assemblies, all

24
00:01:45.080 --> 00:01:48.920
of which were written in,
in C sharp. One of

25
00:01:48.920 --> 00:01:52.460
the things in looking at
creating that watch was we

26
00:01:52.460 --> 00:01:54.740
were looking, as you can
tell from the name, we

27
00:01:54.740 --> 00:01:58.370
were looking at a very
broad idea of smart, personal

28
00:01:58.370 --> 00:02:01.430
objects, all sorts of things,
becoming smarter in your environment.

29
00:02:02.030 --> 00:02:04.760
And we were looking for
a platform that we thought

30
00:02:05.300 --> 00:02:07.250
we would want it, frankly,
we want to be working

31
00:02:07.250 --> 00:02:11.600
in, in these small devices
and not finding one. We

32
00:02:11.600 --> 00:02:15.890
ended up creating one and
by, by taking the idea

33
00:02:15.890 --> 00:02:19.790
and the, and the CLR
model, and reimplementing it for

34
00:02:19.790 --> 00:02:24.050
these specifically for these very
small devices and then actually

35
00:02:24.050 --> 00:02:27.950
extending it quite a bit
for things that are specific

36
00:02:27.950 --> 00:02:33.020
requirements of embedded devices. So
exposing the underlying hardware interfaces,

37
00:02:33.050 --> 00:02:36.860
GPIO things like that and
our management things that frankly,

38
00:02:36.860 --> 00:02:39.830
aren't very interesting on a,
on a, on a, on,

39
00:02:40.100 --> 00:02:44.870
on a desktop.net application. W
was that an unusual idea?

40
00:02:44.900 --> 00:02:46.730
I mean, were you there
in those first meetings where

41
00:02:46.730 --> 00:02:48.560
they were like, yeah, let's
do it and see, and

42
00:02:48.560 --> 00:02:49.940
you're like, no, no, let's
do it. And you just

43
00:02:49.940 --> 00:02:52.070
use.net. Yeah. We actually tried
to do it and see

44
00:02:52.070 --> 00:02:55.580
to start with, and we
looked at some, some platforms

45
00:02:55.610 --> 00:03:00.130
that were available in research
and commercially and I had

46
00:03:00.130 --> 00:03:05.560
some failures right off the
bat and the embedded. Development's

47
00:03:05.570 --> 00:03:10.030
always been a very specialized
set of skills and which

48
00:03:10.300 --> 00:03:12.700
frankly, we didn't have a
lot of inside Microsoft. We

49
00:03:12.700 --> 00:03:16.960
did have a lot of.net
developers. And so we could

50
00:03:16.960 --> 00:03:19.090
see that if we were
going to develop applications, it

51
00:03:19.090 --> 00:03:21.520
was going to be much
easier to get the skills

52
00:03:21.520 --> 00:03:25.300
to do that. If we
had a platform that that

53
00:03:25.300 --> 00:03:27.520
would allow us to use
the, the bulk of the

54
00:03:27.550 --> 00:03:31.450
development skills that both Microsoft
has, but also frankly, the,

55
00:03:31.450 --> 00:03:35.470
the, the general industry has.
And the idea certainly was

56
00:03:35.470 --> 00:03:38.830
that we would, we would
have a platform that would

57
00:03:38.830 --> 00:03:42.520
be open to a lot
of variations in applications. So

58
00:03:43.270 --> 00:03:45.910
finding something where we had
a much higher productivity than

59
00:03:45.910 --> 00:03:50.740
the current model of embedded
application development was, was key

60
00:03:50.740 --> 00:03:53.920
to the whole, to the
whole idea. And this happened

61
00:03:54.100 --> 00:03:56.950
sort of concurrently with some
things happening at hardware that

62
00:03:56.950 --> 00:04:01.240
made all this possible, that
you know, up until not

63
00:04:01.240 --> 00:04:03.520
too many years ago, about
that same time, almost all

64
00:04:03.520 --> 00:04:08.350
applications were written on little
eight bit processors. And, and

65
00:04:08.440 --> 00:04:11.650
then suddenly the 32 bit
processors came down in power

66
00:04:11.650 --> 00:04:15.400
consumption and price. So it
was economically feasible to make

67
00:04:15.400 --> 00:04:19.510
these devices in, in, on
a, in a, in a

68
00:04:19.510 --> 00:04:21.790
language that is the same
set of tools that are

69
00:04:21.790 --> 00:04:24.640
the same ones you use
on a desktop and, and

70
00:04:24.640 --> 00:04:28.300
to change and change the
way embedded development is done.

71
00:04:28.300 --> 00:04:31.480
So it's not done again
by specialized skills and using

72
00:04:31.480 --> 00:04:34.480
specialized tools, but by using
the same tools that you

73
00:04:34.480 --> 00:04:39.340
have using for your other
applications. One of the things

74
00:04:39.340 --> 00:04:41.260
that I think makes it
really interesting is that we're

75
00:04:41.260 --> 00:04:47.170
seeing more and more connected
devices coming out. There's, there's

76
00:04:47.170 --> 00:04:51.070
actually estimations that there are
more as many devices at

77
00:04:51.070 --> 00:04:53.140
this point talking to each
other over the internet, as

78
00:04:53.140 --> 00:04:55.990
there are people, and the
expectation that that's going to

79
00:04:55.990 --> 00:04:59.830
be many times as many
devices as people in the

80
00:04:59.830 --> 00:05:03.880
near future. So these devices
are now becoming part of

81
00:05:03.880 --> 00:05:07.390
the ecosystem. Like we sort
of saw potentially happening back

82
00:05:07.390 --> 00:05:11.710
in 2004. And as they
happen as that, as they

83
00:05:11.710 --> 00:05:14.620
start to become parts of
larger solutions, rather than isolated

84
00:05:14.620 --> 00:05:17.830
embedded devices, it becomes more
and more interesting for the

85
00:05:17.830 --> 00:05:21.790
developers to be able to
for.net to the developers, to

86
00:05:21.790 --> 00:05:24.670
be able to, to work
in these, on these small

87
00:05:24.670 --> 00:05:28.270
devices as well at the
PDC, not too long ago,

88
00:05:28.300 --> 00:05:31.570
professional developers conference, I had
one guy extremely excited about

89
00:05:31.570 --> 00:05:35.140
the micro framework because his
company had just turned down

90
00:05:35.140 --> 00:05:39.130
a job, which included, required
that they work on a

91
00:05:39.130 --> 00:05:42.310
device. And now he realized
that they didn't have to

92
00:05:42.310 --> 00:05:45.730
do that anymore. That doesn't
mean that this is the

93
00:05:45.730 --> 00:05:48.730
platform for all embedded development,
but for a large number

94
00:05:48.730 --> 00:05:53.020
of embedded applications, the kind
of the kind of productivity

95
00:05:53.680 --> 00:05:57.810
that you get from development
makes it, makes it feasible

96
00:05:58.130 --> 00:06:01.580
to generate applications really quickly
that may not have the

97
00:06:01.580 --> 00:06:04.310
same, you know, real time
or very specialized requirements as

98
00:06:04.320 --> 00:06:08.290
others that others do. When
I think when I think

99
00:06:08.290 --> 00:06:10.600
32 bit processor, I think
about three to six is

100
00:06:10.600 --> 00:06:14.140
and 43 sixes. And now
you're saying that they're connected

101
00:06:14.140 --> 00:06:16.690
and I've seen a lot
of these boards have USB

102
00:06:16.690 --> 00:06:19.480
and have different plugs that
I'm used to seeing are

103
00:06:19.480 --> 00:06:23.080
these tiny three sixes and
46, is that we're able

104
00:06:23.080 --> 00:06:25.000
to buy for a couple
of dollars now, or is

105
00:06:25.000 --> 00:06:28.300
it something else? Well, these,
these are mostly like arm

106
00:06:28.300 --> 00:06:34.870
processors that sh two processors
from an assist cortex processors,

107
00:06:35.110 --> 00:06:37.330
not too many, three 86
is, and four 86 is

108
00:06:37.340 --> 00:06:41.110
these are, these are mostly
like the arm seven sized

109
00:06:41.110 --> 00:06:48.820
processors. They're yeah. They're almost
all risk processors. The, and

110
00:06:48.820 --> 00:06:51.820
they're up in the, you
know, the watches were done

111
00:06:51.820 --> 00:06:56.680
in a 27 megahertz processor.
The, the current ones are

112
00:06:56.680 --> 00:07:00.550
in the 70 megahertz range
frequently, Really, but they are

113
00:07:00.550 --> 00:07:02.890
equivalent in power. I mean,
thinking about the machines that

114
00:07:02.890 --> 00:07:06.460
I used when I was
in school, I'm hearing you

115
00:07:06.460 --> 00:07:10.600
say that, you know, as
far as like horsepower, they're

116
00:07:10.600 --> 00:07:14.050
there, they're there. Yeah. We
estimated that the, that the,

117
00:07:14.050 --> 00:07:16.810
that the processor in that
watch was about to say

118
00:07:16.840 --> 00:07:19.060
same as a, that was
an old PCAT that we

119
00:07:19.060 --> 00:07:22.690
worked on when we were
younger and took up most

120
00:07:22.690 --> 00:07:28.510
of my desk. That's amazing.
Now, when you're compiling, when

121
00:07:28.510 --> 00:07:30.460
you're trying to make the
done at framework and that

122
00:07:30.460 --> 00:07:34.480
then the CLR work, how
confident were you that it

123
00:07:34.480 --> 00:07:36.400
was gonna fit? I mean,
I think of the framework

124
00:07:36.400 --> 00:07:39.520
scaling up. I remember switching
from 32 bit processors to

125
00:07:39.520 --> 00:07:44.200
64 bit. I remember applications
using two, three and four

126
00:07:44.230 --> 00:07:49.000
gigabytes of Ram, you know,
scaling out, scaling up, how

127
00:07:49.000 --> 00:07:51.040
hard is it to scale
down and what kinds of

128
00:07:51.040 --> 00:07:53.980
things you have to throw
away. It actually requires that

129
00:07:53.980 --> 00:07:58.270
you start from scratch. There
there's really no effective way

130
00:07:58.270 --> 00:08:00.640
that we've never found anything
that we could take an

131
00:08:00.640 --> 00:08:05.350
implementation that didn't start thinking
how small it could be

132
00:08:05.350 --> 00:08:10.420
and effectively scale it down.
So what we do is

133
00:08:10.420 --> 00:08:12.370
we, we, and it's one
of the reasons why we're

134
00:08:12.370 --> 00:08:17.290
sort of an odd, odd
ball and the.net family, the

135
00:08:17.290 --> 00:08:21.360
other.net versions, the compact framework
and the full framework are,

136
00:08:21.490 --> 00:08:25.210
are in sync and compatible.
So if, if when you

137
00:08:25.210 --> 00:08:28.770
look at version 4.0 of,
of compact framework, it will

138
00:08:28.770 --> 00:08:33.190
be the same as 4.0
the full framework. Our 4.0

139
00:08:33.220 --> 00:08:35.200
is sort of a, an
odd mix because we go

140
00:08:35.200 --> 00:08:37.300
up and look at what's
going on. And then main,

141
00:08:37.540 --> 00:08:41.350
main framework. We sort of
cherry pick what's appropriate for

142
00:08:41.350 --> 00:08:43.930
these, for these smaller devices.
There's a lot of things

143
00:08:43.930 --> 00:08:46.900
that frankly are not as
useful, not likely to be

144
00:08:46.900 --> 00:08:51.070
useful on these small devices.
And then we reimplement what

145
00:08:51.250 --> 00:08:54.460
what's important down there. So
we spent, you know, because

146
00:08:54.460 --> 00:08:58.290
these, because these are connected
devices, we spent a lot

147
00:08:58.290 --> 00:09:01.590
of time picking things out
of WCF. And so we

148
00:09:01.590 --> 00:09:06.150
have support for web services
for devices or DPW S

149
00:09:07.350 --> 00:09:11.220
because these devices frequently have
user interfaces. We take, we

150
00:09:11.220 --> 00:09:14.940
took a lot of the
WPF model and, and put

151
00:09:14.940 --> 00:09:17.760
that down here. But again,
all these things are, are

152
00:09:17.760 --> 00:09:24.890
uniquely uniquely implemented for these
devices. The development environment is

153
00:09:24.890 --> 00:09:30.590
visual studio, and I was
actually surprised slash impressed when

154
00:09:30.590 --> 00:09:33.380
I, I just installed on
a framework micro framework, rather

155
00:09:33.410 --> 00:09:37.220
4.1, I said, file new
project inside of the same

156
00:09:37.280 --> 00:09:40.550
IDE that I was using
for websites that I was

157
00:09:40.550 --> 00:09:43.550
using for windows phone. It's
just, it's all inside there.

158
00:09:43.550 --> 00:09:46.550
So that was cool. And
then F five debugging, all

159
00:09:46.550 --> 00:09:49.670
that stuff worked exactly as
before now, I noticed that

160
00:09:49.670 --> 00:09:53.810
I did have to install
something special for each board

161
00:09:53.870 --> 00:09:57.200
that I had. I have
a GHS electronics board. I

162
00:09:57.200 --> 00:09:59.840
have a Tahoe, two board
and a net Duino so

163
00:09:59.840 --> 00:10:03.110
three different boards from three
different manufacturers. They all use

164
00:10:03.110 --> 00:10:05.240
the micro framework, but for
each of them, I had

165
00:10:05.240 --> 00:10:08.420
to install something else. Can
you talk about the relationship

166
00:10:08.420 --> 00:10:10.820
between the micro framework and
that thing that I have

167
00:10:10.820 --> 00:10:14.840
to install for each board?
Yeah, there's, there's, there's essentially

168
00:10:14.840 --> 00:10:18.770
two layers of, of work
that are, that our partners

169
00:10:18.770 --> 00:10:23.720
do. The, the application that
you create is hopefully going

170
00:10:23.720 --> 00:10:26.660
to be very hardware independent
because you're working in a

171
00:10:26.660 --> 00:10:31.580
virtual machine, which is our,
our CLR and underneath that

172
00:10:32.300 --> 00:10:35.870
too, because the processors and
the hardware that these each

173
00:10:35.870 --> 00:10:39.260
of these partners is using
is fundamentally different in some

174
00:10:39.260 --> 00:10:42.680
way or another. It's, there's
a requirement that they actually

175
00:10:42.680 --> 00:10:47.060
work at the, at the
driver level that's done in

176
00:10:47.480 --> 00:10:50.480
C plus plus with the
tools that are provided by

177
00:10:50.480 --> 00:10:54.320
the processor manufacturer that they
select. So they do some

178
00:10:54.320 --> 00:10:58.100
of the heavy lifting to
glue the, the micro framework

179
00:10:58.130 --> 00:11:01.430
into their specific hardware. And
then at the, at the

180
00:11:01.460 --> 00:11:04.400
upper level, another thing that
you're going to find is

181
00:11:04.400 --> 00:11:07.700
that they, that they extend
the micro framework. So they'll

182
00:11:07.700 --> 00:11:10.910
have libraries that run on
the micro framework on the

183
00:11:10.910 --> 00:11:17.930
CLR that provide things like
additional drivers for canvas, for

184
00:11:18.740 --> 00:11:24.500
wifi, for a variety of
other sorts of functionality that,

185
00:11:24.530 --> 00:11:27.980
that aren't, aren't supported natively
in the micro framework. One

186
00:11:27.980 --> 00:11:29.980
of the things that this
model does is that it

187
00:11:30.050 --> 00:11:33.890
actually enables because we give
you access inside the micro

188
00:11:33.890 --> 00:11:36.830
framework to the underlying hardware,
you can actually write your

189
00:11:36.830 --> 00:11:39.410
drivers in, in, in manage
code and have it run

190
00:11:39.410 --> 00:11:42.740
on top as well as,
as writing at the bottom

191
00:11:42.740 --> 00:11:45.830
layer. Yeah. That's, that's interesting
that you point that out

192
00:11:45.830 --> 00:11:48.350
because I think it was
the Tahoe too, that I

193
00:11:48.350 --> 00:11:52.070
was looking at that had
an accelerometer and the, the

194
00:11:52.130 --> 00:11:54.670
code that I was for
that actually referred to the

195
00:11:54.700 --> 00:11:57.850
name of the chip that
was like namespace dot, you

196
00:11:57.850 --> 00:12:00.640
know, whatever the name of
that particular chip was. And

197
00:12:00.760 --> 00:12:04.780
it was written entirely in
C sharp. So I was

198
00:12:04.780 --> 00:12:06.610
wondering, is it really a
driver, or is it just

199
00:12:06.610 --> 00:12:09.490
a layer of abstraction, or
I guess, is that the

200
00:12:09.490 --> 00:12:13.860
same thing, But by functional
definition, it becomes a driver.

201
00:12:14.400 --> 00:12:16.890
You could, you could do
that same thing in, in

202
00:12:16.890 --> 00:12:24.520
C at the bottom layer,
but, but it's it. And

203
00:12:24.600 --> 00:12:26.190
whether or not you do
need to do that as

204
00:12:26.190 --> 00:12:29.040
opposed to using C sharp,
largely depends on what your

205
00:12:29.040 --> 00:12:33.960
performance requirements are. Obviously, obviously
there's a significant difference between

206
00:12:33.960 --> 00:12:40.590
running interpreted code and running
native code. Is this code

207
00:12:40.590 --> 00:12:42.740
jetted? I mean, is it
interpreted the whole time, or

208
00:12:42.740 --> 00:12:44.490
did you do what kind
of performance can you expect

209
00:12:44.490 --> 00:12:48.300
to see with C-sharp on
this, on these devices? It's

210
00:12:48.300 --> 00:12:51.180
all interpreted one of the
things. So to give you

211
00:12:51.180 --> 00:12:54.120
an idea of what the,
what our footprint target is,

212
00:12:54.120 --> 00:12:56.730
we actually will run on
a, on a machine with

213
00:12:57.240 --> 00:13:00.480
about 64 K at Ram,
which was one of our

214
00:13:00.480 --> 00:13:04.350
targets and two 56 K
of flash. And when we

215
00:13:04.350 --> 00:13:07.440
were doing that, as you
get down to those sizes,

216
00:13:07.800 --> 00:13:11.490
jet doesn't really work very
well because there's a couple

217
00:13:11.490 --> 00:13:13.650
of things. One is that
native code is about 10

218
00:13:13.650 --> 00:13:19.230
times larger than, than I
L a. So right off

219
00:13:19.230 --> 00:13:21.030
the bat, as soon as
you get something, it becomes

220
00:13:21.030 --> 00:13:24.600
larger. And the other thing
is that when you, when

221
00:13:24.600 --> 00:13:26.970
you're close to the edges
of memory of your memory

222
00:13:26.970 --> 00:13:30.060
availability, what we'd find is
you would start thrashing, you

223
00:13:30.060 --> 00:13:32.190
would get something, it would
call into something else, you'd

224
00:13:32.190 --> 00:13:33.900
throw away what you just
did it so that you

225
00:13:33.900 --> 00:13:36.330
could get the other thing.
And then when that returns,

226
00:13:36.330 --> 00:13:38.280
you have to read yet
what you just threw away.

227
00:13:39.210 --> 00:13:42.000
And so there was a,
there was a very steep

228
00:13:42.030 --> 00:13:45.600
performance cliff. When, when we,
when we looked at <inaudible>

229
00:13:46.380 --> 00:13:50.640
in terms of performance, it,
it really depends on the

230
00:13:50.640 --> 00:13:54.000
application. It's, it works fine
for UI. It works. I've

231
00:13:54.000 --> 00:13:59.070
used it in a number
of applications that, that that's

232
00:13:59.580 --> 00:14:02.340
where it's going to be
very responsive. One of the

233
00:14:02.340 --> 00:14:05.040
things in terms of, you
know, when people talk about

234
00:14:05.040 --> 00:14:07.110
real time, one of the
things that they insist on

235
00:14:07.110 --> 00:14:11.010
is, is having deterministic response.
So that if I, if

236
00:14:11.010 --> 00:14:13.110
I hit a button, I
know every time I'm going

237
00:14:13.110 --> 00:14:16.920
to get some, some specific
latency, we don't have that

238
00:14:16.920 --> 00:14:19.830
right now because we have
a garbage collection cycle that

239
00:14:19.830 --> 00:14:25.950
may hit, hit some on
determined time. So that's one

240
00:14:25.950 --> 00:14:28.860
thing that if we were
going to try and address

241
00:14:28.860 --> 00:14:33.150
more, more real time applications,
we would have to address.

242
00:14:33.150 --> 00:14:35.640
And we, we have, we've
discussed some, some strategies for

243
00:14:35.640 --> 00:14:38.400
that, but it hasn't quite
made it up to the

244
00:14:38.400 --> 00:14:43.050
top of our priority queue.
Yet. This is the part

245
00:14:43.050 --> 00:14:46.170
of the show where I
mock you while actually Tellerik

246
00:14:46.170 --> 00:14:50.160
mock says your applications, that
you're testing dependent on external

247
00:14:50.160 --> 00:14:53.180
systems over which you have
no control, maybe you're being

248
00:14:53.180 --> 00:14:56.960
slowed down by those systems
or lack of availability, responsiveness.

249
00:14:56.960 --> 00:14:59.480
Do you want to do
TDD, right? Our friends at

250
00:14:59.480 --> 00:15:01.790
Tellerik help you solve some
of those problems with their

251
00:15:01.790 --> 00:15:05.810
newest mocking tool, just mock
it'll let you do fast,

252
00:15:05.810 --> 00:15:10.010
simple controlled unit tests, independent
of external resources, like databases,

253
00:15:10.010 --> 00:15:14.600
web services, proprietary code, unlike
some mocking tools, just mock

254
00:15:14.660 --> 00:15:19.460
works with non-virtual methods, seal
classes, static methods, giving you

255
00:15:19.460 --> 00:15:22.580
complete control of your code.
You can get more details.

256
00:15:22.580 --> 00:15:27.620
You can download just mock
at telerik.com/just mock. And don't

257
00:15:27.620 --> 00:15:29.900
forget to thank Tellerik for
supporting Hanselman it's on their

258
00:15:29.900 --> 00:15:36.890
Facebook fan page, facebook.com/tellerik. Thanks
a lot. I, I took

259
00:15:36.890 --> 00:15:39.740
the net Duino, which was
a device that I wanted

260
00:15:39.740 --> 00:15:41.240
to play with it immediately,
and I didn't have any

261
00:15:41.240 --> 00:15:43.670
hardware yet just to speak
of. So I was, the

262
00:15:43.670 --> 00:15:45.680
only thing I could really
do was blink the led

263
00:15:45.680 --> 00:15:48.350
on the, on the net
Duino cause it's the smallest

264
00:15:48.350 --> 00:15:51.140
of the devices that I
have. But I wrote in,

265
00:15:51.230 --> 00:15:54.710
I dunno, 60 lines of
code, a little Morris code

266
00:15:55.040 --> 00:15:57.980
application. So it would take,
take ASCII and it would

267
00:15:57.980 --> 00:16:00.830
spit it out as a,
as Morse code. And other

268
00:16:00.830 --> 00:16:05.960
than one line, or I
talked to out an output

269
00:16:05.960 --> 00:16:09.620
port object, and I referred
to the onboard led as

270
00:16:09.620 --> 00:16:14.120
a, a constant, everything else
looks exactly like you couldn't

271
00:16:14.120 --> 00:16:16.070
look at it and tell
it wasn't a console app.

272
00:16:16.100 --> 00:16:19.250
So I thought that was
pretty, pretty impressive, but because

273
00:16:19.250 --> 00:16:21.170
I was on such a
tiny device, I will say

274
00:16:21.170 --> 00:16:26.100
that I was a little
paralyzed from a, from an,

275
00:16:26.510 --> 00:16:29.120
from a programmer's perspective because
I was, I was paranoid

276
00:16:29.120 --> 00:16:32.630
that I was going write
something that wasn't performing. And

277
00:16:32.630 --> 00:16:34.490
I went back and forth.
I use a hash table.

278
00:16:34.490 --> 00:16:35.960
Should I have a bunch
of constants? Should I use

279
00:16:35.960 --> 00:16:39.050
parallel arrays? How, how worried
should I be about that

280
00:16:39.050 --> 00:16:40.790
kind of thing? And was
it, was that, is that

281
00:16:40.790 --> 00:16:43.460
a natural feeling to be
so concerned that now I'm

282
00:16:43.460 --> 00:16:45.680
in a tiny, tiny world,
I should write my code

283
00:16:45.680 --> 00:16:51.940
differently. Not sure the range
of trying to do like,

284
00:16:52.110 --> 00:16:56.980
like voice processing for the
kinds of applications that P

285
00:16:57.060 --> 00:16:59.230
certainly I needed that hobbyist
applications. I don't think you

286
00:16:59.230 --> 00:17:01.570
would run into many, many
times when you have to

287
00:17:01.570 --> 00:17:05.170
worry about performance at all.
There are some tricks, I

288
00:17:05.170 --> 00:17:07.600
think to, you know, and
there, there are, there are

289
00:17:07.600 --> 00:17:11.110
tricks to, if you were
writing a commercial application that

290
00:17:11.110 --> 00:17:13.330
had to run on batteries,
those are then you want

291
00:17:13.330 --> 00:17:16.720
to, then you want to
make sure that for instance,

292
00:17:16.720 --> 00:17:20.920
that you, that you run
everything on events so that,

293
00:17:21.190 --> 00:17:23.870
so that the processor can
cause the processor will, if

294
00:17:24.370 --> 00:17:26.260
it's red manager, when it
can't find a thread to

295
00:17:26.260 --> 00:17:29.470
run will automatically go into
a lower power state, as

296
00:17:29.470 --> 00:17:33.520
long as that's supported in
that, by that processor. So

297
00:17:33.520 --> 00:17:36.900
you have some programming tricks
like that for, for, for

298
00:17:36.910 --> 00:17:41.080
commercial applications where you might
have power constraints, but for,

299
00:17:41.100 --> 00:17:44.930
for most, any of the
hobbyists sorts of applications, I

300
00:17:44.980 --> 00:17:49.710
have never, never run into
performance problems. That's interesting. And

301
00:17:49.710 --> 00:17:51.930
then, yeah, The whole thing
is open source. So, you

302
00:17:51.930 --> 00:17:57.350
know, if you ever do
have Any, Any real performance

303
00:17:57.350 --> 00:17:59.300
problems and you want to
solve them by going into

304
00:17:59.300 --> 00:18:02.060
native code, we, we both
have the source out there

305
00:18:02.060 --> 00:18:05.630
and we support interrupt. So
one of the nice things

306
00:18:05.630 --> 00:18:08.390
I think about the model
as it's currently set up

307
00:18:08.390 --> 00:18:10.760
is that you can get
into one of these devices

308
00:18:10.760 --> 00:18:14.000
at a very high level.
If you are real are

309
00:18:14.000 --> 00:18:16.340
really want to get, you
know, roll your sleeves up

310
00:18:16.340 --> 00:18:18.200
and get, get into it.
So you can, you can

311
00:18:18.200 --> 00:18:19.910
take it as far as
you want, in terms of

312
00:18:20.690 --> 00:18:23.420
diving into, you know, doing,
like I said, native code,

313
00:18:23.420 --> 00:18:26.390
or even going into the
bowels of the micro framework

314
00:18:26.390 --> 00:18:30.380
or the porting layer and
redoing what you want. So

315
00:18:30.380 --> 00:18:32.870
it's all open source. It's
all, what is it? Apache

316
00:18:32.870 --> 00:18:38.270
license all the way down,
right? Wow. Was that hard

317
00:18:38.390 --> 00:18:41.390
to get Microsoft to do
that And parts, but I

318
00:18:41.390 --> 00:18:46.460
think that there's, there's certainly
an appreciation for, for that,

319
00:18:46.820 --> 00:18:50.090
that model. That's, that's growing
in the company. There's a

320
00:18:50.090 --> 00:18:52.580
lot more support for that.
Then I think there wasn't

321
00:18:52.580 --> 00:18:54.200
a path and there's a
lot more things you're seeing,

322
00:18:54.200 --> 00:18:56.330
you know, like iron Ruby
and iron Python and things

323
00:18:56.330 --> 00:18:59.660
like that that are, that
are joining that trend. We

324
00:18:59.660 --> 00:19:03.800
actually took a couple of
years where we tried to

325
00:19:03.800 --> 00:19:07.010
make a commercial business out
of this and, and charge

326
00:19:07.010 --> 00:19:11.840
a per unit royalty for
the micro framework. But they're

327
00:19:12.680 --> 00:19:14.900
real, that reality struck us
that there just really isn't

328
00:19:14.900 --> 00:19:21.200
enough money And go, when
you're talking about it, you

329
00:19:21.200 --> 00:19:24.380
know, a two bit pro
$2 processor and a, you

330
00:19:24.380 --> 00:19:27.890
know, a $10 device in
terms of its bill of

331
00:19:27.890 --> 00:19:30.500
materials. It's really hard to
squeeze a couple of dollars

332
00:19:30.500 --> 00:19:34.610
or anything meaningful out of
that. So, so, so it's,

333
00:19:34.610 --> 00:19:36.760
it's this, this is a
much better approach for, for

334
00:19:36.790 --> 00:19:40.520
this, for this size device
thing. What does Microsoft get

335
00:19:40.520 --> 00:19:42.680
out of it? I mean,
don't you worry that if

336
00:19:42.680 --> 00:19:45.050
it's not a big business
near the whole group will

337
00:19:45.050 --> 00:19:48.680
go away someday? Well, it's
not a big business from

338
00:19:48.680 --> 00:19:51.590
a Microsoft standpoint. I think
it's an important business for

339
00:19:51.590 --> 00:19:54.380
Microsoft, because like I said,
these, these devices are now

340
00:19:54.410 --> 00:19:59.300
connected. Microsoft is absolutely unique
in this, in this arena

341
00:19:59.330 --> 00:20:02.270
because we know we have
a single programming model and

342
00:20:02.270 --> 00:20:05.180
tool chain. That'll take you
from that little, the net

343
00:20:05.180 --> 00:20:08.930
wino board up to your
PC, up to web of

344
00:20:08.930 --> 00:20:11.840
webpages, up to servers and
up eventually to the cloud.

345
00:20:12.560 --> 00:20:15.440
So the same programming skills
translate through all of that.

346
00:20:15.860 --> 00:20:18.800
I think that's an important
story from Microsoft. And, and,

347
00:20:18.980 --> 00:20:23.720
and I'll be quite honest,
if, if, if other, if

348
00:20:23.720 --> 00:20:26.570
other platforms are used at
the bottom end, nobody wants

349
00:20:26.570 --> 00:20:28.820
to have a mixed development
shop if they don't have

350
00:20:28.820 --> 00:20:32.180
to. So, so I think
it's, it's, it's useful for

351
00:20:32.180 --> 00:20:35.030
Microsoft from Microsoft standpoint, for
us to be able to

352
00:20:35.030 --> 00:20:39.200
say that we have this,
this single programming model that

353
00:20:39.200 --> 00:20:42.890
has the broadest range of
any, How many, how many

354
00:20:42.890 --> 00:20:45.890
people do you have actively
writing code on this inside

355
00:20:45.890 --> 00:20:51.160
Microsoft? How many, like Microsoft
work on this thing, that's

356
00:20:51.160 --> 00:20:53.590
amazing that you pull that
off. I'm sure that many,

357
00:20:53.590 --> 00:20:55.720
many people worked on it
over the years, but the

358
00:20:55.720 --> 00:20:58.150
fact that there's four now
is pretty amazing. And how

359
00:20:58.150 --> 00:21:00.160
does the open source stuff
changed the way that the

360
00:21:00.160 --> 00:21:03.100
inner that the partners interact?
Like, like I assume that

361
00:21:03.100 --> 00:21:05.380
Duino one day they called
you. Like, when I assume

362
00:21:05.410 --> 00:21:06.670
it just came out of
blue, right. One day the

363
00:21:06.670 --> 00:21:08.590
phone rang, Hey, I want
to do this. Or can

364
00:21:08.590 --> 00:21:10.270
you do all of it
by himself without ever giving

365
00:21:10.270 --> 00:21:13.620
you a call? He actually
showed up one day and

366
00:21:13.620 --> 00:21:18.000
said, look, what I got
working. Oh yeah, he could

367
00:21:18.000 --> 00:21:20.190
do. You can do, you
can do this all by

368
00:21:20.190 --> 00:21:22.410
yourself. We try and help
people as much as possible.

369
00:21:24.090 --> 00:21:26.760
Yeah. But, you know, obviously
with four people, we, we

370
00:21:26.760 --> 00:21:29.880
do rely on the community
to be self sustaining and

371
00:21:30.030 --> 00:21:33.810
to some extent, and we
have some participants in the

372
00:21:33.810 --> 00:21:37.650
community who have been just
great at, at pitching in

373
00:21:37.870 --> 00:21:42.960
and helping each other out.
So, and we've actually, so

374
00:21:42.960 --> 00:21:45.960
we went to open source
with 4.0 the last November.

375
00:21:46.110 --> 00:21:50.010
We did our 4.1 release
just six months later to

376
00:21:50.010 --> 00:21:52.770
get visual studio support and
a couple other things in

377
00:21:52.770 --> 00:21:55.830
there. And we already, within
that timeframe had our first

378
00:21:55.830 --> 00:21:59.820
contributions from the community that
were included in that release.

379
00:22:00.660 --> 00:22:04.440
And we're hoping that continues
to grow, frankly. That's cool.

380
00:22:04.530 --> 00:22:07.500
And so, so there's committed
code from people who aren't

381
00:22:07.500 --> 00:22:13.340
you inside of 4.1. Absolutely.
That's cool. So, so I,

382
00:22:13.340 --> 00:22:15.580
I brought up the net
Dorina one, cause it's, it's

383
00:22:15.600 --> 00:22:18.360
the smallest one I have.
Are there smaller boards or

384
00:22:18.360 --> 00:22:20.670
is that pretty much the
smallest as far as like

385
00:22:20.670 --> 00:22:24.600
the limited amount of functionality?
I think that's a that's

386
00:22:24.810 --> 00:22:27.270
there are, there are two
companies that are making boards

387
00:22:27.270 --> 00:22:30.990
in that size GHR electronics.
And as, as a board

388
00:22:30.990 --> 00:22:33.720
on their tiny CLR site
and the net Duino board,

389
00:22:34.440 --> 00:22:39.510
they are both, they're both
Arduino compatible boards are very

390
00:22:39.510 --> 00:22:43.560
popular hobbyist in education board.
And so there's a lot

391
00:22:43.560 --> 00:22:48.480
of peripherals for that. I
just blogged recently about putting

392
00:22:48.480 --> 00:22:52.440
a, a, an Arduino shield
and the hardware is frequently

393
00:22:52.440 --> 00:22:56.640
called shields for the, for
the Arduino, a joystick shield

394
00:22:56.640 --> 00:22:59.340
on top of a net
wino and running a robotic

395
00:22:59.340 --> 00:23:04.590
arm with that. And so,
so they take advantage. Both

396
00:23:04.590 --> 00:23:06.870
those companies take advantage of
the fact that there is

397
00:23:06.870 --> 00:23:11.130
an existing ecosystem of, of
hardware packages for, for the,

398
00:23:11.160 --> 00:23:14.760
for the Ardwino. You know,
I, yesterday this is true

399
00:23:14.760 --> 00:23:17.890
story yesterday. I was cleaning
up my office and I

400
00:23:17.910 --> 00:23:19.860
I've seen your office by
the way. And I know

401
00:23:19.860 --> 00:23:22.830
that if either you or
I clean our offices out,

402
00:23:23.220 --> 00:23:25.080
it's going to be an
event. And it's going to

403
00:23:25.080 --> 00:23:29.490
uncover some amazing pieces of
artifacts and pieces out of

404
00:23:29.490 --> 00:23:31.470
the past. So I'm digging
through my office and I

405
00:23:31.470 --> 00:23:34.890
found a Newton message pad.
And I found, you know,

406
00:23:34.900 --> 00:23:38.070
computers that were 20 plus
years old. And I found

407
00:23:38.070 --> 00:23:41.730
this thing called a space
orb three 60. This is

408
00:23:41.730 --> 00:23:45.030
a three-dimensional controller. It's basically
a rubber ball posted on

409
00:23:45.080 --> 00:23:48.100
stick. And instead of using
your thumbs and two, two

410
00:23:48.110 --> 00:23:50.870
joysticks, you just push this
ball up, down left, right.

411
00:23:50.870 --> 00:23:53.570
And it was, it is
to this day, still used

412
00:23:53.570 --> 00:23:57.380
as a 360 degree, three
D modeling tool. But in

413
00:23:57.380 --> 00:24:01.340
the early nineties was used
on games like descent and

414
00:24:01.340 --> 00:24:05.240
doom to do 360 degree
stuff. But it only works

415
00:24:05.300 --> 00:24:09.020
on a nine pin RS,
two 30, two serial. And

416
00:24:09.140 --> 00:24:12.500
the company's basically given up
on the gaming world and

417
00:24:12.830 --> 00:24:14.870
to the hardcore gamer. This
is, this is the thing,

418
00:24:14.870 --> 00:24:17.840
right? Over the years, I've
been looking around and trying

419
00:24:17.840 --> 00:24:19.070
to figure out if I'm
ever going to bring this

420
00:24:19.070 --> 00:24:22.340
thing back to life. And
last night I started poking

421
00:24:22.340 --> 00:24:25.280
around and I find a
guy who made an orbit

422
00:24:25.280 --> 00:24:29.240
shield. And you just said,
shield is a board. It's

423
00:24:29.240 --> 00:24:33.170
a, daughterboard effectively for one
of these compatible devices. And

424
00:24:33.590 --> 00:24:36.260
because the it's a standardized
platform and there's some work

425
00:24:36.260 --> 00:24:39.620
that's been done to make
it show up inside of

426
00:24:39.620 --> 00:24:43.250
windows. This guy has basically,
you pay 30 or 40

427
00:24:43.250 --> 00:24:45.230
bucks. You buy this Arduino
shield. And he has that

428
00:24:45.230 --> 00:24:49.160
bridge that makes this, this
20 year old joystick look

429
00:24:49.170 --> 00:24:52.520
like a joystick and windows
seven. So I'm really looking

430
00:24:52.520 --> 00:24:54.200
forward to playing with that
and seeing what I can

431
00:24:54.200 --> 00:24:57.860
do, maybe moving things around
and writing a net, Duino

432
00:24:58.220 --> 00:25:00.470
port a.net port. And they're
not in a micro framework

433
00:25:00.470 --> 00:25:03.170
to see if I can
take input from this, from

434
00:25:03.170 --> 00:25:05.630
this thing. And that, that
just in the three days

435
00:25:05.630 --> 00:25:07.970
that I've been playing with,
this is already kind of,

436
00:25:07.970 --> 00:25:13.750
what's opened up for me,
which is amazing. Well, yeah,

437
00:25:13.780 --> 00:25:16.540
so there's, I think one
of the interesting things is

438
00:25:16.630 --> 00:25:20.740
that I think everybody went
through engineering school at either

439
00:25:20.830 --> 00:25:26.380
either computer science or electrical
engineering had some remembered some

440
00:25:26.380 --> 00:25:28.270
of the great fun they
had and making things work

441
00:25:29.260 --> 00:25:31.840
and, and everybody has a
story and they, and it

442
00:25:31.840 --> 00:25:33.430
almost, and that was one
of the things I think

443
00:25:33.430 --> 00:25:35.470
that sort of excites people
about this as being able

444
00:25:35.470 --> 00:25:38.170
to get back to just
being able to, to make

445
00:25:38.170 --> 00:25:41.920
things happen. A lot of
times we get into our

446
00:25:41.920 --> 00:25:43.870
jobs and they, and they're,
and they're a little bit

447
00:25:43.900 --> 00:25:47.530
more abstract than, than making
an led blink. So, Yeah,

448
00:25:47.530 --> 00:25:50.590
it's funny when I got
the led to blink and

449
00:25:50.590 --> 00:25:54.180
literally, I think I put
an hour into this, I

450
00:25:54.250 --> 00:25:57.430
just, it's so silly. There's
just this little internal child

451
00:25:57.430 --> 00:26:00.610
that was just like, woo.
Even though it was such

452
00:26:00.610 --> 00:26:03.550
a basic thing. So then
I started poking around with

453
00:26:03.550 --> 00:26:06.820
the larger boards. W talk
to me about how these

454
00:26:06.820 --> 00:26:09.610
boards scale up physically. Cause
like we said, we've got

455
00:26:09.610 --> 00:26:14.380
the Arduino and the, the
tiny clr.com from JHI and

456
00:26:14.380 --> 00:26:16.000
then on the, on the,
on the higher end they've

457
00:26:16.000 --> 00:26:20.890
got touchscreens and they've got
accelerometers and buttons. Yeah. So

458
00:26:20.890 --> 00:26:24.370
there's, there's a full range
of boards, right, right. Up

459
00:26:24.370 --> 00:26:28.000
to some, obviously some very
expensive, very serious commercial boards,

460
00:26:29.440 --> 00:26:32.020
essentially. All of our ports
that were, have been made

461
00:26:32.020 --> 00:26:36.370
have been done by the
Silicon providers. So usually they

462
00:26:36.370 --> 00:26:40.180
have for each of their
processors, they have either they

463
00:26:40.180 --> 00:26:45.750
or some partners provide development
boards. And then folks like

464
00:26:46.020 --> 00:26:52.500
OD in Europe device solutions.net
solutions in, in, in England

465
00:26:52.770 --> 00:26:56.940
are all providing additional boards
that have they go right

466
00:26:56.940 --> 00:27:01.230
up to, like you say,
touch screens and a full,

467
00:27:01.800 --> 00:27:05.100
full exposure of some very
powerful processors. By that time

468
00:27:05.100 --> 00:27:07.560
you're looking at usually an
arm nine and the hundreds

469
00:27:07.560 --> 00:27:13.950
of megahertz processing power. Another
project I did recently on

470
00:27:13.950 --> 00:27:17.040
the blog was to actually
create a, a bicycle computer.

471
00:27:18.150 --> 00:27:21.360
And it's the, the idea
behind it was that I'm

472
00:27:21.360 --> 00:27:24.570
always saying that now anybody
with dotnet skills can create

473
00:27:24.570 --> 00:27:26.970
an embedded application. So I
thought, well, maybe I should

474
00:27:26.970 --> 00:27:30.300
do it to show sort
of a demonstration. So defined

475
00:27:30.300 --> 00:27:33.900
what I thought would be
a reasonable commercial application, a

476
00:27:34.170 --> 00:27:38.490
few bells and whistles. It's
got a gesture interface, partly

477
00:27:38.490 --> 00:27:40.380
because I didn't want to
be fumbling for buttons at

478
00:27:40.380 --> 00:27:45.480
40 miles an hour downhill.
And, and there's going to

479
00:27:45.480 --> 00:27:48.600
be a, an article on
it's coming out in an

480
00:27:48.600 --> 00:27:53.400
MSDN magazine. And I think
next month, talking about how

481
00:27:53.400 --> 00:27:55.200
you can now take that
and connect that up to

482
00:27:55.200 --> 00:27:58.110
the cloud. So now when
you just, when you get

483
00:27:58.110 --> 00:28:02.580
your bicycle into the, into
the garage, you just tap

484
00:28:02.580 --> 00:28:04.740
the screen and an off
goes the data to some

485
00:28:05.100 --> 00:28:08.760
service that lets you, you
know, either compete or with

486
00:28:08.760 --> 00:28:11.700
your friends or collect your
data. But that was written

487
00:28:11.700 --> 00:28:16.140
on a sort of intermediate
board from Phi. So there's,

488
00:28:16.440 --> 00:28:21.350
there's a board for almost
any, any application. Yeah. This

489
00:28:21.350 --> 00:28:23.540
was a nine part series
that you did bicycle and

490
00:28:23.540 --> 00:28:26.570
the bicycle computers on the
dinette micro framework blog. And

491
00:28:26.570 --> 00:28:28.580
I'll post all the links
in the show notes to

492
00:28:28.580 --> 00:28:31.010
make sure. And this was
a really great tutorial because

493
00:28:31.010 --> 00:28:33.920
you went through it really
step by step. Was this

494
00:28:33.920 --> 00:28:35.840
about the way that you
thought about it? I mean,

495
00:28:35.850 --> 00:28:38.180
you started with, you know,
picking the board and then

496
00:28:38.420 --> 00:28:41.390
deciding on the sensors and
integrating the touch and then

497
00:28:41.390 --> 00:28:44.870
adding more complicated sensors is
the way you wrote it,

498
00:28:44.870 --> 00:28:47.600
the way that you built
it. It was absolutely stream

499
00:28:47.600 --> 00:28:49.640
of consciousness. In fact, I
had thought I would do

500
00:28:49.640 --> 00:28:55.040
three articles and, and got,
just took it where it

501
00:28:55.040 --> 00:28:57.560
would lead me. I actually
have three more articles in

502
00:28:57.560 --> 00:29:01.430
draft form that I haven't
had time to finish that

503
00:29:01.430 --> 00:29:04.430
I hope to get back
to at some point cause

504
00:29:05.030 --> 00:29:08.930
the, the project keeps evolving
And this is something that

505
00:29:09.300 --> 00:29:11.310
all the full source code
is available. And we'll put

506
00:29:11.330 --> 00:29:14.810
up on code Plex, you
use a GA chai Cobra

507
00:29:15.380 --> 00:29:19.190
board. Did you have to
custom build anything? Or was

508
00:29:19.190 --> 00:29:21.410
this all stuff people could,
you know, brackets and things

509
00:29:21.410 --> 00:29:24.770
that we could find at,
at home Depot, This, the

510
00:29:24.770 --> 00:29:27.440
stuff that most of the
things that I bought, I

511
00:29:27.440 --> 00:29:30.170
got out of places like
spark fund. And I identified

512
00:29:30.170 --> 00:29:34.190
the, the, the particular boards
that I used. They were

513
00:29:34.190 --> 00:29:38.840
things like accelerometers and, and
pressure sensors. There was some

514
00:29:39.350 --> 00:29:40.910
back and forth, but I
was trying to use a

515
00:29:41.230 --> 00:29:43.450
sensor to tell what my
altitude was. And I ended

516
00:29:43.450 --> 00:29:47.950
up using an inclinometer instead.
And I went through, you

517
00:29:47.950 --> 00:29:49.930
know, why I ended up
with that. It was certainly

518
00:29:49.930 --> 00:29:53.050
easier to deal with in
the pressure sensor, which seemed

519
00:29:53.050 --> 00:29:56.440
to be a little odd,
but yeah, all that stuff

520
00:29:56.440 --> 00:30:00.580
is available. There is some,
you know, some soldering involved

521
00:30:02.620 --> 00:30:05.260
I have, well, to that
point, I'll give you a

522
00:30:05.260 --> 00:30:08.380
sort of a sneak preview.
We're gonna announce something at

523
00:30:08.440 --> 00:30:13.660
a maker fair and New York
later this month, that is

524
00:30:13.660 --> 00:30:16.410
a little bit of a
breakthrough on making this, this

525
00:30:16.570 --> 00:30:19.390
kind of project available to
people who don't have electronic

526
00:30:19.390 --> 00:30:25.140
skills. Yeah. For that. You're
not going to drop, you're

527
00:30:25.140 --> 00:30:26.580
not going to drop the
scoop right here. Are you,

528
00:30:28.020 --> 00:30:31.860
I better not get in
trouble for, for, so it's

529
00:30:31.860 --> 00:30:34.500
actually, it's actually a project
coming out of MSR and

530
00:30:34.500 --> 00:30:38.850
Cambridge, Microsoft research in Cambridge.
And, and so it's really

531
00:30:38.850 --> 00:30:42.390
their scoop to drop, but,
but will later this month

532
00:30:42.420 --> 00:30:45.510
we will be, we'll be
talking about some, I think

533
00:30:45.510 --> 00:30:48.980
some really cool stuff. It's
like one to your point,

534
00:30:48.990 --> 00:30:53.160
to the point of, of
your recent art blog, where,

535
00:30:53.340 --> 00:30:55.920
you know, hardware for, at,
for software engineers, this makes

536
00:30:55.920 --> 00:31:00.270
it possible for anybody without
any particular, anybody who can

537
00:31:00.270 --> 00:31:05.670
program to do some really
fun stuff really quickly it's

538
00:31:06.270 --> 00:31:10.650
it was technology that they,
Microsoft research did specifically so

539
00:31:10.650 --> 00:31:14.640
that they could prototype devices
quickly. But it, it makes

540
00:31:14.640 --> 00:31:17.730
it easy for anybody to
do things now. All right.

541
00:31:17.730 --> 00:31:19.650
Well, we'll look for that
at maker fair. And I'd

542
00:31:19.650 --> 00:31:23.070
love to see when you
finish your series on the

543
00:31:23.070 --> 00:31:25.740
bicycle computer, I'd love to
see a YouTube video of

544
00:31:25.740 --> 00:31:28.050
the whole thing in action.
Yeah. I'm going to do

545
00:31:28.050 --> 00:31:31.300
that. I was thinking about
doing that hopefully before the

546
00:31:32.640 --> 00:31:37.290
summer is completely gone. Yeah.
It's raining down here too.

547
00:31:37.290 --> 00:31:39.810
We've to beginning of September
what we've already decided here

548
00:31:39.810 --> 00:31:43.980
in the Northwest that November
has arrived. All right. Well,

549
00:31:43.980 --> 00:31:45.990
thank you so much. Colin
Miller for talking to us

550
00:31:45.990 --> 00:31:49.470
about the dotnet Michael framework.
And this has been another

551
00:31:49.470 --> 00:31:52.170
episode of Hansel minutes. See
you again next week.


WEBVTT FILE

1
00:00:12.120 --> 00:00:17.520
From Hansel minutes.com is Hanselman's
a weekly discussion with web

2
00:00:17.520 --> 00:00:22.620
developer and technologists and Scott
Hanselman hosted by Carl Franklin. This

3
00:00:22.620 --> 00:00:27.030
is Lawrence Ryan announcing show number
one 45. Recorded live Monday,

4
00:00:27.030 --> 00:00:32.640
January 5th, 2009. Support for Hansel minutes
is provided by tolerant already

5
00:00:32.640 --> 00:00:36.510
controls the most comprehensive suite
of components for windows forms

6
00:00:36.510 --> 00:00:47.280
and asp.net web applications. online@wwwdottelerikdotcomandby.net
developers journal, the world's leading

7
00:00:47.280 --> 00:00:52.590
dotnet developer magazine online at
www dot <inaudible> dot com.

8
00:00:53.430 --> 00:00:56.130
In this episode, Scott talks
about the solid principles of

9
00:00:56.130 --> 00:01:02.130
object oriented design with Robert C. Martin.
Hi, this is Scott Hanselman,

10
00:01:02.130 --> 00:01:04.800
and this is another episode
of Hansel minutes. And we're

11
00:01:04.800 --> 00:01:08.250
sitting down today with uncle
Bob, Robert C. Martin, the founder CEO,

12
00:01:08.250 --> 00:01:11.010
and president of object mentor
incorporated, but known colloquially to

13
00:01:11.010 --> 00:01:13.990
the software community as uncle
Bob. Thank you, sir, for,

14
00:01:14.120 --> 00:01:18.390
for chatting with me today.
It's my pleasure. One of

15
00:01:18.390 --> 00:01:21.510
the things that, that I'm
hearing talk about a lot

16
00:01:21.510 --> 00:01:23.640
in the, in the community
that I kind of run

17
00:01:23.640 --> 00:01:29.310
in the.net community, is this
the solid principles, these principles

18
00:01:29.310 --> 00:01:32.820
that you kind of outlined
in, in, in your discussion

19
00:01:32.820 --> 00:01:36.750
of the principles of object
oriented design, and it's an

20
00:01:36.750 --> 00:01:40.620
acronym of acronyms that listed
out five kind of basic

21
00:01:40.620 --> 00:01:45.990
principles that add up to
solid. And when someone who's

22
00:01:45.990 --> 00:01:50.160
maybe not a, a, a
software development want sits down

23
00:01:50.160 --> 00:01:52.560
and looks at these things,
it's like patterns and more

24
00:01:52.560 --> 00:01:54.870
patterns and principles. And it's
just, it's very kind of,

25
00:01:55.800 --> 00:01:57.750
it could be looked at
as a little academic and

26
00:01:57.750 --> 00:02:00.060
I could see where some
people's eyes would blur when

27
00:02:00.060 --> 00:02:02.640
reading this kind of stuff.
So how do we make

28
00:02:02.640 --> 00:02:05.370
this more accessible? How do
you demystify the solid, the

29
00:02:05.370 --> 00:02:10.520
solid principles? Yeah, I confess
that the names of the

30
00:02:10.520 --> 00:02:17.090
principals were something of a
conceit. I, I had spent

31
00:02:17.090 --> 00:02:20.690
a lot of time studying
physics and astronomy. And in

32
00:02:20.690 --> 00:02:25.340
those disciplines, you find principles
like the Heisenberg uncertainty principle

33
00:02:25.340 --> 00:02:29.300
or the Pauli exclusion principle.
And so I rather like

34
00:02:29.300 --> 00:02:33.740
the idea of three words
with the last word being

35
00:02:33.740 --> 00:02:37.970
principle that was spurred on
even more by a book

36
00:02:37.970 --> 00:02:42.560
that was written in 1992
by James Copeland, affectionately known as

37
00:02:42.560 --> 00:02:47.390
COVID who, who coined the
word, the list, Goff substitution

38
00:02:47.390 --> 00:02:51.110
principle, which is the third
in the solid list. So

39
00:02:51.110 --> 00:02:54.770
to demystify them, let's take
the first one, the, the

40
00:02:54.770 --> 00:02:58.580
single responsibility principle. It's a
nice word. It flows real

41
00:02:58.580 --> 00:03:02.980
well. Single responsibility principle. What
does it mean? It means

42
00:03:02.980 --> 00:03:06.610
that a software module should
have one reason to change.

43
00:03:06.750 --> 00:03:09.490
And then that's what I
call a responsibility, a reason

44
00:03:09.490 --> 00:03:17.110
to change. So for example,
take a, a payroll application.

45
00:03:17.520 --> 00:03:20.770
If, Hey, if there's an
employee class in that payroll

46
00:03:20.770 --> 00:03:25.060
application, you could imagine that
it might have methods for

47
00:03:25.330 --> 00:03:31.180
calculate pay or perhaps another
method for print a report,

48
00:03:31.450 --> 00:03:35.020
perhaps another method in the
employee object for save me

49
00:03:35.020 --> 00:03:38.770
to the database. And what's
unfortunate about these three methods

50
00:03:38.890 --> 00:03:41.470
existing in the same class
is that they all have

51
00:03:41.470 --> 00:03:46.330
three completely different reasons to
change the, the payroll will,

52
00:03:46.810 --> 00:03:50.860
the calculate pay will change.
If the accountants decide on

53
00:03:50.860 --> 00:03:54.580
a new way of calculating
pay, the report generator will

54
00:03:54.580 --> 00:03:59.320
change. If the people who
consume the reports want the

55
00:03:59.320 --> 00:04:04.780
format of the report to
change the, the save function

56
00:04:04.780 --> 00:04:08.140
will change. If the DBH
decide that we need to

57
00:04:08.140 --> 00:04:11.740
change the database schema, that
means that this one class

58
00:04:11.770 --> 00:04:15.880
has three different reasons to
change. And there are probably

59
00:04:15.880 --> 00:04:19.840
many other classes that depend
upon it. And so, as

60
00:04:19.840 --> 00:04:25.000
it changes those depending classes
also suffer through change, they'll

61
00:04:25.000 --> 00:04:29.710
be affected or impacted by
those changes. Single responsibility principle

62
00:04:29.730 --> 00:04:34.420
simply says, find one reason
to change and take everything

63
00:04:34.420 --> 00:04:37.600
else out of the class.
So the, you separate the

64
00:04:37.600 --> 00:04:42.310
things that change for different
reasons. You group together, the

65
00:04:42.310 --> 00:04:46.270
things that change for the
same reasons. This is somewhat

66
00:04:46.930 --> 00:04:51.970
out of, out of the
norm for object oriented design,

67
00:04:52.000 --> 00:04:59.560
early object oriented design principles
had us grouping together functions

68
00:04:59.590 --> 00:05:02.350
that operated on the same
data structures so that the

69
00:05:02.350 --> 00:05:06.640
methods of a class would
all manipulate the same variables

70
00:05:06.640 --> 00:05:10.630
of that class. But if
those methods change for different

71
00:05:10.630 --> 00:05:16.170
reasons, then they really belong
in separate classes. That's that

72
00:05:16.170 --> 00:05:18.030
definitely flips things on his
head. Cause I remember when

73
00:05:18.030 --> 00:05:20.580
I got into C plus
plus I was moving from

74
00:05:20.580 --> 00:05:22.680
C and we were already
trying to write what we

75
00:05:22.680 --> 00:05:25.950
called, object oriented C you
know, having an associated group

76
00:05:25.950 --> 00:05:28.470
of static methods act on
a structure that was in

77
00:05:28.470 --> 00:05:31.080
C structure and we lied
to ourselves instead. It was,

78
00:05:31.090 --> 00:05:34.110
Oh, and then moving that
to C plus plus we

79
00:05:34.110 --> 00:05:37.230
would take, you know, book
objects and people objects, and

80
00:05:37.230 --> 00:05:40.320
then give them all sorts
of bits of functionality. This

81
00:05:40.320 --> 00:05:43.980
almost inverts that whole, that
whole concept. Well, it does.

82
00:05:43.980 --> 00:05:46.930
In fact, it drives it
somewhat closer to the, the

83
00:05:47.160 --> 00:05:50.040
thing that you were kidding
yourself about because in C

84
00:05:50.070 --> 00:05:54.030
you could take a list
of a data structure and

85
00:05:54.030 --> 00:05:56.760
a dot H file. And
then you could take a

86
00:05:56.760 --> 00:05:59.390
list functions that manipulated it
and put that in the

87
00:05:59.390 --> 00:06:01.940
one that C file, but
you can take another list

88
00:06:01.940 --> 00:06:04.670
of functions. That's still manipulated
it and put it on

89
00:06:04.670 --> 00:06:09.260
another Dotsie file, separate them
so that you could in,

90
00:06:09.260 --> 00:06:13.730
in that case have functions
that did reports, functions that

91
00:06:13.730 --> 00:06:20.120
did database manipulation functions that
did calculations manipulating the same

92
00:06:20.120 --> 00:06:23.780
data structure, but in completely
separate Datto files. And that

93
00:06:23.780 --> 00:06:26.660
would allow you to separate
them into different DLLs nowadays,

94
00:06:26.660 --> 00:06:30.200
which probably couldn't do back
then and, and deploy them

95
00:06:30.200 --> 00:06:35.380
independently, which is one of
the main goals here. Now,

96
00:06:36.160 --> 00:06:38.500
one of the things that
I was taught in school

97
00:06:38.500 --> 00:06:42.250
was that naming your objects
was very, very important. And

98
00:06:42.670 --> 00:06:45.250
my particular instructor just pounded
that into my head, that

99
00:06:45.250 --> 00:06:46.960
if you can't name it
and feel good about the

100
00:06:46.960 --> 00:06:48.820
name and feel that the
name says what it is,

101
00:06:49.150 --> 00:06:51.250
then you need a better
name. It seems like the

102
00:06:51.250 --> 00:06:55.180
single responsibility principle would cause
an explosion of classes. And

103
00:06:55.180 --> 00:06:58.000
I would suddenly be faced
with difficult naming decisions. Like

104
00:06:58.000 --> 00:07:02.080
what exactly is this now
that now that it's not

105
00:07:02.080 --> 00:07:03.940
the object that I expected
it was going to be.

106
00:07:04.690 --> 00:07:08.590
Yes. And in fact the
exact opposite is true because

107
00:07:08.710 --> 00:07:12.070
the more smaller objects you
have, the more focused they

108
00:07:12.070 --> 00:07:14.530
are more easy, the easier
it is to think of

109
00:07:14.530 --> 00:07:18.040
a name for them. We
get into naming dilemmas when

110
00:07:18.040 --> 00:07:20.920
we have an object that
does so much, that it's

111
00:07:20.920 --> 00:07:24.610
impossible to name it except
to given some broad brush

112
00:07:24.640 --> 00:07:28.750
name, like employee manager. But
if you separate out a

113
00:07:28.750 --> 00:07:31.180
bunch of very small objects,
it's very simple to come

114
00:07:31.180 --> 00:07:34.450
up with names, if they're
focused. So you could have

115
00:07:34.450 --> 00:07:38.800
the, the employee report generator
and the employee database savor

116
00:07:38.800 --> 00:07:44.020
and the employee payroll calculator,
and those names are very

117
00:07:44.020 --> 00:07:49.240
specific to what those classes.
So the, if we're grouping

118
00:07:49.240 --> 00:07:55.990
things based on their reason
to change, which isn't quite

119
00:07:56.200 --> 00:07:59.710
data, and it isn't quite
methods, it's more, it's more

120
00:07:59.710 --> 00:08:01.540
their domain. It's more of
the space that they work

121
00:08:01.540 --> 00:08:05.590
within. What are the names
that, I mean, traditional object

122
00:08:05.590 --> 00:08:08.380
joints designed kind of the
way that I was taught,

123
00:08:08.590 --> 00:08:12.880
pushes us into these manager
objects, master object, service objects,

124
00:08:12.880 --> 00:08:17.500
these generic terms. That that
mean I know too much.

125
00:08:18.070 --> 00:08:20.200
What kinds of names of
objects am I going to

126
00:08:20.200 --> 00:08:22.690
end up with when I'm
replying the single responsibility principle

127
00:08:22.690 --> 00:08:27.850
appropriately? Well, you'll, you'll wind
up with longer names generally,

128
00:08:27.850 --> 00:08:32.080
but very focused. So you'll
create a class and that

129
00:08:32.080 --> 00:08:36.280
class will do one thing.
For example, the class that

130
00:08:36.290 --> 00:08:40.570
saves the employee to the
database, you might call this

131
00:08:40.570 --> 00:08:45.970
the employee gateway using Martin
Fowler's gateway pattern, or you

132
00:08:45.970 --> 00:08:52.210
might call it the, the
employee DB bad name, but

133
00:08:52.930 --> 00:08:54.730
some people like to put
DB at the end of

134
00:08:55.050 --> 00:08:59.340
their database controllers, whatever convention
you use, it becomes clear

135
00:08:59.340 --> 00:09:03.870
that this class relates employees
to the database and does

136
00:09:03.870 --> 00:09:08.520
not do calculations and does
not do reports generation. If

137
00:09:08.520 --> 00:09:13.800
you had a, a class
that put an employee record

138
00:09:13.830 --> 00:09:18.060
up on the screen, perhaps
an HTML, you might call

139
00:09:18.060 --> 00:09:23.010
this the employee HTML renderer
or something like that. Very

140
00:09:23.010 --> 00:09:29.640
precise names for many small
classes, as opposed to a

141
00:09:29.670 --> 00:09:34.230
very generic names for a
few large classes. And by

142
00:09:34.230 --> 00:09:36.840
the way, this, this practice
goes right down to the

143
00:09:36.840 --> 00:09:39.360
function level as well. We
want to have lots of

144
00:09:39.360 --> 00:09:43.440
little functions, not, not few
big functions and by little,

145
00:09:43.440 --> 00:09:46.590
I mean, you know, five,
six, seven lines, long functions

146
00:09:46.590 --> 00:09:49.080
should be, should follow the
same rule as the single

147
00:09:49.080 --> 00:09:53.090
responsibility principle. And that applies
to methods to what you're

148
00:09:53.090 --> 00:09:55.550
saying. So a class should
have only one reason and

149
00:09:55.550 --> 00:09:58.130
a method should have only
one reason to change. Exactly.

150
00:09:58.430 --> 00:10:02.620
Yeah. A method should be
extremely focused. If it's got

151
00:10:02.690 --> 00:10:04.760
an if statement in it,
it probably shouldn't have two

152
00:10:04.760 --> 00:10:06.830
or three. If it's got
a wild loop in it,

153
00:10:06.830 --> 00:10:09.770
it probably shouldn't have two
or three and very, very

154
00:10:09.770 --> 00:10:13.310
small focused methods. And what
you get with that is

155
00:10:14.120 --> 00:10:17.030
it becomes very easy to
name them because you can

156
00:10:17.030 --> 00:10:21.740
choose very long names because
they're only called once. And

157
00:10:21.740 --> 00:10:25.700
those names can be extremely,
extremely informative. And then you

158
00:10:25.700 --> 00:10:29.630
wind up with lots of
little bits of code underneath

159
00:10:29.630 --> 00:10:36.680
well-named functions. I call this
cleaning up the room. I

160
00:10:36.680 --> 00:10:41.420
remember when you were a
teenager or younger, your filing

161
00:10:41.420 --> 00:10:43.310
system in your room was
to dump everything on the

162
00:10:43.310 --> 00:10:45.560
floor. And you knew where
everything was and it was

163
00:10:45.560 --> 00:10:47.750
fine. And then your clothes
would be on the floor

164
00:10:47.750 --> 00:10:49.310
and your toys and your
books and whatever they'd be

165
00:10:49.310 --> 00:10:50.720
on the floor. You knew
where it all was, but

166
00:10:50.720 --> 00:10:52.100
your mother would come in
and say, no, you've got

167
00:10:52.100 --> 00:10:55.970
to clean up this room.
She would clean it for

168
00:10:55.970 --> 00:10:58.970
you. And she would touch
you, put things in certain

169
00:10:58.970 --> 00:11:02.440
places, know where they go.
And maybe if she was

170
00:11:02.450 --> 00:11:05.860
in the old school, she
recited that old, old saw

171
00:11:05.930 --> 00:11:08.150
a place for everything and
everything. And it's a place

172
00:11:08.570 --> 00:11:10.910
that's the same kind of
thing we get with the

173
00:11:10.910 --> 00:11:14.960
single responsibility principle. We divide
things up into small little

174
00:11:14.960 --> 00:11:18.290
bits. We name the places
that they go with extremely

175
00:11:18.290 --> 00:11:22.880
informative names so that our
code, our entire system follows

176
00:11:22.880 --> 00:11:25.010
the rule, a place for
everything and everything in its

177
00:11:25.010 --> 00:11:28.400
place. Well, how, how long
is this going to, if

178
00:11:28.400 --> 00:11:31.460
I go and apply this
today and start thinking about

179
00:11:31.460 --> 00:11:34.370
this, how draconian should I
be about, about these kinds

180
00:11:34.370 --> 00:11:36.110
of things? How ruthless should
I be when I make

181
00:11:36.110 --> 00:11:38.990
these decisions? I think it
would apply a very different

182
00:11:39.500 --> 00:11:42.650
feel. It would make my,
it would make my programming

183
00:11:42.650 --> 00:11:45.440
day feel different for lack
of a better way to

184
00:11:45.440 --> 00:11:49.280
phrase that, Oh yes, it
probably would make your programming

185
00:11:49.280 --> 00:11:55.300
day feel different because what
you're doing is imposing a

186
00:11:55.300 --> 00:11:59.770
great deal of structure on
something that otherwise would have

187
00:11:59.770 --> 00:12:03.340
been somewhat a morphous. Imagine
a function that is 50

188
00:12:03.340 --> 00:12:06.190
lines long, and the left
edge looks like the side

189
00:12:06.190 --> 00:12:09.520
of a cross cut thoughts,
deeply indented. And it goes

190
00:12:09.520 --> 00:12:11.800
in and out and finding
your way around in there

191
00:12:11.800 --> 00:12:16.600
is fairly difficult. And then
remove chunks of that. Split

192
00:12:16.600 --> 00:12:20.470
it up into 10 functions,
five lines long. Each one

193
00:12:20.470 --> 00:12:24.310
has one level of indent
and name each one of

194
00:12:24.310 --> 00:12:26.920
them. And you wind up
with a structure that is

195
00:12:26.920 --> 00:12:30.970
readable and understandable, and you
don't have to dig your

196
00:12:30.970 --> 00:12:33.790
way deep inside to the
sixth or seventh in depth

197
00:12:34.090 --> 00:12:36.130
to figure out what's going
on. You can read the

198
00:12:36.130 --> 00:12:38.020
name of the function above
it and say, Oh, that's

199
00:12:38.020 --> 00:12:42.220
what's happening here. That's a
much more powerful way of

200
00:12:42.220 --> 00:12:46.060
working. Some people get afraid
that well, that's going to

201
00:12:46.060 --> 00:12:48.280
proliferate all the functions like
crazy. I'm going to have

202
00:12:48.280 --> 00:12:50.650
too many functions in too
many classes, and I'm going

203
00:12:50.650 --> 00:12:54.130
to get lost in a
sea of classes and functions.

204
00:12:54.760 --> 00:12:57.820
And actually the opposite is
true. If you don't do

205
00:12:57.820 --> 00:13:00.580
this, you are already lost
in a sea of heavily

206
00:13:00.580 --> 00:13:05.290
indented code that has no
names in those structures. Once

207
00:13:05.290 --> 00:13:07.510
you put the name and
the structure upon it, it

208
00:13:07.540 --> 00:13:11.820
becomes a lot easier to
find your way around. Okay.

209
00:13:12.000 --> 00:13:14.250
All right. So that's the
S and solid then. So

210
00:13:14.250 --> 00:13:17.550
then the, Yeah, we got
through one. I got through

211
00:13:17.550 --> 00:13:19.560
one, but this is good
though, because this is, this

212
00:13:19.560 --> 00:13:22.530
is important because I think
that this is the closest

213
00:13:22.530 --> 00:13:25.770
thing to commandments. And I
don't mean commandments in the

214
00:13:25.770 --> 00:13:28.380
sense that, you know, uncle
Bob and family went up

215
00:13:28.380 --> 00:13:31.050
on high and came down
with this information, but this

216
00:13:31.050 --> 00:13:36.930
is a guiding principles that
are good, basic stuff that

217
00:13:37.170 --> 00:13:39.480
aren't really arguable. I mean,
you know, thou shalt not

218
00:13:39.480 --> 00:13:44.520
steal is pretty unambiguous and
you could always find reasons

219
00:13:44.520 --> 00:13:46.740
to there's always exceptions, right.
You know, I'm sure that

220
00:13:46.740 --> 00:13:51.330
there are reasons to make
an multiple sport, multiple responsibility

221
00:13:51.330 --> 00:13:55.230
class, but then you can
certainly debate that until the

222
00:13:55.230 --> 00:13:57.600
cows come home. Sure. You
can think of these as

223
00:13:57.600 --> 00:14:02.580
engineering principles as opposed to
Yeah, exactly. So the O

224
00:14:02.610 --> 00:14:08.340
open-close principle, Yes. This is
a principle that was coined

225
00:14:08.760 --> 00:14:13.200
in 1988. I believe by
Bertrand Meyer and in a

226
00:14:13.200 --> 00:14:18.420
wonderful book of object oriented
software construction, which was one

227
00:14:18.420 --> 00:14:22.890
of the early terrific books
on object oriented design. This

228
00:14:22.890 --> 00:14:27.780
principle States, what sounds like
an oxymoron sounds like a

229
00:14:27.780 --> 00:14:32.700
contradiction in terms, it says
that modules should be open

230
00:14:32.700 --> 00:14:38.220
for extension, but closed for
modification. And that means that

231
00:14:38.220 --> 00:14:41.430
you should be able to
change what a module does.

232
00:14:41.550 --> 00:14:45.480
You should be able to
extend its behavior without modifying

233
00:14:45.480 --> 00:14:49.110
any code in the module,
whatever. Imagine that you have

234
00:14:49.110 --> 00:14:52.370
a module and you've set
the read bit. You're not

235
00:14:52.370 --> 00:14:55.760
allowed to change it. And
yet you can still modify

236
00:14:55.760 --> 00:15:00.050
what this module does by
using some other mechanism. And

237
00:15:00.050 --> 00:15:04.280
that's what the OB open-close
principles is all about. Obviously

238
00:15:04.280 --> 00:15:09.470
the mechanism we use as
polymorphism, we create abstract interfaces

239
00:15:09.560 --> 00:15:12.320
so that we can have
the module that we want

240
00:15:12.320 --> 00:15:17.030
closed calling and abstract interface.
And then we can extend

241
00:15:17.030 --> 00:15:20.690
what that module does by
creating derivatives of the abstract

242
00:15:20.690 --> 00:15:25.910
interface. The benefit here is
that it allows us to

243
00:15:25.910 --> 00:15:32.210
create systems whose behavior can
be extended without modifying the

244
00:15:32.210 --> 00:15:36.710
core of the code. We
can add new features by

245
00:15:36.710 --> 00:15:41.020
adding new code, not by
changing old existing code. And

246
00:15:41.020 --> 00:15:44.510
that has obvious benefits. If
you could, if you could

247
00:15:44.510 --> 00:15:48.800
add a whole new suite
of features and never touched

248
00:15:48.800 --> 00:15:51.740
the core of the code,
just add new code, you

249
00:15:51.740 --> 00:15:54.590
would not break the core
of them. The core of

250
00:15:54.590 --> 00:15:56.480
the code. You wouldn't be
putting it in any kind

251
00:15:56.480 --> 00:16:00.890
of risk. So the open-close
principle is a principle of

252
00:16:00.950 --> 00:16:05.150
attitude. We want you to
think about how you can

253
00:16:05.150 --> 00:16:09.020
separate the behaviors of the
system so that you can

254
00:16:09.020 --> 00:16:15.500
keep those behaviors that are
utterly intrinsic behind a wall

255
00:16:15.860 --> 00:16:18.830
that, that can't be touched.
And then all of the

256
00:16:18.830 --> 00:16:22.160
behaviors that are variable and
transient and change a lot,

257
00:16:22.400 --> 00:16:24.080
you put on the other
side of the wall and

258
00:16:24.080 --> 00:16:26.240
you allow them to change
as frequently as you want.

259
00:16:27.080 --> 00:16:29.510
And you make sure that
all of the dependencies that

260
00:16:29.510 --> 00:16:34.670
cross that boundary point inwards
towards the code, that can't

261
00:16:34.670 --> 00:16:38.270
be changed. The beauty of
the inheritance relationship is that

262
00:16:38.270 --> 00:16:40.760
a point that the base
class and the base class

263
00:16:40.760 --> 00:16:44.450
changes less frequently than the
derivative. And so we try

264
00:16:44.450 --> 00:16:47.660
to apply that with object
oriented techniques, using the open-close

265
00:16:47.660 --> 00:16:52.820
principle to create this two
sided structure. On one side,

266
00:16:52.940 --> 00:16:56.960
you have all the base
classes where nothing changes. And

267
00:16:56.960 --> 00:16:59.150
on the right side, you
have all the derivatives where

268
00:16:59.150 --> 00:17:03.230
things are very, very volatile
and all the dependencies point

269
00:17:03.500 --> 00:17:07.420
towards the base class. Hi,
this is Scott coming at

270
00:17:07.420 --> 00:17:09.850
you from another place in
time. Are you looking for

271
00:17:09.850 --> 00:17:12.760
an object, relational mapping tool
for mission critical projects using

272
00:17:12.760 --> 00:17:16.840
lincoln.net? I wanted to share
with you genome. So specifically

273
00:17:16.840 --> 00:17:20.290
designed for developing dot and
enterprise applications. Genome is a

274
00:17:20.290 --> 00:17:23.710
mature link, integrated ORM tool.
It's been employed in numerous

275
00:17:23.710 --> 00:17:26.740
large scale projects over the
last six years, genome was

276
00:17:26.740 --> 00:17:29.560
created for the.net platform as
opposed to being a port

277
00:17:29.560 --> 00:17:33.760
from Java. And it's thrived
on platform innovation since.net. 1.0

278
00:17:34.870 --> 00:17:37.750
genome has supported links since
its CTP release in may

279
00:17:37.750 --> 00:17:41.590
of 2006. It offers several
unique features, such as encapsulation

280
00:17:41.590 --> 00:17:44.680
and reuse of link queries
and expressions. You can really

281
00:17:44.710 --> 00:17:47.140
fully harness the power of
link while benefiting from your

282
00:17:47.140 --> 00:17:51.660
database platforms. Unique features, compose
complex LINQ queries decompose the

283
00:17:51.660 --> 00:17:54.540
query logic and your domain
model link supports all the

284
00:17:54.540 --> 00:17:57.900
major database platforms you find
in enterprise environments like SQL

285
00:17:57.900 --> 00:18:01.860
server, but also Oracle and
IBM DB too. And find

286
00:18:01.860 --> 00:18:04.920
out more about how genome
integrates tightly with visual studio

287
00:18:05.520 --> 00:18:07.320
and what tools do you
know them offers to reduce

288
00:18:07.320 --> 00:18:13.440
development time@tinyurl.com slash try genome
G E N O M

289
00:18:13.470 --> 00:18:16.290
E, where you can also
download a free and fully

290
00:18:16.290 --> 00:18:19.800
functional trial version. I hope
you enjoy it. Now. These

291
00:18:19.800 --> 00:18:24.270
principles don't dictate language, but
they do kind of there's

292
00:18:24.270 --> 00:18:29.820
an, I mean, it feels
like traditional object oriented languages.

293
00:18:30.990 --> 00:18:33.990
Do we use traditional? I
mean, is this a polymorphism

294
00:18:34.260 --> 00:18:37.320
principle or can we do
strategy patterns and have different,

295
00:18:37.710 --> 00:18:41.880
you know, pluggable interfaces to
achieve the open-close principles? Does

296
00:18:41.880 --> 00:18:47.840
this dictate Mark your methods
virtual? You can, you can

297
00:18:47.840 --> 00:18:51.890
do this with a standard
virtual methods in C sharp

298
00:18:51.890 --> 00:18:55.370
or in Java or C
plus plus, or if you

299
00:18:55.370 --> 00:18:57.890
wanted to, you could use
pointers to functions in C

300
00:18:58.180 --> 00:19:04.960
or you could use cleverly
crafted switch statements in <inaudible>

301
00:19:05.690 --> 00:19:09.530
or in other languages. There
are many, many ways to

302
00:19:09.530 --> 00:19:15.290
achieve this, even the, the
template language of C plus

303
00:19:15.320 --> 00:19:18.830
plus, and to a lesser
extent, Java give you some

304
00:19:18.830 --> 00:19:22.730
capabilities for doing this. The
basic ideas is very simple.

305
00:19:23.930 --> 00:19:29.570
Keep the things that, that,
that change frequently away from

306
00:19:29.570 --> 00:19:32.300
the things that don't change,
and then make sure that

307
00:19:32.330 --> 00:19:35.360
if they depend on each
other, the things that change

308
00:19:35.390 --> 00:19:40.070
frequently depend on the things
that don't change frequently, that's

309
00:19:40.070 --> 00:19:42.050
really the open-close principle. And
you can do that with

310
00:19:42.050 --> 00:19:45.380
polymorphism. You can do it
with textual substitution, the whole

311
00:19:45.380 --> 00:19:48.890
bunch of ways to do
that. The open-close principle kind

312
00:19:48.890 --> 00:19:51.920
of segues very neatly into
the, the, the crazily named

313
00:19:51.920 --> 00:19:55.010
or the interestingly named Liz
cough, substitution principle. That's the

314
00:19:55.010 --> 00:19:57.320
one that you make, you
sound extra smart if you

315
00:19:57.320 --> 00:20:01.130
throw it around the office.
Yes, that was the one

316
00:20:01.130 --> 00:20:02.930
I liked because it sounded
so much like the Pauli

317
00:20:02.930 --> 00:20:07.070
exclusion principle. Yeah. You can't
help, but sound, sound intelligent

318
00:20:07.070 --> 00:20:11.090
saying these things around the
water cooler, This golf substitution

319
00:20:11.090 --> 00:20:15.950
principle. Yes. Yeah. Very erudite
Now does this one. This

320
00:20:15.950 --> 00:20:20.000
seems to be a little
closer to this principle. It

321
00:20:20.000 --> 00:20:23.510
seems to expect virtual, you
know, virtual methods to work

322
00:20:23.510 --> 00:20:26.090
a certain way. It seems
to expect a language to

323
00:20:26.090 --> 00:20:28.970
work a certain way more
than the other, the previous

324
00:20:28.970 --> 00:20:33.650
two principles we've covered so
far. It, it certainly has

325
00:20:33.650 --> 00:20:40.520
a very strong connection to
inheritance and virtual functions. Although

326
00:20:40.520 --> 00:20:45.290
it, it applies in languages
like Ruby or Python, which

327
00:20:45.290 --> 00:20:49.810
don't have a traditional inheritance
of that nature. The idea,

328
00:20:49.810 --> 00:20:52.840
the idea behind this principle
is it's pretty simple. Although

329
00:20:52.840 --> 00:20:56.830
the implications are very far
reaching. If you have a,

330
00:20:57.750 --> 00:21:04.590
an expectation of some object
or some entity, and there

331
00:21:04.590 --> 00:21:09.720
are several possible sub entities,
we'll call them subtypes that

332
00:21:09.720 --> 00:21:15.150
could implement that original entity.
The car color of the

333
00:21:15.150 --> 00:21:19.920
original entities should not be
surprised by anything that happens.

334
00:21:20.310 --> 00:21:24.060
If, if one of the
sub entities is substituted. So

335
00:21:24.070 --> 00:21:26.370
simple way to think about
this is that if you're

336
00:21:26.370 --> 00:21:29.310
used to driving a Chevrolet,
you shouldn't be too surprised

337
00:21:29.730 --> 00:21:31.860
at when you get into
a Volkswagen, she'd still be

338
00:21:31.860 --> 00:21:37.950
able to drive. That's the
basic idea. There's an interface.

339
00:21:38.460 --> 00:21:42.150
You can use that interface.
Lots of things implement that

340
00:21:42.150 --> 00:21:45.210
interface one way or another,
and none of them should

341
00:21:45.210 --> 00:21:50.460
surprise you. Now, the, the,
the canonical example is the,

342
00:21:51.540 --> 00:21:54.930
the rectangle square problem. And
this is a huge philosophical

343
00:21:54.930 --> 00:21:58.380
debate that goes on all
the time in circles, or

344
00:21:58.380 --> 00:22:00.090
at least it used to,
I think it's pretty well

345
00:22:00.090 --> 00:22:05.640
resolved now, but given a,
a rectangle based class and

346
00:22:05.640 --> 00:22:11.400
given a, the need for
a square should the square

347
00:22:11.400 --> 00:22:15.330
class derive from the rectangle
and the at first blush,

348
00:22:15.360 --> 00:22:17.490
this seems like it's obvious,
of course the square should

349
00:22:17.490 --> 00:22:20.250
derive from the rectangle. A
square is a rectangle and

350
00:22:20.250 --> 00:22:25.620
the word is becomes a
square is a rectangle. Well,

351
00:22:25.620 --> 00:22:28.980
then you face some interesting
dilemmas. Once you create that

352
00:22:28.980 --> 00:22:31.890
relationship, then, then you start
to ask yourself some funny

353
00:22:31.890 --> 00:22:34.440
questions, like, well, wait a
minute. How many variables does

354
00:22:34.440 --> 00:22:37.590
a rectangle have? Well, that's
two height and width. How

355
00:22:37.590 --> 00:22:41.010
many variables does this? Square
need only needs one? Or

356
00:22:41.010 --> 00:22:42.600
how many needs are going
to inherit the wind here

357
00:22:42.610 --> 00:22:46.380
at two? Well, there's something
wrong there. It's getting too

358
00:22:46.380 --> 00:22:50.430
many variables from the base
class. There's a dilemma here.

359
00:22:50.430 --> 00:22:54.300
And it sounds right. Rip
square should derive from rectangle.

360
00:22:54.300 --> 00:22:57.270
But if it does, it's
going to be wasteful of

361
00:22:57.270 --> 00:22:59.520
memory, not memory is cheap.
So maybe we ignore that.

362
00:23:00.480 --> 00:23:04.980
Okay. There are methods inside
of rectangle methods like set

363
00:23:04.980 --> 00:23:09.630
height and width. And when
we derive square from rectangle,

364
00:23:09.630 --> 00:23:12.630
we're going to inherit those
methods. What does that height

365
00:23:13.530 --> 00:23:16.590
on a square? And how
is it different from the

366
00:23:16.590 --> 00:23:20.970
other method that's inherited by
square, which is width. There's

367
00:23:20.970 --> 00:23:24.630
a naming problem. And the
user of square is going

368
00:23:24.630 --> 00:23:27.030
to be faced with these
names that heightened set width.

369
00:23:27.060 --> 00:23:29.730
They don't make any sense
on a square. Now we

370
00:23:29.730 --> 00:23:34.410
can make them work by
causing the, a set height

371
00:23:34.440 --> 00:23:37.680
function to also set the
width and the cause the

372
00:23:37.680 --> 00:23:41.190
set width function to also
set the height, but the

373
00:23:41.190 --> 00:23:44.250
names are still messed up.
There's something wrong. And then

374
00:23:44.250 --> 00:23:47.690
we forced failure. There is
a failure mode that can

375
00:23:47.690 --> 00:23:50.750
occur here. And the failure
mode is very simple. You've

376
00:23:50.750 --> 00:23:54.290
got some guy up there.
Who's some class who uses

377
00:23:54.290 --> 00:23:57.440
rectangles and the programmer of
this class has made an

378
00:23:57.440 --> 00:24:00.530
assumption. When you change the
height of a rectangle, the

379
00:24:00.530 --> 00:24:04.130
width never changes perfectly reasonable
assumption if you're dealing with

380
00:24:04.130 --> 00:24:07.580
a rectangle. But now, because
I have derived square from

381
00:24:07.580 --> 00:24:10.610
rectangle, I can pass him
a square. He's going to

382
00:24:10.610 --> 00:24:13.850
call set width and height
is going to change out

383
00:24:13.850 --> 00:24:17.240
from underneath him. And because
he didn't expect that he'll

384
00:24:17.240 --> 00:24:19.880
have some, if statement that
blows up, he'll corrupt, the

385
00:24:19.880 --> 00:24:22.640
heap and a billion instructions
later, the whole system will

386
00:24:22.640 --> 00:24:25.900
crash and he'll get his
logic analyzers out and there'll

387
00:24:25.900 --> 00:24:28.010
be bugs this thing for
two weeks. And eventually you'll

388
00:24:28.010 --> 00:24:30.590
find out that, Oh my
God, somebody passed me a

389
00:24:30.590 --> 00:24:33.800
square. And I was expecting
a rectangle as the result

390
00:24:33.800 --> 00:24:35.810
of that. He will put
an if statement in his

391
00:24:35.810 --> 00:24:39.770
code and the statement will
read if this rectangle is

392
00:24:39.770 --> 00:24:44.960
really an instance of square.
And as he's done that

393
00:24:44.990 --> 00:24:48.950
he has hung a dependency
on the derivative of rectangle.

394
00:24:48.950 --> 00:24:52.220
He is, he has mentioned
the name of square and

395
00:24:52.220 --> 00:24:59.540
that, that, that dependency violates
the open-close principle. So you

396
00:24:59.540 --> 00:25:04.220
wind up with if statements
scattered around your code because

397
00:25:04.220 --> 00:25:08.440
of these, these violations of
the, the substitution principle that

398
00:25:08.440 --> 00:25:11.600
you couldn't even see it
first. And those, this statements

399
00:25:12.500 --> 00:25:16.970
hang dependencies on nasty, nasty
derivatives, that then violate the

400
00:25:16.970 --> 00:25:20.240
open-close primp principle makes it
very difficult for you to

401
00:25:20.390 --> 00:25:25.430
modify a square without changing
all of these things that

402
00:25:25.430 --> 00:25:30.490
now depend on rectangle. That
makes sense. But let me

403
00:25:30.580 --> 00:25:33.370
push, what would you do?
I mean, this is a,

404
00:25:33.940 --> 00:25:37.240
you know, pick a side
With the square rectangle problem.

405
00:25:37.540 --> 00:25:42.520
Yeah. They're not related at
all squares and rectangles aren't

406
00:25:42.520 --> 00:25:47.800
related in, in the code,
a square in geometry is

407
00:25:47.800 --> 00:25:51.010
related to a rectangle in
geometry, but these two pieces

408
00:25:51.010 --> 00:25:54.100
of code are not pieces
of geometry. They're just COVID

409
00:25:54.100 --> 00:25:56.980
they have completely separate behavior.
So I wouldn't have any

410
00:25:56.980 --> 00:25:59.860
relationship between them at all,
or at most perhaps they

411
00:25:59.860 --> 00:26:03.470
would have a common parent,
which might be shaped. Yeah.

412
00:26:03.490 --> 00:26:07.030
Yeah. That's interesting. In the,
when you, when, when you

413
00:26:07.030 --> 00:26:10.630
first said is the course,
the, the object oriented light

414
00:26:10.630 --> 00:26:13.560
went on, but then later
on you said is related.

415
00:26:14.650 --> 00:26:18.850
Hm. Yeah, I think it's,
it's comforting sometimes to try

416
00:26:18.850 --> 00:26:20.650
to make, as, as we,
as programmers, try to make

417
00:26:20.650 --> 00:26:23.770
order out of chaos to
go and say, Oh, a

418
00:26:23.770 --> 00:26:26.080
cat is a mammal is
an animal. This is a

419
00:26:26.080 --> 00:26:30.870
nice clean hierarchy. Let's go
and start naming things. And

420
00:26:30.910 --> 00:26:35.680
we try to simulate these
hierarchies. When, you know, maybe,

421
00:26:35.740 --> 00:26:39.400
maybe a cat is different,
you know, suspend disbelief. It's

422
00:26:39.400 --> 00:26:43.350
not a mammal. It's something
else. The word is crypt

423
00:26:43.350 --> 00:26:45.780
into our vocabulary. And by
the way, that's one word

424
00:26:45.780 --> 00:26:51.510
ISA it's crept into our
vocabulary through a circuitous route

425
00:26:51.510 --> 00:26:55.020
and became very important in
object oriented circles. But it

426
00:26:55.020 --> 00:26:58.320
didn't start out that way.
It crept in and the,

427
00:26:58.520 --> 00:27:02.340
the eighties through the AI
crowd who had created these

428
00:27:02.340 --> 00:27:05.370
wonderful knowledge nets, you might
remember this all the hype

429
00:27:05.370 --> 00:27:09.300
about artificial intelligence in the
late eighties, early nineties. And

430
00:27:09.300 --> 00:27:12.450
they had created these structures
that would walk knowledge nets,

431
00:27:12.450 --> 00:27:16.020
these inference engines and the
relationships between the entities and

432
00:27:16.020 --> 00:27:21.000
the knowledge nets were things
like, like tastes like smells,

433
00:27:21.000 --> 00:27:26.040
like, looks like a, is
all of these dash a

434
00:27:26.670 --> 00:27:31.020
relationships is a, like a
HAZOP. And when the AI

435
00:27:31.020 --> 00:27:34.860
crowd lost its funding and
all this funding dried up,

436
00:27:34.860 --> 00:27:36.540
they kind of looked over
and said, Oh, there's this

437
00:27:36.890 --> 00:27:39.210
stuff it's kind of cool.
And look, there's these relationships

438
00:27:39.240 --> 00:27:42.300
like has done is others
real similar. We ought to

439
00:27:42.300 --> 00:27:44.580
just move in and they
kind of did. And the

440
00:27:44.610 --> 00:27:49.980
vocabulary transitioned over. That's interesting.
It's also a little unfortunate

441
00:27:49.980 --> 00:27:55.170
because inheritance is not a
in inheritance. If you look

442
00:27:55.170 --> 00:27:58.200
at it with a very
jaded eye inheritance is the

443
00:27:58.200 --> 00:28:01.170
declaration of methods and variables
in the sub scope. And

444
00:28:01.170 --> 00:28:03.540
it has nothing to do
with is a whatever. And

445
00:28:03.540 --> 00:28:06.480
the, the notion of is
that can be very confounding.

446
00:28:06.540 --> 00:28:11.010
A simple example, an integer
is a real number and

447
00:28:11.010 --> 00:28:13.680
a real number is a
complex number. You could draw

448
00:28:13.680 --> 00:28:15.870
that in UML, it'd be
very simple with all the

449
00:28:15.870 --> 00:28:19.080
inheritance Ceros and so forth,
but think about trying to

450
00:28:19.080 --> 00:28:22.680
compile it an integer, we
would hope would be 16

451
00:28:22.680 --> 00:28:25.920
or maybe 64 bits. But
if it were to derive

452
00:28:25.920 --> 00:28:28.380
from a real number, a
real number has two integers

453
00:28:28.380 --> 00:28:32.970
in it, a man Tessa,
and a characteristic, the exponent,

454
00:28:33.300 --> 00:28:37.620
and they use the, they
imply binary points inside them

455
00:28:37.620 --> 00:28:40.830
to make the floating point
number, the floating point number,

456
00:28:40.830 --> 00:28:43.560
the real number derives from
complex, but a complex has

457
00:28:43.560 --> 00:28:46.470
two real numbers in it.
The imaginary and the real

458
00:28:46.470 --> 00:28:49.910
park. If you were to
think about writing that in,

459
00:28:49.910 --> 00:28:53.820
in C plus plus, or
in Java you'd you would

460
00:28:53.820 --> 00:28:56.340
write a structure that could
not be compiled cause it

461
00:28:56.340 --> 00:29:00.900
has infinite size makes perfect
sense in English makes no

462
00:29:00.900 --> 00:29:05.330
sense at all in software,
Which it seems to be

463
00:29:05.330 --> 00:29:07.700
most of the things that
I work on, that it

464
00:29:07.700 --> 00:29:10.190
all seems so clean. And
then you start trying to

465
00:29:10.190 --> 00:29:12.680
model it. It makes me
think about those, these, these,

466
00:29:12.710 --> 00:29:14.990
these new modeling languages that
people are coming out with

467
00:29:14.990 --> 00:29:18.320
to, you know, model everything
we try to teach, you

468
00:29:18.320 --> 00:29:19.880
know, what do you, what
do you think about those

469
00:29:19.880 --> 00:29:22.730
grand designs to T to
model? All we need is

470
00:29:22.730 --> 00:29:25.060
a new modeling language, and
then it will be okay

471
00:29:25.190 --> 00:29:27.140
With it's. We've always been
on the hunt for a

472
00:29:27.140 --> 00:29:29.930
new modeling language. We always
will be. And that's a

473
00:29:29.930 --> 00:29:32.540
fine thing. I think, you
know, we want to continue

474
00:29:32.540 --> 00:29:36.830
to hunt for the grand
unifying language. There is no

475
00:29:36.830 --> 00:29:42.760
such thing, obviously. Yeah. There's,
you've heard the MDA people,

476
00:29:42.760 --> 00:29:44.920
the model driven architecture folks.
I think this is a

477
00:29:44.920 --> 00:29:48.340
great effort. I wish them
a lot of luck. I

478
00:29:48.340 --> 00:29:51.070
have no confidence whatsoever that
they're going to find a

479
00:29:51.070 --> 00:29:57.610
way to create a modeling
language that is so good

480
00:29:57.880 --> 00:30:03.490
that you won't need programmers
anymore. Programming is the, is

481
00:30:03.550 --> 00:30:09.190
the, the profession of managing
the tail detailing information systems.

482
00:30:09.670 --> 00:30:11.140
And there's no way to
get rid of all that.

483
00:30:12.490 --> 00:30:15.880
Any, any modeling language is
going to have to be

484
00:30:15.880 --> 00:30:22.480
able to deal with nasty
with the lousy detail and

485
00:30:22.480 --> 00:30:25.720
its programmers who drive the
language to do that kind

486
00:30:25.720 --> 00:30:28.180
of mastery. So if it's,
you know, a language that

487
00:30:28.180 --> 00:30:31.120
uses UML or a language,
it uses some other wonderful

488
00:30:31.120 --> 00:30:34.840
graphic tool or, or a
language of some other kind

489
00:30:34.840 --> 00:30:38.140
it's still going to be
dominated by massive amounts of

490
00:30:38.140 --> 00:30:43.410
detail and require programmers to
manage it. Yup. Yup. And

491
00:30:43.410 --> 00:30:45.630
at some point someone will
do a switch statement and

492
00:30:45.630 --> 00:30:47.820
then they'll spackle over it
and pretend it didn't happen.

493
00:30:48.510 --> 00:30:53.370
And then it's becomes legacy
code. Well, yeah, like have

494
00:30:53.370 --> 00:30:56.310
you read feather's book on
legacy codes? I, I have,

495
00:30:56.310 --> 00:30:59.310
and actually Carl Franklin had him
on dotnet rocks, I think

496
00:30:59.310 --> 00:31:04.170
at or dev. Oh good.
Yeah. Fedora dev at Michael's

497
00:31:05.040 --> 00:31:08.160
Michael's definition of legacy code
is code. That's not under

498
00:31:08.160 --> 00:31:13.500
test board. It's already legacy
code. Yeah. It's interesting going

499
00:31:13.500 --> 00:31:16.830
back and finding code that
I wrote not 10 years

500
00:31:16.830 --> 00:31:18.840
ago, which had no tests,
but five years ago, which

501
00:31:18.840 --> 00:31:21.960
did have, you know, piles
of in unit tests. The

502
00:31:21.960 --> 00:31:24.810
only thing that I feel
when I see my old

503
00:31:24.810 --> 00:31:26.910
legacy code is well not
legacy code, but my older

504
00:31:26.910 --> 00:31:29.610
code is, gosh, I should
have written more tests. That's

505
00:31:29.610 --> 00:31:32.400
the one thing I keep
coming back to it like,

506
00:31:32.430 --> 00:31:35.820
Oh wow, there's tests. That's
great test dot bat. Oh,

507
00:31:35.850 --> 00:31:40.080
there's not enough tests that
I continually have that feeling.

508
00:31:41.310 --> 00:31:43.950
This is something that the
community owes a great debt

509
00:31:43.950 --> 00:31:48.570
to Beck and ward Cunningham
for the whole whole notion

510
00:31:48.570 --> 00:31:53.130
of test driven development and
the drive towards a massive

511
00:31:53.130 --> 00:31:56.190
amounts of unit testing and
acceptance testing. And it makes

512
00:31:56.190 --> 00:32:00.090
a huge difference. Just an
enormous difference in the quality

513
00:32:00.090 --> 00:32:02.340
of code and the ability
to get into code and

514
00:32:02.340 --> 00:32:05.640
manipulate it and change it.
When you have tests, you're

515
00:32:05.640 --> 00:32:08.400
not afraid if you've got
a big wad of code

516
00:32:08.400 --> 00:32:10.560
out there, there's no test,
you're scared to death to

517
00:32:10.560 --> 00:32:13.230
touch it. So, you know,
you're going to break things

518
00:32:13.230 --> 00:32:16.140
in there, but if you
have tests, you can reach

519
00:32:16.140 --> 00:32:17.760
into it and fiddle with
it and pull on it

520
00:32:17.760 --> 00:32:20.040
and push at it and
tweak it, run the test

521
00:32:20.040 --> 00:32:22.110
down there. I'll still pass.
I didn't break anything. Right.

522
00:32:22.140 --> 00:32:25.560
As long as those tests
have enough coverage, You know,

523
00:32:25.570 --> 00:32:27.240
there was an interesting discussion
I got into with some

524
00:32:27.240 --> 00:32:30.630
people about dynamic languages versus
statically typed languages. And the

525
00:32:30.630 --> 00:32:33.660
individual said that the compiler
was just a unit test,

526
00:32:35.070 --> 00:32:37.800
but once you, once you
accepted the fact that the

527
00:32:37.800 --> 00:32:40.610
competitor was just a unit
test and the whole argument

528
00:32:40.610 --> 00:32:46.060
of dynamically type versus static
type didn't matter anymore, The,

529
00:32:46.190 --> 00:32:49.690
the argument of static versus
dynamic is an interesting one

530
00:32:50.410 --> 00:32:55.030
because the static typing creates
a set of very rigid

531
00:32:55.030 --> 00:33:00.070
dependencies that tends to make
the codes inflexible. But then

532
00:33:00.070 --> 00:33:04.840
it's, it's really hard to
segregate your code into a

533
00:33:04.840 --> 00:33:08.950
nice set of flexible module.
Whereas with dynamic languages, it's

534
00:33:08.950 --> 00:33:11.530
really easy to keep the
code as flexible as you

535
00:33:11.530 --> 00:33:14.200
want. And it's also really
easy to make a horrid

536
00:33:14.200 --> 00:33:18.640
mess. So you wind up
with this double edge sword,

537
00:33:18.640 --> 00:33:20.740
which one would you like,
would you like to be

538
00:33:21.250 --> 00:33:24.130
a, you know, highly disciplined
and ordered, but you have

539
00:33:24.130 --> 00:33:26.050
to live within a rigid
framework or do you want

540
00:33:26.050 --> 00:33:29.230
to be a little bit
lackadaisical and you know, and

541
00:33:29.230 --> 00:33:35.740
do some nice, flexible things.
And I, my, my preference

542
00:33:35.920 --> 00:33:39.610
of late is towards the
dynamic language. I've gotten very

543
00:33:40.420 --> 00:33:44.290
pleased with languages like Ruby.
I enjoy them a great

544
00:33:44.290 --> 00:33:48.100
deal. I maintain my discipline
by writing gobs and gobs

545
00:33:48.100 --> 00:33:51.910
of tests. Although I probably
still write much more Java

546
00:33:51.910 --> 00:33:56.590
than Ruby. Well, let's pound
through the last two principles

547
00:33:56.590 --> 00:33:59.050
here. As we get towards
the end of the show

548
00:33:59.050 --> 00:34:01.030
here, we've still got to
talk about dependency and version

549
00:34:01.030 --> 00:34:03.550
and interface segregation. If we
do it in order on

550
00:34:03.550 --> 00:34:08.590
your article, it's Sol DEI,
we spell out solid though.

551
00:34:08.590 --> 00:34:10.270
Why is that? Why is
it not spelled out? So

552
00:34:10.270 --> 00:34:14.020
you don't actually never say
solid in your article? No,

553
00:34:14.020 --> 00:34:16.630
the, the word solid actually
came up later. Michael feathers

554
00:34:16.630 --> 00:34:18.310
wrote me a quick email
saying, you know, if you

555
00:34:18.310 --> 00:34:24.070
reorder these, it's spelled the
word solid Salty, didn't get,

556
00:34:24.100 --> 00:34:28.300
didn't quite roll off the
tongue. No, but I wasn't

557
00:34:28.300 --> 00:34:30.220
looking for an acronym. He
just found it for me.

558
00:34:30.220 --> 00:34:33.520
And then we've since found
some pictures. So if we

559
00:34:33.520 --> 00:34:35.890
do it in order, the,
the, if we do it

560
00:34:35.890 --> 00:34:37.480
in the original order, then
the next one is the

561
00:34:37.480 --> 00:34:41.830
dependency and version principle. And
this is a, almost a

562
00:34:41.830 --> 00:34:47.470
restatement of the open-close principle,
except from a 90 degree

563
00:34:47.620 --> 00:34:51.880
rotation, the open-close principle States
the goal, you know, it

564
00:34:51.880 --> 00:34:55.810
makes things so that you
don't have to modify them

565
00:34:55.840 --> 00:34:59.650
and you can extend their
behavior. The dependency inversion principle

566
00:34:59.670 --> 00:35:04.090
says don't depend on anything.
Concrete depend only on things

567
00:35:04.090 --> 00:35:08.110
that are abstract. If you
think about that, those two

568
00:35:08.110 --> 00:35:11.380
are roughly the same. The
open-close principle is achieved by

569
00:35:11.380 --> 00:35:15.340
having derivatives depending on base
classes and making sure that

570
00:35:15.340 --> 00:35:17.620
all of your volatile code
is in the derivatives and

571
00:35:17.620 --> 00:35:21.040
your, your nonviolence code is
in the base classes. Dependency,

572
00:35:21.060 --> 00:35:23.650
inversion principle just says that
the opposite way around it

573
00:35:23.650 --> 00:35:26.380
says, okay, make sure that
all your dependencies pointed things

574
00:35:26.380 --> 00:35:30.250
that are abstract. The dependency
inversion principle goes to a

575
00:35:30.250 --> 00:35:34.990
pretty far extreme. It goes
on to say, don't depend

576
00:35:34.990 --> 00:35:38.670
on anything concrete ever. If
you're calling a function, it

577
00:35:38.670 --> 00:35:42.360
should be an abstract function,
a pure function. If you're

578
00:35:42.510 --> 00:35:46.620
overriding a function, make sure
it's pure. If you're, if

579
00:35:46.620 --> 00:35:50.220
you're a CRE calling an,
an object or you're holding

580
00:35:50.220 --> 00:35:52.230
a reference to an object,
make sure it's a reference

581
00:35:52.230 --> 00:35:55.200
to an abstract base class
of the object. Never touch

582
00:35:55.200 --> 00:36:00.590
anything concrete. Obviously you can't,
you can't do that. Yeah.

583
00:36:00.590 --> 00:36:02.570
I mean, that's pretty, like
I say, I keep saying

584
00:36:02.600 --> 00:36:05.540
draconian, but I mean, sometimes
people take the solid principles

585
00:36:05.540 --> 00:36:08.000
and they wield them with
like a stick. Well, yeah.

586
00:36:08.030 --> 00:36:10.340
Then that'd be silly. You
have to do it again.

587
00:36:10.340 --> 00:36:13.400
They're engineering principles, Right? I
mean, it's, it's, it's an

588
00:36:13.400 --> 00:36:18.170
interesting thing that, I mean,
you work with, with groups

589
00:36:18.170 --> 00:36:20.270
and you go in and
consult with groups, but you

590
00:36:20.270 --> 00:36:22.430
know, when you're a member
of one of these groups

591
00:36:22.430 --> 00:36:24.500
and someone comes in and
drop some principles on you

592
00:36:24.500 --> 00:36:27.680
that maybe you're unfamiliar with,
and then, and then leaves

593
00:36:28.130 --> 00:36:31.220
the people who drank the
deepest of the Koolaid, then

594
00:36:31.280 --> 00:36:34.420
you start to have, have
these principles. You know, they

595
00:36:34.430 --> 00:36:37.220
basically, they out they'll shut,
not kill. I now remember

596
00:36:37.220 --> 00:36:41.720
the commandments at every, at
every turn at how much,

597
00:36:41.780 --> 00:36:43.460
you know, how many grains
of salt should we use

598
00:36:43.460 --> 00:36:46.730
when we're applying these, these
principles? How important are these?

599
00:36:46.730 --> 00:36:49.370
Are they, is one more
important than another? Or are

600
00:36:49.370 --> 00:36:52.460
they all equally? No, I
think they're all very important.

601
00:36:52.460 --> 00:36:55.280
Although if I had to
pick one to, if I

602
00:36:55.280 --> 00:36:58.430
had to pick an order,
I'd probably say single responsibility

603
00:36:58.430 --> 00:37:04.580
dependency in version open-close lists
off interface. That was, that

604
00:37:04.580 --> 00:37:09.710
was completely off the top.
But dependency in version, it's

605
00:37:09.710 --> 00:37:12.440
very mechanistic. It says, make
sure you depend only in

606
00:37:12.440 --> 00:37:18.740
the direction of, of abstraction.
There are certain parts of

607
00:37:18.740 --> 00:37:21.170
the code that must violate
that. But then I have

608
00:37:21.170 --> 00:37:23.540
a rule about those certain
parts that must violate it.

609
00:37:23.810 --> 00:37:27.350
They belong on the, on
the right side. So remember

610
00:37:27.350 --> 00:37:30.050
we had this, when we
talked about the open-close principle,

611
00:37:30.050 --> 00:37:33.710
we had these two sides
of the volatile side and

612
00:37:33.710 --> 00:37:41.990
the, the non-volatile side and
the, the, the things that

613
00:37:41.990 --> 00:37:46.010
violate the dependency in version
sensible, all belong on the

614
00:37:46.400 --> 00:37:50.990
volatile side, the things that
change frequently, anything that we

615
00:37:50.990 --> 00:37:53.840
don't want to change, anything
that's part of the core

616
00:37:53.840 --> 00:37:58.100
abstraction of our system. We
furiously defends the dependency and

617
00:37:58.100 --> 00:38:02.450
version principle. I, I call
the other side, the side

618
00:38:02.450 --> 00:38:06.080
related to main the volatile
part. That's the side related

619
00:38:06.080 --> 00:38:08.780
to Maine. Maine is the
most concrete of our functions.

620
00:38:09.050 --> 00:38:12.170
And it will, it will
create all of our instances

621
00:38:12.170 --> 00:38:15.560
and all of the factories
and all of the concrete

622
00:38:15.560 --> 00:38:18.980
classes for us. And it
will then hand off to

623
00:38:18.980 --> 00:38:22.910
the, to the abstract part,
a set of abstract pointers,

624
00:38:22.910 --> 00:38:27.500
abstract and interfaces. And the
abstract core will manipulate it

625
00:38:27.500 --> 00:38:29.660
as though it were in
this fantasy world where everything

626
00:38:29.660 --> 00:38:34.250
was abstracting, that boundary line
that I draw between the

627
00:38:34.250 --> 00:38:38.500
volatile and the non-volatile actually
repeats itself several times in

628
00:38:38.500 --> 00:38:41.920
every system. So you'll find
lots of those boundary lines

629
00:38:41.950 --> 00:38:45.760
all through. And on the
one side, you've got flagrant

630
00:38:45.760 --> 00:38:48.760
violations of dependency inversion version,
because somebody's got to create

631
00:38:48.760 --> 00:38:51.700
these objects. And then on
the other side, you've got,

632
00:38:51.760 --> 00:38:55.300
you know, really strong defense
of the dependency version principles.

633
00:38:57.630 --> 00:38:58.650
Yeah. I mean, at some
point you have to draw

634
00:38:58.650 --> 00:39:01.170
the line. I mean, the,
the frame, the framework itself

635
00:39:01.170 --> 00:39:03.870
that does the new thing
has to break some principles.

636
00:39:04.830 --> 00:39:07.050
And so we make sure
that those go on into

637
00:39:07.050 --> 00:39:11.220
a certain place. You don't
do things in the normal

638
00:39:11.220 --> 00:39:14.730
part of the code. You
call new inside of factories

639
00:39:14.730 --> 00:39:18.720
or inside of prototype methods
or somewhere that's related to

640
00:39:18.720 --> 00:39:21.840
the volatile part of the
system. We don't want to

641
00:39:21.840 --> 00:39:24.780
see any news in the
nonbillable part of the system.

642
00:39:26.280 --> 00:39:28.590
That's a good, that's a
very good way to phrase

643
00:39:28.590 --> 00:39:30.810
it. That that makes a
lot of sense. So then

644
00:39:30.810 --> 00:39:37.050
the, your self decide, describe
least important or least important

645
00:39:37.050 --> 00:39:42.390
amongst peers here, the interface
segregation principle. Yes, this is

646
00:39:43.620 --> 00:39:47.460
eight applies to a very
fat classes, classes that have

647
00:39:48.210 --> 00:39:52.500
hundreds of methods and many,
many clients. And you get

648
00:39:52.500 --> 00:39:56.700
into a situation where you'll
have populations of the clients

649
00:39:56.760 --> 00:40:01.410
that use subsets of the
methods of this class. So

650
00:40:01.680 --> 00:40:03.300
to make this simple, let's
say you've got a big

651
00:40:03.300 --> 00:40:06.060
class, call it fat, and
it's got a bunch of

652
00:40:06.060 --> 00:40:09.660
methods in it. And there's
a group of clients over

653
00:40:09.660 --> 00:40:12.480
here that calls the first
three methods and another group

654
00:40:12.480 --> 00:40:14.700
of clients that were here,
the calls last three method.

655
00:40:17.160 --> 00:40:21.480
Now imagine that one in
one of the first three

656
00:40:21.480 --> 00:40:24.990
methods changes its signature. For
some reason, we've got to

657
00:40:25.020 --> 00:40:29.040
add an argument to it.
The population of clients that

658
00:40:29.040 --> 00:40:33.570
does not care about that
method is still forced to

659
00:40:33.570 --> 00:40:39.240
be to change because the
class itself changed. This was

660
00:40:39.240 --> 00:40:42.240
really important in C plus
plus where a pound include

661
00:40:42.480 --> 00:40:46.080
was involved in the pound
include cause they recompile of,

662
00:40:46.320 --> 00:40:51.390
of everybody that, that depended
on it. It's also important

663
00:40:51.390 --> 00:40:54.150
in Java and C sharp,
although not quite as important.

664
00:40:54.900 --> 00:40:57.750
Some people play a funny
game where they, they change

665
00:40:57.760 --> 00:40:59.820
the signature of a method.
And then the other files

666
00:40:59.820 --> 00:41:02.400
that don't care about it,
they just don't bother to

667
00:41:02.400 --> 00:41:05.640
recompile them. We found everybody
in the Benton fit the

668
00:41:05.640 --> 00:41:09.090
mountain back in general. You
want to be able to,

669
00:41:09.090 --> 00:41:13.140
if a source file changes,
you have to recompile everybody

670
00:41:13.140 --> 00:41:16.650
who depends on that source
file. Even if nothing, they

671
00:41:16.650 --> 00:41:20.370
really cared about changed. Now,
the way we can avoid

672
00:41:20.370 --> 00:41:24.990
that from happening is by
taking each of the, each

673
00:41:24.990 --> 00:41:33.090
of the clients and creating
an interface that contains only

674
00:41:33.200 --> 00:41:36.020
methods that they care about.
And if we had a,

675
00:41:36.020 --> 00:41:38.660
if we had 10 clients,
then we'd create 10 interfaces

676
00:41:39.050 --> 00:41:41.120
and each of those interface
would have a different set

677
00:41:41.120 --> 00:41:43.070
of methods in it. And
all the methods in there

678
00:41:43.070 --> 00:41:46.310
would be abstract. And then
the fat class would inherit

679
00:41:46.310 --> 00:41:49.460
from all 10 of the
interfaces. And if there were

680
00:41:49.460 --> 00:41:54.440
duplications in the methods, they
would just be grouped together.

681
00:41:54.440 --> 00:41:57.560
But through that interface, and
once you've done that, then

682
00:41:58.010 --> 00:42:00.620
Nope, no class depends on
any more methods than it

683
00:42:00.620 --> 00:42:04.250
ever needs. It simply depends
only on the methods that

684
00:42:04.250 --> 00:42:07.400
it needs. And if a
change happens, it changes to

685
00:42:07.400 --> 00:42:11.270
the interface. The clients of
that interface obviously has to

686
00:42:11.270 --> 00:42:14.780
be recompiled, but nobody else
does. And so all the

687
00:42:14.780 --> 00:42:18.340
other clients are safe. There's
an, there's an elegant pragmatism

688
00:42:18.340 --> 00:42:20.950
to that. I don't usually
think of being for some

689
00:42:20.950 --> 00:42:23.860
reason. I always feel like
when I say pragmatic, when

690
00:42:23.860 --> 00:42:25.090
I'm doing something, I say,
Oh, I have to make

691
00:42:25.090 --> 00:42:27.880
a pragmatic decision. I always
feel like that's a difficult

692
00:42:27.880 --> 00:42:30.430
decision or the wrong decision.
And I just apply the

693
00:42:30.430 --> 00:42:33.100
word pragmatic to make myself
feel better about it, but

694
00:42:34.270 --> 00:42:36.280
for something to be both
elegant and pragmatic feels really,

695
00:42:36.640 --> 00:42:38.080
really good. That makes it,
that makes a lot of

696
00:42:38.080 --> 00:42:40.870
sense. Well, in general, you
don't want to depend on

697
00:42:40.870 --> 00:42:44.380
something you don't use. And
here you got a class

698
00:42:44.380 --> 00:42:45.700
of a whole bunch of
methods in it and you

699
00:42:45.700 --> 00:42:50.290
don't call them any dependency
on them. You're depending on

700
00:42:50.290 --> 00:42:53.680
this method. So The, the
number of interfaces, the sheer

701
00:42:53.680 --> 00:42:58.780
number of interfaces, the specialization
applying the single responsibility principle,

702
00:42:58.780 --> 00:43:01.450
just not just to classes,
but also to, to methods

703
00:43:01.450 --> 00:43:06.190
and to interfaces will definitely
cause a, a relative proliferation

704
00:43:06.190 --> 00:43:09.770
of, of, of new things
within, you know, new, new,

705
00:43:09.790 --> 00:43:13.090
new interfaces, new methods, new
classes. But like you said,

706
00:43:13.090 --> 00:43:16.900
they'll each be very specialized
and basic and simple. There'll

707
00:43:16.900 --> 00:43:21.280
be more of them, but
they will be specialized. That's

708
00:43:21.280 --> 00:43:24.430
certainly true. Especially in languages
like C sharp and Java

709
00:43:24.430 --> 00:43:27.340
and C plus plus, right?
Think of language like Ruby

710
00:43:28.120 --> 00:43:31.960
in language like Ruby, you
never depend on anything more

711
00:43:31.960 --> 00:43:35.950
than the method you're calling
the methods declared in a

712
00:43:35.980 --> 00:43:38.620
class are not part of
what you depend upon when

713
00:43:38.620 --> 00:43:41.020
you, when you send a
message to an object. In

714
00:43:41.020 --> 00:43:43.150
fact, when you send a
message to an object, you

715
00:43:43.150 --> 00:43:47.530
don't know what class it
is. And so dynamic languages

716
00:43:47.950 --> 00:43:52.210
automatically obey the interface, segregation
principle, and obey it in

717
00:43:52.210 --> 00:43:56.170
the most extreme way possible.
There is no way for

718
00:43:56.170 --> 00:43:58.060
them to depend on any
more than the methods that

719
00:43:58.060 --> 00:44:02.560
they actually call. Well, that
is an excellent way to

720
00:44:02.560 --> 00:44:06.400
end. Our discussion of the,
the solid principles are demystification

721
00:44:07.090 --> 00:44:09.430
uncle Bob. I really appreciate
you taking as much time

722
00:44:09.430 --> 00:44:10.780
as you did to sit
down and chat with me

723
00:44:10.780 --> 00:44:14.050
about these principles. And folks
can, can learn about them

724
00:44:14.050 --> 00:44:16.450
at a, at object mentor.com
and you can poke around

725
00:44:16.450 --> 00:44:19.690
on the site there, there's
also blog dot object, mentor.com.

726
00:44:19.690 --> 00:44:21.190
And if you go up
there, you can see that

727
00:44:21.190 --> 00:44:24.820
uncle Bob, as well as
his cohorts, Dean, Brett, Michael

728
00:44:24.820 --> 00:44:27.670
and Bob are all on
Twitter. So you can drink

729
00:44:27.670 --> 00:44:31.110
in as much of the,
the wit and wisdom of

730
00:44:31.110 --> 00:44:34.110
uncle Bob, as you could
possibly take in one sitting.

731
00:44:37.470 --> 00:44:39.560
Well, you know, thanks so
much for your, for your,

732
00:44:39.560 --> 00:44:42.090
your work in the last
many, many years, you've been

733
00:44:42.720 --> 00:44:45.450
in the business so long,
and we look to you

734
00:44:45.450 --> 00:44:48.270
and your cohorts with a
lot of respect, and we

735
00:44:48.270 --> 00:44:51.590
really appreciate everything that you
offer to the community. Well,

736
00:44:51.590 --> 00:44:53.900
thank you. I appreciate that.
And it's just been a

737
00:44:53.900 --> 00:44:57.350
lot of fun. So we'll
do it again. Well, this

738
00:44:57.350 --> 00:44:59.480
has been another episode of
Hanselminutes and we'll see you

739
00:44:59.480 --> 00:45:00.350
again next week.


WEBVTT FILE

1
00:00:00.210 --> 00:00:03.360
Hi, this is Scott. I
really appreciate our sponsors because

2
00:00:03.360 --> 00:00:06.330
they make the show possible.
Today's show is sponsored by

3
00:00:06.330 --> 00:00:10.530
developer express, become a UI
superhero with dev express controls

4
00:00:10.530 --> 00:00:15.060
and libraries. Deliver elegant.net solutions
that address customer needs today

5
00:00:15.420 --> 00:00:19.500
by leveraging your existing knowledge,
you can build next generation

6
00:00:19.530 --> 00:00:23.610
touch enabled solutions for tomorrow,
you can download your free

7
00:00:23.730 --> 00:00:48.270
30 day trial@dxdothanselminutes.com. That's dx.hanselminutes.com
from hanselminutes.com. It's Hansel minutes,

8
00:00:48.510 --> 00:00:52.800
our weekly discussion with web
developer and technologist Scott Hanselman.

9
00:00:53.400 --> 00:00:58.530
This is Lawrence Ryan announcing show
number 538. In this episode,

10
00:00:58.530 --> 00:01:02.280
Scott talks with Frank Krueger
about Frank's newly released app

11
00:01:02.400 --> 00:01:06.180
continuous, which lets you do
C-sharp and dev sharp programming

12
00:01:06.450 --> 00:01:13.110
on the iPad. Hi, this
is Scott Hanselman. This is

13
00:01:13.110 --> 00:01:16.170
another episode of Hansel minutes
today. We're talking with Frank

14
00:01:16.200 --> 00:01:20.010
Krueger from Kruger systems. You
may know him from Kalka

15
00:01:20.130 --> 00:01:24.030
or I circuit, and Frank
just released an amazing new

16
00:01:24.030 --> 00:01:28.080
app called continuous that lets
you do C sharp and

17
00:01:28.080 --> 00:01:32.010
F sharp programming on your
iPad. And it is lit

18
00:01:32.010 --> 00:01:35.100
the internet on fire. How
are you Frank Krueger. Oh,

19
00:01:35.100 --> 00:01:37.680
I'm very well, Scott. Thanks
for having me on this

20
00:01:37.710 --> 00:01:41.430
is very exciting day. You
just like tweeted and then,

21
00:01:41.700 --> 00:01:44.880
you know, the world exploded
in a good way. I've

22
00:01:44.880 --> 00:01:46.770
been waiting for this day
for about six months though.

23
00:01:46.770 --> 00:01:49.740
Honestly, really? Does that mean
it's been close to being

24
00:01:49.740 --> 00:01:51.570
done for the last six
months or is this a

25
00:01:51.570 --> 00:01:53.460
matter of going around and
around with the app store?

26
00:01:53.910 --> 00:01:56.460
Now? It's a little bit
of, I, I wasn't supposed

27
00:01:56.460 --> 00:01:58.800
to be working on this
project in the beginning. And

28
00:01:58.800 --> 00:02:01.470
so every month that it
took to write, I kind

29
00:02:01.470 --> 00:02:03.990
of felt a little bit
bad for, but decided to

30
00:02:03.990 --> 00:02:07.710
push through to the very
end. What do you mean

31
00:02:07.710 --> 00:02:09.570
you weren't, we weren't supposed
to be working on this

32
00:02:09.570 --> 00:02:11.370
or is this just a,
a toy that turned into

33
00:02:11.370 --> 00:02:15.210
like your flagship? Yeah, that's
exactly what happened here. I,

34
00:02:15.270 --> 00:02:17.490
what happened was I had
written a little ad in

35
00:02:17.490 --> 00:02:20.640
for Xamarin studio to aid
in development. I wanted to

36
00:02:20.640 --> 00:02:23.400
be able to test things
a lot faster on the

37
00:02:23.400 --> 00:02:26.610
device and on the simulator
very quickly. And that led

38
00:02:26.610 --> 00:02:29.160
down a rabbit hole of
me wanting to be able

39
00:02:29.160 --> 00:02:32.010
to get that ad in
working on the device itself.

40
00:02:32.850 --> 00:02:35.670
And what I realized once
I actually got that technology

41
00:02:35.670 --> 00:02:38.130
working was that, Oh, darn
I can actually build a

42
00:02:38.130 --> 00:02:41.370
full IDE. Now I have
all the technology here. And

43
00:02:41.370 --> 00:02:43.200
so I gave myself permission
to work on it for

44
00:02:43.200 --> 00:02:45.180
three months to see how
things turned out and it

45
00:02:45.180 --> 00:02:49.410
ended up taking six months,
but one person in six

46
00:02:49.410 --> 00:02:53.760
months built a very functional
IDE that runs on a

47
00:02:53.760 --> 00:02:58.800
freaking iPad. So does that
mean, is that a, that's

48
00:02:58.800 --> 00:03:02.710
either a Testament to your
skills or are the, as

49
00:03:02.710 --> 00:03:04.450
I like to say the
Lego pieces are all the

50
00:03:04.450 --> 00:03:06.370
right size. I mean, you
did have a compiler to

51
00:03:06.370 --> 00:03:09.270
work from, correct? Yeah. I
had two compilers to work

52
00:03:09.270 --> 00:03:12.420
from. Yeah. This was definitely
a confluence of a lot

53
00:03:12.420 --> 00:03:16.080
of things going on. All
the compilers were open sourced,

54
00:03:16.080 --> 00:03:18.270
I guess I've, Sharp's been
open source for awhile, but

55
00:03:18.630 --> 00:03:22.920
C-sharp was recently open source.
So we we've always had

56
00:03:23.460 --> 00:03:27.000
mano open sourced, but Roslyn
was kind of a pleasure

57
00:03:27.000 --> 00:03:30.270
to work with, especially cause
Rosalyn's written in a very

58
00:03:30.270 --> 00:03:33.690
functional style. And so accessing
it from F sharp was

59
00:03:34.020 --> 00:03:37.110
very nice. But on top
of that, I've worked in

60
00:03:37.110 --> 00:03:40.230
this space for a while
now, I guess I I've

61
00:03:40.230 --> 00:03:44.910
written an IRL to JavaScript
converter I've. As I mentioned,

62
00:03:44.910 --> 00:03:49.250
I wrote this ad in
earlier and years ago, I

63
00:03:49.440 --> 00:03:52.800
kept writing MSI L interpreters.
So I, I had some

64
00:03:52.800 --> 00:03:57.750
experience I've written iPad apps.
I wrote Calco, which was

65
00:03:57.810 --> 00:04:01.920
very similar to an ID,
almost a simplified IDE. So

66
00:04:01.920 --> 00:04:04.230
I had the experience running
into it and I had

67
00:04:04.230 --> 00:04:08.370
all these huge, important, awesome
open source projects available to

68
00:04:08.370 --> 00:04:11.700
me. So it was just
put it all together. Yeah.

69
00:04:12.120 --> 00:04:13.950
When the last time I
had you on, we talked

70
00:04:13.950 --> 00:04:18.270
about Calca, which is basically
like an interactive note pad

71
00:04:18.270 --> 00:04:20.910
where you type in equations
and you type in markdown

72
00:04:20.910 --> 00:04:24.450
and magic happens. It's kind
of like electric paper, math

73
00:04:24.450 --> 00:04:27.900
focused. And the thing that
was exciting about Calca and

74
00:04:27.900 --> 00:04:30.390
what I think was groundbreaking
about it was that it

75
00:04:30.390 --> 00:04:34.200
was kind of the example
for a portable class libraries.

76
00:04:34.200 --> 00:04:37.380
And the more specifically the
example for code reuse, you

77
00:04:37.380 --> 00:04:40.260
know, making is portable code
that you could run, you

78
00:04:40.260 --> 00:04:42.750
know, everywhere. And then you
ended up with a didn't

79
00:04:42.750 --> 00:04:46.440
you do versions for basically
every place Kalka hasn't gotten

80
00:04:46.440 --> 00:04:48.840
quite as far as I
circuit, I circled as the

81
00:04:48.840 --> 00:04:50.910
one that I feel like
I've put on every device

82
00:04:50.910 --> 00:04:54.210
known to man at this
point, but Coca hasn't gotten

83
00:04:54.210 --> 00:04:57.000
quite there. It's mostly, I
keep, always keep running into

84
00:04:57.000 --> 00:05:02.160
this. It's the text editors
on the different platforms. But

85
00:05:03.060 --> 00:05:05.610
yeah, I, I w once
you've learned how to write

86
00:05:05.610 --> 00:05:07.680
an app and are kind
of cross platform style, it's

87
00:05:07.680 --> 00:05:10.530
hard to prevent yourself from
doing that, especially when all

88
00:05:10.530 --> 00:05:13.770
the opportunities are there with
something like.net that runs everywhere.

89
00:05:14.010 --> 00:05:16.590
How can you not architect
your app? And that style

90
00:05:17.400 --> 00:05:20.160
Was Kalka and I circuit
written entirely in C sharp

91
00:05:20.190 --> 00:05:22.740
and Xamarin. Yep. You got
it. All C sharp, a

92
00:05:22.740 --> 00:05:27.000
hundred percent. You went and
rode continuous in F sharp.

93
00:05:27.000 --> 00:05:30.630
Is that right? Yeah. Yeah.
That's right. Yeah. Where do

94
00:05:30.630 --> 00:05:33.300
you even begin with that?
Was that something that you

95
00:05:33.300 --> 00:05:36.570
felt confident about? Like, I
think that I would feel

96
00:05:36.570 --> 00:05:39.540
comfortable goofing around in a
language that is not my

97
00:05:39.540 --> 00:05:41.460
language, but I don't know
if I'd write my flagship

98
00:05:41.460 --> 00:05:47.730
product. Oh, well again, I
got a little bit of

99
00:05:47.730 --> 00:05:51.930
experience before doing this project.
So years ago I got

100
00:05:51.930 --> 00:05:54.270
into F sharp a little
bit heavily. I was really

101
00:05:54.270 --> 00:05:57.530
into functional programming and all
of that, but I kind

102
00:05:57.530 --> 00:06:00.170
of had to drop F
sharp for various reasons. It

103
00:06:00.170 --> 00:06:03.020
just wasn't supported in places
and it didn't run on

104
00:06:03.020 --> 00:06:07.010
iOS when I got into
iOS programming. So I picked

105
00:06:07.010 --> 00:06:11.330
it up for us second
time, seriously, actually learning the

106
00:06:11.330 --> 00:06:14.300
language properly, trying to learn
idiomatic, I've sharp, all that

107
00:06:14.300 --> 00:06:18.530
kind of stuff. And I
started writing iOS apps and,

108
00:06:18.950 --> 00:06:21.140
and at first they were
pretty bad. I mean, I

109
00:06:21.140 --> 00:06:24.890
was still still learning how
to architect the things, but

110
00:06:24.890 --> 00:06:28.250
then I started writing this
three D modeler. And it

111
00:06:28.250 --> 00:06:30.920
was that, that I started
having a few small little

112
00:06:30.920 --> 00:06:34.340
epiphany is about how F
sharp can actually simplify a

113
00:06:34.340 --> 00:06:36.320
lot of things in my
app and actually make it

114
00:06:36.320 --> 00:06:39.950
possible to write large what
I consider large complicated apps

115
00:06:39.950 --> 00:06:42.680
and actually get away with
it in a reasonable amount

116
00:06:42.680 --> 00:06:45.290
of time. And so I
was running kind of app

117
00:06:45.320 --> 00:06:48.830
after app and F sharp
from small to medium size.

118
00:06:49.400 --> 00:06:52.190
And I was able to
take that knowledge when I

119
00:06:52.190 --> 00:06:56.150
started working on this IDE
and at least I had

120
00:06:56.150 --> 00:06:58.730
a starting point. I, yes,
I did have some confidence

121
00:06:58.730 --> 00:07:02.410
going into it that it
was at least possible. Well,

122
00:07:02.470 --> 00:07:05.770
people like me who speak
about functional programming and F

123
00:07:05.770 --> 00:07:10.210
sharp squarely from a place
of ignorance, typically think of

124
00:07:10.210 --> 00:07:13.060
it as something where you
would write the engine, you

125
00:07:13.060 --> 00:07:15.880
know, like some financial services
engine or the thinking part,

126
00:07:15.910 --> 00:07:19.240
everything, but the UI in
the functional bit, you know,

127
00:07:19.240 --> 00:07:21.580
I did Haskell in college
and that's just kind of

128
00:07:21.580 --> 00:07:24.910
like, I would think about
the, the brain being in

129
00:07:24.910 --> 00:07:26.800
the functional programming language. And
then when you came to

130
00:07:26.800 --> 00:07:28.150
do the real work, you
know, we do it in

131
00:07:28.150 --> 00:07:30.730
C sharp, but you've proven
that perhaps to be not

132
00:07:30.730 --> 00:07:33.940
the case with, with continuous.
Yeah. I mean, first I'll

133
00:07:33.940 --> 00:07:36.400
say, I think that's a
very valid approach too. I

134
00:07:36.400 --> 00:07:38.140
mean, the fact of the
matter is all of our

135
00:07:38.140 --> 00:07:42.730
user interface libraries on all
that assume object oriented mutation

136
00:07:42.730 --> 00:07:46.540
based stuff, you know, so
there's a little impedance mismatch

137
00:07:46.540 --> 00:07:50.650
between functional programming and object
running programming when you're programming

138
00:07:51.250 --> 00:07:57.880
gooeys, but let's see where
to begin with this. Well,

139
00:07:58.480 --> 00:08:01.150
yeah, at sharp is great
for engines when I think

140
00:08:01.150 --> 00:08:03.760
of it as great at
is data transformation. So I

141
00:08:03.760 --> 00:08:07.150
have some data, I wrote
a function, outcomes, other data.

142
00:08:07.570 --> 00:08:10.930
And if you want to
think of it differently, I

143
00:08:10.930 --> 00:08:14.500
can move between domain models.
So F sharp and other

144
00:08:14.500 --> 00:08:17.470
functional languages are really good
at modeling data to like

145
00:08:17.500 --> 00:08:20.500
at the schema level and
your function, you can always

146
00:08:20.650 --> 00:08:22.930
think of as taking a
domain and are putting a

147
00:08:22.930 --> 00:08:26.230
range from one type system
to another type system. So

148
00:08:26.230 --> 00:08:30.700
I always think of functional
programming in those terms. And

149
00:08:30.700 --> 00:08:32.590
if you want to think
about a gooey then, well,

150
00:08:32.590 --> 00:08:35.350
a gooey is just more
data. How do you get

151
00:08:35.350 --> 00:08:37.990
data while you just write
a function that transforms from

152
00:08:37.990 --> 00:08:40.570
one data source to another
data source? It just so

153
00:08:40.570 --> 00:08:44.740
happens that last data source
is gooey is a UI

154
00:08:44.740 --> 00:08:50.080
objects. And so there's not
a big mental leap and

155
00:08:50.380 --> 00:08:54.580
going from functional programming to
gooey programming, the devil just

156
00:08:54.580 --> 00:08:57.600
shows up the details. Like
I said, all the libraries

157
00:08:57.600 --> 00:09:01.500
assume object oriented. They don't
like you recreating the gooey

158
00:09:01.500 --> 00:09:04.530
every time data changes, anything
like that. So you have

159
00:09:04.530 --> 00:09:09.750
to come up with solutions
for emulating mutation basically, and

160
00:09:09.750 --> 00:09:13.980
allowing for that impedance mismatch.
But I think as a

161
00:09:13.980 --> 00:09:17.250
community of developers, we're all
kind of figuring that out

162
00:09:17.250 --> 00:09:22.340
lately Do now in F
sharp and in functional languages,

163
00:09:22.370 --> 00:09:25.850
they don't want state held.
They don't want state changed.

164
00:09:26.420 --> 00:09:29.750
Do do you, but when
you're using libraries that expect,

165
00:09:30.080 --> 00:09:32.210
you know, like you said,
mutable things, do you, do

166
00:09:32.210 --> 00:09:35.570
you end up cheating and
then dirtying the whole thing?

167
00:09:35.570 --> 00:09:37.580
Or do you just try
to compartmentalize the yucky bits?

168
00:09:38.060 --> 00:09:40.400
That's exactly what you do.
You try to compartmentalize the

169
00:09:40.400 --> 00:09:43.820
yucky bits and, and to
be clear, state is fine.

170
00:09:44.330 --> 00:09:49.100
Changing state is the problem
well said, well, you know,

171
00:09:49.100 --> 00:09:52.250
state is just data and
data's fine. There isn't, there's

172
00:09:52.250 --> 00:09:58.250
nothing wrong with that. If
you want to, there's multiple

173
00:09:58.250 --> 00:10:00.710
ways to attack this problem.
I just gave a presentation

174
00:10:00.710 --> 00:10:02.810
at a meetup last night,
where I was actually describing

175
00:10:02.810 --> 00:10:07.940
my architecture for solving this
very problem. And someone else

176
00:10:07.940 --> 00:10:10.190
gave a lightning talk just
before it was pretty much

177
00:10:10.280 --> 00:10:13.250
a different solution, but a
perfectly equivalent on one. That's

178
00:10:13.250 --> 00:10:15.830
why I'm hesitating a little
bit, cause there's many ways

179
00:10:15.830 --> 00:10:19.010
to do this, but yeah,
you compartmentalize it. So in

180
00:10:19.010 --> 00:10:21.110
my apps, I ended up
going with a view model

181
00:10:21.110 --> 00:10:25.010
approach. So from my application
data, I just write functions.

182
00:10:25.010 --> 00:10:28.850
My application data is essentially
immutable data. I write functions

183
00:10:28.850 --> 00:10:32.600
that transform that data into
view models. Those themselves are

184
00:10:32.600 --> 00:10:36.590
just immutable objects. They're fine.
View models are great because

185
00:10:36.770 --> 00:10:39.290
they're good for cross platform
and for testability and that

186
00:10:39.290 --> 00:10:42.410
kind of stuff. And then
all I need then is

187
00:10:42.410 --> 00:10:45.560
a binding layer between the
view model and the icky

188
00:10:45.560 --> 00:10:50.180
gooey object oriented objects that
expect state changes. And then

189
00:10:50.180 --> 00:10:53.300
it just becomes an issue
of that simple little binding

190
00:10:53.300 --> 00:10:57.590
later, When you say things
like simple little verse and

191
00:10:57.590 --> 00:11:00.980
simple little that somehow I
suspect that the result perhaps

192
00:11:00.980 --> 00:11:08.750
isn't that simple. Yeah. Okay.
For sure. There are tricks

193
00:11:08.750 --> 00:11:14.060
to be had. Sorry. I'm
thinking through. Oh, that's all

194
00:11:14.060 --> 00:11:16.070
right. We can make it
not simple. How to make

195
00:11:16.070 --> 00:11:19.140
it complicated. Hey, if it's,
if it's simple, like let's

196
00:11:19.140 --> 00:11:21.440
look at it like this
let's let's take, let's take

197
00:11:21.440 --> 00:11:24.380
it back to the basics.
I've got a hello world

198
00:11:24.380 --> 00:11:26.930
and C-sharp, and I throw
it into a text controller

199
00:11:26.960 --> 00:11:29.750
and I make an iPad
app and I've got, now

200
00:11:29.750 --> 00:11:32.750
I've got some C-sharp and
I, I want it to

201
00:11:32.750 --> 00:11:36.170
compile. So I put in
a button and I move

202
00:11:36.170 --> 00:11:38.480
Roslyn over. And does Roslyn
just compile? Does it just

203
00:11:38.480 --> 00:11:40.970
work? Is it ready to
go? Yeah. Roselyn was pretty

204
00:11:40.970 --> 00:11:42.890
close. I did have to
fork it. I did have

205
00:11:42.890 --> 00:11:45.470
to bang out a few
things or a few little

206
00:11:45.470 --> 00:11:48.890
like calm interrupt, you know,
calm. It's still hanging its

207
00:11:48.890 --> 00:11:51.620
head over.net. A few things
had to be torn out

208
00:11:51.620 --> 00:11:55.000
a Roslyn to actually get
it running Xamarin. But that

209
00:11:55.000 --> 00:11:56.980
was just a little bit
of grunt work. That one

210
00:11:56.980 --> 00:11:59.460
wasn't too bad. Is that
scary at all? Like now

211
00:11:59.460 --> 00:12:00.750
you have this fork that
you have to keep up

212
00:12:00.750 --> 00:12:03.780
to date. Totally scary. And
so I w I was

213
00:12:03.780 --> 00:12:07.170
pushing to get up Frank
or something or Great. If

214
00:12:07.170 --> 00:12:11.670
you go to <inaudible> slash
Rosalyn, you'll find it. Yeah.

215
00:12:12.660 --> 00:12:16.710
Yeah. So I I'm pushing
to get that one put

216
00:12:16.710 --> 00:12:19.230
up into master or into
some version so that my

217
00:12:19.230 --> 00:12:21.360
little changes won't be put
in. Unfortunately, there are some

218
00:12:21.360 --> 00:12:24.210
changes that happen have to
happen at Xamarin because they

219
00:12:24.210 --> 00:12:27.420
don't want to change Roslyn
code just because of Samara

220
00:12:27.420 --> 00:12:30.270
and that kind of stuff.
But it's a tiny bit

221
00:12:30.270 --> 00:12:32.250
scary. But at the same
time, Roslyn has lots of

222
00:12:32.250 --> 00:12:36.570
unit tests. It's a pretty
safe. Okay. So the unit

223
00:12:36.570 --> 00:12:39.030
tests and Roslyn make it
less scary. Like I look

224
00:12:39.030 --> 00:12:41.730
here and I see, you
know, this branch is 5,000

225
00:12:41.730 --> 00:12:46.410
commits behind master. Oh God.
But they move the code

226
00:12:46.410 --> 00:12:49.350
so fast. Okay. So that's
not a worry. So then

227
00:12:49.350 --> 00:12:52.260
you have the Roslyn, Roslyn
has some well, you know,

228
00:12:52.260 --> 00:12:55.800
very nice tests. It's a
very well respected code base.

229
00:12:56.220 --> 00:12:59.550
You throw your code that
was in the text box

230
00:12:59.550 --> 00:13:02.190
over at Roslyn and stuff
pops out the other end.

231
00:13:02.520 --> 00:13:07.110
But don't, I remember something
about, you know, iOS, not

232
00:13:07.110 --> 00:13:09.690
allowing jitters and compilers and
exactly what you're trying to

233
00:13:09.690 --> 00:13:14.160
do. Yeah. It's a little
bit of an issue. Yeah.

234
00:13:14.190 --> 00:13:18.600
It totally is. The actual
requirement is a lot more

235
00:13:18.840 --> 00:13:23.730
technical than that. It is
you cannot execute memory. So

236
00:13:23.850 --> 00:13:27.000
that prevents jets, because what
does it do? It allocates

237
00:13:27.000 --> 00:13:30.660
a memory runs a compiler,
emit, some arm code or

238
00:13:30.660 --> 00:13:34.560
some xAd X 86 code
into memory. And then it

239
00:13:34.560 --> 00:13:37.950
tells the CPU go execute
that memory. It's that last

240
00:13:37.950 --> 00:13:40.800
little step that iOS doesn't
allow. You can actually do

241
00:13:40.800 --> 00:13:43.620
everything up till then, but
you can't execute that memory.

242
00:13:44.760 --> 00:13:46.380
So what are you left
with? You have to write

243
00:13:46.380 --> 00:13:50.070
an interpreter. And that's what
I did. I wrote an

244
00:13:50.310 --> 00:13:53.280
I L interpreter for iOS
That's right. I wrote an

245
00:13:53.280 --> 00:13:56.010
IO interpreter. I had a
decision in the beginning. I

246
00:13:56.010 --> 00:13:59.220
could have written a C
sharp interpreter that worked off

247
00:13:59.220 --> 00:14:03.240
of the Roslyn syntax tree.
But in the beginning I

248
00:14:03.240 --> 00:14:04.950
said, I needed to be
true to myself. I can't

249
00:14:04.950 --> 00:14:07.950
write this app and F
sharp and then not support

250
00:14:07.950 --> 00:14:10.680
F sharp in the app.
That just seems ridiculous to

251
00:14:10.680 --> 00:14:13.410
me. And so I took
the slightly harder route of

252
00:14:13.410 --> 00:14:17.130
writing an IOL interpreter instead
of Well, sharp entrepreneur, just

253
00:14:17.130 --> 00:14:22.080
to Smith. I say that
with the, like, with respect

254
00:14:22.080 --> 00:14:24.240
and awe, I want to
make sure you're clear. So

255
00:14:24.480 --> 00:14:28.320
you, you emit this, you
know, Roslyn goes and admits

256
00:14:28.350 --> 00:14:31.560
the assembly, which then sits
in memory somewhere and you

257
00:14:31.560 --> 00:14:34.350
get some array of instructions
and then you interpret over

258
00:14:34.350 --> 00:14:39.060
it. That seems like a
big deal. Was that a

259
00:14:39.060 --> 00:14:41.070
lot of work was that
five of the six months,

260
00:14:41.910 --> 00:14:44.190
No work. And it's continually
going to be a lot

261
00:14:44.190 --> 00:14:47.610
of work. Yeah. I got
the rough demo. That's what

262
00:14:47.610 --> 00:14:49.980
I was talking about happened
about six months ago, it

263
00:14:49.980 --> 00:14:52.490
was, I got the rough
demo of a rough interpret

264
00:14:52.490 --> 00:14:57.800
or working, but it's been
six months of continuously rereading

265
00:14:57.830 --> 00:15:01.580
the IOL spec and trying
to understand all the exact

266
00:15:01.580 --> 00:15:06.710
semantics and getting everything exactly
right. It's an ongoing, painful

267
00:15:06.710 --> 00:15:09.140
little part, but I couldn't
come up with any other

268
00:15:09.140 --> 00:15:13.070
solution for it. And I
figured it's always, it's always

269
00:15:13.070 --> 00:15:15.470
been the problem I've wanted
to write this app or

270
00:15:15.470 --> 00:15:19.010
things similar to it before.
And I just was, this

271
00:15:19.010 --> 00:15:22.250
was always the hurdle to
get over. And so just

272
00:15:22.250 --> 00:15:24.860
one night I decided, well,
if I remove that hurdle,

273
00:15:24.860 --> 00:15:26.600
I have a lot of
opportunities in front of me.

274
00:15:26.660 --> 00:15:28.460
So I'm just going to
sit here and drink diet

275
00:15:28.460 --> 00:15:30.730
Coke until that hurdle It
was gone. And I did

276
00:15:30.730 --> 00:15:34.900
that. So if you have
the pie chart that represents

277
00:15:34.900 --> 00:15:38.560
the work, there is continuous.
How much of that pie

278
00:15:38.560 --> 00:15:43.150
chart is the aisle interpreter
Let's do two pie charts.

279
00:15:43.150 --> 00:15:45.850
One is features. One is
bugs and the bugs column,

280
00:15:45.880 --> 00:15:49.450
it's a hundred percent of
the interpreter. The gooey has

281
00:15:49.450 --> 00:15:51.670
been pretty easy to work
with. The compilers have been

282
00:15:51.670 --> 00:15:54.040
pretty easy to work with.
I mean, dealing with project

283
00:15:54.040 --> 00:15:56.440
systems is always a hairy
mess, but you can get

284
00:15:56.440 --> 00:15:59.860
over that. The entrepreneur has
just been one thing over

285
00:15:59.860 --> 00:16:03.190
another and they are hard
bugs. I just, I keep

286
00:16:03.190 --> 00:16:06.160
screenshots of debugging sessions and
I go back and look

287
00:16:06.160 --> 00:16:08.080
at them and kind of
get sick to my stomach.

288
00:16:08.110 --> 00:16:09.880
Looking at all this stuff
you had to Wade through,

289
00:16:10.180 --> 00:16:13.570
because basically you have to
write a tracing interpreter, watch

290
00:16:13.600 --> 00:16:16.900
every aisle instruction, see what
all the state, every IO

291
00:16:16.900 --> 00:16:21.370
instruction is changing and slowly
learn that and figure out

292
00:16:21.370 --> 00:16:25.660
all the bugs. Interesting. Is
there a product there as

293
00:16:25.660 --> 00:16:29.110
well? I actually did break
it out into its own

294
00:16:29.110 --> 00:16:32.410
library. I was thinking about
open sourcing. I'm still debating

295
00:16:32.410 --> 00:16:36.430
on that side. It's a
funny interpreter. A lot of

296
00:16:36.430 --> 00:16:38.830
the bugs come from the
fact that I don't actually

297
00:16:38.830 --> 00:16:43.000
want to run everything interpreted
because I knew well, for

298
00:16:43.000 --> 00:16:45.250
one, it's just going to
be slow. I knew this

299
00:16:45.250 --> 00:16:49.390
interpreter was going to be
slow. And so the interpreter,

300
00:16:49.420 --> 00:16:53.500
every opportunity it can, it
tries to go to reflection.

301
00:16:53.980 --> 00:16:58.090
And that means execute things
through reflection because they're compiled

302
00:16:58.090 --> 00:17:01.690
and compiled all the way
down to native arm code.

303
00:17:01.690 --> 00:17:05.440
It's very fast And that's
allowed why, because that's what

304
00:17:05.440 --> 00:17:08.710
your app is. Okay. When
I write a Xamarin app,

305
00:17:08.800 --> 00:17:12.820
it has to compile all
of my I L and

306
00:17:12.820 --> 00:17:16.750
two arm code. And that
means every well, they have

307
00:17:16.750 --> 00:17:20.590
a linker, but essentially every
ms. Correlate function, every library

308
00:17:20.590 --> 00:17:25.870
function turns into a arm
native function. That's the beauty

309
00:17:25.870 --> 00:17:30.400
of Xamarin is it's real
fast executable code. And so

310
00:17:30.400 --> 00:17:33.940
my app, it's constantly trying
to bridge over to that

311
00:17:33.940 --> 00:17:37.000
code to get out of
the interpreted land and into

312
00:17:37.000 --> 00:17:40.750
the fastest, My end. I
see. Yeah. And so most

313
00:17:40.750 --> 00:17:43.420
of the bugs, pretty much
all the limitations happen at

314
00:17:43.420 --> 00:17:45.850
that bridge point of me
trying to get over into

315
00:17:45.850 --> 00:17:49.740
the reflection land, but it's
an important one. All my

316
00:17:49.740 --> 00:17:52.320
performance comes from that. If
I was to run everything

317
00:17:52.320 --> 00:17:55.920
interpreted well, I don't think
people would enjoy the app

318
00:17:56.010 --> 00:17:59.160
as it stands right now.
Yeah. Yeah. One of the

319
00:17:59.160 --> 00:18:01.640
other things that's really impressive
about it and like surprisingly

320
00:18:01.640 --> 00:18:06.020
impressive is the, the course
syntax highlighting, which hard, but

321
00:18:06.110 --> 00:18:10.220
you know, not like the
world's hardest problem part, but,

322
00:18:10.220 --> 00:18:14.660
but IntelliSense of a sword
is that Roslyn that's giving

323
00:18:14.660 --> 00:18:17.030
you that information. You've kind
of built an Omni sharp

324
00:18:17.030 --> 00:18:20.570
for iPad. Yeah. Basically. And
as kicking myself a little

325
00:18:20.570 --> 00:18:24.170
bit, because I saw a
Omni sharp released like job

326
00:18:24.590 --> 00:18:28.310
Jason RPC protocol lately, too.
I was kind of kicking

327
00:18:28.310 --> 00:18:34.400
myself for not implementing that
protocol, but yeah, Roselyn does

328
00:18:34.400 --> 00:18:36.260
a bit of the work
it does about, I would

329
00:18:36.260 --> 00:18:41.540
say half of the work
Microsoft doesn't include one function

330
00:18:41.540 --> 00:18:43.370
that I could call and
it would give me back

331
00:18:43.370 --> 00:18:47.720
like visual studio, quality code
completion. So a lot of

332
00:18:47.720 --> 00:18:50.480
that, I have to hammer
together myself. They gave me

333
00:18:50.480 --> 00:18:53.300
all the query functions, but
I actually have to put

334
00:18:53.300 --> 00:18:56.030
together that list and match
it up the way I

335
00:18:56.030 --> 00:18:59.090
want to match it up,
which is a bit of

336
00:18:59.090 --> 00:19:01.130
work, but that's actually the
kind of the fun work

337
00:19:02.210 --> 00:19:05.030
I want to make even
better improvements there. But it's

338
00:19:05.030 --> 00:19:07.670
fun. I was running a
scripts on my computer that

339
00:19:07.670 --> 00:19:10.400
would build hits to grounds
of all the identifiers and

340
00:19:10.400 --> 00:19:12.770
all the keywords and all
the operators use throughout all

341
00:19:12.770 --> 00:19:15.080
my code on my computers.
And I was trying to

342
00:19:15.080 --> 00:19:18.800
figure out ways to make
that just better, just the

343
00:19:18.800 --> 00:19:21.860
smoother typing experience. And so
I can kind of nerd

344
00:19:21.860 --> 00:19:23.720
out on that side and
I, I actually kind of

345
00:19:23.720 --> 00:19:27.110
really enjoy it. And then
I have to write it

346
00:19:27.110 --> 00:19:29.390
twice. I have to write
it for F sharp also.

347
00:19:29.930 --> 00:19:32.840
And the sharp side is
a little bit trickier to

348
00:19:33.770 --> 00:19:36.380
Roslyn helps out quite a
bit. So when you make

349
00:19:36.380 --> 00:19:40.550
a new project on this
thing on continuous, is it,

350
00:19:40.550 --> 00:19:42.500
is it a CS proj?
I noticed that some of

351
00:19:42.500 --> 00:19:46.250
the extensions are CSX. Is
that not C-sharp? I mean,

352
00:19:46.460 --> 00:19:48.740
give me a sense of
how much is this Frank

353
00:19:48.740 --> 00:19:52.460
world versus how this is
classic done a development? Well,

354
00:19:52.460 --> 00:19:55.460
it's CSX files. Let's address
us first. I think these,

355
00:19:55.700 --> 00:19:59.390
this is a standard because
visual studio code supports it.

356
00:20:00.890 --> 00:20:04.550
I think the newest visual
studio does also Xamarin studio

357
00:20:04.550 --> 00:20:08.420
does not, but it's just
a C-sharp script file. So

358
00:20:08.720 --> 00:20:11.030
than pretty neat because it
has two modes. It has

359
00:20:11.030 --> 00:20:13.970
regular C-sharp mode. And now
it has this new, all

360
00:20:13.970 --> 00:20:16.790
C sharp has a scripting
mode also, which allows you

361
00:20:16.790 --> 00:20:20.960
to create a global variables
put statements right. At the

362
00:20:20.990 --> 00:20:25.580
root level script stuff, basically.
Right, Right. Yeah. He has

363
00:20:25.580 --> 00:20:29.120
X files. They were added
in Roslyn in 2011. Wow.

364
00:20:29.150 --> 00:20:32.120
And what's neat about them
as you can put, what

365
00:20:32.120 --> 00:20:38.870
is it pers hashtag R
for the reference inline, the

366
00:20:38.870 --> 00:20:42.020
reference rather than saying dash
are on the command line,

367
00:20:42.020 --> 00:20:45.590
which doesn't exist in your
world. Right. And a little

368
00:20:45.590 --> 00:20:48.250
sad thing there for continuous.
It has a limited set

369
00:20:48.250 --> 00:20:50.590
of libraries. I didn't, I
didn't fully pack it with

370
00:20:50.590 --> 00:20:52.750
everything. It has all of
ms. Score live all of

371
00:20:52.750 --> 00:20:54.940
Samara and all that stuff,
but there's a lot of

372
00:20:54.940 --> 00:20:57.210
new gets I want to
get on there also. Okay.

373
00:20:57.210 --> 00:20:59.070
That's a great question. So
if I go, you know,

374
00:20:59.280 --> 00:21:03.840
pound signed are Newton, soft
dot Jason, right? Does that?

375
00:21:04.080 --> 00:21:05.310
There's no new, good. I'm
not going to get it

376
00:21:05.310 --> 00:21:08.400
to I'm out of luck
because A few fun limitations

377
00:21:08.430 --> 00:21:10.770
in there right now, these
are on the documentation of

378
00:21:10.770 --> 00:21:12.540
the website. If you go
to the bottom of it,

379
00:21:13.620 --> 00:21:18.420
the big ones are reflection.
Basically doesn't work. And that's

380
00:21:18.420 --> 00:21:21.030
just a limitation of my
interpreter, the way I decided

381
00:21:21.030 --> 00:21:23.130
for the interpreter to work,
I can get it to

382
00:21:23.130 --> 00:21:25.110
work in some scenarios, but
I couldn't get it to

383
00:21:25.110 --> 00:21:28.380
work 100%. So I'm just
saying there's a limitation, reflection,

384
00:21:28.380 --> 00:21:31.230
doesn't work. And unfortunately that
affects a lot of great

385
00:21:31.230 --> 00:21:36.690
libraries like Jason, jason.net. I
think the best use of

386
00:21:36.690 --> 00:21:39.960
it. If it's a reflection
stuff, can it never work?

387
00:21:41.040 --> 00:21:43.440
It can work. I just
have to bang my head

388
00:21:43.440 --> 00:21:45.810
a little bit and maybe
get me gal on the

389
00:21:45.810 --> 00:21:48.600
phone and bug him a
little better. Some of the

390
00:21:48.600 --> 00:21:52.500
other Xamarin and figure out
something, Hopefully they'll hook you

391
00:21:52.500 --> 00:21:56.250
up. I'm sure that they
will. They will. I just,

392
00:21:56.250 --> 00:21:58.320
as a small matter of
pride, I tried to do

393
00:21:58.320 --> 00:22:00.450
this without asking too many
questions. I was trying to

394
00:22:00.450 --> 00:22:03.030
figure everything out, but I'm
at the point now where

395
00:22:03.650 --> 00:22:06.960
I'm humble enough to start
begging for some more knowledge.

396
00:22:07.500 --> 00:22:09.720
I think it's a pretty
impressive accomplishment as it is.

397
00:22:09.720 --> 00:22:12.060
So yes, I think it's
okay to ask questions. I

398
00:22:12.060 --> 00:22:14.850
can ask now. Okay. It's
okay to ask. We all

399
00:22:14.850 --> 00:22:17.250
appreciate you. And we want
you to ask, okay, now

400
00:22:17.280 --> 00:22:20.640
let's, let's ask the trolling
questions because you've, you've had

401
00:22:20.640 --> 00:22:24.030
500 plus retweets at the
time of this recording. It's

402
00:22:24.030 --> 00:22:27.030
going to be thousands. By
the time anyone listens to

403
00:22:27.030 --> 00:22:31.440
this, I tweeted it 500
retweets. There is a hunger

404
00:22:31.440 --> 00:22:35.910
for this kind of thing.
So we have seen a,

405
00:22:36.150 --> 00:22:38.250
what would you want this
on a tablet? How dumb

406
00:22:38.250 --> 00:22:41.820
is this? Are you really,
is this a toy or

407
00:22:41.820 --> 00:22:44.790
are you doing real work
on your iPad? No, this

408
00:22:44.790 --> 00:22:47.310
is in fact I've been
stopping myself by putting the

409
00:22:47.310 --> 00:22:50.850
word professional everywhere because that's
my whole point here is

410
00:22:50.850 --> 00:22:54.960
I actually want something I
can use. Does that mean

411
00:22:54.960 --> 00:22:57.030
I'm going to switch a
hundred percent of my development

412
00:22:57.060 --> 00:23:03.090
over to the iPad? No,
for a various reasons. One

413
00:23:03.090 --> 00:23:05.280
being, I have a 30
inch monitor that I adore,

414
00:23:09.540 --> 00:23:12.360
but that said, I want
this. I want to be

415
00:23:12.360 --> 00:23:15.150
able to load a real
project and it, and work

416
00:23:15.210 --> 00:23:19.200
on sub parts of that
project within it. Namely user

417
00:23:19.200 --> 00:23:25.740
interfaces controls, basically the object
oriented type stuff. On top

418
00:23:25.740 --> 00:23:31.740
of that, it's just a
better experience for writing interactive

419
00:23:31.830 --> 00:23:34.620
apps. I said, in my
blog entry, I get really

420
00:23:34.620 --> 00:23:38.820
tired of the waiting during
compile and deployment phase of

421
00:23:38.820 --> 00:23:41.640
development. And I get really
impatient and I start checking

422
00:23:41.640 --> 00:23:44.460
Twitter and all that kind
of stuff. And so I've

423
00:23:44.460 --> 00:23:49.160
just found having live objects
right next to the code

424
00:23:49.160 --> 00:23:53.780
has just really changed. I
write better controls now, basically

425
00:23:54.170 --> 00:23:57.650
because I actually spend time
fine tuning them, trying out

426
00:23:57.650 --> 00:24:00.230
different ways of attacking them,
playing with them, you know,

427
00:24:00.230 --> 00:24:05.180
different interactions. So my response
is I am building this

428
00:24:05.180 --> 00:24:09.050
specifically to aid myself in
my professional career. So if

429
00:24:09.080 --> 00:24:12.800
other people can't find that
a use for it, sorry,

430
00:24:12.830 --> 00:24:17.620
but definitely going for pro
on this. So this is

431
00:24:17.680 --> 00:24:19.660
a, and we, we, maybe
we should, we should push

432
00:24:19.660 --> 00:24:21.250
on this a little bit.
Maybe we, maybe I failed

433
00:24:21.250 --> 00:24:25.120
to the app is called
continuous because even though there's

434
00:24:25.120 --> 00:24:28.360
a, you know, an arrow
button, a play button it's

435
00:24:28.360 --> 00:24:31.330
compiling and running your code
as you're typing it, like

436
00:24:31.330 --> 00:24:34.990
it's, you are, you're in
a running more than a

437
00:24:34.990 --> 00:24:38.980
ripple. Yeah. All the time.
Yeah. I want to, I'm

438
00:24:38.980 --> 00:24:40.930
always trying to improve upon
the rep. Oh, I love

439
00:24:40.930 --> 00:24:43.510
the rappel. It's very cool.
You type in some code,

440
00:24:43.510 --> 00:24:46.090
you get an answer back.
But my problem with it

441
00:24:46.090 --> 00:24:48.280
has always been that it
never worked with what I

442
00:24:48.280 --> 00:24:51.460
call Breo code. Whereas in
C sharp, we don't really

443
00:24:51.460 --> 00:24:55.090
write scripts. We write declarations,
we declare a class and

444
00:24:55.090 --> 00:24:58.060
we declare methods on it.
We declare fields. We don't

445
00:24:58.060 --> 00:25:01.810
really declare objects though. That
stuff happens procedurally and methods

446
00:25:01.810 --> 00:25:05.260
and all that kind of
stuff. So I decided that

447
00:25:07.330 --> 00:25:09.160
the rappel just doesn't work
for me. So I need

448
00:25:09.170 --> 00:25:11.500
a different kind of solution.
And I came up with

449
00:25:11.500 --> 00:25:13.900
this idea of, well, I'll
just let people new up

450
00:25:13.930 --> 00:25:16.000
any object that they want.
And I'll just keep that

451
00:25:16.000 --> 00:25:18.640
object running. What the heck,
what could go wrong with

452
00:25:18.640 --> 00:25:22.780
that? And so anytime you're
in the app, you can

453
00:25:22.780 --> 00:25:25.390
find a class new up
that class and just start

454
00:25:25.390 --> 00:25:28.870
inspecting it as if you
are always debugging. So I

455
00:25:28.870 --> 00:25:31.780
guess it's always, it's almost
like continuous debugging instead of

456
00:25:31.780 --> 00:25:35.530
continuously building. And that's why
I call that inspector window,

457
00:25:35.530 --> 00:25:37.330
the watch window. Cause I
figured, well, it's like a

458
00:25:37.330 --> 00:25:41.620
debugging context. You're just going
to be inspecting objects. If

459
00:25:41.620 --> 00:25:47.620
I find typing, does it
start compiling after I like,

460
00:25:47.660 --> 00:25:51.550
like, you know, X milliseconds
after the up I stopped

461
00:25:51.550 --> 00:25:54.400
typing or is it okay,
Second right now I play

462
00:25:54.400 --> 00:25:56.140
with that number, but it's
a third year Type type

463
00:25:56.140 --> 00:25:58.660
type. You do your thing.
And then you wait for

464
00:25:58.660 --> 00:26:01.270
a third of the second
or you breathe and then

465
00:26:01.270 --> 00:26:04.630
it's running again. Okay. It
compiles first of course it

466
00:26:04.630 --> 00:26:08.490
has to compile that that's
pretty fast because Rosalyn's already

467
00:26:08.500 --> 00:26:11.410
did it. Roslyn's all fast
and ready to go. So

468
00:26:11.410 --> 00:26:13.120
I have to spit out
an assembly and then I

469
00:26:13.120 --> 00:26:16.150
have to pass that assembly
over to the interpreter, load

470
00:26:16.150 --> 00:26:19.330
up all of its references,
find a good entry points

471
00:26:19.330 --> 00:26:21.520
to it. That's what the
watch window does. It's, you're

472
00:26:21.520 --> 00:26:25.750
actually picking entry points into
that assembly and then just

473
00:26:25.750 --> 00:26:30.040
start executing that code. Yeah.
But it feels continuous. Like,

474
00:26:30.070 --> 00:26:33.790
you know, if there's multiple
pages on a complicated application,

475
00:26:34.120 --> 00:26:35.860
you know, you, you go
and hit F five and

476
00:26:35.860 --> 00:26:37.660
you compile and then you
have to go and get

477
00:26:37.660 --> 00:26:41.050
back to that state. Is
this something where you want

478
00:26:41.050 --> 00:26:44.130
to set up your application?
So that the thing you're

479
00:26:44.130 --> 00:26:47.690
working on is the, the
screen at hand. Yeah. And

480
00:26:48.350 --> 00:26:50.330
that's kind of the focus
of the app is you're

481
00:26:50.330 --> 00:26:53.780
usually working at our class
or an object at a

482
00:26:53.780 --> 00:26:57.050
hand at a time. So
that could be an iOS

483
00:26:57.050 --> 00:26:59.360
world. That could be your
route view controller that contains

484
00:26:59.360 --> 00:27:02.450
all the other views of
your entire app. Or if

485
00:27:02.450 --> 00:27:05.090
I'm working on a specific
user control, say like a

486
00:27:05.090 --> 00:27:07.250
dial where I have to
spin my finger around to

487
00:27:07.250 --> 00:27:09.950
change the numbers or something
like that, I'll just have

488
00:27:09.950 --> 00:27:12.890
the class that represents that
view up in the editor.

489
00:27:13.220 --> 00:27:14.870
I can go over to
the watch window, tell it

490
00:27:14.870 --> 00:27:17.420
to knew what one of
these dials and I can

491
00:27:17.420 --> 00:27:19.490
just interact with it and
play with it while I'm

492
00:27:19.490 --> 00:27:23.330
coding. And that was the,
that was kind of the

493
00:27:23.330 --> 00:27:25.430
realization I had when I
wrote the add in for

494
00:27:25.430 --> 00:27:28.670
Xamarin studio was the style
of programming of just picking

495
00:27:28.670 --> 00:27:30.800
a class and working with
that class one at a

496
00:27:30.800 --> 00:27:33.800
time, it seems a little
bit constraining at first, but

497
00:27:33.830 --> 00:27:38.690
it's very surprising how easy
it actually makes coning. So

498
00:27:38.690 --> 00:27:41.000
if I were doing something
that wasn't, you know, a

499
00:27:41.000 --> 00:27:45.260
game or a physics demo,
it would be, let's say

500
00:27:45.260 --> 00:27:49.040
a master detail pages, then
I would make it so

501
00:27:49.040 --> 00:27:51.500
that like, if I was
working on the details page,

502
00:27:51.530 --> 00:27:53.630
I would set, set it.
So that was the default

503
00:27:53.630 --> 00:27:57.590
startup. And then I would
have constant, ongoing feedback as

504
00:27:57.590 --> 00:27:59.600
I work on details. And
then when I came time

505
00:27:59.600 --> 00:28:02.360
to work on the list,
I would change my application.

506
00:28:02.360 --> 00:28:04.310
So that, that was running
all the time. Yeah. That

507
00:28:04.310 --> 00:28:06.350
that's pretty much it, but
you're not really, you don't

508
00:28:06.350 --> 00:28:08.210
even have to pick a
startup object. You just kind

509
00:28:08.210 --> 00:28:11.180
of navigate through the watch
window. You're just navigating an

510
00:28:11.180 --> 00:28:14.480
object graph. And so yeah,
you just kind of navigate

511
00:28:14.480 --> 00:28:17.270
around, find the object object
that you want and do

512
00:28:17.270 --> 00:28:20.750
that focusing on that. And
if you need context, if

513
00:28:20.750 --> 00:28:22.680
you need other classes around,
then you find a more

514
00:28:22.680 --> 00:28:25.890
apparent object that contains that
one or a component has

515
00:28:25.910 --> 00:28:28.520
that, something like that. And
then How do I get

516
00:28:28.520 --> 00:28:30.500
the file off though? How
do I get the file

517
00:28:30.500 --> 00:28:32.450
off the iPad? The kind
of the writing of the

518
00:28:32.450 --> 00:28:35.690
file system has always been
difficult There, unfortunately, a tiny

519
00:28:35.690 --> 00:28:37.850
bit of limitation of the
V one. I wanted to

520
00:28:37.850 --> 00:28:39.980
have better support for all
of this, but right now

521
00:28:39.980 --> 00:28:43.220
you just have the standard
iOS share sheet, which interacts

522
00:28:43.220 --> 00:28:46.640
with all the other apps
on your, on your iPad.

523
00:28:46.910 --> 00:28:50.240
So if you have a,
get a good client app,

524
00:28:50.270 --> 00:28:52.520
you'll be able to send
files over to that app.

525
00:28:52.550 --> 00:28:55.580
Or if you have Dropbox
on your iPad, then you

526
00:28:55.580 --> 00:28:58.670
can send the files over
to that. I do hope

527
00:28:58.670 --> 00:29:01.430
to be able to put
in native, get support and

528
00:29:01.940 --> 00:29:04.670
iCloud drive, but guy called
drive. I'm not too excited

529
00:29:04.670 --> 00:29:07.190
about, but I would like
some native get support. There's

530
00:29:07.190 --> 00:29:09.770
a little disagreement in the
Apple community about whether that's

531
00:29:09.770 --> 00:29:13.130
actually allowed in a program
like this. Apple has a

532
00:29:13.130 --> 00:29:17.930
little clause saying something about
downloading executable code and it

533
00:29:17.930 --> 00:29:21.080
gets very lawyery about what's
executable code and what's not,

534
00:29:21.080 --> 00:29:25.070
but Like his source code
executable code. Okay. Right. And

535
00:29:25.070 --> 00:29:27.050
I'm not a lawyer and
I get nervous about that

536
00:29:27.050 --> 00:29:29.690
kind of stuff. But I
personally, I want some good

537
00:29:29.720 --> 00:29:33.560
integration in there. Well, in
Calca you had all sorts

538
00:29:33.560 --> 00:29:36.920
of like, you implemented your
own file, save dialogues, basically

539
00:29:36.920 --> 00:29:41.090
in support for iCloud and
drop. Oh, wait. So much

540
00:29:42.100 --> 00:29:44.350
talk about talking about pie
charts. I feel like half

541
00:29:44.350 --> 00:29:48.240
of my time is spent
on file management UI Because

542
00:29:48.240 --> 00:29:51.090
there is no file management
UI. Oh God. I wish

543
00:29:51.090 --> 00:29:53.640
I would build that in.
Yeah. Well then it would

544
00:29:53.640 --> 00:29:55.350
be a laptop and that
would be, I can't go

545
00:29:55.350 --> 00:29:58.230
there. I guess. How much
of your time are you

546
00:29:58.230 --> 00:30:01.530
spending using it now? Like
how much, like you've got

547
00:30:01.530 --> 00:30:03.570
the iPad pro, which is
quite a bit larger than

548
00:30:03.570 --> 00:30:06.900
the iPad and I assume
you have an external Bluetooth

549
00:30:06.930 --> 00:30:10.950
keyboard. Yeah. I use Apple's
a keyboard cover. I think

550
00:30:10.950 --> 00:30:13.830
they call it. Oh, okay.
Oh, the keyboard cover that

551
00:30:13.830 --> 00:30:17.160
came with the iPad pro.
Okay. And you added some

552
00:30:17.160 --> 00:30:20.940
extra buttons for the keyboard
to get to things that

553
00:30:20.940 --> 00:30:23.400
are hard to get to
symbols and things. How much

554
00:30:23.400 --> 00:30:26.460
of your time are you
spending working on continuous? Well,

555
00:30:26.460 --> 00:30:30.240
running continuous. So I, I
actually use it in two

556
00:30:30.240 --> 00:30:34.740
different scenarios. One is late
at night, I'm watching TV

557
00:30:34.740 --> 00:30:36.960
and I just have some
stupid programming idea that I

558
00:30:36.960 --> 00:30:39.900
want to whip out. So
it definitely works as the

559
00:30:39.900 --> 00:30:43.320
casual iPad on the couch
scenario. So that that's all

560
00:30:43.320 --> 00:30:47.280
fine. But the other scenario
is when I'm in the

561
00:30:47.280 --> 00:30:50.370
office, I shouldn't say this,
but I, I have a,

562
00:30:50.450 --> 00:30:53.580
I have a secret advanced
version. That's actually able to

563
00:30:53.580 --> 00:30:56.550
talk to Xamarin studio and
things like that. So I

564
00:30:56.550 --> 00:30:59.100
can actually ship code around
pretty quickly between the app

565
00:30:59.100 --> 00:31:02.280
and that. And so I'll
do that during the day

566
00:31:02.280 --> 00:31:06.690
sometimes. And then otherwise it's
basically the one with me

567
00:31:06.690 --> 00:31:09.210
when I'm at home and
at my apartment when I'm

568
00:31:09.210 --> 00:31:11.550
away from my 30 inch
monitor is basically when I

569
00:31:11.550 --> 00:31:15.750
use the app. Cool. And
so, so far it's been

570
00:31:15.750 --> 00:31:19.170
11 hours since you launched,
as of the time of

571
00:31:19.170 --> 00:31:22.770
this, of this recording. This
show will probably come out

572
00:31:22.770 --> 00:31:24.450
in a couple of weeks
from when we're recording right

573
00:31:24.450 --> 00:31:27.840
now. But what has been
the feedback so far Then

574
00:31:27.840 --> 00:31:30.420
super positive, which has been
a huge relief for me.

575
00:31:30.450 --> 00:31:33.510
Well, it's been numerous and
positive, which is an even

576
00:31:33.510 --> 00:31:38.520
bigger relief. I wasn't sure.
I always tell people, you

577
00:31:38.520 --> 00:31:42.200
hate your app just before
you release it. And I

578
00:31:42.240 --> 00:31:44.430
didn't hate this app before
I released. I actually really

579
00:31:44.430 --> 00:31:46.710
liked it, but I went
through multiple hate this app

580
00:31:46.710 --> 00:31:50.910
cycles throughout its development. So
it's been an up and

581
00:31:50.910 --> 00:31:53.250
down journey. I ended on
a high note and so

582
00:31:53.250 --> 00:31:56.850
it was good to see
everyone reacting very positively to

583
00:31:56.850 --> 00:32:00.960
it. I always get worried
cause I mean, the app

584
00:32:00.990 --> 00:32:04.380
is best experienced actually using
it. And it's hard to

585
00:32:04.380 --> 00:32:07.140
capture that and screenshots, I
tried to put a lot

586
00:32:07.140 --> 00:32:09.660
of Jeff's up and things
like that, but I was

587
00:32:09.660 --> 00:32:12.180
still worried that everyone would
say, Oh, it's just, why

588
00:32:12.180 --> 00:32:14.340
would I want a program
on my iPad? You know,

589
00:32:14.340 --> 00:32:18.150
that classic thing. But it
seems like most people are

590
00:32:18.150 --> 00:32:22.560
able to, I don't know,
imagine, I guess how, how

591
00:32:22.560 --> 00:32:25.110
awesome this could be. Well,
it's one of those things

592
00:32:25.110 --> 00:32:29.250
where people say, what problem
does this solve? And the

593
00:32:29.250 --> 00:32:31.230
answer is, well it's, if
you have that problem, it

594
00:32:31.230 --> 00:32:33.630
solves that problem for you.
And if you don't, well

595
00:32:33.630 --> 00:32:36.480
then maybe this isn't for
you. Yeah. Or just give

596
00:32:36.480 --> 00:32:39.410
it a shot and you
might discover something new. Yeah,

597
00:32:39.410 --> 00:32:42.800
yeah, yeah. It is interesting
to see that, that the

598
00:32:42.800 --> 00:32:46.010
issues with Apple development in
iOS development, for people who

599
00:32:46.010 --> 00:32:50.000
are maybe aren't familiar are
virtually never technical issues. It's

600
00:32:50.000 --> 00:32:54.020
always digging around in the
iOS developer program, license agreement,

601
00:32:54.830 --> 00:32:56.960
you know, I'm like, Oh,
I want to do this.

602
00:32:56.960 --> 00:33:00.170
That'll be great. Oh yeah.
Well section 3.3 0.2, you

603
00:33:00.170 --> 00:33:05.870
know, explicitly allows that or
whatever. Yeah. And it gets

604
00:33:05.870 --> 00:33:08.450
worse than that. Sometimes just
getting the app approved. I

605
00:33:08.450 --> 00:33:11.000
remember Calco went through like
a two month or three

606
00:33:11.000 --> 00:33:14.180
month approval process. It was
terrible the last time through.

607
00:33:14.720 --> 00:33:16.940
And I was getting really
stressed out by that. I

608
00:33:16.940 --> 00:33:19.130
mean, in contrast, this thing
was approved in a day

609
00:33:19.130 --> 00:33:22.200
and a half, so it's
a little bit random or

610
00:33:22.200 --> 00:33:25.250
a biobank has, Apple's been
making improvements. There is that

611
00:33:25.250 --> 00:33:28.730
one of those things where
they like, do they scan

612
00:33:28.730 --> 00:33:31.160
it or are they paying
attention and, or they're not

613
00:33:31.160 --> 00:33:33.800
paying attention? Like could, could
you theoretically get an app

614
00:33:33.830 --> 00:33:37.820
in with some feature and
then discover that, Oh gosh,

615
00:33:37.850 --> 00:33:39.260
you know, we didn't mean
to really let you in

616
00:33:39.260 --> 00:33:40.670
with that. And then we're
going to rank you after

617
00:33:40.670 --> 00:33:42.950
the fact. I mean the,
the one feature that I

618
00:33:42.950 --> 00:33:45.950
would absolutely love is the
ability to run Git code,

619
00:33:45.950 --> 00:33:49.580
to be able to execute
memory. And that is an

620
00:33:49.610 --> 00:33:53.330
operating system and forced the
limitation. So there's no chance

621
00:33:53.330 --> 00:33:55.790
I would ever, even if
I wrote the code to

622
00:33:55.790 --> 00:33:58.460
make that happen, the app
would just crashed the moment

623
00:33:58.460 --> 00:34:01.070
and tried to do that.
So that would never get

624
00:34:01.070 --> 00:34:03.920
through. And the rest of
Apple's rules I can just

625
00:34:03.920 --> 00:34:06.500
deal with. So they're not
really a concern of mine.

626
00:34:07.970 --> 00:34:10.520
I see. So it really,
that part of it is

627
00:34:11.390 --> 00:34:13.670
the technical stuff. But for
the most part, it's just,

628
00:34:13.700 --> 00:34:16.220
you know, Apple. Well, fortunately,
I've been doing this for

629
00:34:16.220 --> 00:34:18.350
a few years now, so
you kind of learn what's

630
00:34:18.350 --> 00:34:21.410
allowed and what's not allowed.
It's, it's just always in

631
00:34:21.410 --> 00:34:23.720
the back of your head.
So even when I'm planning

632
00:34:23.720 --> 00:34:26.750
an app, I'm always thinking
about the rules and I

633
00:34:26.750 --> 00:34:28.850
won't even start an app
until I'm pretty sure it's

634
00:34:28.850 --> 00:34:31.490
going to pass all the
rules. It's not worth working

635
00:34:31.490 --> 00:34:35.770
on otherwise. Yeah. Well, this
is a really exciting application.

636
00:34:35.800 --> 00:34:36.980
I think it is going
to, Oh, you know, there

637
00:34:36.980 --> 00:34:41.660
are other, you know, IDs
and pseudo IDs in the,

638
00:34:41.660 --> 00:34:43.850
out there on the world,
but this is the first

639
00:34:43.850 --> 00:34:45.920
one that really feels like
it's more than just web

640
00:34:45.920 --> 00:34:49.310
pages. You know, it feels
like something, something significant. Thank

641
00:34:49.310 --> 00:34:50.840
you. Thank you. I put
a lot of time into

642
00:34:50.840 --> 00:34:52.550
it. I spent a lot
of time in front of

643
00:34:52.550 --> 00:34:55.010
a profiler trying to make
sure it was always fast,

644
00:34:55.300 --> 00:34:59.720
always running very quickly. So
I'm really excited that it's

645
00:34:59.720 --> 00:35:03.140
out there. Basically. This is
great. And we can get

646
00:35:03.140 --> 00:35:05.840
this at, you had a
cool URL. It was conditioned

647
00:35:05.850 --> 00:35:13.010
continuous.codes. You got it. continuous.codes.
C yeah. That's a great

648
00:35:13.040 --> 00:35:17.690
TLD. They're great top level.
So folks can check it

649
00:35:17.690 --> 00:35:21.920
out. It's continuous mobile development
environment. It's professional C sharp

650
00:35:21.920 --> 00:35:26.690
and F sharp IDE for
the freaking iPad. continuous.coach. Thanks

651
00:35:26.690 --> 00:35:29.390
so much Frank Kruger for
chatting with me today. Thank

652
00:35:29.390 --> 00:35:31.880
you Scott, for having me.
I really appreciate it. My

653
00:35:31.880 --> 00:35:34.820
pleasure. This has been another
episode of Hanselminutes and we'll

654
00:35:34.820 --> 00:35:36.050
see you again next week.


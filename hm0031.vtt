WEBVTT FILE

1
00:00:12.090 --> 00:00:17.100
From Hansel minutes.com. It's Hanselman.
It's a weekly discussion with

2
00:00:17.100 --> 00:00:22.440
web developer and technologists. Scott
Hanselman hosted by Carl Franklin. This

3
00:00:22.440 --> 00:00:29.280
is Lawrence Ryan announcing show number
31 recorded Monday, August 28th, 2006 sport

4
00:00:29.280 --> 00:00:32.490
for Hanselman it's just provided
by COVID Smith tools, makers

5
00:00:32.520 --> 00:00:36.270
of code Smith and extensible
template based code generator for.net

6
00:00:37.290 --> 00:00:39.750
Hansel minutes, listeners get a
hundred dollars off coach Smith

7
00:00:39.750 --> 00:00:46.770
professional with coupon code H
M 100. online@covidsmithtools.com. Support is

8
00:00:46.770 --> 00:00:51.030
also provided by dotnet developers
journal. The world's leading dotnet

9
00:00:51.030 --> 00:00:57.630
developer magazine online at www
dot <inaudible> dot com. In

10
00:00:57.630 --> 00:01:04.530
this episode, Scott discusses test
driven development. Hi, this is

11
00:01:04.530 --> 00:01:07.560
Carl Franklin and you're listening to
Hansel minutes. I'm here with

12
00:01:07.560 --> 00:01:10.350
Scott once again. Hi Scott,
how are you, sir? I'm

13
00:01:10.350 --> 00:01:15.180
fine. So we got some
email addressing our dynamic languages

14
00:01:16.200 --> 00:01:19.050
show. Yeah, we got a
lot of email about it

15
00:01:19.050 --> 00:01:22.290
actually. And we got some,
some good, some kind of

16
00:01:22.290 --> 00:01:25.740
good, some mediocre. I think
a lot of people took,

17
00:01:27.540 --> 00:01:31.440
took, took us to task
or took umbrage at some

18
00:01:31.440 --> 00:01:34.290
of the assumptions that we
were making about when you

19
00:01:34.290 --> 00:01:37.020
move from a compiler based
model to a test based

20
00:01:37.020 --> 00:01:40.860
model that, you know, before
the compile did a lot

21
00:01:40.860 --> 00:01:43.140
of checking for you. And
now I'm saying that the

22
00:01:43.470 --> 00:01:46.170
testing does a lot of
checking for you, but the

23
00:01:46.170 --> 00:01:50.550
argument that test driven development
saves you lines of code

24
00:01:51.120 --> 00:01:52.380
is kind of a, I
guess it's kind of a

25
00:01:52.380 --> 00:01:55.560
specious argument, I think was
the, yeah, I think that's

26
00:01:55.800 --> 00:01:58.260
the gist of it. Yeah.
And then I think that

27
00:01:58.260 --> 00:02:00.270
you made a really good
point that many people called

28
00:02:00.270 --> 00:02:02.820
out, which was that having
lots and lots of unit

29
00:02:02.820 --> 00:02:05.130
tests and having good tests.
Coverage is a very different

30
00:02:05.130 --> 00:02:10.380
thing from test driven development,
formally test first methodology. Our,

31
00:02:11.010 --> 00:02:14.790
one of our writers who
was email was dead. David Leon,

32
00:02:15.120 --> 00:02:18.030
who thought that if he's
got to go and write

33
00:02:18.030 --> 00:02:21.810
a 168 water tests just
to validate something, then you

34
00:02:21.810 --> 00:02:24.510
know, is that really a
beneficial thing? And I think

35
00:02:24.510 --> 00:02:27.810
he was basically calling me
out on test driven development,

36
00:02:27.990 --> 00:02:31.170
as it relates to dynamic
languages is they're really totally

37
00:02:31.170 --> 00:02:34.710
separate things. I was basically
saying that there's a certain

38
00:02:34.710 --> 00:02:38.190
freedom that a, a dynamic
language offers you, but that

39
00:02:38.190 --> 00:02:40.380
is a totally separate thing
from doing test driven development.

40
00:02:40.380 --> 00:02:42.330
So I figured let's just
do a show on TDD

41
00:02:42.660 --> 00:02:46.280
and, and talk about it.
Okay. So, so right. The,

42
00:02:46.280 --> 00:02:50.070
the general idea of, of
test driven development, like the,

43
00:02:50.070 --> 00:02:54.450
the, the man mantra is
write a test that fails.

44
00:02:54.510 --> 00:02:57.150
So like step one, write
a test and cause it

45
00:02:57.150 --> 00:03:00.490
to fail. Usually it will
fail the stuff that you're

46
00:03:00.490 --> 00:03:02.290
trying to test doesn't exist
yet. You haven't written the

47
00:03:02.290 --> 00:03:06.280
code yet. Right? Exactly. Number
two is fixed the code.

48
00:03:06.520 --> 00:03:09.010
So then you can pass
the test and then number

49
00:03:09.010 --> 00:03:11.080
three, which is often forgotten,
but it's really kind of

50
00:03:11.080 --> 00:03:14.470
the whole point of test
driven development specifically, which is

51
00:03:14.470 --> 00:03:18.580
refactor the code, you know,
refactor, ruthlessly is what people

52
00:03:18.580 --> 00:03:21.520
like to say. Right. And
then step four, rinse repeat,

53
00:03:22.180 --> 00:03:24.790
right? Yeah. So yes, it's
true test driven development. Isn't

54
00:03:24.790 --> 00:03:27.340
necessarily allowing you to write
less code, although from a

55
00:03:27.340 --> 00:03:30.310
design perspective, it can, when,
when you are sitting down

56
00:03:30.400 --> 00:03:35.410
writing code test first, and
this is Greenfield's fresh stuff,

57
00:03:35.410 --> 00:03:38.920
right? When you're writing from
scratch, really test driven development

58
00:03:38.920 --> 00:03:41.560
is allowing you to become
your own client, right? You

59
00:03:41.560 --> 00:03:43.360
are the client of the
code. You're you get to

60
00:03:43.360 --> 00:03:46.150
sit down and say in
a perfect world. If I

61
00:03:46.150 --> 00:03:48.610
were to write this framework,
how would it behave from

62
00:03:48.610 --> 00:03:52.810
the outside? Scott, Scott bellwether
has a really great essay

63
00:03:52.810 --> 00:03:56.770
that we'll post up about
this called write naive tests.

64
00:03:57.400 --> 00:03:59.950
Basically say, this is how
it ought to work, become

65
00:03:59.950 --> 00:04:03.490
your own client. It's a
tiny URL slash H B

66
00:04:03.660 --> 00:04:08.100
Three CDW. And we're reasonably
Using tiny URL today's cause

67
00:04:08.100 --> 00:04:12.930
shrinks or.com Effectively down. Yeah.
Some of that's disappeared, but

68
00:04:12.930 --> 00:04:14.190
we're going to hook up
with that guy and try

69
00:04:14.200 --> 00:04:16.770
to find his database and
getting back up. Right. We'll

70
00:04:16.770 --> 00:04:18.720
figure that out. All of
these links will be up

71
00:04:18.720 --> 00:04:20.550
on the site. So you'll
be able to reference these

72
00:04:20.550 --> 00:04:23.400
at the show site or
at my blog. Okay. So

73
00:04:23.670 --> 00:04:27.420
test driven development at the
pure, the purest sense is

74
00:04:27.540 --> 00:04:31.200
become your own client. Okay.
But remember, step one, write

75
00:04:31.200 --> 00:04:33.690
a test that fails. Step
two, fix the code. Step

76
00:04:33.690 --> 00:04:36.900
three, refactor. One of the
benefits really kind of the

77
00:04:37.200 --> 00:04:40.290
primary benefit of test driven
development is that it lets

78
00:04:40.290 --> 00:04:43.890
you refactor very freely, right?
It gives you a formal

79
00:04:43.890 --> 00:04:46.530
suite of tests that are
lying out there that you

80
00:04:46.530 --> 00:04:49.200
can, you can run against
your code whenever you want.

81
00:04:49.530 --> 00:04:52.290
Now test driven development doesn't
necessarily mean you have to

82
00:04:52.290 --> 00:04:54.990
have a unit testing framework,
right? It doesn't mean you

83
00:04:54.990 --> 00:04:56.700
have to use an unit
or you have to use

84
00:04:57.000 --> 00:05:00.300
team system test. And certainly
in the, in the eighties,

85
00:05:00.300 --> 00:05:03.090
when people were writing test
code in C plus, plus

86
00:05:03.120 --> 00:05:05.010
they were just writing little
test programs or they'd write

87
00:05:05.010 --> 00:05:08.340
their own testing library. They
didn't have a formalized method

88
00:05:08.340 --> 00:05:10.800
early, early on until things
like calm unit and some

89
00:05:10.800 --> 00:05:12.570
of the early, even before
that, the earliest C plus

90
00:05:12.570 --> 00:05:15.300
plus unit testing stuff came
out, but it lets you

91
00:05:15.300 --> 00:05:18.240
refactor freely. And this is
what, what Fowler was talking

92
00:05:18.240 --> 00:05:22.410
about when he wrote in
refactoring. And that's it refactoring.com

93
00:05:22.920 --> 00:05:28.320
is that if you've got
this, this, this netting, that's

94
00:05:28.320 --> 00:05:30.600
protecting you, right? If you
can, you can, you can

95
00:05:30.600 --> 00:05:33.300
climb up the mountain and
do something crazy and someone

96
00:05:33.300 --> 00:05:35.670
will catch you when you
fall. It is those tests

97
00:05:35.700 --> 00:05:39.000
that will catch you. So
it is the ability to

98
00:05:39.180 --> 00:05:42.690
refactor ruthlessly. There's a person
who's got a great essay

99
00:05:42.690 --> 00:05:45.900
on test driven development, where
they say refactor without fear

100
00:05:45.930 --> 00:05:49.770
and a refactor ruthlessly. This
is at a we'll post

101
00:05:49.770 --> 00:05:52.890
this up there. This is
a poor VA. Murata hada

102
00:05:52.950 --> 00:05:56.670
has an essay on test
driven development That said JP

103
00:05:56.670 --> 00:06:03.730
B and refactor ruthlessly, is
it <inaudible>. And this, this

104
00:06:03.730 --> 00:06:07.030
individual says that the coding
cycle is red, green refactor.

105
00:06:07.060 --> 00:06:10.720
That's a really great way
to remember the, the rules

106
00:06:10.720 --> 00:06:13.600
of, of, of test driven
development. So it's really that

107
00:06:13.600 --> 00:06:16.030
ability. So that's the first
benefit that ability to refactor

108
00:06:16.030 --> 00:06:19.360
freely and rip the guts
out of stuff. We recently

109
00:06:19.360 --> 00:06:23.380
refactored some stuff. Patrick Caldwell, my
buddy at work ripped the

110
00:06:23.380 --> 00:06:25.330
complete guts out of a
chunk of code that we

111
00:06:25.330 --> 00:06:29.200
had, but we had 150,
160 unit tests backing that

112
00:06:29.200 --> 00:06:32.140
up. And they were almost,
they were almost a specification,

113
00:06:32.230 --> 00:06:36.570
right? This, these unit tests
read like specification code, right?

114
00:06:36.570 --> 00:06:38.380
So we were able to
yank out the middle part

115
00:06:38.380 --> 00:06:41.740
of that service and replace
it with a much faster

116
00:06:41.740 --> 00:06:47.110
implementation. And the, the test
where our guide, the thing

117
00:06:47.110 --> 00:06:48.970
that was significant is that
when we, when, when the

118
00:06:48.970 --> 00:06:52.930
tests passed, we knew we
were done. Right, right. So

119
00:06:52.930 --> 00:06:54.400
this is one of the
things that the test driven

120
00:06:54.550 --> 00:06:58.630
purists will say, is that
right? The simplest possible code

121
00:06:59.140 --> 00:07:02.080
to let the test pass.
Yeah. Right. And then when

122
00:07:02.080 --> 00:07:04.660
the test passes, you're done,
if you don't feel done,

123
00:07:04.660 --> 00:07:07.210
you know, that there's more
work to be done than

124
00:07:07.330 --> 00:07:10.780
write another test, as opposed
to expand on the code

125
00:07:11.200 --> 00:07:14.320
and the design folks who
say that test driven development

126
00:07:14.320 --> 00:07:17.110
improves your design. It makes
it more, more flexible. It

127
00:07:17.110 --> 00:07:19.510
makes it more extensible. It
makes it easier to maintain.

128
00:07:19.690 --> 00:07:21.670
These are the people who
are refactoring while they're writing

129
00:07:21.670 --> 00:07:25.210
their code, because you shouldn't
be refactoring unless there's something

130
00:07:25.210 --> 00:07:28.600
about the test or something
about that, about a test

131
00:07:28.630 --> 00:07:31.090
that uncovers an aspect of
the design that says, Oh,

132
00:07:31.090 --> 00:07:34.750
this really, this test just
pushed the, just the specification,

133
00:07:34.750 --> 00:07:37.270
just push the application into
a new world, into a

134
00:07:37.270 --> 00:07:40.540
new location. Oh, I see
an opportunity now to refactor.

135
00:07:40.810 --> 00:07:42.880
I will refactor and I'll
see if all my tests

136
00:07:42.880 --> 00:07:46.670
still pass. So like we
did point out before, but

137
00:07:46.670 --> 00:07:50.110
I, I didn't say where
they explicitly asked him, you

138
00:07:50.110 --> 00:07:53.050
sometimes will write a lot
more code in your tests

139
00:07:53.500 --> 00:07:56.590
then in your, then in
your actual code, you'll spend

140
00:07:56.590 --> 00:08:00.250
more time writing tests. Whether
people feel that that is

141
00:08:00.260 --> 00:08:02.500
a good thing or a
bad thing. Some people say

142
00:08:02.500 --> 00:08:05.140
that that's silly, right? Because
when we were talking about

143
00:08:05.140 --> 00:08:07.750
dynamic languages last week, we
were saying that in the

144
00:08:07.750 --> 00:08:10.060
application that my 16 year
old intern wrote, he ended

145
00:08:10.060 --> 00:08:11.950
up writing more code in
the tests than he did

146
00:08:11.950 --> 00:08:14.710
in the code itself. Right.
Number of people said, well,

147
00:08:14.710 --> 00:08:18.940
that's not exactly a step
forward. It really depends. It

148
00:08:18.940 --> 00:08:21.760
depends on how complicated the
application is. Depends on what

149
00:08:21.760 --> 00:08:24.370
the application is meant to
be. I mean, how many

150
00:08:24.370 --> 00:08:26.320
times have you written an
application that you're going to

151
00:08:26.320 --> 00:08:29.350
run once, you know, to
convert some data or doing

152
00:08:29.410 --> 00:08:32.320
some, some other kind of
thing? Oh wow. Absolutely. And

153
00:08:32.320 --> 00:08:34.150
that's, and that might not
be an application you want

154
00:08:34.150 --> 00:08:36.670
to apply test driven development
to at all, but an

155
00:08:36.670 --> 00:08:38.500
application where there's a lot
of, you know, maybe a

156
00:08:38.500 --> 00:08:40.810
small app, but there's a
lot of potential unknown input

157
00:08:41.110 --> 00:08:43.360
or an application that needs
to be very secure. You

158
00:08:43.360 --> 00:08:46.060
want to use a lot
of negative unit tests, really

159
00:08:46.060 --> 00:08:48.700
beat on the thing and
see if it'll stop. The

160
00:08:48.700 --> 00:08:51.610
other thing is that when,
when you're done is really

161
00:08:51.610 --> 00:08:54.850
up to you, some people
use test coverage, right? The,

162
00:08:54.880 --> 00:08:58.620
the of code paths that
have been covered as a,

163
00:08:59.460 --> 00:09:02.820
an, an I'm done metric
they'll use tools like end

164
00:09:02.820 --> 00:09:07.500
cover@endcover.org and the end cover
Explorer. And sometimes they'll tie

165
00:09:07.500 --> 00:09:09.960
all of that stuff together
with things like test-driven dot

166
00:09:09.960 --> 00:09:14.100
net, Jamie candidate test driven.net,
which is at www dot

167
00:09:14.130 --> 00:09:18.600
test-driven dot net. Those tools
will allow you to right

168
00:09:18.600 --> 00:09:21.750
click and visual studio and
say, run tests or right.

169
00:09:21.750 --> 00:09:25.680
Click and say, test with
coverage. And there's one individual

170
00:09:25.680 --> 00:09:28.050
at my work who just
refuses to check anything out.

171
00:09:28.740 --> 00:09:31.680
She me refuses to check
anything in rather to source

172
00:09:31.680 --> 00:09:34.320
control, unless it has a
hundred percent coverage. Now that's

173
00:09:34.320 --> 00:09:37.410
not necessarily reasonable for every
application, but some people say,

174
00:09:37.410 --> 00:09:40.110
you know, if you can
get a 50, 60, 70%

175
00:09:40.110 --> 00:09:43.290
of your code covered, that
means that after every single

176
00:09:43.290 --> 00:09:47.490
build, that chunk of code
is running and arguably, if

177
00:09:47.490 --> 00:09:51.690
you do test driven development
and the test really wags

178
00:09:51.690 --> 00:09:54.930
the code, you won't write
any code that isn't run

179
00:09:54.930 --> 00:09:57.690
by a test because the
tests are driving the code.

180
00:09:57.720 --> 00:09:59.400
So it is possible to
get that kind of, that

181
00:09:59.400 --> 00:10:02.990
kind of test coverage. Do
you use Refactor from developer

182
00:10:02.990 --> 00:10:06.850
express or ReSharper, or, or
both what's your take on

183
00:10:06.860 --> 00:10:10.940
it? I, I really love
refactor from dev express in

184
00:10:10.940 --> 00:10:13.820
particular, I love the kind
of graphical tools that show

185
00:10:13.820 --> 00:10:17.090
you things like psychosomatic complexity
and, and the sort of

186
00:10:17.090 --> 00:10:19.340
the arrows and things that
Mark draws all over the

187
00:10:19.340 --> 00:10:22.250
screen. Yeah. The, the stuff
going on in code rush

188
00:10:22.250 --> 00:10:25.130
and refactor from dev express
is really great at knowing

189
00:10:25.340 --> 00:10:28.220
is this code too complicated?
Yeah. There's a lot of

190
00:10:28.220 --> 00:10:30.710
really cool templates. There's a
where you can actually say

191
00:10:30.710 --> 00:10:33.350
like TF and it'll build
a whole test framework for

192
00:10:33.350 --> 00:10:36.590
you And intelligence, you know,
he's trying to read your

193
00:10:36.590 --> 00:10:40.190
mind basically, and it does
a pretty good job. Totally.

194
00:10:40.370 --> 00:10:43.940
Yeah. Now the jet brains,
the guys that make ReSharper

195
00:10:44.300 --> 00:10:47.810
have a similar, a similar
tool, not exactly like code

196
00:10:47.810 --> 00:10:51.110
rush, but similar, but that
also has a code rush

197
00:10:51.140 --> 00:10:54.050
beat when it comes to
analysis of code kind of

198
00:10:54.050 --> 00:10:56.960
real time compilation and analysis
of code, but they also

199
00:10:56.960 --> 00:10:59.990
have a built in test
runner of their own that

200
00:10:59.990 --> 00:11:03.560
will run unit tests that
you have within your project

201
00:11:03.560 --> 00:11:05.870
that are built in either
end unit or in an

202
00:11:05.870 --> 00:11:10.610
alternative and unit testing framework
called CS unit. And that

203
00:11:10.640 --> 00:11:13.580
is integrated within visual studio
for those of us who

204
00:11:13.580 --> 00:11:19.370
aren't using test team system
tester. And it also allows

205
00:11:19.400 --> 00:11:22.700
inline profiling. So you can
actually click on a test,

206
00:11:23.450 --> 00:11:26.540
say, run this task, debug
this test, or profile it,

207
00:11:26.900 --> 00:11:30.080
using the JetBrains dot trace
profiler. And that's a sweet

208
00:11:30.140 --> 00:11:34.280
profile if you've ever used
dot trace fantastic stuff, which

209
00:11:34.280 --> 00:11:37.580
is interesting. If you think
about profiling, a test remembering

210
00:11:37.580 --> 00:11:39.500
that the test is a
client of the code that

211
00:11:39.500 --> 00:11:42.680
you're actually writing, the code
that you're writing in the

212
00:11:42.680 --> 00:11:46.490
om is being, being wagged
right at the incident wag,

213
00:11:46.490 --> 00:11:48.320
the dog kind of essentially
are the tests that you're

214
00:11:48.320 --> 00:11:50.510
writing. So then why not
use it as an opportunity

215
00:11:50.510 --> 00:11:52.760
to profile sections of the
code that you know, are

216
00:11:52.760 --> 00:11:56.910
going to be really slow.
And I like to, to

217
00:11:56.920 --> 00:11:59.110
look at alternative frameworks because
a lot of people think,

218
00:11:59.110 --> 00:12:02.290
well, it's either a team
system or it's an unit,

219
00:12:02.830 --> 00:12:05.140
but there was also a
for awhile, a kind of

220
00:12:05.140 --> 00:12:08.800
an upstart. It was called
M B unit written by

221
00:12:08.800 --> 00:12:12.280
a guy named Pelley who
had an original article up

222
00:12:12.280 --> 00:12:15.070
on code project. We have
the tiny role for that.

223
00:12:15.630 --> 00:12:19.770
Any URL, six 16 O
w O Z. That's not

224
00:12:19.770 --> 00:12:23.700
zero one six O w
L And Pelly wrote an

225
00:12:23.700 --> 00:12:27.480
article on code project.com about
this potential unit testing framework

226
00:12:27.480 --> 00:12:30.810
that then turned into M
unit it's. I'm not quite

227
00:12:30.810 --> 00:12:32.370
sure I'd like to get
an email from them to

228
00:12:32.370 --> 00:12:35.130
find out if it's abandoned,
where or not. But one

229
00:12:35.130 --> 00:12:37.050
of the things that M
B unit did that end

230
00:12:37.050 --> 00:12:40.980
unit does not, is the
ability to say via attributes,

231
00:12:41.100 --> 00:12:44.490
run this test 10 times,
or do a data-driven test

232
00:12:44.490 --> 00:12:46.800
by pulling data in, from
somewhere, and then do a

233
00:12:46.800 --> 00:12:51.080
unit test. You know, not,
not everything exists in an

234
00:12:51.080 --> 00:12:53.700
unit. There's a lot of
timing and it really precise

235
00:12:54.030 --> 00:12:57.480
performance, counter type timing and
things like CS unit. But

236
00:12:57.510 --> 00:13:00.060
one of the things that's
nice is test-driven dot net

237
00:13:01.020 --> 00:13:05.400
ReSharper will run those kinds
of tests as is. So

238
00:13:05.400 --> 00:13:08.310
you could potentially mix and
match your unit testing frameworks.

239
00:13:08.850 --> 00:13:11.010
There's no reason that you
have to use all of

240
00:13:11.010 --> 00:13:14.910
one unit testing framework, if
another meets your needs. Now,

241
00:13:15.240 --> 00:13:17.790
typically we talk about test
driven development within the context

242
00:13:17.790 --> 00:13:20.400
of Greenfield. You sit down
and you go file new

243
00:13:20.400 --> 00:13:23.040
and you start out from
fresh, but, but not everybody

244
00:13:23.040 --> 00:13:25.080
necessarily has the chance to
do that. Sometimes you need

245
00:13:25.080 --> 00:13:28.830
to write unit tests for
existing code code that may

246
00:13:28.830 --> 00:13:32.700
not be particularly pretty. Now
there's a gentleman named Jay

247
00:13:32.700 --> 00:13:36.660
flowers who has a thing
called J flowers doubler. And

248
00:13:36.660 --> 00:13:39.930
this is a little confusing
I found, but basically it's

249
00:13:39.930 --> 00:13:44.190
a plugin to Lutz, rotors,
reflector, and doubler is a

250
00:13:44.190 --> 00:13:48.030
code generator that lets you
work with legacy code. And

251
00:13:48.030 --> 00:13:52.860
it lets you create a
basically stubs and rappers and

252
00:13:52.890 --> 00:13:56.670
fake objects around existing code.
Cause sometimes you can't test

253
00:13:56.670 --> 00:13:58.230
a chunk of code if
it has a huge number

254
00:13:58.230 --> 00:14:00.990
of dependencies, right? So you
can, you can kind of

255
00:14:01.320 --> 00:14:05.010
break code apart. You can
say, this is a great

256
00:14:05.010 --> 00:14:07.110
type, but I need to
mirror that type with an

257
00:14:07.110 --> 00:14:10.500
interface over here and then
run generators, run, run code

258
00:14:10.500 --> 00:14:14.250
on that. Then, then you
get into mock objects. I

259
00:14:14.250 --> 00:14:15.960
think we'll do a whole,
Yeah, we should. We could

260
00:14:15.960 --> 00:14:19.050
probably do a whole show
on that. Yeah. And actually,

261
00:14:19.050 --> 00:14:20.970
you know, speaking of people
who know a lot about

262
00:14:20.970 --> 00:14:25.200
mock objects, Roy <inaudible> has
started writing a book On

263
00:14:25.200 --> 00:14:28.170
the art of unit testing.
Wow. And he's got a

264
00:14:28.170 --> 00:14:30.510
separate RSS feed for this
book. Then he's going to

265
00:14:30.510 --> 00:14:33.960
be updating that feed as
he goes through his, the

266
00:14:33.960 --> 00:14:36.660
book writing process. And it's,
it's sure to be a

267
00:14:36.660 --> 00:14:38.550
great book. You've got the
Earl for that. Yeah. That's

268
00:14:38.550 --> 00:14:44.880
tiny URL slash GB nine
five two. Cool. Yeah. Roy

269
00:14:44.910 --> 00:14:47.490
is a, is an agile
practitioner and definitely someone who

270
00:14:47.490 --> 00:14:50.310
knows the difference between a
test driven development and then

271
00:14:50.310 --> 00:14:54.680
just writing a bunch tests.
And now as far as

272
00:14:54.680 --> 00:14:57.020
do I do, I do
test driven development. I have

273
00:14:57.020 --> 00:14:59.840
in the past, I've sat
down from scratch and started

274
00:14:59.840 --> 00:15:01.600
out where I wrote the
test first. And I, and

275
00:15:01.600 --> 00:15:04.280
I'd have to say that
the code did end up

276
00:15:04.280 --> 00:15:07.280
simpler, but let me tell
you, it's hard. It takes,

277
00:15:07.550 --> 00:15:10.910
thought to sit down and
force yourself to do that

278
00:15:11.210 --> 00:15:13.340
because you just want to
go running when you get

279
00:15:13.340 --> 00:15:16.490
into the code code. And
then next thing you know,

280
00:15:16.490 --> 00:15:17.990
you've written a chunk of
code that you have no

281
00:15:17.990 --> 00:15:21.670
tests for. And writing tests
is tedious, frankly, I'm just

282
00:15:21.670 --> 00:15:25.510
saying Coding practices goes against
one of the main reasons

283
00:15:25.510 --> 00:15:27.940
why, you know, we got
into this business in the

284
00:15:27.940 --> 00:15:31.300
first place, which is, you
know, to create quickly. I

285
00:15:31.300 --> 00:15:34.270
mean, we, you know, there's
a certain satisfaction that comes

286
00:15:34.270 --> 00:15:39.400
with, you know, getting your
thoughts into electronic form as

287
00:15:39.400 --> 00:15:43.690
quick as possible, and actually
seeing it run Definitely. But

288
00:15:43.690 --> 00:15:46.300
at the same time, there's
a different feeling. And it's

289
00:15:46.300 --> 00:15:48.670
hard to explain until you
have several hundred or a

290
00:15:48.670 --> 00:15:51.040
thousand unit tests, but there's
a different feeling when you

291
00:15:51.040 --> 00:15:54.310
have a crap load of
unit tests and someone comes

292
00:15:54.310 --> 00:15:55.810
and says, you know, I
think it's a problem in

293
00:15:55.810 --> 00:15:57.730
this section of the code.
And you say, you know,

294
00:15:58.150 --> 00:16:01.240
I'm pretty confident that it's
not, and here's, here's why,

295
00:16:01.600 --> 00:16:04.330
or if someone finds a
bug and you do the

296
00:16:04.330 --> 00:16:07.870
right thing, fix the bug,
write a test to confirm

297
00:16:07.870 --> 00:16:11.290
that you fix the bug.
And then later on, when

298
00:16:11.290 --> 00:16:14.470
you add new features, you
can actually run regression tests

299
00:16:14.470 --> 00:16:16.810
to find out if you
broke the fix to that

300
00:16:16.810 --> 00:16:21.340
bug. I talked before about
a gentleman who had built

301
00:16:21.340 --> 00:16:24.190
in a he'd shipped an
unit with his code. He

302
00:16:24.190 --> 00:16:27.220
has a WinForms application, right?
And the help about you

303
00:16:27.220 --> 00:16:29.440
would actually go run tests.
So if you ended up

304
00:16:29.470 --> 00:16:31.750
calling him for support, he
would say, well, go to

305
00:16:31.750 --> 00:16:33.490
help about and hit run
tests. And he would actually

306
00:16:33.490 --> 00:16:35.350
run the test locally. I
thought that was such a

307
00:16:35.350 --> 00:16:38.860
creative way to really leverage
that code and also find

308
00:16:38.860 --> 00:16:40.930
out whether it was running
different on his machine versus

309
00:16:40.930 --> 00:16:45.400
on the remote. Very cool.
Very, very cool. Totally. Now

310
00:16:46.090 --> 00:16:49.930
test driven, developed development is
starting to have some people

311
00:16:49.960 --> 00:16:51.670
kind of spin off and
say, well, we want you

312
00:16:51.670 --> 00:16:56.620
to do business driven development
or specification, Even development, domain

313
00:16:56.620 --> 00:16:59.290
driven kind of thing. Well,
domain-driven is a little bit

314
00:16:59.290 --> 00:17:00.850
different. We'll talk about that
in a second. That's a

315
00:17:00.850 --> 00:17:04.660
good point, but specification driven
development, they want it to

316
00:17:04.660 --> 00:17:07.900
have a more businesslike language.
So there's a, a project

317
00:17:07.900 --> 00:17:10.840
called N spec, which is
kind of business driven or

318
00:17:10.840 --> 00:17:16.840
what they call behavior driven
development, where it's mostly changing

319
00:17:16.870 --> 00:17:19.840
of the naming of things
like in test driven development,

320
00:17:19.840 --> 00:17:23.230
you Mark something as a
test and you make assertions

321
00:17:23.770 --> 00:17:27.520
with within spec, you would
Mark something as a specification

322
00:17:28.330 --> 00:17:32.050
and you would say things
like specify that this should

323
00:17:32.050 --> 00:17:36.610
equal that or specify that
this object should not be

324
00:17:36.610 --> 00:17:39.010
the same as this object
or that this object should

325
00:17:39.010 --> 00:17:43.480
throw an exception. You know,
it seems kind of weird

326
00:17:43.480 --> 00:17:46.450
to me because all they
really done is change the

327
00:17:46.450 --> 00:17:49.530
terminology. But there's a number
of people who are interested

328
00:17:49.530 --> 00:17:52.020
in this, in this way
of thinking of making the

329
00:17:52.020 --> 00:17:55.740
spec not be a word
document, not be some texts

330
00:17:55.740 --> 00:17:57.900
we talked before about the
notion of a word document,

331
00:17:57.900 --> 00:18:01.950
having no teeth. Yeah. We're
documents, don't break, break builds,

332
00:18:02.520 --> 00:18:05.850
but it seems to me
that a specification description language,

333
00:18:05.970 --> 00:18:08.670
if it happens to be
written in the language that

334
00:18:09.780 --> 00:18:11.910
you're writing your code in,
in this case in C

335
00:18:11.910 --> 00:18:16.830
sharp.net, if a business person
can't really express it, then

336
00:18:16.890 --> 00:18:20.930
it provides minimal benefit. Unless
there's a tool that can

337
00:18:20.930 --> 00:18:24.230
sort of translate between the
two worlds, Right? So then

338
00:18:24.230 --> 00:18:27.950
you go into to generating
your, your unit tests Well,

339
00:18:27.950 --> 00:18:31.400
or generating your spec from
your unit tests. The other

340
00:18:31.400 --> 00:18:34.430
way around, There are some
that think that business, people

341
00:18:34.430 --> 00:18:38.120
should write the test themselves.
And ward Cunningham has this

342
00:18:38.120 --> 00:18:41.990
notion of fit. We've heard
of fit framework for integrated

343
00:18:41.990 --> 00:18:46.700
tests. This is basically a
way to write a test

344
00:18:47.060 --> 00:18:52.340
in HTML, right? So ward
and a, and Jim Shaw

345
00:18:52.340 --> 00:18:54.980
and a bunch of people
who work on this basically,

346
00:18:55.100 --> 00:18:58.550
would you go into word,
you write out your specification

347
00:18:59.660 --> 00:19:03.410
in prose and in HTML
tables you put in, you

348
00:19:03.410 --> 00:19:06.920
know, here's some input, here's
an expected output. And, and

349
00:19:06.920 --> 00:19:09.440
then you would actually have
a test runner that would

350
00:19:09.650 --> 00:19:12.680
look at that word document,
which has now been saved

351
00:19:12.680 --> 00:19:16.160
as HTML. Here's the trick,
right? Looks at that HTML

352
00:19:16.160 --> 00:19:19.100
document looks at the inputs
and the outputs, and this

353
00:19:19.100 --> 00:19:22.250
might be written by a
business person and then run

354
00:19:22.260 --> 00:19:26.330
some, some code harnesses that
you've written yourself and plugs

355
00:19:26.330 --> 00:19:29.390
in those values and sees
if they match what the

356
00:19:29.390 --> 00:19:32.600
spec says. Yeah, well, there's
like a little red flag

357
00:19:32.630 --> 00:19:35.300
going off in my head
like that possibly can't be

358
00:19:35.930 --> 00:19:39.050
expressive enough. Well, you know,
and it really kind of

359
00:19:39.050 --> 00:19:42.500
depends. It depends on if
your application is, has clear

360
00:19:42.500 --> 00:19:45.500
boundaries about inputs and outputs.
Maybe if you're doing financial

361
00:19:45.500 --> 00:19:48.920
calculations or if you're doing
an application that's filling out

362
00:19:48.920 --> 00:19:52.520
alone for people, it just
depends on the number of

363
00:19:52.520 --> 00:19:56.660
inputs. If an application is
a very interactive yeah. Then

364
00:19:56.660 --> 00:19:58.940
you might want to look
at Ruby or some different

365
00:19:58.940 --> 00:20:01.400
web automation tools. Right. Cause
it seems, I mean, as

366
00:20:01.400 --> 00:20:04.670
you get down into the
bowels of an application, you

367
00:20:04.670 --> 00:20:08.030
know, you're talking about things
that, you know, you're using

368
00:20:08.030 --> 00:20:10.970
entities that are just beyond
the understanding of, of a

369
00:20:10.970 --> 00:20:13.490
business person, you know? So
that's a very good point.

370
00:20:14.210 --> 00:20:15.980
That's a view. Yeah. You
bring up a fantastic point

371
00:20:15.980 --> 00:20:17.720
because here's the question then?
Where do you draw the

372
00:20:17.720 --> 00:20:19.880
line of business person know
about this component? Right? So

373
00:20:19.880 --> 00:20:24.200
then there's the difference between
functional testing, right? And unit

374
00:20:24.200 --> 00:20:26.870
testing, like a developer might
still do unit testing and

375
00:20:26.870 --> 00:20:29.510
end unit or something like
that. But the whole service

376
00:20:29.510 --> 00:20:32.690
oriented architecture point of view
is really another person could

377
00:20:32.690 --> 00:20:36.180
call it boundary based programming,
right? Cause all the services

378
00:20:36.180 --> 00:20:40.010
is a component with a
very clear boundary and you

379
00:20:40.010 --> 00:20:42.920
could design a service such
that it would be reasonable

380
00:20:42.920 --> 00:20:45.560
for a business person to,
to describe that. Because if

381
00:20:45.560 --> 00:20:48.910
the business person understands that
a workflow exists a certain

382
00:20:48.910 --> 00:20:53.890
way, there's customer objects and
there's there's invoice objects and

383
00:20:53.890 --> 00:20:56.860
vendors. And when a person
does this, a vendor should

384
00:20:56.860 --> 00:21:01.060
do that, it would, it
could very conceivably be reasonable

385
00:21:01.060 --> 00:21:06.280
for the, the business person
to describe interactions between these

386
00:21:06.340 --> 00:21:09.700
higher level services as they
understand them as business people.

387
00:21:10.510 --> 00:21:13.660
So they're almost writing kind
of an orchestration. Yeah. It's

388
00:21:13.660 --> 00:21:15.350
a really kind of depends,
but you know, fit is,

389
00:21:15.350 --> 00:21:20.170
is an interesting way. I
mean, thinking about HTML tables

390
00:21:20.170 --> 00:21:23.260
as orchestration or as programming,
I mean, fit can be

391
00:21:23.260 --> 00:21:27.700
as simple as someone pushing
the buttons automated in an

392
00:21:27.700 --> 00:21:29.560
automated fashion, on a website,
you can use it in

393
00:21:29.560 --> 00:21:31.960
a, in a, in a
water like fashion. There's also

394
00:21:31.960 --> 00:21:35.050
tools like selenium that allows
someone to write code in

395
00:21:35.050 --> 00:21:38.830
an HTML table using front
page or using word at

396
00:21:38.830 --> 00:21:41.950
the level that a reasonably
technical business person could could

397
00:21:41.950 --> 00:21:46.780
write, but it fit isn't
explicitly set up for, for,

398
00:21:46.810 --> 00:21:48.820
for Joe business. Got it.
Right. But it's just a

399
00:21:48.820 --> 00:21:51.670
different way of thinking about
the level that you might

400
00:21:51.670 --> 00:21:55.310
want to write your, write
your test that, You know,

401
00:21:55.320 --> 00:21:58.260
it always occurs to me
when we talk about the

402
00:21:58.260 --> 00:22:03.300
differences between business oriented people
and programmers is that, you

403
00:22:03.300 --> 00:22:05.280
know, really what we ought
to be doing is breeding

404
00:22:05.280 --> 00:22:09.210
business programmers, you know, programmers
who are fully technical and

405
00:22:09.210 --> 00:22:14.110
capable, but then, you know,
can go and understand the

406
00:22:14.160 --> 00:22:18.480
business process as well. I
mean, nothing takes the place

407
00:22:18.480 --> 00:22:21.900
of somebody with knowledge writing
the code. And it seems

408
00:22:21.900 --> 00:22:24.630
to me that there's a
lot of emphasis placed on,

409
00:22:25.080 --> 00:22:30.120
you know, translating between, you
know, giving business people tools

410
00:22:30.120 --> 00:22:32.910
so that they can get
closer and closer to writing

411
00:22:32.910 --> 00:22:35.070
code without actually having to
write it. You know what

412
00:22:35.070 --> 00:22:37.260
I mean? Totally. Yeah, absolutely.
I think you're right on,

413
00:22:37.260 --> 00:22:39.840
because from my point of
view, what's the, what's the

414
00:22:39.840 --> 00:22:42.840
goal, right? Like if you
read like Eli gold rat's

415
00:22:42.840 --> 00:22:46.140
book, the goal yeah. Software
that does what it's supposed

416
00:22:46.140 --> 00:22:49.020
to do Well in the
book, in the book, the

417
00:22:49.020 --> 00:22:52.470
goal, the goal is make
more money, right? So if

418
00:22:52.470 --> 00:22:54.540
you think about software, the
tools we use to write

419
00:22:54.540 --> 00:22:57.390
software is this thing, whatever
it is that we're doing,

420
00:22:57.390 --> 00:22:59.910
making us more money. Right.
You know, so test driven

421
00:22:59.910 --> 00:23:02.790
development, not necessarily gonna make
you more money, but it

422
00:23:02.790 --> 00:23:05.280
may save you money later
when, you know, when you

423
00:23:05.280 --> 00:23:07.950
don't have bugs. But what
you just did, what you

424
00:23:07.950 --> 00:23:10.170
just said is getting the
business person closer, The code

425
00:23:10.260 --> 00:23:12.120
or the code are closer
to the business one or

426
00:23:12.130 --> 00:23:16.260
the other right. Programmers do
all day. They, they translate

427
00:23:16.290 --> 00:23:21.480
intent into computer instructions. So
a business person says, I

428
00:23:21.480 --> 00:23:24.180
intend the software to do
this and the program or

429
00:23:24.180 --> 00:23:25.890
the only thing the program
is good for is to

430
00:23:25.890 --> 00:23:29.130
express that business person's intent
in a way that is

431
00:23:29.220 --> 00:23:33.360
computerized, right? So if you
merge them two birds with

432
00:23:33.360 --> 00:23:37.350
two and you get business
savvy programmers, which are typically

433
00:23:37.350 --> 00:23:39.960
called micro ISVM, right. You
know, you get like an

434
00:23:39.960 --> 00:23:42.810
Eric sync type who is
a coder and a business

435
00:23:42.810 --> 00:23:45.440
person, then you can get,
do some serious and they've

436
00:23:45.440 --> 00:23:47.450
proven it out in their
company. Right. And you get

437
00:23:47.450 --> 00:23:49.390
people like Mark. Right. Cause
I mean, we all know

438
00:23:49.390 --> 00:23:51.970
that we all know the
downside to programmers who just

439
00:23:51.970 --> 00:23:55.540
do exactly what they're told.
You know, they tend not

440
00:23:55.540 --> 00:23:59.650
to get hired. I mean,
yeah, absolutely. If you can't

441
00:23:59.650 --> 00:24:01.870
be in, in the middle
of something and recognize that

442
00:24:01.870 --> 00:24:05.470
it needs to change. If
the, if the business person

443
00:24:05.470 --> 00:24:09.520
can express the intent in
some format that the programmer

444
00:24:09.520 --> 00:24:12.850
can consume more readily than
a word document, then that

445
00:24:12.850 --> 00:24:16.330
document, that business document has
teeth at Kirlian. It's usually

446
00:24:16.540 --> 00:24:20.710
custom XML documents where our
business person will, will be

447
00:24:20.710 --> 00:24:23.080
able to read XML in
the, in the most basic

448
00:24:23.170 --> 00:24:26.830
sense or possibly use a
tool like InfoPath to express

449
00:24:26.830 --> 00:24:29.530
their intent in a, in
some kind of a domain

450
00:24:29.530 --> 00:24:32.890
specific language fit is an
example of a domain specific

451
00:24:32.890 --> 00:24:38.410
language for expressing functional intent.
You can write these yourself

452
00:24:38.800 --> 00:24:41.530
things like Ruby and Ruby
spec or end spec are

453
00:24:41.710 --> 00:24:44.680
direct ways to move in
that direction. So if the

454
00:24:44.680 --> 00:24:48.130
person can say this meets
the business need, and I

455
00:24:48.130 --> 00:24:52.540
can assert it in a
program in a programmatic way,

456
00:24:52.750 --> 00:24:55.090
then like we've said, in
the past, the number of

457
00:24:55.090 --> 00:24:59.620
non-software artifacts approaches zero, You
think it's a good idea.

458
00:24:59.620 --> 00:25:02.760
Maybe for people on the
beginning process of, of a,

459
00:25:02.760 --> 00:25:06.100
of a project to give
the business people, to write

460
00:25:06.400 --> 00:25:08.890
an application for the business
people to help them express

461
00:25:08.890 --> 00:25:11.800
what they, you know, what
they need to get done

462
00:25:11.810 --> 00:25:14.650
in the code. So that's,
that was more specific to

463
00:25:14.650 --> 00:25:17.590
their domain. Something that's less
off the shelf. Well, yeah,

464
00:25:17.590 --> 00:25:21.400
I think rapid prototyping is
a way of, of commiserating

465
00:25:21.400 --> 00:25:23.650
of getting together with the
business person and saying, did

466
00:25:23.650 --> 00:25:26.650
you mean this right? So
I think, yeah, you're right.

467
00:25:26.650 --> 00:25:30.070
Anything that a programmer can
do to express to the

468
00:25:30.070 --> 00:25:32.770
business person. Yeah. That's what
I meant or, Or tool

469
00:25:32.770 --> 00:25:35.770
to help them express it.
Right. A tool that they

470
00:25:35.770 --> 00:25:40.150
can use, however, their domain
dictates that can generate XML

471
00:25:40.150 --> 00:25:42.850
or can generate C-sharp or
VB net or whatever. Yes.

472
00:25:43.450 --> 00:25:44.920
If it's, it may not
be, it may not be

473
00:25:44.920 --> 00:25:46.180
fit. It may not be
an unit. It may not

474
00:25:46.180 --> 00:25:50.350
be whatever. But if you
could write a format could

475
00:25:50.350 --> 00:25:52.540
be just CSV file. It
could be just the look

476
00:25:52.540 --> 00:25:54.940
like a make file. Some
text file that the business

477
00:25:54.940 --> 00:25:58.600
person could say, I intend
this, you click generate. You

478
00:25:58.600 --> 00:26:01.660
could generate your test. You
could do whatever. I think

479
00:26:01.660 --> 00:26:04.270
the point of all of
this, this discussion of test

480
00:26:04.270 --> 00:26:08.950
driven development is have a
suite of tests. It gives

481
00:26:08.950 --> 00:26:11.770
you that constant feedback that
the thing is still working.

482
00:26:11.950 --> 00:26:13.600
Yeah. Not, this is not
just that it's working at

483
00:26:13.600 --> 00:26:15.700
a technical level, but that
it's still doing the business

484
00:26:15.700 --> 00:26:18.910
that the business person who
pays you is doing. But

485
00:26:18.910 --> 00:26:22.540
also that document, that documentation,
that kind of implicit documentation

486
00:26:22.540 --> 00:26:24.940
that, Oh, it works like
this. The unit test almost

487
00:26:24.940 --> 00:26:28.360
becomes documentation. It can't, it
doesn't go out of date.

488
00:26:28.390 --> 00:26:31.210
It is, it is how
it works. If it passes,

489
00:26:31.210 --> 00:26:33.880
this is how the system,
the system works. If that

490
00:26:33.880 --> 00:26:36.760
looks like what a business
person can understand all the

491
00:26:36.760 --> 00:26:38.590
better, because then the business
person can say, yes, it

492
00:26:38.590 --> 00:26:41.920
does work like this. And
then all of the benefits

493
00:26:41.920 --> 00:26:45.750
of rapid and ruthless refactoring,
the ripping the guts out

494
00:26:45.750 --> 00:26:48.720
of an application is never
a good idea. Unless you

495
00:26:48.720 --> 00:26:52.800
have a whole bunch of
code written in test format

496
00:26:52.860 --> 00:26:56.490
that confirms that you made
it better, you made it

497
00:26:56.490 --> 00:26:59.190
faster, you made it smaller,
you made it more extensible.

498
00:26:59.190 --> 00:27:01.500
You made it, you made
it. Whatever. If I change

499
00:27:01.510 --> 00:27:04.230
the application and test break,
no benefit there at all.

500
00:27:05.130 --> 00:27:07.650
But then also the, the
forcing you to think if

501
00:27:07.650 --> 00:27:10.170
you're writing frameworks, forcing you
to think like a client

502
00:27:10.440 --> 00:27:13.390
of this code. Right? Right.
One of the things that

503
00:27:13.410 --> 00:27:16.050
we didn't do on DAS
blog was think about anyone

504
00:27:16.050 --> 00:27:18.810
other than the Dodge blog
team, using the data access

505
00:27:18.810 --> 00:27:23.730
layer. If we had maybe
done more tests, it would

506
00:27:23.730 --> 00:27:26.220
have looked like a different
layer. It right now it's

507
00:27:26.220 --> 00:27:29.190
become very organic and it's
extended it's and fold it

508
00:27:29.190 --> 00:27:32.160
over on itself. But it
really was meant to be,

509
00:27:32.370 --> 00:27:34.590
it should have been a
public API that was formally

510
00:27:34.590 --> 00:27:37.620
tested and we should have
described it in our tests

511
00:27:37.620 --> 00:27:41.190
as the ideal. And then
the idea would have wagged

512
00:27:41.280 --> 00:27:44.100
the design and not the,
it wouldn't have grown in

513
00:27:44.100 --> 00:27:47.700
such a such an organic
way. Yeah. And then another

514
00:27:47.700 --> 00:27:49.980
thing that I found that
last, last comment about testing

515
00:27:49.980 --> 00:27:51.510
and development is that if
you spend a lot of

516
00:27:51.510 --> 00:27:55.680
time writing tests, rich language
are not a dynamic language

517
00:27:55.680 --> 00:27:59.100
or knocks, you know, strict
compiler language. You're not, if

518
00:27:59.100 --> 00:28:00.780
you write a lot of
tests, you spend less time

519
00:28:00.780 --> 00:28:04.110
debugging. A lot of people
spend time stepping through their

520
00:28:04.110 --> 00:28:06.240
code. And they're just trying
to get their head around.

521
00:28:06.300 --> 00:28:09.090
Does it work right? But
a test is a way

522
00:28:09.090 --> 00:28:12.270
to do an express if
it works right. This test

523
00:28:12.270 --> 00:28:16.110
will pass. Yeah. I like
what you said about, about

524
00:28:16.380 --> 00:28:18.900
thinking like a client. It
gives you that from the

525
00:28:18.900 --> 00:28:21.990
client perspective that is often
missing when you're in the

526
00:28:21.990 --> 00:28:24.390
middle of writing the goo.
Yeah. And then they don't

527
00:28:24.390 --> 00:28:26.130
care about stepping through it.
They just want to know

528
00:28:26.130 --> 00:28:28.980
that it happens and it
happens fast. So with some

529
00:28:28.980 --> 00:28:31.200
of these different unit testing
frameworks, you can go and

530
00:28:31.200 --> 00:28:34.080
say, you know, test this
and does it pass? Does

531
00:28:34.080 --> 00:28:36.330
it go, does it take
half a half a second?

532
00:28:36.360 --> 00:28:40.620
Does it take 10 milliseconds?
Is that within spec? If

533
00:28:40.620 --> 00:28:42.450
not, you know, what are
we going to do about

534
00:28:42.450 --> 00:28:47.460
it? Right. Express your intent.
Assert your assumptions. Anytime you

535
00:28:47.460 --> 00:28:50.820
say this application must do
this. Anytime a business person

536
00:28:50.820 --> 00:28:53.550
has ever said it should
behave like this. Write a

537
00:28:53.550 --> 00:29:00.000
test. Very good. Cool. Scott,
that's a show. Yeah, let's

538
00:29:00.000 --> 00:29:01.710
do it. We'll do it
one on mock objects soon.

539
00:29:02.220 --> 00:29:04.350
That's a great topic we
could go on and on.

540
00:29:04.530 --> 00:29:07.080
Absolutely. Alright. And until then,
we'll see you next week

541
00:29:07.470 --> 00:29:08.340
on Hansel minutes.


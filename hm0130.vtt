WEBVTT FILE

1
00:00:12.060 --> 00:00:17.220
From Hanselman it's dot com.
It's Hansel minutes, weekly discussion

2
00:00:17.220 --> 00:00:20.670
with web developer and technologist
and Scott Hanselman hosted by

3
00:00:20.670 --> 00:00:25.650
Carl Franklin. This is Lawrence Ryan announcing
show number one 30 recorded

4
00:00:25.650 --> 00:00:31.260
live Friday, September 19th, 2008. Support for
Hanselman it's just provided by

5
00:00:31.290 --> 00:00:35.280
Tellerik rad controls, the most
comprehensive suite of components for

6
00:00:35.280 --> 00:00:46.620
windows forms and asp.net web
applications online@wwwdotterikdotcomandby.net developers journal the

7
00:00:46.620 --> 00:00:52.890
world's leading.net developer magazine online
at www dot <inaudible> dot

8
00:00:52.890 --> 00:00:57.000
com. In this episode, Scott
talks to JavaScript with Brandon

9
00:00:57.000 --> 00:01:02.490
type. I, this is Scott
Hanselman, and this is another

10
00:01:02.490 --> 00:01:04.530
episode of Hansel minutes. And
I'm sitting down today with

11
00:01:04.530 --> 00:01:09.180
Brendan Eich chief technology officer
at MoCo Mozilla corporation. Thank

12
00:01:09.180 --> 00:01:10.500
you, sheriff, for taking the
time to chat with me

13
00:01:10.500 --> 00:01:14.010
today. No, there's a lot
of really amazing stuff going

14
00:01:14.010 --> 00:01:16.680
on in JavaScript right now.
It feels like there was

15
00:01:16.680 --> 00:01:21.930
a, an amazing resurgence, you
know, after XML HTTP request

16
00:01:22.020 --> 00:01:24.840
kind of showed up in
Firefox and, you know, Ajax

17
00:01:24.960 --> 00:01:27.750
kind of leapt out of
the I E world and

18
00:01:27.750 --> 00:01:31.230
into the, into the mainstream.
But do you think that

19
00:01:31.230 --> 00:01:35.010
JavaScript as a language has,
has moved much, much beyond

20
00:01:35.010 --> 00:01:38.190
kind of it's one point
to kind of state there's

21
00:01:38.190 --> 00:01:41.990
a lot happened between then
and now? I think so

22
00:01:41.990 --> 00:01:44.390
a lot of dot releases,
at least on our side,

23
00:01:44.390 --> 00:01:47.360
we we've been adding values
JavaScript over the years. So

24
00:01:47.360 --> 00:01:52.250
1.5 was the release from
10 years ago and we've

25
00:01:52.250 --> 00:01:56.540
done at 1.6. That was
in a Firefox one five.

26
00:01:56.540 --> 00:02:01.490
If I recall correctly, we
did 1.7 Joshua at 1.7

27
00:02:01.490 --> 00:02:05.660
in Firefox to JavaScript 1.8
in Firefox three. If you're

28
00:02:05.660 --> 00:02:08.300
seeing a trend here towards
JavaScript two, you wouldn't be

29
00:02:08.780 --> 00:02:12.080
too far wrong. We try
to standardize what we're doing.

30
00:02:12.080 --> 00:02:13.850
And that was part of
our work with the AGMA

31
00:02:13.850 --> 00:02:17.390
committee. And that's ongoing. It's
a little scale back from

32
00:02:17.390 --> 00:02:21.050
the ambition to unify the
language in the flash player

33
00:02:21.380 --> 00:02:24.440
or the target splash player
action, script three from Adobe,

34
00:02:24.800 --> 00:02:26.480
but there are certainly a
lot of things in there

35
00:02:26.480 --> 00:02:29.690
that we'd like to get
standardized. And as you said,

36
00:02:29.690 --> 00:02:32.180
the performance is really getting
good now, so developers can

37
00:02:32.180 --> 00:02:36.150
start using JavaScript in ways
that weren't possible before. What

38
00:02:36.200 --> 00:02:37.790
is, can you, maybe you
could explain to kind of

39
00:02:37.790 --> 00:02:39.200
some of the layman in
the audience, or what are

40
00:02:39.210 --> 00:02:44.750
the relationship between ECMAScript 1.4
Java script and an action

41
00:02:44.750 --> 00:02:48.350
script? What does that relationship?
So some of these are

42
00:02:48.350 --> 00:02:52.370
trade names like action script,
and I guess JavaScript too.

43
00:02:52.400 --> 00:02:55.160
That's just a, some Mark
that I think mobile has

44
00:02:55.160 --> 00:02:58.280
been allowed to use for
a long time. Now Netscape

45
00:02:58.460 --> 00:03:03.460
used it originally through a
trademark license. The, the Aqua

46
00:03:03.470 --> 00:03:05.600
script name is, is sort
of an anti-trade Mark. It's

47
00:03:05.600 --> 00:03:08.920
not really an attractive name.
The Atma standards body used

48
00:03:08.920 --> 00:03:12.850
to stand for a European
computer manufacturers association it's worldwide.

49
00:03:12.850 --> 00:03:15.760
And it's a fast track
into ISO the international standards

50
00:03:16.090 --> 00:03:19.270
organization. And it's its name
is now just eczema proper

51
00:03:19.270 --> 00:03:22.690
now. So ECMAScript is one
of the names used the

52
00:03:22.690 --> 00:03:25.870
standard number is AGMA two
62, and these are not

53
00:03:26.650 --> 00:03:27.940
names that are going to
sweep the world and be

54
00:03:28.210 --> 00:03:31.690
on everyone's tongue. What the
standard allowed us to do

55
00:03:31.690 --> 00:03:35.290
back in the day with
Netscape and Microsoft was to

56
00:03:35.350 --> 00:03:38.050
agree on how the language
should work at its core,

57
00:03:38.320 --> 00:03:41.710
which is the fundamental syntax
and semantics, not including the

58
00:03:41.710 --> 00:03:44.920
document object model or the
browser sort of API APIs

59
00:03:44.920 --> 00:03:49.240
that were there in those
days. And that standard in

60
00:03:49.240 --> 00:03:52.390
spite of, you know, too
many flaws is actually a

61
00:03:52.390 --> 00:03:54.880
pretty good standard. All things
considered because a lot of

62
00:03:54.880 --> 00:04:00.460
language standards don't have to
be accurate in the crucible

63
00:04:00.460 --> 00:04:03.640
of the web where interoperation
is King, where, what developers

64
00:04:03.640 --> 00:04:06.340
know if something works differently
in, in, you know, Mozilla

65
00:04:06.340 --> 00:04:09.370
versus I E they can
tell, and you can't hide

66
00:04:09.370 --> 00:04:14.080
anything. A lot of computer
programming languages are under specified

67
00:04:14.080 --> 00:04:16.510
intentionally. So that's compiler writers
to make them go very

68
00:04:16.510 --> 00:04:20.920
fast and they are used
in various forms behind firewalls

69
00:04:20.920 --> 00:04:23.620
or in silos. So you
use Microsoft visual C plus

70
00:04:23.650 --> 00:04:26.830
plus, or you use the
canoe seed compiler or a

71
00:04:26.830 --> 00:04:29.710
number of forceful compilers, I
think, which used to be

72
00:04:30.010 --> 00:04:33.670
more popular and have been
eclipsed by one of the

73
00:04:33.670 --> 00:04:37.690
two GCC or Microsoft seeking
power. Those, those compilers didn't

74
00:04:37.690 --> 00:04:39.340
all agree on how the
C language of the C

75
00:04:39.340 --> 00:04:42.430
plus plus language worked, not
just because the standard was

76
00:04:42.460 --> 00:04:47.950
under specified on purpose, but
because there were actual bugs

77
00:04:47.950 --> 00:04:50.590
or quirks in the compounders.
And no one noticed because

78
00:04:50.590 --> 00:04:53.440
the code didn't have to
work across the web. So

79
00:04:53.470 --> 00:04:57.070
JavaScript is probably the most
interoperatively implemented programming language in

80
00:04:57.070 --> 00:04:59.830
the world. So the Atma
standard was the basis for

81
00:04:59.830 --> 00:05:03.880
that interoperation, but the browser
vendors try to agree, at

82
00:05:03.880 --> 00:05:06.940
least on that much. Sometimes
there are things that internet

83
00:05:06.940 --> 00:05:10.810
Explorer never fixed based on
the ECMO standard. And we've

84
00:05:10.810 --> 00:05:13.960
had to actually insert the
standard to match reality because

85
00:05:14.440 --> 00:05:17.020
a market leader, as it
was and remains in some

86
00:05:17.020 --> 00:05:19.750
ways can set the de
facto standard and it trumps

87
00:05:19.750 --> 00:05:23.970
the standard. Do you think
that, that what you think

88
00:05:23.980 --> 00:05:25.710
about some of the liberties
that are taken, like whether

89
00:05:25.710 --> 00:05:27.270
it be I E or
some of the liberties that

90
00:05:27.270 --> 00:05:29.700
Adobe takes with action script,
you know, and, and the

91
00:05:29.700 --> 00:05:32.460
tend towards static typing, do
you think that those things

92
00:05:32.460 --> 00:05:34.110
are a little bit of
a tug of war, or

93
00:05:34.110 --> 00:05:35.820
do you feel that you've
firmly, you know, you and

94
00:05:35.820 --> 00:05:38.370
ECMO firmly have a grip
on where JavaScript is heading

95
00:05:39.720 --> 00:05:45.210
Well, Adobe it's something for
their developers that was designed

96
00:05:45.210 --> 00:05:48.240
to make sort of flashed
development more like, you know,

97
00:05:48.240 --> 00:05:52.650
windows or Java swing development,
dealing with a tool kit

98
00:05:52.650 --> 00:05:56.550
with a class hierarchy, having
the ability to write down

99
00:05:56.550 --> 00:06:01.310
type to annotate the types
of variables and arguments. This

100
00:06:01.310 --> 00:06:03.790
has benefits for programming in
the large for making API

101
00:06:03.790 --> 00:06:06.250
APIs, where you can count
on the values coming in,

102
00:06:06.260 --> 00:06:10.760
being well conditioned or well
typed. There are limits to

103
00:06:10.760 --> 00:06:13.700
it. And we're all familiar
with, from other languages because

104
00:06:13.910 --> 00:06:16.730
many languages in the current
state of the art have

105
00:06:17.330 --> 00:06:21.440
somewhat weak type systems with
very exotic, strong type systems.

106
00:06:21.440 --> 00:06:23.510
Aren't used that much. And
I'm thinking of functional languages

107
00:06:23.540 --> 00:06:28.720
like Haskell here, though. I
would say Jane street deaf,

108
00:06:28.720 --> 00:06:32.780
a lot of camel programming.
So there's an exception, but,

109
00:06:32.810 --> 00:06:36.890
but really action script three
was in some ways trying

110
00:06:36.890 --> 00:06:40.550
to appeal to Java programmers,
or maybe you would say

111
00:06:40.970 --> 00:06:44.000
C plus plus, or C
sharp programmers. And I think

112
00:06:44.000 --> 00:06:48.650
it's been successful in its
domain. The type system in

113
00:06:48.650 --> 00:06:51.860
ActionScript free was influential in
our work on the fourth

114
00:06:51.860 --> 00:06:56.150
edition proposals for ECMAScript. And
there's still an active conversation

115
00:06:56.150 --> 00:06:58.880
in the AGMA committee to
add an optional type system,

116
00:06:58.880 --> 00:07:01.850
which is what's the actual
script three to JavaScript. Now

117
00:07:01.850 --> 00:07:05.000
it wouldn't be something where
you had to annotate all

118
00:07:05.000 --> 00:07:07.880
the variables. You could write
little untied, JavaScript like you

119
00:07:07.880 --> 00:07:09.800
do today. And in feed,
you can do that. And

120
00:07:09.800 --> 00:07:11.810
extra two with three, you're
just, I think, encouraged not

121
00:07:11.810 --> 00:07:15.650
to buy the tooling that
Adobe has, but, you know,

122
00:07:15.650 --> 00:07:17.890
there are reasons for that
tooling to want things to

123
00:07:17.900 --> 00:07:20.840
be fully typed. If you're
just doing JavaScript for the

124
00:07:20.840 --> 00:07:24.110
web it's on today, if
we ever do standardized the

125
00:07:24.120 --> 00:07:26.510
type system, I think it'll
look like some of the

126
00:07:26.510 --> 00:07:28.310
things we worked on and
maybe I'll have some other

127
00:07:28.310 --> 00:07:31.160
features, but it will be
optional. And it'll have a

128
00:07:31.190 --> 00:07:33.440
sort of dynamic flavor there
won't be this ahead of

129
00:07:33.440 --> 00:07:36.860
time checking that says, well,
your, your, your file loaded,

130
00:07:36.860 --> 00:07:39.390
but we can't compile it
because of some type of

131
00:07:39.410 --> 00:07:41.990
error. And so you're not
going to have any rich

132
00:07:42.050 --> 00:07:46.850
Ajax of app experience. Sorry,
it'll be a dynamic language

133
00:07:46.880 --> 00:07:52.280
like, like, like Pearl Python
and Ruby with optional types.

134
00:07:52.340 --> 00:07:55.880
And those languages have had
experimental variance in case of

135
00:07:55.880 --> 00:07:59.150
Pearl pro six, I would
say, have type systems added

136
00:07:59.150 --> 00:08:02.110
to them. So it sounds
like from your answer that

137
00:08:02.680 --> 00:08:04.300
as a, as a line,
kind of as a language

138
00:08:04.300 --> 00:08:07.120
walk, as a person involved
in languages that on the,

139
00:08:07.150 --> 00:08:11.260
on the access of purist
versus pragmatist, you're kind of

140
00:08:11.260 --> 00:08:14.110
flat in the middle. It
doesn't sound like you're really

141
00:08:14.140 --> 00:08:18.580
pure peer dynamic languages. You
know, there's a pragmatism to

142
00:08:18.580 --> 00:08:21.430
what you're saying. That is
a little surprising. Yeah. I'm

143
00:08:21.430 --> 00:08:24.610
not religious. I have been
a Unix kernel hacker, which

144
00:08:24.610 --> 00:08:27.520
was writing in C, which
is portable assembly language. I've

145
00:08:27.670 --> 00:08:30.280
played with a lot of
languages and implemented language processes

146
00:08:30.370 --> 00:08:33.310
for my whole career. And
going back into the graduate

147
00:08:33.310 --> 00:08:36.100
and undergraduate studies, and, you
know, this is sort of

148
00:08:36.100 --> 00:08:40.900
a dual or a sort
of a correspondence between statically

149
00:08:40.900 --> 00:08:45.400
type languages and dynamically type
language is you can make

150
00:08:45.460 --> 00:08:49.690
proofs out of your programs
in static type languages. If

151
00:08:49.690 --> 00:08:53.140
the type system is sound
by writing down types of

152
00:08:53.830 --> 00:08:57.480
variables and arguments and return
values, and these proofs can

153
00:08:57.480 --> 00:09:00.450
be helpful, or they can
just be kind of tedious

154
00:09:00.450 --> 00:09:03.090
and still not keep your
program from crashing depending on

155
00:09:03.120 --> 00:09:04.800
the nature of the language
and the nature of the

156
00:09:04.800 --> 00:09:09.690
type system. So, and if
you have a really sort

157
00:09:09.690 --> 00:09:12.090
of advanced type system like
in Haskell, you can do

158
00:09:12.090 --> 00:09:15.450
some amazing things, but it's
not yet well taught and

159
00:09:15.570 --> 00:09:19.230
programmers tend to bounce off
it. So maybe that will

160
00:09:19.230 --> 00:09:21.210
be the wave of the
future. I'm actually a fan

161
00:09:21.210 --> 00:09:24.630
of languages like Haskell, but
right now people are being

162
00:09:24.630 --> 00:09:27.090
taught Java. It's sort of
like the new cobalt it's

163
00:09:27.180 --> 00:09:29.190
safer than C plus plus
it's memory safe. There are

164
00:09:29.190 --> 00:09:33.480
no ways to forge pointers
or bad memory addresses, but

165
00:09:33.480 --> 00:09:35.190
it's type system doesn't do
a lot for you. And

166
00:09:35.190 --> 00:09:37.830
yet it requires you to
write things down sometimes redundantly

167
00:09:37.830 --> 00:09:43.080
or sometimes tediously and sort
of without real benefit. So

168
00:09:43.770 --> 00:09:46.860
this dynamic languages community has
had a resurgence lately. You've

169
00:09:46.860 --> 00:09:48.960
seen this with the books
on Ruby versus Java and

170
00:09:48.960 --> 00:09:52.020
sort of these fake food
fights that happen. I'm like

171
00:09:52.020 --> 00:09:56.730
Ruby on rails versus the
three tier Java architecture that

172
00:09:57.090 --> 00:09:59.850
with an AMEC languages, you
can sometimes write very generic,

173
00:09:59.880 --> 00:10:03.630
functional code, functional programming that
doesn't have to worry about

174
00:10:03.630 --> 00:10:06.030
ties to because it's universally
quantified. It works on any

175
00:10:06.210 --> 00:10:09.480
type and you can be
very productive. And with the

176
00:10:09.480 --> 00:10:11.370
right debugger and testing, you
can go a long way.

177
00:10:12.000 --> 00:10:14.730
There still can be benefits
to having some kind of

178
00:10:14.790 --> 00:10:18.600
type or contract system. That's
another sort of dynamic type

179
00:10:18.600 --> 00:10:21.600
system. That's actually very expressive
where you can have your

180
00:10:21.600 --> 00:10:28.260
API APIs decorated with extra
declarations that say here's what

181
00:10:28.260 --> 00:10:29.850
the types should be or
here's what the contract should

182
00:10:29.850 --> 00:10:32.730
be. And when someone violates
that contract, I'm thinking particularly

183
00:10:32.730 --> 00:10:35.370
of the contract systems and
scheme, you get a good

184
00:10:35.520 --> 00:10:38.910
error of blame pointing to
the originator of the bad

185
00:10:38.910 --> 00:10:41.850
value. And this is really
good for debugging it right

186
00:10:41.850 --> 00:10:44.670
now, bad values and JavaScript
tends to lead to a,

187
00:10:44.700 --> 00:10:47.340
you know, food has no
properties or undefined. It's not

188
00:10:47.340 --> 00:10:50.970
defined in any sort of
error message. And that's, that's

189
00:10:50.970 --> 00:10:54.290
no fun at all, But
that's a contract system, not

190
00:10:54.290 --> 00:10:57.460
a type system, right? And
that's an interesting distinction. This

191
00:10:57.460 --> 00:11:00.380
is the station. It's not
a static system that you

192
00:11:00.380 --> 00:11:05.870
can prove facts about. So
it's an open question in

193
00:11:05.870 --> 00:11:08.660
my mind, at least how
much benefit there is to

194
00:11:08.660 --> 00:11:11.240
adding an optional type system,
as opposed to a contract

195
00:11:11.240 --> 00:11:17.120
system, people would like to
write down certain facts about

196
00:11:17.120 --> 00:11:19.040
API APIs, but do they
really need to say this

197
00:11:19.040 --> 00:11:22.790
loop variable is an integer?
I don't think so. And

198
00:11:22.790 --> 00:11:25.370
I think the, the optimization
work you're seeing in JavaScript

199
00:11:25.370 --> 00:11:28.040
engines right now makes that
a moot point as far

200
00:11:28.040 --> 00:11:30.800
as performance, because in the
past it's been said, Oh,

201
00:11:30.830 --> 00:11:33.020
to make your code fast,
you must, you know, add

202
00:11:33.020 --> 00:11:36.050
a colon int type annotation
to your VAR. I that's

203
00:11:36.110 --> 00:11:38.810
used as a loop control
variable. And I just don't

204
00:11:38.810 --> 00:11:42.910
see that that's either fruit
for necessary for performance. The

205
00:11:42.910 --> 00:11:45.680
really interesting type terms that
you'd like to write down

206
00:11:45.710 --> 00:11:48.470
are more like contracts. They
are more like higher order

207
00:11:48.680 --> 00:11:51.710
types and, and ways of
saying things at the API

208
00:11:51.710 --> 00:11:55.540
boundaries, but inside implementation of
the API or inside the

209
00:11:55.540 --> 00:11:58.360
client that uses the API,
you may be able to

210
00:11:58.360 --> 00:12:01.090
have untied code that goes
super fast and doesn't need

211
00:12:01.420 --> 00:12:05.430
heavy pipe sanitation. And how
do you think that that

212
00:12:05.430 --> 00:12:09.300
contract would relate to something
like, like open Ajax, metadata?

213
00:12:09.360 --> 00:12:11.550
I mean, it sounds like
we're all kind of dancing

214
00:12:11.550 --> 00:12:15.510
around. We want to keep
JavaScript fast and loose, but

215
00:12:15.510 --> 00:12:17.550
at the same time we
want our IntelliSense. We want

216
00:12:17.550 --> 00:12:20.130
our tooling. We want better
IDs. You know, there was

217
00:12:20.130 --> 00:12:22.410
a long time there where
everyone was writing JavaScript and

218
00:12:22.860 --> 00:12:25.380
VI and notepad, and suddenly
there was this insane, you

219
00:12:25.380 --> 00:12:28.290
know, this resurgence of IDs
and better tooling and debuggers.

220
00:12:29.060 --> 00:12:30.900
Now we're, we've got people
trying to get into more

221
00:12:30.900 --> 00:12:35.220
metadata. People want IntelliSense for
jQuery. They're, they're adding metadata

222
00:12:35.220 --> 00:12:38.040
and comments. Wouldn't a contract
system. Give them the same

223
00:12:38.040 --> 00:12:41.070
stuff that this open Ajax
metadata would provide. It might,

224
00:12:41.070 --> 00:12:43.680
or a decorator syntax like
you see in other languages

225
00:12:43.680 --> 00:12:47.640
like Python and Java as
well. C-sharp some of the,

226
00:12:47.640 --> 00:12:50.250
sometimes you, you try to
wedge things into this sort

227
00:12:50.250 --> 00:12:53.430
of domain specific decorator language
that really should be properly

228
00:12:53.430 --> 00:12:56.910
thought through in the full,
the main language. But here's

229
00:12:56.910 --> 00:12:58.560
an example. It's not a
contract system. It's a real

230
00:12:58.560 --> 00:13:01.140
type system. This is something
we've explored in the Atmos

231
00:13:01.140 --> 00:13:04.860
script. Fourth edition proposals, a
structural type system would be

232
00:13:04.860 --> 00:13:07.920
a way of describing data,
sort of like Jason data

233
00:13:08.190 --> 00:13:12.810
objects and arrays of strings
and doings and numbers. And

234
00:13:12.870 --> 00:13:16.200
you could write these nested
fashion and these types, these

235
00:13:16.200 --> 00:13:20.460
structural types would not have
names that defines their equality

236
00:13:20.460 --> 00:13:23.670
or that identity. It's not
like running a class declaration

237
00:13:23.670 --> 00:13:26.370
in Java. You're actually saying
it's a record. It has

238
00:13:26.370 --> 00:13:29.940
these three fields. And you
know, the first one is

239
00:13:30.000 --> 00:13:32.160
read and type his number.
And the second one is

240
00:13:32.160 --> 00:13:33.750
green and it's type his
number. And the third one's

241
00:13:33.750 --> 00:13:35.760
blue and it's type his
number. This kind of structural

242
00:13:35.760 --> 00:13:38.160
type system has been used
in some languages. We think

243
00:13:38.160 --> 00:13:41.370
this is possibly more valuable
than a nominal type system

244
00:13:41.370 --> 00:13:45.590
that is a class or
a interface type system. They

245
00:13:45.630 --> 00:13:49.650
both have use cases. They're
somewhat complimentary. But if you

246
00:13:49.650 --> 00:13:52.800
look at how people do
JavaScript today, they program around

247
00:13:52.800 --> 00:13:55.650
Jason, where there's sort of
a latent schema in the

248
00:13:55.650 --> 00:13:58.710
code. There's an implicit implicit
scheme in their heads, programmers,

249
00:13:58.710 --> 00:14:01.890
writing, dynamic languages do write
wall type code. And I

250
00:14:01.890 --> 00:14:03.990
can get into that when
we talk about optimizations, because

251
00:14:04.140 --> 00:14:07.830
at least for Mozilla's approach
with trace monkey, we depend

252
00:14:07.830 --> 00:14:11.340
on there being stable, latent
types in the code. And

253
00:14:11.340 --> 00:14:13.950
indeed there are, Well, we
should talk about that because

254
00:14:13.950 --> 00:14:17.190
I think that JavaScript is
getting incredibly fast, but there's

255
00:14:17.190 --> 00:14:19.680
things that have been around
like rhino, you know, you

256
00:14:19.680 --> 00:14:21.750
know, of course, an open,
an open source implementation of

257
00:14:21.750 --> 00:14:27.000
JavaScript written in Java. Microsoft's
got a managed JavaScript running

258
00:14:27.000 --> 00:14:31.110
in the CLR DLR that
dynamic language runtime. So people

259
00:14:31.110 --> 00:14:36.240
are building these dynamic language
jitters on top of existing

260
00:14:36.630 --> 00:14:41.340
static language jitters, but trace
monkeys and V8 are heading

261
00:14:41.340 --> 00:14:44.370
in a little bit different
way. Aren't they? Yeah, you'll

262
00:14:44.370 --> 00:14:47.760
hear this claim made about
like the job of VM

263
00:14:47.770 --> 00:14:51.590
and the CLR that Dutton,
that runtime, that they were

264
00:14:51.590 --> 00:14:54.530
designed for static languages and
that shows. So when you

265
00:14:54.530 --> 00:14:56.390
have a dynamic line, which
mapped onto them, it doesn't

266
00:14:56.390 --> 00:14:59.420
know its performance well, or
it has to do more

267
00:14:59.420 --> 00:15:02.390
work to optimize itself. It
doesn't get things for free

268
00:15:02.390 --> 00:15:04.340
from the runtime time. And
sometimes the runtime actually gets

269
00:15:04.340 --> 00:15:08.810
in the way, whereas with
something from scratch, like Google's

270
00:15:08.810 --> 00:15:11.840
VA or trace monkey, which
is an evolution of spider

271
00:15:11.840 --> 00:15:14.600
monkey, the interpreter we've had
in Firefox for a long

272
00:15:14.600 --> 00:15:17.900
time, we can do things
just for JavaScript and just

273
00:15:17.900 --> 00:15:21.790
for the dynamic language performance
that we need. Hi, this

274
00:15:21.790 --> 00:15:24.340
is Scott Hanselman with a
word from our sponsor. Do

275
00:15:24.340 --> 00:15:26.920
you know how to build
web 2.0 Ajax applications with

276
00:15:26.920 --> 00:15:29.770
web 1.0 components? You really
can't. If you want to

277
00:15:29.770 --> 00:15:32.770
do the next generation web
applications you'll need next generation

278
00:15:32.770 --> 00:15:35.200
components. Just like the ones
that our friends at Telerik

279
00:15:35.200 --> 00:15:38.380
have got their rad controls
for ESPN at Ajax. It's

280
00:15:38.380 --> 00:15:40.930
a huge pack of web
controls built on top of

281
00:15:40.960 --> 00:15:45.670
asp.net Ajax. That'll add previously
impossible performance interactivity to your

282
00:15:45.670 --> 00:15:50.080
next project. The new controls
mirror, the Ajax API from

283
00:15:50.080 --> 00:15:53.710
asp.net. So development is really
straightforward. The client scripts are

284
00:15:53.710 --> 00:15:56.350
shared. So loading time is
not a problem. If you

285
00:15:56.350 --> 00:15:58.030
just set a couple of
properties and you'll be able

286
00:15:58.030 --> 00:16:00.580
to automatically bind a web
services for a really efficient

287
00:16:00.580 --> 00:16:05.500
operation, the new rad editor
from ESPN Ajax, Telerik loads

288
00:16:05.500 --> 00:16:07.930
up to four times faster
than before. And the new

289
00:16:07.930 --> 00:16:11.020
rad grid handles thousands of
records and just milliseconds, but

290
00:16:11.380 --> 00:16:14.230
as always, it's best to
try for yourself. So you

291
00:16:14.230 --> 00:16:17.560
can visit <inaudible> dot com
slash ASP, net Ajax, and

292
00:16:17.560 --> 00:16:21.430
download a trial. Thanks a
lot. There's some interesting speed

293
00:16:21.430 --> 00:16:23.890
stuff going on up on
your, up in your blog

294
00:16:23.890 --> 00:16:26.290
at Brendan's roadmap updates, you've
got some charts and there's,

295
00:16:26.590 --> 00:16:29.020
there's a little bit of
an arm wrestling match between

296
00:16:29.020 --> 00:16:32.140
trace monkey and V8 VH
seems to be a little

297
00:16:32.140 --> 00:16:34.750
bit obsessed with recursion and
likes to show that they're,

298
00:16:34.810 --> 00:16:38.290
you know, a jillion times
faster in this particular micro

299
00:16:38.530 --> 00:16:42.340
benchmark in your graph, you're
showing that the trace monkey

300
00:16:42.370 --> 00:16:45.070
fair is pretty darn favorable,
but one of the points

301
00:16:45.070 --> 00:16:47.080
that you make is that
you developed it a lot

302
00:16:47.080 --> 00:16:51.040
faster. Then they've been working
on VA for quite awhile.

303
00:16:51.790 --> 00:16:54.730
I don't know if that's
true. I met Lars box

304
00:16:55.060 --> 00:16:58.240
once he's the VM guru
created it. And I think

305
00:16:58.240 --> 00:17:00.550
he works very quickly. I
wouldn't be surprised if he

306
00:17:00.550 --> 00:17:04.030
had gotten the bulk of
the work done very quickly,

307
00:17:04.030 --> 00:17:07.300
so no disrespect intended, but,
but they only released it

308
00:17:07.300 --> 00:17:10.420
after a couple of years
at Google. And that may

309
00:17:10.420 --> 00:17:12.310
have, and frankly that may
have hurt them because when

310
00:17:12.310 --> 00:17:14.860
you do open source development,
it's best to release early

311
00:17:14.860 --> 00:17:17.380
and often. And in fact,
in the Google Chrome comics,

312
00:17:17.410 --> 00:17:19.660
they talk about releasing early
and often, but they didn't

313
00:17:19.660 --> 00:17:23.620
actually do it in this
case. The two approaches are

314
00:17:23.620 --> 00:17:28.390
different though, trace monkey in
VA. And right now we're

315
00:17:28.440 --> 00:17:31.600
working on getting the performance
and recursion to be better.

316
00:17:32.230 --> 00:17:34.750
Google has focused on some
benchmarks, some of which are

317
00:17:35.050 --> 00:17:38.620
kind of macro they're, they're
very object oriented, JavaScript, very

318
00:17:38.620 --> 00:17:41.890
stylized in a way that's
you see on the web

319
00:17:41.890 --> 00:17:45.830
though, in some ways, even
more layered than the web

320
00:17:46.570 --> 00:17:50.580
JavaScript code that I've looked
at and are heavy on

321
00:17:50.580 --> 00:17:55.170
recursion or heavy on sort
of method, method dispatch, and

322
00:17:55.380 --> 00:17:58.440
with praise monkey, we can
inline methods very quickly. If

323
00:17:58.440 --> 00:18:01.800
we can handle all the
case combinations in the spider

324
00:18:01.800 --> 00:18:05.280
monkey bike code, we're simply
working through uncover cases to

325
00:18:05.280 --> 00:18:07.950
stay on trace and not
abort the recording. And as

326
00:18:07.950 --> 00:18:09.900
we do that, you'll see
us get faster and faster

327
00:18:10.170 --> 00:18:12.600
and we'll see how it
goes. I don't want to

328
00:18:12.930 --> 00:18:16.020
brag at all, and I
wouldn't want to claim results

329
00:18:16.290 --> 00:18:18.600
before I had them. But
I, as I said in

330
00:18:18.600 --> 00:18:20.580
the blog, I do believe
that the tracing approach gives

331
00:18:20.580 --> 00:18:23.160
us a unique way of
looking at what the program

332
00:18:23.160 --> 00:18:25.650
is actually doing. It's it's
its current set of values,

333
00:18:25.650 --> 00:18:28.170
the latent types that are
there that may not be

334
00:18:28.170 --> 00:18:31.590
evidenced from a static analysis
of the code. And that

335
00:18:32.130 --> 00:18:33.930
should let us go very
fast. It should let us

336
00:18:33.930 --> 00:18:37.530
specialize as well as inline.
And the combination of inlining

337
00:18:37.530 --> 00:18:40.290
and specializing can keep our
code footprint. Small can make

338
00:18:40.290 --> 00:18:42.810
us generate very tight machine
code that doesn't have to

339
00:18:42.810 --> 00:18:46.050
worry about case analysis at
runtime. VA is probably going

340
00:18:46.050 --> 00:18:49.140
to get into speculation more
and more, but originally when

341
00:18:49.140 --> 00:18:50.760
I looked at it and
I don't know if it's

342
00:18:50.760 --> 00:18:55.050
changed much, they were doing
sort of, is it this

343
00:18:55.050 --> 00:18:58.140
case of the plus operator,
which concatenate shoestrings, or is

344
00:18:58.140 --> 00:19:00.060
it that case of the
plus operator, which adds two

345
00:19:00.060 --> 00:19:02.940
numbers and maybe the optimize
further? Is it the case

346
00:19:02.940 --> 00:19:04.860
of the plus operator where
the number is both can

347
00:19:04.860 --> 00:19:07.800
fit into machine integers and
not overflow into the double

348
00:19:07.800 --> 00:19:12.480
precision floating point that kind
of cogeneration makes for more

349
00:19:12.480 --> 00:19:15.780
code. And because you're doing
those tests, it runs a

350
00:19:15.780 --> 00:19:19.020
little bit slower with tracing.
We can speculate that, Oh,

351
00:19:19.020 --> 00:19:21.750
it's only integers it doesn't
overflow. We're going to put

352
00:19:21.750 --> 00:19:23.640
a very quick garden. So
there's still a little test

353
00:19:23.640 --> 00:19:26.130
overhead, but it's smaller. And
we're going to just use

354
00:19:26.190 --> 00:19:28.740
integers all the way. And
that allows us to do

355
00:19:28.740 --> 00:19:30.780
really well on these micro
benchmarks. He saw us beating

356
00:19:30.780 --> 00:19:34.440
beat on micro benchmarks, I
think more than macro, and

357
00:19:34.440 --> 00:19:35.940
we're just going to have
to keep competing and see

358
00:19:35.940 --> 00:19:38.660
how it levels out. So
just to make sure that

359
00:19:38.660 --> 00:19:40.880
the listeners are falling, this
notion of tracing, I mean,

360
00:19:40.880 --> 00:19:44.090
are you, are you watching
it run slowly once by

361
00:19:44.090 --> 00:19:47.330
basically instrumenting it in, you
know, in real time and

362
00:19:47.330 --> 00:19:50.480
then, and then doing your
nano jetting, does it in

363
00:19:50.480 --> 00:19:53.930
fact run slowly for a
moment or do you, I

364
00:19:53.930 --> 00:19:55.340
mean, this seems like it's
a little bit of a

365
00:19:55.550 --> 00:19:57.860
Schrodinger's cat thing, you know,
did the JavaScript run or

366
00:19:57.860 --> 00:20:00.080
not, I'm not quite clear
on how you are. In

367
00:20:00.080 --> 00:20:04.610
fact seeing this happen versus
doing a static analysis. Sure.

368
00:20:04.630 --> 00:20:07.250
This is based on work
Andrea's gal did for a

369
00:20:07.250 --> 00:20:10.940
PhD thesis under Michael France
at UC Irvine. And it's

370
00:20:11.000 --> 00:20:14.810
it's novel work. It's has
very few predecessors in computer

371
00:20:14.810 --> 00:20:19.940
science research and Andreas is
twist to it made, made

372
00:20:19.940 --> 00:20:23.240
the traces be prettier and
structure and have a sort

373
00:20:23.240 --> 00:20:26.900
of a tree structure that
allows for larger scale optimization.

374
00:20:27.200 --> 00:20:29.810
But we are recording what
the interpreter does. So we

375
00:20:29.810 --> 00:20:33.440
have an interpreter which means
a bytecode interpreter. People probably

376
00:20:33.440 --> 00:20:35.960
know what that is, where
you, you generate a pretend

377
00:20:35.960 --> 00:20:38.990
instruction set. It's like a
little toy language machine language,

378
00:20:39.020 --> 00:20:42.740
and you still there, you
still there, it's still got

379
00:20:42.740 --> 00:20:46.250
an interpreter. VA does not
have an interpreter. They parsed

380
00:20:46.250 --> 00:20:48.850
JavaScript into the trees. And
then they, when they see

381
00:20:48.850 --> 00:20:50.920
something has to run, they
can do this lately. So

382
00:20:50.920 --> 00:20:52.450
they don't have to do
it up ahead of time.

383
00:20:52.690 --> 00:20:55.180
They then go generate machine
code directly. But as I

384
00:20:55.180 --> 00:20:57.250
noted, it's still in general
has to be machine code

385
00:20:57.250 --> 00:21:00.190
that says, is it case
number one is a case.

386
00:21:00.190 --> 00:21:02.380
Number two is a case
number three in order to

387
00:21:02.380 --> 00:21:07.180
handle all the dynamic case
combinations. Whereas with tracing, we

388
00:21:07.180 --> 00:21:10.120
let the interpreter handle loops.
And when the loops look

389
00:21:10.480 --> 00:21:13.660
hot enough, when, when a
simple way of counting loop

390
00:21:13.660 --> 00:21:16.630
frequency trips, we can then
say, okay, we're going to

391
00:21:16.630 --> 00:21:19.060
start a recorder. And that's
just like a VCR for

392
00:21:19.060 --> 00:21:23.080
your interpreter. It's at the
little overhead for that one

393
00:21:23.110 --> 00:21:25.630
iteration that it tries to
record. But if the iteration

394
00:21:26.170 --> 00:21:29.950
complete, if the loop body
control flow, reaches back to

395
00:21:29.950 --> 00:21:33.520
the top of the loop
again, then boarding is done

396
00:21:33.520 --> 00:21:37.300
and we get this beautiful
linear stream of instructions that

397
00:21:37.300 --> 00:21:40.780
we can use modern optimization
techniques on. And because it's

398
00:21:40.780 --> 00:21:45.580
linear, it's a it's it's
branch free. All these modern

399
00:21:45.580 --> 00:21:48.610
optimization techniques become very simple
and efficient. Whereas if you

400
00:21:48.610 --> 00:21:54.930
were using whole method compilation,
I see. Okay. Right, right.

401
00:21:54.960 --> 00:21:58.230
By avoiding a holistic view
by, by actually focusing in,

402
00:21:58.230 --> 00:22:01.740
on giving yourself tunnel vision,
then you make things look

403
00:22:01.740 --> 00:22:04.710
more linear than by taking
it, but basically a small

404
00:22:04.710 --> 00:22:07.290
bite at a time. Yeah.
And like I said, my

405
00:22:07.290 --> 00:22:10.500
blog, you, you free the
interpreter from being neurotic about

406
00:22:10.800 --> 00:22:13.200
while the same thing didn't
happen next time, but I'm

407
00:22:13.200 --> 00:22:15.510
going to keep testing just
in case something might change.

408
00:22:16.080 --> 00:22:18.690
You know, they say the
definition of neurosis is doing

409
00:22:18.690 --> 00:22:20.790
the same thing over and
over expecting a different result.

410
00:22:21.090 --> 00:22:23.430
And the interpreter is doing
this sort of case analysis

411
00:22:23.430 --> 00:22:25.440
that the generated VA code
is doing its thing. Is

412
00:22:25.440 --> 00:22:27.660
it a string? Is it
an integer? I don't know

413
00:22:27.660 --> 00:22:29.790
it could change. But when
you record a trace, you

414
00:22:29.790 --> 00:22:33.870
stipulate, well, it's an imager
types are stable. And then

415
00:22:33.870 --> 00:22:37.410
in a programming language programming,
we're going to put a

416
00:22:37.410 --> 00:22:41.250
very efficient guard instruction that
will bail out if it's

417
00:22:41.250 --> 00:22:43.530
not an integer. And then
we're going to proceed, assuming

418
00:22:43.530 --> 00:22:46.380
that it's an integer. And
because you have this linear

419
00:22:46.710 --> 00:22:50.790
loop body fragment, this is
trace. You can consolidate the

420
00:22:50.790 --> 00:22:53.880
guards. You can eliminate guards.
You don't need, you can

421
00:22:53.940 --> 00:22:57.990
consolidate various kinds of loads
and stores and you can

422
00:22:57.990 --> 00:23:01.650
make the code very tight.
How much faster can this

423
00:23:01.650 --> 00:23:03.570
get? I mean, how much
headroom is there? Is there

424
00:23:03.570 --> 00:23:06.660
another factor of 10 improvement
that's hiding somewhere? Or, I

425
00:23:06.660 --> 00:23:09.000
mean, when, when are we
going to say we're done?

426
00:23:10.380 --> 00:23:13.230
So are these micro benchmarks
we're getting close to sort

427
00:23:13.230 --> 00:23:16.830
of the speed of a
unoptimized C compiler? I think

428
00:23:16.830 --> 00:23:19.650
Mike shaver shows in his
blog running GCC with a

429
00:23:19.800 --> 00:23:22.140
minus Oh zero or some,
you know, turn off the

430
00:23:22.140 --> 00:23:24.870
optimizer. And we were getting
close to that. So we

431
00:23:24.870 --> 00:23:26.640
don't need to go 10
X faster. We're going to

432
00:23:26.640 --> 00:23:29.910
hit the speed limits that
are inherent in the machine

433
00:23:29.910 --> 00:23:32.490
code. You know, hand tuned
machine code can be to

434
00:23:32.490 --> 00:23:34.260
seek and power still, but
it's really not worth it.

435
00:23:36.120 --> 00:23:37.980
If you're going to see
two X improvements or three

436
00:23:37.980 --> 00:23:41.460
X linear, small factors, we
haven't even got a decent

437
00:23:41.460 --> 00:23:44.310
register allocator and trace monkey.
Yet we haven't done some

438
00:23:44.310 --> 00:23:48.680
redundant garden and load and
store elimination, optimizations that are

439
00:23:48.740 --> 00:23:51.290
easy to do. They're just
work that we haven't had

440
00:23:51.290 --> 00:23:53.240
time to get to yet.
And when we get to

441
00:23:53.240 --> 00:23:56.390
them, you'll see doubling and
tripling, I think. And that

442
00:23:56.390 --> 00:23:59.840
will help because apart from
the benchmarks where we're falling

443
00:23:59.840 --> 00:24:01.940
off the trace and you
see our speed in the

444
00:24:01.940 --> 00:24:05.390
sort of long tail presentation
on my blog, get back

445
00:24:05.390 --> 00:24:07.180
to where the interpreter is.
We would be great as

446
00:24:07.180 --> 00:24:10.490
the interpreter, essentially, we don't
get any getting better speed

447
00:24:10.490 --> 00:24:13.970
up as, as we get
those cases covered, we'll start

448
00:24:13.970 --> 00:24:16.070
to get speed ups and
those benchmarks too. And then

449
00:24:16.070 --> 00:24:17.870
I think across the board,
you'll see this sort of

450
00:24:18.380 --> 00:24:21.470
10 to 2030 X speed
up from what was in

451
00:24:21.470 --> 00:24:24.910
Firefox three, which was just
the interpreter. Now, doesn't it

452
00:24:24.910 --> 00:24:27.790
seem like we're talking about
theoretical stuff. We're talking about

453
00:24:28.060 --> 00:24:31.240
JavaScript as a language, doing
things like, like Ray tracing,

454
00:24:31.240 --> 00:24:33.340
but you know, who's really
gonna rate trace with JavaScript.

455
00:24:33.550 --> 00:24:35.950
Doesn't it? I mean, with
any language things get slow

456
00:24:35.950 --> 00:24:38.500
when you hit the disc.
And in this instance, JavaScript

457
00:24:38.500 --> 00:24:41.530
hitting quote unquote for disc
is talking to the Dom,

458
00:24:41.980 --> 00:24:44.070
are we then going to
move our focus towards Dominic

459
00:24:44.080 --> 00:24:47.530
isolation as being, being faster?
Cause that's when JavaScript is

460
00:24:47.530 --> 00:24:50.980
as fast as C things
are going to get slow.

461
00:24:50.980 --> 00:24:53.140
When we start generating our
dibs dynamically and all that

462
00:24:53.140 --> 00:24:54.760
kind of stuff. When we
start doing our jQuery work,

463
00:24:55.840 --> 00:24:58.210
That's true. And so we're
working on tracing into the

464
00:24:58.210 --> 00:25:01.420
Dom because the same sort
of beautiful specialization you can

465
00:25:01.420 --> 00:25:05.080
do with this, this trace
tree approach that Andre scout

466
00:25:05.080 --> 00:25:08.590
pioneer applies to the dong
code. In fact, the Don

467
00:25:08.590 --> 00:25:10.420
code in most browsers is
a bunch of C plus

468
00:25:10.420 --> 00:25:13.120
plus and it's object oriented
C plus plus. So it

469
00:25:13.120 --> 00:25:15.850
has what are called virtual
methods. So it, it has

470
00:25:15.850 --> 00:25:19.900
some amount of polymorphism, some
amount of, of the ability

471
00:25:19.900 --> 00:25:22.870
to make similar types look
like a single type, and

472
00:25:22.870 --> 00:25:24.820
that has a cost to
it. But the bad thing

473
00:25:24.820 --> 00:25:27.250
about it is that apart
from any sort of profile

474
00:25:27.250 --> 00:25:30.340
guided optimization, you throw out
the compiler, it really doesn't

475
00:25:30.340 --> 00:25:33.160
know what's going on in
the trace, but if you

476
00:25:33.160 --> 00:25:35.080
could trace into the Dom,
then you could make the

477
00:25:35.080 --> 00:25:37.510
same sort of type speculations
that we're doing in the

478
00:25:37.510 --> 00:25:39.460
pure JavaScript world. And you
can make your Dom code

479
00:25:39.460 --> 00:25:42.670
go really fast. That's point
number one, number two is

480
00:25:42.670 --> 00:25:45.820
that there are elements like
the canvas tag that's in

481
00:25:46.180 --> 00:25:48.820
Firefox and as far as
an opera, and there are

482
00:25:48.820 --> 00:25:51.280
ways to sort of shim
it into I E and

483
00:25:51.280 --> 00:25:53.320
I hope Microsoft implements it
cause they, they can easily

484
00:25:53.320 --> 00:25:56.530
do it. The canvas tag
gives you a low level

485
00:25:56.530 --> 00:26:00.130
sort of rectangular programmable image,
and you can get different

486
00:26:00.130 --> 00:26:01.750
kinds of APIs to draw
to it. This is a

487
00:26:01.750 --> 00:26:06.640
standard 2d fin transform API,
there's other proposed API APIs.

488
00:26:06.640 --> 00:26:09.340
We have one that's open
G L E S for

489
00:26:09.370 --> 00:26:13.900
3d and texture shading, and
using the GPU. Even when

490
00:26:13.900 --> 00:26:16.600
you get really fast JavaScript
and the canvas tag, maybe

491
00:26:16.600 --> 00:26:18.220
you don't need a Dom.
Maybe you make your own

492
00:26:18.220 --> 00:26:20.860
Dom and JavaScript because Hey,
the thumb is just an

493
00:26:20.860 --> 00:26:22.810
old standard from the nineties.
Do we, do we really

494
00:26:22.810 --> 00:26:25.120
think that's the last word
on object models? And certainly

495
00:26:25.120 --> 00:26:27.280
not for games, games have
their own scene graphs and

496
00:26:27.280 --> 00:26:30.190
their own ways of doing,
you know, a level of

497
00:26:30.190 --> 00:26:34.780
detail. So I think super
fast JavaScript plus canvas is

498
00:26:34.780 --> 00:26:36.430
going to be huge. You're
going to see not only

499
00:26:36.430 --> 00:26:40.930
games, but sort of visualization
tools and, and all sorts

500
00:26:40.930 --> 00:26:43.890
of things. Well, doesn't that
mean? If you add canvas,

501
00:26:44.100 --> 00:26:46.560
you have super fast JavaScript
and you have video, you

502
00:26:46.560 --> 00:26:49.200
have HTML five and the
video tag don't what do

503
00:26:49.200 --> 00:26:52.880
you need a flex? And
Silverlight for, That's a good

504
00:26:52.880 --> 00:26:57.500
question. And Adobe has been
a good partner, certainly contributing

505
00:26:57.500 --> 00:27:00.350
Tamar. And we used the
Tameron tracing nano jet as

506
00:27:00.350 --> 00:27:03.200
a big boost to trace
monkey development. It's a little

507
00:27:03.200 --> 00:27:06.770
backend for recording traces at
a low level and generating

508
00:27:06.770 --> 00:27:10.910
machine code. It's sort of
low level intermediate form code

509
00:27:10.910 --> 00:27:14.990
back end cogeneration backend. So
we, we have to make

510
00:27:14.990 --> 00:27:17.360
browsers better. It's just in
our DNA. The web has

511
00:27:17.360 --> 00:27:19.490
to evolve and it is
evolving. And at some point

512
00:27:19.490 --> 00:27:23.150
I think this, this becomes
disruptive to things like flash

513
00:27:23.150 --> 00:27:26.060
and Silverlight now flash still
has lots of value to

514
00:27:26.060 --> 00:27:28.730
offer. And, you know, Silverlight
is in many ways a

515
00:27:28.730 --> 00:27:32.360
flash quote. So those will
be around. They have tools,

516
00:27:32.390 --> 00:27:35.520
find tools that I don't
think anybody's really seen on

517
00:27:35.550 --> 00:27:38.300
the open website of it
though. Aptana and the open

518
00:27:38.300 --> 00:27:42.290
Ajax guys, you know, there's
efforts there, our own efforts

519
00:27:42.290 --> 00:27:44.720
and tools have been more
about doing it by hand,

520
00:27:44.720 --> 00:27:47.270
but also Firebug this sort
of integrated debugger that gives

521
00:27:47.270 --> 00:27:50.690
you complete visibility on the
sort of computed styles and

522
00:27:50.690 --> 00:27:54.140
the cascade of CSS styles
and gives you a little

523
00:27:54.140 --> 00:27:56.380
ways to tweak things and,
and see all the, the

524
00:27:56.540 --> 00:28:00.560
network latencies in your HTTP
requests. We're going to work

525
00:28:00.560 --> 00:28:02.540
on Firebag, we're investing more
in it and we're going

526
00:28:02.540 --> 00:28:04.520
to make it even better.
And I think JavaScript debugging

527
00:28:04.520 --> 00:28:06.770
is going to become really
good. Like you'll, you'll get

528
00:28:07.280 --> 00:28:09.530
time traveling debuggers. So let
you go back and see

529
00:28:09.530 --> 00:28:13.310
where that bad value came
from. Things like that. So

530
00:28:14.330 --> 00:28:16.700
I think there'll be a
lot of coexistence among flashover

531
00:28:16.700 --> 00:28:19.010
light and the open web,
but, and this is what

532
00:28:19.010 --> 00:28:21.020
I'm working on. So maybe
I'm biased. I think the

533
00:28:21.020 --> 00:28:25.820
open web will become just
as competent. Maybe not quite

534
00:28:25.820 --> 00:28:29.390
as coherent. When you have
these single vendor proprietary stacks,

535
00:28:29.390 --> 00:28:32.420
you can make something that's
laser light, coherent, as far

536
00:28:32.420 --> 00:28:37.040
as developer docs and polished
API and a tool experience.

537
00:28:37.040 --> 00:28:39.830
That's really nice. You asked
about things like five down

538
00:28:39.830 --> 00:28:43.070
auto complete Firebug just has
a bunch of tables of

539
00:28:43.070 --> 00:28:48.140
well-known Dom property names and
JavaScript keywords. And you can

540
00:28:48.140 --> 00:28:51.860
go a long way with
that. So depending on, on

541
00:28:51.860 --> 00:28:55.100
the nature of the dynamic
language and whether you really

542
00:28:55.100 --> 00:28:58.460
need those type annotations to
go fast, maybe we can

543
00:28:58.550 --> 00:29:02.630
do sort of a 90%
case versus better case that

544
00:29:03.530 --> 00:29:05.720
has good tools. And I
think that's, that's something to

545
00:29:05.720 --> 00:29:08.210
work on. The webs OpenWeb
tooling is not where it

546
00:29:08.210 --> 00:29:10.820
should be worked to get
where it should be. I

547
00:29:10.820 --> 00:29:12.830
don't think it would look
exactly like eclipse. I think

548
00:29:12.830 --> 00:29:15.200
it would be lighter weight.
I think it might be

549
00:29:15.200 --> 00:29:19.040
a more integrated in where
like Firebug Yeah, so it

550
00:29:19.040 --> 00:29:22.490
sounds like five years down
the road, JavaScript is C

551
00:29:22.490 --> 00:29:27.380
speed. It's competitive with flash
and server light. And maybe

552
00:29:27.380 --> 00:29:29.180
not even as coherent on
the page, cause certainly with

553
00:29:29.180 --> 00:29:30.950
flash and Silverlight you kind
of draw a square and

554
00:29:30.950 --> 00:29:32.750
you say that this is
where flashes, and this is

555
00:29:32.750 --> 00:29:34.790
where several light is in
the nose. There's bridges that

556
00:29:34.790 --> 00:29:37.130
go back and forth. But
I assume you think that

557
00:29:37.130 --> 00:29:39.890
there's a benefit to having
no having no bridge to

558
00:29:39.950 --> 00:29:41.950
not having to jump inside
or out of the, the

559
00:29:41.950 --> 00:29:45.420
object tag? I think so.
I mean the podium vendors,

560
00:29:45.480 --> 00:29:48.600
and I say this as
someone who appreciates flash for

561
00:29:48.600 --> 00:29:51.240
what it does, when you,
when you encounter a flash

562
00:29:51.240 --> 00:29:53.760
plugging, you may not have
the events work, right. Or

563
00:29:53.760 --> 00:29:56.400
the tab key might not
take focus into the plug

564
00:29:56.400 --> 00:29:58.020
in or take it out
again, these are bugs that

565
00:29:58.020 --> 00:29:59.790
we're working on with Adobe,
we're trying to fix, but

566
00:29:59.790 --> 00:30:02.130
there will always be such
bugs because you have the

567
00:30:02.130 --> 00:30:04.020
separate code base of the
plugin and you have this

568
00:30:04.320 --> 00:30:07.020
sort of narrow plugging API
that we've been working to

569
00:30:07.020 --> 00:30:11.040
evolve that which goes back
to Netscape Netscape 1.1 release.

570
00:30:11.040 --> 00:30:14.550
I think so for or
on Microsoft side, you have

571
00:30:14.550 --> 00:30:18.420
active X. There's just sort
of the plugin is the

572
00:30:18.420 --> 00:30:22.770
other in some politically incorrect
sense. And it, it, it

573
00:30:22.890 --> 00:30:25.110
gets put in the penalty
box in various ways. Or

574
00:30:25.440 --> 00:30:27.660
if you build all your
code on the plugin side,

575
00:30:27.690 --> 00:30:29.520
then the browser seems like
it's in the penalty box

576
00:30:29.520 --> 00:30:33.120
and it seems less, less
polished and less flashy. So

577
00:30:33.850 --> 00:30:36.330
this, this kind of seemed
full experience is, is an

578
00:30:36.330 --> 00:30:39.000
app amount of designers and
a lot of users. So

579
00:30:39.000 --> 00:30:41.310
I think it should go
away and the market forces

580
00:30:41.310 --> 00:30:43.440
will tend to make it
go away over time. How

581
00:30:43.440 --> 00:30:45.420
are we going to get
out of a backward compatibility?

582
00:30:45.420 --> 00:30:47.640
I mean, isn't navigator dot
plugins and its all of

583
00:30:47.640 --> 00:30:49.650
its history and all of
its quirks and its lack

584
00:30:49.650 --> 00:30:53.220
of clean versioning and people
splitting open the descriptions to

585
00:30:53.220 --> 00:30:55.260
look for tunneled versions and
all those kinds of things

586
00:30:55.470 --> 00:30:56.880
are they're going to be
with us forever. I mean

587
00:30:56.880 --> 00:31:00.840
there's backward compatibility and JavaScript.
That seems like it's hamstrung

588
00:31:00.840 --> 00:31:04.200
it's, it'll be there forever.
Don't you think It could

589
00:31:04.200 --> 00:31:08.670
be? The web is a
shortest path evolution plus compatibility

590
00:31:08.670 --> 00:31:11.100
til it hurts. But you
know, it's changed the way

591
00:31:11.130 --> 00:31:14.310
you look at pages from
10 or 12 years ago

592
00:31:14.310 --> 00:31:17.400
that used the tables of
that era and maybe they

593
00:31:17.400 --> 00:31:20.940
use spacer images. They don't
work right now. And that's

594
00:31:20.940 --> 00:31:24.270
a good thing. So you
find that the intersection semantics

595
00:31:24.270 --> 00:31:29.010
between the browser's moves and
what developers target moves and

596
00:31:29.010 --> 00:31:32.940
you know, we're done with
<inaudible>. I think different locales

597
00:31:32.940 --> 00:31:35.130
may have different opinions on
that one, but I six

598
00:31:35.130 --> 00:31:38.100
is still kind of an
albatross hope. It goes away.

599
00:31:38.100 --> 00:31:41.760
Soon things like Google gears
will help to uplift new

600
00:31:41.760 --> 00:31:45.390
web features into it. The
mobile web will will cause

601
00:31:45.390 --> 00:31:50.820
I think a big shift
toward more modern implementations of

602
00:31:50.820 --> 00:31:53.760
web standards because I think
the iPhone did open people's

603
00:31:53.760 --> 00:31:56.340
eyes that even though there's
a fair amount of iPhone,

604
00:31:56.340 --> 00:31:58.650
only content is not quite
open web, but some of

605
00:31:58.650 --> 00:32:01.380
it's tied into, you know,
the exact screen dimensions to

606
00:32:01.390 --> 00:32:04.740
the iPhone or even to
Apple's platform, but be that

607
00:32:04.740 --> 00:32:06.540
as it may, they did
move people away from sort

608
00:32:06.540 --> 00:32:10.400
of the whap WML, you
know, mobile web. This is

609
00:32:10.410 --> 00:32:12.510
the thing that was still
kind of a threat to

610
00:32:12.510 --> 00:32:15.780
the open web a couple
of years ago. So mobile

611
00:32:15.780 --> 00:32:19.230
is going to, I think
help modernize standard support and

612
00:32:19.260 --> 00:32:24.690
obsolete old web content that
just isn't isn't worth keeping

613
00:32:24.690 --> 00:32:27.240
compatibility with, but you can't
really predict this. This is

614
00:32:27.240 --> 00:32:29.580
something that I keep saying
in the context of JavaScript,

615
00:32:29.580 --> 00:32:31.830
you have to be careful
not to try to say,

616
00:32:31.860 --> 00:32:34.350
Oh, we broke compatibility and
you should know better. You

617
00:32:34.350 --> 00:32:37.350
should go use our new
feature. Y instead of that

618
00:32:37.350 --> 00:32:40.250
battle feature X, but that
doesn't work often. You're not

619
00:32:40.250 --> 00:32:42.620
even talking to a developer.
The developer resilient was a

620
00:32:42.620 --> 00:32:44.900
contractor on a gig five
years ago and they're long

621
00:32:44.900 --> 00:32:47.720
gone. All you've done is
make the user suffer. You

622
00:32:47.720 --> 00:32:50.120
know, your mom at home,
the page doesn't work. Right.

623
00:32:50.150 --> 00:32:52.280
What good did you do?
So compatibility has to be

624
00:32:52.280 --> 00:32:54.740
kept until it hurts, but
you have to keep using

625
00:32:54.770 --> 00:32:58.580
the carrot of innovative new
features and can keep competitive

626
00:32:58.580 --> 00:33:03.800
browsers being numerous being used
in contexts like the mobile

627
00:33:03.800 --> 00:33:08.210
web and in desktop settings,
like Firefox is compete and

628
00:33:08.480 --> 00:33:11.860
good things will happen. Okay.
That's fantastic. I got one

629
00:33:11.860 --> 00:33:14.290
last question. I know you've
got to go, but what

630
00:33:14.290 --> 00:33:16.690
do you think of jQuery?
And do you think that

631
00:33:16.690 --> 00:33:18.760
jQuery and some of the
framework that kind of explosion

632
00:33:18.760 --> 00:33:21.520
of frameworks really kind of
raise the water level and

633
00:33:21.520 --> 00:33:24.490
kind of reminded people that
JavaScript was still out there?

634
00:33:24.490 --> 00:33:27.010
Was it the popularity and
the flexibility of those frameworks

635
00:33:27.010 --> 00:33:29.500
that, that reminded people that
you could really do some

636
00:33:29.500 --> 00:33:33.070
powerful stuff with JavaScript? Oh,
I love jQuery and I

637
00:33:33.070 --> 00:33:36.220
should give a disclaimer, John
Reznik works for Mozilla and

638
00:33:36.280 --> 00:33:39.070
he is just very bright
and great. It's wonderful to

639
00:33:39.070 --> 00:33:40.720
see them do demos. He'll
do them without a net

640
00:33:40.720 --> 00:33:42.520
in his editor and then
he'll reload and show the

641
00:33:42.520 --> 00:33:45.370
effects that jQuery has. And
he did amazing stuff with

642
00:33:45.370 --> 00:33:48.670
processing this visualization language from
MIT. Yeah. We had John

643
00:33:48.670 --> 00:33:51.370
LASIK on the show last
week. Did, did he work

644
00:33:51.370 --> 00:33:54.070
for Mozilla when he wrote
jQuery? We got him. I

645
00:33:54.070 --> 00:33:55.630
think after he wants to
say queer. I remember I

646
00:33:55.630 --> 00:34:00.310
met him at the, the
Ajax experience in 2006 in

647
00:34:00.310 --> 00:34:02.890
Boston in the fall. And
I thought, wow, another ATF

648
00:34:02.890 --> 00:34:06.190
library, isn't it too late.
But of course jQuery is

649
00:34:06.190 --> 00:34:09.100
really just zoomed the prominence
since then, you know, you

650
00:34:09.100 --> 00:34:13.420
have to give credit to
dojo and prototype and others

651
00:34:13.420 --> 00:34:16.090
that came before. I have
a soft spot for mochi

652
00:34:16.090 --> 00:34:18.820
kit. All these are good.
We're still in the early

653
00:34:18.820 --> 00:34:21.880
days. So people are not
just building better agents, libraries

654
00:34:21.880 --> 00:34:24.760
like jQuery. They're also building
plugins for there were higher

655
00:34:24.760 --> 00:34:27.460
level, no turtles on the
backs of turtles to do

656
00:34:27.460 --> 00:34:29.800
things like make it really
easy to not just build

657
00:34:30.160 --> 00:34:33.190
your user interface or a
widget, but your whole app.

658
00:34:33.520 --> 00:34:35.590
And we're seeing that now
that kind of evolution with

659
00:34:35.590 --> 00:34:39.640
JavaScript frameworks coming online and
it's pretty exciting times. So,

660
00:34:40.270 --> 00:34:41.680
So it doesn't seem to
me like you think that

661
00:34:41.680 --> 00:34:43.900
we're anywhere near the top
of the popularity curve of

662
00:34:43.900 --> 00:34:48.790
JavaScript? No, I think that,
that just now with these

663
00:34:48.790 --> 00:34:51.550
high performance engines, people are
starting to think, but when

664
00:34:51.550 --> 00:34:53.320
they actually get them in
their hands and can use

665
00:34:53.320 --> 00:34:57.520
them, it's just going to
be amazing. Fantastic. Well, thank

666
00:34:57.520 --> 00:34:59.140
you so much, Brendan. Eich
for sitting down with me

667
00:34:59.140 --> 00:35:03.250
today. I really appreciate your
time. My pleasure. This has

668
00:35:03.250 --> 00:35:05.530
been another episode of Hansel
minutes and we'll see you

669
00:35:05.530 --> 00:35:06.310
again next week.


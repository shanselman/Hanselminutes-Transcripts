WEBVTT FILE

1
00:00:00.120 --> 00:00:02.700
Sick of waiting for your
CIA test to pass or

2
00:00:02.700 --> 00:00:06.330
having to manage different CII
servers for different teams using

3
00:00:06.330 --> 00:00:09.750
Buildkite. You can run fast
and reliable CIA pipelines for

4
00:00:09.750 --> 00:00:13.440
every type of project, whether
it's backend tests, mobile apps,

5
00:00:13.440 --> 00:00:16.620
or even custom hardware build
kites agent helps you scale

6
00:00:16.620 --> 00:00:19.710
to thousands of parallel jobs
and your secrets and source

7
00:00:19.710 --> 00:00:23.850
code never leave your infrastructure.
There's great documentation, a clean

8
00:00:23.850 --> 00:00:27.510
web UI, and plugins for
different types of tools. Visit

9
00:00:27.570 --> 00:00:32.880
Buildkite that's K I T
e.com/hanselman for a 14 day

10
00:00:32.880 --> 00:00:36.300
free trial. And see how
Shopify has scaled from 300

11
00:00:36.330 --> 00:00:40.290
to 1500 engineers while keeping
their build times under five

12
00:00:40.290 --> 00:00:59.430
minutes, that's built kite.com/hanselman. Hi,
this is Scott Hanselman. This

13
00:00:59.430 --> 00:01:01.740
is another episode of Hansel
minutes today. I'm talking with

14
00:01:01.770 --> 00:01:05.910
Carol Nichols. She's the owner of
the 32 consultancy. The author

15
00:01:05.910 --> 00:01:08.940
of the rust programming language
book was Steve <inaudible> as

16
00:01:08.940 --> 00:01:12.300
well as the wonderful rust
in motion video series. How

17
00:01:12.300 --> 00:01:15.710
are you? Great, thank you
for having me on. So

18
00:01:15.710 --> 00:01:18.530
you're a rust core contributor.
What does that mean to

19
00:01:18.530 --> 00:01:21.770
be a core contributor? I
am part of the core

20
00:01:21.770 --> 00:01:27.380
team, which is the team
that makes overarching decisions having

21
00:01:27.380 --> 00:01:32.300
to do with the projects.
So there's the compiler team

22
00:01:32.300 --> 00:01:35.300
and the language team do
a lot of the technical

23
00:01:35.300 --> 00:01:39.050
work as far as evolving
the language and maintaining the

24
00:01:39.050 --> 00:01:42.830
compiler. The core team is
more of the, what is

25
00:01:42.830 --> 00:01:47.690
the direction of the projects?
What do we want to

26
00:01:47.690 --> 00:01:53.360
say as far as describing
Russ evolution? How do we

27
00:01:54.680 --> 00:01:59.870
talk with production users? Things
like that. Is, is that

28
00:01:59.870 --> 00:02:02.240
something that one is like
nominated for? Or do you

29
00:02:02.240 --> 00:02:04.190
just kind of like sidle
into the job? How does

30
00:02:04.190 --> 00:02:06.320
one become a core member?
Is that like, cause there's

31
00:02:06.320 --> 00:02:07.670
a lot of people who
are listening who want to

32
00:02:07.670 --> 00:02:09.920
get involved in open source
and it's all that they

33
00:02:09.920 --> 00:02:12.530
can think about to like
maybe fix a spelling error

34
00:02:12.530 --> 00:02:15.380
in the docs. How does
one make themselves known and

35
00:02:15.380 --> 00:02:17.630
then work their way up
to effectively? What is leading?

36
00:02:18.290 --> 00:02:22.940
Yeah. So a lot of
the core team members are

37
00:02:23.690 --> 00:02:29.270
leaders of some of the
sub teams. And, but not

38
00:02:29.270 --> 00:02:33.800
everyone. I kind of got
invited by doing a whole

39
00:02:33.800 --> 00:02:37.640
bunch of work that no
one else was doing. And

40
00:02:37.640 --> 00:02:41.690
that got noticed, and I
got asked to join the

41
00:02:41.690 --> 00:02:46.730
core team. So in general,
I think we're, we're still

42
00:02:46.730 --> 00:02:48.890
trying to figure out how
we want the project to

43
00:02:48.890 --> 00:02:52.010
rerun. That's one of the
things we're struggling with on

44
00:02:52.010 --> 00:02:55.520
the core team is how
should the governance of this

45
00:02:55.520 --> 00:02:58.610
big open source project work.
And so it's been pretty

46
00:02:58.610 --> 00:03:03.340
ad hoc, but in general,
if you like the different

47
00:03:03.340 --> 00:03:07.240
teams that have different responsibilities,
usually have a meeting, mostly

48
00:03:07.240 --> 00:03:11.470
in chat, sometimes on video
to discuss the kinds of

49
00:03:11.530 --> 00:03:14.590
things that we want to
work on together as a

50
00:03:14.590 --> 00:03:21.640
team and often teams have
smaller issues or, or ways

51
00:03:21.640 --> 00:03:24.340
people can help out, or
you see people in the

52
00:03:24.340 --> 00:03:26.620
meeting saying, Oh, I wish
I wish we had time

53
00:03:26.620 --> 00:03:30.040
to do this. And that's
a great opportunity to jump

54
00:03:30.040 --> 00:03:35.440
in and get involved in
things. And if you keep

55
00:03:35.530 --> 00:03:39.250
showing up and keep doing
work, people will notice that

56
00:03:39.250 --> 00:03:43.720
because it's pretty rare, which
I understand as like it,

57
00:03:44.110 --> 00:03:46.210
most people don't have very
much time to spend on

58
00:03:46.210 --> 00:03:48.550
open source. So you get
a PR in here, up

59
00:03:48.550 --> 00:03:50.650
here and there, but if
you have the time to

60
00:03:50.650 --> 00:03:53.980
dedicate to it, people will
take notice. And the more

61
00:03:53.980 --> 00:03:58.270
work you do, the more
work you'll get as you

62
00:03:58.750 --> 00:04:02.710
show yourself to be someone
who enjoys and has time

63
00:04:02.710 --> 00:04:06.010
and is capable of doing
what needs to be done

64
00:04:06.010 --> 00:04:09.520
to keep the project moving.
And that's kind of how

65
00:04:09.520 --> 00:04:13.600
you get rewarded with leaders,
shift positions so far, what,

66
00:04:13.600 --> 00:04:15.630
from what I've seen, It
sounds like what I tell

67
00:04:15.630 --> 00:04:17.430
my kids is that it's
like a big part of

68
00:04:17.430 --> 00:04:20.220
success is just showing up.
But then of course, figuring

69
00:04:20.220 --> 00:04:21.840
out how you can find
the time to show up

70
00:04:21.840 --> 00:04:24.690
while also having a life
is challenging. Everyone in opensource

71
00:04:24.690 --> 00:04:27.990
has that has that issue.
Now, have you found the

72
00:04:27.990 --> 00:04:29.520
time to show up because
this is something that you're

73
00:04:29.520 --> 00:04:35.460
using in your consultancy? Yes.
That's definitely something that motivated

74
00:04:35.460 --> 00:04:37.950
me to start my own
company is that I can

75
00:04:37.950 --> 00:04:42.870
choose to not be earning
money and spend some time

76
00:04:42.870 --> 00:04:46.140
on open source. A lot
of the team members are

77
00:04:46.140 --> 00:04:49.710
lucky enough to be employed.
My <inaudible> who employs most

78
00:04:49.710 --> 00:04:52.590
of the people who work
full time on rust. There

79
00:04:52.590 --> 00:04:57.030
are some other companies who
let people spend time on

80
00:04:57.630 --> 00:05:01.620
working on open source Russ
stuff. And that's another way

81
00:05:01.710 --> 00:05:06.150
that people get time to
work on Russ things. But

82
00:05:06.180 --> 00:05:09.210
yeah, I'm, I'm very lucky
to have a lot of

83
00:05:09.210 --> 00:05:12.690
savings, not need to work
a hundred percent of my

84
00:05:12.690 --> 00:05:16.350
time so that I have,
I'm able to contribute to

85
00:05:16.350 --> 00:05:18.570
open source because I think
open source in general is

86
00:05:18.570 --> 00:05:22.830
really important. And I think
Rustin particular is a worthwhile

87
00:05:23.310 --> 00:05:27.000
way to spend my time.
Rust is a work worthwhile

88
00:05:27.000 --> 00:05:29.070
way to spend your time.
It's been around for nine

89
00:05:29.070 --> 00:05:32.100
years and it's some people
have said it smells like,

90
00:05:32.100 --> 00:05:35.970
or it is syntactically similar
to C plus plus why

91
00:05:36.060 --> 00:05:39.690
was C plus plus lacking?
And why did someone at

92
00:05:39.690 --> 00:05:43.140
Mozilla need to make rest?
What was, what was wrong

93
00:05:43.140 --> 00:05:44.670
with C plus plus? And
what does Russ try to

94
00:05:44.670 --> 00:05:50.550
solve? So Russ is trying
to solve memory safety problems.

95
00:05:51.210 --> 00:05:53.190
It's trying to be a
replacement for both CNC plus

96
00:05:53.190 --> 00:05:58.070
plus, and B memory safe
across threads as well though.

97
00:05:58.100 --> 00:06:01.190
I would say those are
the big aspects of Russ

98
00:06:01.200 --> 00:06:05.780
that are different. The memory
safety is achieved through this

99
00:06:05.780 --> 00:06:11.420
system of ownership that makes
sure there's only one owner

100
00:06:11.420 --> 00:06:13.370
of a piece of data
at a time. And that

101
00:06:13.430 --> 00:06:18.830
owner is responsible for cleaning
up that data, which those

102
00:06:18.830 --> 00:06:22.370
cleanups are, are inserted by
the compiler so that you

103
00:06:22.370 --> 00:06:28.070
aren't doing operations like Alec
and free, which people mess

104
00:06:28.070 --> 00:06:32.360
up all the time. And
those ownership rules extend across

105
00:06:32.360 --> 00:06:35.810
threads. And the type system
of rest helps enforce that.

106
00:06:36.320 --> 00:06:42.080
So where race conditions, data
races are very easy to

107
00:06:42.080 --> 00:06:45.290
do in C plus plus
and C plus plus is

108
00:06:45.290 --> 00:06:51.020
getting things like the shared
pointers, smart pointers that do

109
00:06:51.020 --> 00:06:54.110
some of this logic, but
rust has it built into

110
00:06:54.110 --> 00:06:58.790
everything by default. So whereas
you have to upgrade your

111
00:06:58.790 --> 00:07:01.010
C plus plus to the
newest version. Then you have

112
00:07:01.010 --> 00:07:04.790
to choose to use the
shared pointers. This is an

113
00:07:04.790 --> 00:07:08.420
abstraction, that's the default to
use in rust. So I

114
00:07:08.420 --> 00:07:12.260
feel like the whole mental
model is different and the

115
00:07:12.260 --> 00:07:16.280
abstractions are built such that
the default is both safe

116
00:07:16.310 --> 00:07:20.470
and fast to use. Then
when people are moving from

117
00:07:20.470 --> 00:07:22.990
C or C plus plus,
or whatever they learned in

118
00:07:22.990 --> 00:07:24.880
school, and then they enter
into the kind of the

119
00:07:24.880 --> 00:07:28.510
world and they start using
go or Java or.net. And

120
00:07:28.510 --> 00:07:31.150
they think that there's two
choices of how one does

121
00:07:31.150 --> 00:07:33.910
memory. There's like a slider
bar and slider bars are

122
00:07:33.910 --> 00:07:37.030
supposed to have like multiple
stops. They're supposed to slide.

123
00:07:37.030 --> 00:07:39.340
But people think that the
slider bar has two choices,

124
00:07:39.340 --> 00:07:41.410
which makes it effectively a
slider bar. That's a checkbox

125
00:07:41.410 --> 00:07:43.990
where it's like, well, either
allocate your own memory or

126
00:07:43.990 --> 00:07:46.900
have a really sophisticated garbage
collector. And there's nothing in

127
00:07:46.900 --> 00:07:50.320
between. It seems like rust
tries to find a better

128
00:07:50.320 --> 00:07:54.310
compromise. Yeah. We're trying to
break the slider into pieces,

129
00:07:54.730 --> 00:07:57.820
be off the slider. A
lot of resources. We talk

130
00:07:57.820 --> 00:08:01.300
about taking tradeoffs that seem
like they're going to, they

131
00:08:01.300 --> 00:08:03.820
have to be one or
the other and saying, what

132
00:08:03.820 --> 00:08:06.340
if it doesn't, what if
we can have both? And

133
00:08:06.760 --> 00:08:11.500
it's been amazing to watch,
watch it evolve. And I

134
00:08:11.530 --> 00:08:15.910
get to use this language
that defies these expectations and,

135
00:08:16.000 --> 00:08:19.450
and makes these trade offs
moot. Hmm. So when I

136
00:08:19.450 --> 00:08:22.690
was doing C and embedded
systems work, I allocate my

137
00:08:22.690 --> 00:08:25.780
own memory. And if I
was a mediocre programmer, which

138
00:08:25.780 --> 00:08:28.840
I am somewhere else, you
know, I would go and

139
00:08:28.840 --> 00:08:32.070
free it. And then you
you'd leak memory, or you

140
00:08:32.110 --> 00:08:34.930
had a whole class of
things, you know, no pointers,

141
00:08:34.960 --> 00:08:38.620
dangly pointers. And then in
the go java.net world, it's

142
00:08:38.620 --> 00:08:41.620
like, well, let's make someone
who's in charge of cleanup,

143
00:08:41.830 --> 00:08:46.180
like a janitor, which is
like, I'm sloppy. So we'll

144
00:08:46.180 --> 00:08:49.420
have a sloppy system clean
up. When you said a

145
00:08:49.420 --> 00:08:53.170
system of ownership, what does
that mean? So It's kind

146
00:08:53.170 --> 00:08:56.940
of like, if you, this
is a metaphor we use

147
00:08:56.940 --> 00:08:59.760
in our video video series,
instead of like having a

148
00:08:59.760 --> 00:09:02.070
janitor, walking around the party
all the time, asking are

149
00:09:02.070 --> 00:09:04.800
you done with that? That
you dump that? Can I

150
00:09:04.800 --> 00:09:07.290
clean this up? It's more
like, if you bring, you

151
00:09:07.290 --> 00:09:10.620
bring your covered dish to
the potluck and you are

152
00:09:10.620 --> 00:09:15.060
responsible for washing the dish
that you brought and cleaning

153
00:09:15.060 --> 00:09:18.800
up what you brought and
you can let other people

154
00:09:18.810 --> 00:09:21.600
use the food you brought
and the plates you bought.

155
00:09:21.930 --> 00:09:24.150
But at the end of
the night, it doesn't matter

156
00:09:24.150 --> 00:09:27.810
who used it. You're the
owner and you're responsible for

157
00:09:27.810 --> 00:09:29.730
cleaning it up and no
one else is going to

158
00:09:29.730 --> 00:09:31.530
do it for you. So
you don't have to worry

159
00:09:31.530 --> 00:09:34.860
about washing something twice. Once
you clean it up, no

160
00:09:34.860 --> 00:09:36.960
one else can use it.
You're going to take it

161
00:09:36.960 --> 00:09:41.010
home. And no one's going
to expect it to still

162
00:09:41.010 --> 00:09:45.450
be there. So I hope
that metaphor helps clear things

163
00:09:45.450 --> 00:09:47.240
up a little bit. No,
let's dig into that a

164
00:09:47.240 --> 00:09:50.840
little bit. So in the
memory, in the garbage collection

165
00:09:50.840 --> 00:09:54.710
world, it's just like chaos.
It's like, Ooh, I'm just

166
00:09:54.710 --> 00:09:56.720
making memory. And I worry
on someone else who is

167
00:09:56.720 --> 00:09:59.360
not me. There's a, we
always talk. We always talk

168
00:09:59.360 --> 00:10:02.450
about single responsibility principle when
we design our large systems,

169
00:10:02.450 --> 00:10:04.070
but no one ever wants
to be responsible for their

170
00:10:04.070 --> 00:10:07.130
own memory. And people are
just making lists and passing

171
00:10:07.130 --> 00:10:10.100
things around by reference and
everything's fine. And someone will

172
00:10:10.100 --> 00:10:12.920
figure it out. And until,
you know, gen one or

173
00:10:12.920 --> 00:10:15.860
gen two or gen three
of the garbage collector, pauses

174
00:10:15.860 --> 00:10:19.490
everything while we stop. And
the janitor cleans up after

175
00:10:19.490 --> 00:10:22.250
the party, and then we're
allowed to continue dancing. You're

176
00:10:22.250 --> 00:10:26.210
saying that with rust, the
compromise is you are in

177
00:10:26.210 --> 00:10:28.940
fact responsible, but it is
you and you alone who

178
00:10:28.940 --> 00:10:32.960
are responsible for your things.
No one else. Yes. And

179
00:10:33.350 --> 00:10:38.720
the compiler is taking care
of this. So any uses

180
00:10:38.720 --> 00:10:41.930
when the owner goes out
of scope, which is kind

181
00:10:41.930 --> 00:10:43.400
of like when you decide
you're going to leave the

182
00:10:43.400 --> 00:10:47.720
party, that's, that's when that
cleanup happens. So the compiler

183
00:10:47.720 --> 00:10:49.850
can see you're going out
of scope. This variable is

184
00:10:49.850 --> 00:10:52.280
going out of scope and
this memory can be cleaned

185
00:10:52.280 --> 00:10:54.740
up now. And the compiler
is going to check that

186
00:10:54.740 --> 00:10:57.800
no one else is currently
using that memory. And if,

187
00:10:58.370 --> 00:11:00.350
if you've written your code
in that way, it's going

188
00:11:00.350 --> 00:11:04.520
to refuse to compile. And
so these checks happen when

189
00:11:04.520 --> 00:11:07.970
you compile your code, it
inserts these statements to clean

190
00:11:07.970 --> 00:11:11.480
up exactly where it knows
that it's safe and correct

191
00:11:11.480 --> 00:11:16.610
to clean up. And there's
nothing happening. No, no determination

192
00:11:16.610 --> 00:11:19.880
of when that happens at
runtime running alongside your code.

193
00:11:20.270 --> 00:11:23.240
Now that's very interesting. So
for people who are listening,

194
00:11:23.240 --> 00:11:26.120
take a moment and absorb
that because a garbage collector

195
00:11:26.870 --> 00:11:31.040
at runtime determines that someone's
going to get and leave

196
00:11:31.040 --> 00:11:34.400
the party. But rust has
figured that out ahead of

197
00:11:34.400 --> 00:11:38.450
time and it's baked in.
So scope exiting happens and

198
00:11:38.450 --> 00:11:41.750
it's almost like an aspect
oriented programming with it. It

199
00:11:41.780 --> 00:11:44.210
looks at the code and
it injects in what would

200
00:11:44.210 --> 00:11:46.280
have been your manual free.
And does it, it does

201
00:11:46.280 --> 00:11:50.480
it for you. Yeah. It's
similar to the concept of

202
00:11:50.510 --> 00:11:55.240
our AI in C plus
plus, which is resource Acquisition

203
00:11:55.240 --> 00:12:00.510
is initialization. Yes. It's a
terrible acronym because to me

204
00:12:00.510 --> 00:12:05.850
it's more about cleaning up,
not the acquisition, that's it?

205
00:12:05.880 --> 00:12:09.090
It seems like when we
were talking about our AI

206
00:12:09.090 --> 00:12:12.870
resource acquisition is initialization in
the, in the late eighties,

207
00:12:13.290 --> 00:12:16.380
it was about accessing resources
where memory wasn't a resource,

208
00:12:16.380 --> 00:12:18.480
but maybe a port was
a resource or a file

209
00:12:18.480 --> 00:12:22.410
handle was a resource. You're
expanding that concept to memory

210
00:12:22.410 --> 00:12:24.690
itself, being a resource in
that, in that sense. And

211
00:12:24.690 --> 00:12:27.150
then do you include reference
counting as well, or you

212
00:12:27.150 --> 00:12:30.210
do not. There is a
reference counted type that you

213
00:12:30.210 --> 00:12:34.080
can choose to use. And
it works in an interesting

214
00:12:34.080 --> 00:12:37.770
way where it's considered a
smart pointer. And when the

215
00:12:37.780 --> 00:12:40.440
last you can have that,
lets you kind of have

216
00:12:40.440 --> 00:12:42.870
multiple owners. And when the
last one goes out of

217
00:12:42.870 --> 00:12:45.930
scope and the reference count
is zero, then it gets

218
00:12:45.930 --> 00:12:49.320
cleaned up. So it's still
kind of fits into this

219
00:12:49.350 --> 00:12:53.130
idea of scope and something
special happening when something goes

220
00:12:53.130 --> 00:12:56.100
out of scope, but you
can opt into doing roughly.

221
00:12:57.270 --> 00:13:01.800
Hmm. Hey friends. Backlog is
an all in one project

222
00:13:01.800 --> 00:13:04.710
and code management tool development
teams have been waiting for

223
00:13:05.250 --> 00:13:09.030
with project management, bug tracking
wikis and get rolled into

224
00:13:09.030 --> 00:13:12.990
one easy to use platform.
Backlog provides the powerful features

225
00:13:12.990 --> 00:13:16.560
that development teams need under
a clean UI that anyone

226
00:13:16.560 --> 00:13:20.520
can use. You can easily
onboard your whole team and

227
00:13:20.520 --> 00:13:24.750
start working on tasks in
minutes, additional features like Gantt

228
00:13:24.750 --> 00:13:27.720
and burdened down charts, make
it easy to manage projects.

229
00:13:28.350 --> 00:13:31.680
Mobile apps, keep your team
connected in simple pricing scales

230
00:13:31.680 --> 00:13:34.050
with you. So you can
stop worrying about per user

231
00:13:34.050 --> 00:13:38.700
charges, build your next project
with backlog. Get a 30

232
00:13:38.700 --> 00:13:45.900
day obligation free trial at
backlog.com/hansel minutes. That's BAC K

233
00:13:46.020 --> 00:13:53.550
L g.com/hansel minutes. There is
an interesting tweet earlier yesterday

234
00:13:53.580 --> 00:13:57.480
by Huda Katz, who said
there has been a little

235
00:13:57.480 --> 00:14:00.570
bit of a, like a
low key controversy going on

236
00:14:00.570 --> 00:14:02.700
Twitter. Cause there's always a
low key controversy going on

237
00:14:03.090 --> 00:14:05.370
where people have said, you
know, well, you know, rust

238
00:14:05.370 --> 00:14:08.490
got nothing done in 2019
and rust is boring and

239
00:14:08.490 --> 00:14:12.330
I love that even on
the rust homepage, it there's

240
00:14:12.330 --> 00:14:15.300
a, there's actually a wonderful
quote from Chris Dickinson from

241
00:14:15.300 --> 00:14:17.460
NPM that says my biggest
compliment to rust is that

242
00:14:17.460 --> 00:14:21.000
it's boring. And that's an
amazing compliment. And then you

243
00:14:21.000 --> 00:14:25.050
Huda says rust does something
that everyone said was impossible.

244
00:14:25.050 --> 00:14:27.660
When I started programming, being
able to write tens of

245
00:14:27.660 --> 00:14:31.860
thousands of lines of safe
code without the performance costs

246
00:14:31.890 --> 00:14:37.380
incurred by garbage collection. Do
you agree with that? Absolutely.

247
00:14:37.590 --> 00:14:40.410
I think I retweeted it
stepping back and thinking about

248
00:14:40.410 --> 00:14:44.250
that is really uplifting. I
guess when you're in the

249
00:14:44.310 --> 00:14:47.460
day to day of working
on something like this, it's

250
00:14:47.460 --> 00:14:50.880
hard to kind of step
back and, and remember that

251
00:14:51.590 --> 00:14:55.130
you're doing something useful. And
I really think I've, I've

252
00:14:55.130 --> 00:14:58.730
had the opportunity lately to
do a few talks about

253
00:14:58.730 --> 00:15:02.210
how I think rust is
moving the industry forward because

254
00:15:02.210 --> 00:15:06.080
these memory safety problems have
just caused so much, so

255
00:15:06.080 --> 00:15:11.120
many problems. And you said
you were mediocre primary programmer

256
00:15:11.120 --> 00:15:15.620
before. As many of us
are myself included, but even

257
00:15:15.680 --> 00:15:20.590
even the best seed programmers,
even the people who have

258
00:15:20.660 --> 00:15:26.390
learned every single rule that
about undefined behavior and you

259
00:15:26.390 --> 00:15:30.800
know, even people at NASA
who code review every line

260
00:15:30.800 --> 00:15:35.540
for an hour, even those
people make these mistakes in

261
00:15:35.540 --> 00:15:39.200
CNC. Plus plus that leads
to these memory safety problems.

262
00:15:39.650 --> 00:15:43.850
And we've known that this
happens for years and years

263
00:15:43.850 --> 00:15:47.180
and years. I think Microsoft,
someone from the Microsoft security

264
00:15:47.180 --> 00:15:51.470
team did like a survey
of all the windows security

265
00:15:51.470 --> 00:15:55.130
problems and 70% of them
over the last 12 years

266
00:15:55.130 --> 00:15:59.330
where the root cause was
memory safety problems. So like

267
00:15:59.330 --> 00:16:01.790
this is, we keep doing
the same thing over and

268
00:16:01.790 --> 00:16:05.270
over again. And I'm really
feel like rust is changing.

269
00:16:05.270 --> 00:16:08.840
That is trying to stop
making that mistake over and

270
00:16:08.840 --> 00:16:10.940
over again. And so that
we can make some new

271
00:16:10.940 --> 00:16:14.840
mistakes instead. So I really
feel like it's moving us

272
00:16:14.840 --> 00:16:17.750
forward. I'm really honored to
be working on it and

273
00:16:17.750 --> 00:16:20.230
be a part of it.
When we think about how

274
00:16:20.230 --> 00:16:22.990
in the eighties and when
people started really getting into

275
00:16:22.990 --> 00:16:26.140
C plus plus and thinking
about these problems and then

276
00:16:26.140 --> 00:16:29.140
10 years ago when rust
nine years ago in restaurants

277
00:16:29.140 --> 00:16:32.860
introduced. But, but there's still,
it still hasn't taken over

278
00:16:32.860 --> 00:16:34.810
the world. I mean, there's
a lot of enthusiasm around

279
00:16:34.810 --> 00:16:37.630
it, but people still write
C plus plus why isn't

280
00:16:37.630 --> 00:16:42.340
this a slam dunk? Why
isn't this like a viral

281
00:16:42.340 --> 00:16:45.310
concept that's taken over the
planet and we've written rewritten

282
00:16:45.310 --> 00:16:49.880
windows and all complicated systems
and rust. Well, the, the

283
00:16:49.900 --> 00:16:54.130
code that's existing, it is
existing and doing what it

284
00:16:54.130 --> 00:16:57.640
needs to do. And there's
a lot of legacy code

285
00:16:57.640 --> 00:17:00.670
out there and I'm very
sympathetic to, if it's not

286
00:17:00.760 --> 00:17:05.470
broken, don't fix it. So
the, the places that we're

287
00:17:06.100 --> 00:17:09.250
trying to get rust adopted
are the places that are

288
00:17:09.250 --> 00:17:13.150
still using CNC plus plus,
which is already kind of

289
00:17:13.150 --> 00:17:17.950
a legacy decision. And those
places are generally large enterprises

290
00:17:17.950 --> 00:17:21.940
that are very risk averse
and slow to move on

291
00:17:21.940 --> 00:17:26.530
anything. So I'm not at
all surprised that despite the

292
00:17:26.950 --> 00:17:31.090
enthusiasm for rust, our adoption
has been slow. And I

293
00:17:31.090 --> 00:17:35.830
think we're happy to be
around and be ready for

294
00:17:36.220 --> 00:17:39.370
the slow adoption because the
types of people we are

295
00:17:39.370 --> 00:17:42.880
trying to get to use
rust are not the type

296
00:17:42.880 --> 00:17:46.180
to make a quick decision.
You're right. This is not

297
00:17:46.180 --> 00:17:48.910
something that you just jump
into. No, it has there

298
00:17:48.910 --> 00:17:52.140
been talk of making the
OnRamp or the bridge between

299
00:17:52.140 --> 00:17:54.750
CNC plus plus to rush
more or easy? Is it

300
00:17:54.750 --> 00:17:56.460
naive of me to think
that if there were a

301
00:17:56.460 --> 00:18:01.250
converter, There are converters, there's
one called SITA to Russ

302
00:18:01.280 --> 00:18:05.390
that Galois has contributed to
the open source community. There's

303
00:18:05.480 --> 00:18:07.970
binge gen bind gen. I'm
never quite sure how to

304
00:18:07.970 --> 00:18:12.290
say it, but a something
that generates bindings in Russ

305
00:18:12.290 --> 00:18:15.980
too. Mm I'm not sure
which way it goes either

306
00:18:15.980 --> 00:18:18.530
in Rustici well saucer in
C plus plus the rest.

307
00:18:19.730 --> 00:18:21.230
I think it's tough when
you have a lot of

308
00:18:22.400 --> 00:18:25.310
function overloading in C plus
plus cause Russ doesn't have

309
00:18:25.340 --> 00:18:28.940
overloading. I think that gets
tricky. But I also have,

310
00:18:28.970 --> 00:18:32.030
I have a talk where
I took a C library

311
00:18:32.030 --> 00:18:36.050
called softly. It's a compression
tool and I rewrote it.

312
00:18:36.050 --> 00:18:39.260
It's written in C. I
rewrote it to rust using

313
00:18:39.260 --> 00:18:43.220
the foreign function interface to
do one function at a

314
00:18:43.220 --> 00:18:47.360
time. And I kept the
test passing at every commit,

315
00:18:49.010 --> 00:18:52.430
which I think proves that
you can do like an

316
00:18:52.430 --> 00:18:58.160
incremental rewrite by using this
FFI and you don't even

317
00:18:58.160 --> 00:19:01.700
have to finish. You could
stop at any point when

318
00:19:01.700 --> 00:19:05.570
you've gotten enough value from
the rewrite, you could start

319
00:19:05.570 --> 00:19:07.580
with the parts that changed
the most. You could start

320
00:19:07.580 --> 00:19:10.730
with the parts that are
the root cause of the

321
00:19:10.730 --> 00:19:14.810
most bugs parts that crash
the most. And if you

322
00:19:15.200 --> 00:19:17.930
get what you're looking to
get out of the rewrite

323
00:19:17.960 --> 00:19:19.820
bin, there's more important things
that come up, you could

324
00:19:19.820 --> 00:19:22.880
stop if you do this
in an incremental sort of

325
00:19:24.410 --> 00:19:27.620
Right. And then they're there
in the sea world. There's

326
00:19:27.620 --> 00:19:31.340
things like, you know, Lipsey
for single third programs and

327
00:19:31.340 --> 00:19:35.540
lib CMT for multi-threaded programs,
rust is known for like

328
00:19:35.540 --> 00:19:38.690
highly concurrent systems. Was that
like a fundamental tenant of

329
00:19:38.690 --> 00:19:40.430
the thing? Like, wow, we're
doing this, let's make sure

330
00:19:40.430 --> 00:19:42.410
it works when there's a
lot of threads of doing

331
00:19:42.410 --> 00:19:45.230
a lot of stuff. Yeah.
That was one of the

332
00:19:45.230 --> 00:19:49.400
main goals. The reason that
Missoula is so invented so

333
00:19:49.400 --> 00:19:53.330
invested in it is that
they want they're slowly rewriting

334
00:19:53.330 --> 00:19:58.220
Firefox and Ross and Firefox
is a, a mostly C

335
00:19:58.280 --> 00:20:02.960
plus plus program that has
it's purpose is to run

336
00:20:02.960 --> 00:20:07.370
on trusted code from the
internet. So they're very interested

337
00:20:07.370 --> 00:20:10.790
in closing any security holes.
And they're also interested in

338
00:20:10.790 --> 00:20:17.510
improving performance by parallelizing, everything
that they can. And they

339
00:20:17.510 --> 00:20:20.930
have tried to parallelize stuff
in C plus plus and

340
00:20:20.960 --> 00:20:24.050
found it that it just
increased the memory safety problems

341
00:20:24.050 --> 00:20:28.460
they had. So when rust
evolved out of Missoula research,

342
00:20:29.300 --> 00:20:33.470
then they created servo, which
is an experimental browser written

343
00:20:33.470 --> 00:20:37.370
entirely in rest. And now
they are pulling components out

344
00:20:37.370 --> 00:20:42.620
of servo and into Firefox.
And the Firefox quantum release

345
00:20:42.650 --> 00:20:46.130
that happens, I think a
year or two ago, one

346
00:20:46.130 --> 00:20:49.900
of the big parts of
quantum that, that improved the

347
00:20:49.900 --> 00:20:54.700
performance was the CSS. Surrendering
was the CSS rendering from

348
00:20:54.700 --> 00:20:58.180
servo that was written in
Ruston pulled over. So that

349
00:20:58.180 --> 00:21:01.930
like parallelizes the entire rendering
of the CSS on the

350
00:21:01.930 --> 00:21:04.470
page. I remember when I
went to quantum as a

351
00:21:04.470 --> 00:21:08.130
user, like it was the
same Firefox that I felt

352
00:21:08.130 --> 00:21:11.400
good about it ran just
as well. So nothing dramatic

353
00:21:11.400 --> 00:21:15.660
happened, which presumably was the
right idea and not noticing

354
00:21:15.660 --> 00:21:18.960
was success. Yes. Hopefully, and
noticing that it was a

355
00:21:18.960 --> 00:21:23.400
little faster, but not noticing
that anything is broken Well

356
00:21:23.400 --> 00:21:26.130
and in a world where
the processors have so many

357
00:21:26.130 --> 00:21:30.660
more native processors, native cores
and the ability to do,

358
00:21:31.080 --> 00:21:32.880
you know, hyper-threading and things
like that, we're going to

359
00:21:32.880 --> 00:21:37.800
want concurrency baked into our
languages. Yeah. Yeah. So if

360
00:21:37.800 --> 00:21:40.920
I understand correctly and there's
operating system threads, you know,

361
00:21:40.920 --> 00:21:43.890
Linux has native threads. Windows
has a native notion of

362
00:21:43.890 --> 00:21:46.530
threads and then programming languages
have this idea of a

363
00:21:46.530 --> 00:21:49.980
thing called green threads, which
is like not an operating

364
00:21:49.980 --> 00:21:53.100
system construct. It's just their
own vibe on what green

365
00:21:53.100 --> 00:21:55.500
threads are. But since rust
is kind of a lowest

366
00:21:55.500 --> 00:22:00.210
level language, the rust standard
library provides a support for

367
00:22:00.210 --> 00:22:02.820
threads. So when you say
thread spawn, you know, it's

368
00:22:02.820 --> 00:22:05.340
real, it's low level, you're
telling the operating system to

369
00:22:05.400 --> 00:22:09.510
spawn a thread, what kind
of problems go wrong when

370
00:22:09.510 --> 00:22:11.880
you do that in CNC
plus plus where you just

371
00:22:11.880 --> 00:22:14.340
like make threads, put data
on the thread and start

372
00:22:14.670 --> 00:22:19.020
going to town that rusts
solves. So I haven't actually

373
00:22:19.020 --> 00:22:21.930
done a whole lot of
CNC plus plus programming myself

374
00:22:21.960 --> 00:22:28.350
because I, I am not
capable of doing anything safely.

375
00:22:28.710 --> 00:22:30.840
Well, that's actually kind of
cool actually, if I may,

376
00:22:30.840 --> 00:22:33.870
because then you're saying that
you've been doing Russ for

377
00:22:33.870 --> 00:22:37.170
so long that this has
freed you from that kind

378
00:22:37.170 --> 00:22:40.170
of administrivia, which is the
whole point of the language.

379
00:22:40.380 --> 00:22:42.780
Yeah. From what I understand
it is that you can

380
00:22:42.780 --> 00:22:46.560
just kind of pass pointers
back and forth across threads

381
00:22:46.560 --> 00:22:50.310
and you have to keep
track of who's cleaning that

382
00:22:50.310 --> 00:22:55.590
up. Or who's accessing that
when, and who's modifying the

383
00:22:55.590 --> 00:22:59.340
data that it's being it's
being pointed to. And if

384
00:22:59.340 --> 00:23:03.780
that pointer is still valid
and all of this is

385
00:23:04.710 --> 00:23:08.190
enforced by the rust type
system, such that you can

386
00:23:08.250 --> 00:23:12.690
kind of Mark a particular
data structures as, okay, we

387
00:23:12.690 --> 00:23:17.760
can share this between threads
because it's synchronized access to

388
00:23:17.760 --> 00:23:22.020
it, the synchronize, or we
can move ownership of this

389
00:23:22.110 --> 00:23:24.420
piece of data from one
thread to another, and then

390
00:23:24.420 --> 00:23:28.050
you're no longer allowed to
access it in the original

391
00:23:28.050 --> 00:23:32.010
thread. So this is a
system of ownership ties into

392
00:23:32.310 --> 00:23:37.650
the multithreaded programming. Right. That
is really interesting because even

393
00:23:37.740 --> 00:23:41.310
like C is, is somewhat,
I wouldn't say threatening, but

394
00:23:41.310 --> 00:23:44.850
intimidating to me and multithreaded
C or C plus plus

395
00:23:44.880 --> 00:23:46.760
it's like, Oh my goodness.
You know, I don't want

396
00:23:46.760 --> 00:23:49.250
to have to go back
and get my PhD, but

397
00:23:49.790 --> 00:23:52.240
I definitely, I feel like
the rust compiler is like,

398
00:23:52.270 --> 00:23:56.260
it's like a pair programmer
that is helping me to

399
00:23:56.290 --> 00:23:59.710
get everything right. That you
have to, you have to

400
00:23:59.710 --> 00:24:01.930
manage yourself and C and
C plus plus, and I'm,

401
00:24:01.960 --> 00:24:04.330
I don't have the brain
power for that. I'm more

402
00:24:04.330 --> 00:24:07.750
interested in, in whatever problem
I'm trying to solve. I

403
00:24:07.750 --> 00:24:10.480
don't want to have to
think about, okay, is this

404
00:24:10.480 --> 00:24:12.940
point are still valid or
not? Or is this over

405
00:24:12.940 --> 00:24:16.540
here? Or who's responsible this,
did I clean that up?

406
00:24:17.140 --> 00:24:19.540
I don't want to have
to think about that. Like,

407
00:24:19.540 --> 00:24:21.970
computers are really good at
taking care of all this

408
00:24:21.970 --> 00:24:26.260
trivia, all this administration and
making sure you get it

409
00:24:26.260 --> 00:24:30.790
right every single time computers
can do that. So that's

410
00:24:30.790 --> 00:24:33.070
what I feel like it's
doing for me. Well, and

411
00:24:33.070 --> 00:24:35.800
here we are like 40,
50 years past CNC plus

412
00:24:35.800 --> 00:24:37.420
plus, and I know that
there's probably a lot of

413
00:24:37.420 --> 00:24:39.450
people who will email me
and say that I, I

414
00:24:39.460 --> 00:24:42.040
program in CNC plus plus
every day. But think about

415
00:24:42.040 --> 00:24:44.200
how far computers have come
in the last 50 years.

416
00:24:44.260 --> 00:24:46.540
And we're still thinking about
this stuff, shouldn't our language,

417
00:24:46.540 --> 00:24:49.600
do it for us. And
I love that, you know,

418
00:24:49.810 --> 00:24:53.350
I'm kind of bumbling around
and asking these questions and

419
00:24:53.350 --> 00:24:54.550
I don't know if they're
good or not. And you're

420
00:24:54.550 --> 00:24:56.800
like, well, I don't really
know because I am a

421
00:24:56.800 --> 00:24:58.900
rushed programmer. I don't think
about those things I know

422
00:24:58.900 --> 00:25:01.840
about threads. And I think
about threads, but worrying about

423
00:25:02.320 --> 00:25:05.860
hurting myself with a thread
is it's not beyond my

424
00:25:05.860 --> 00:25:09.610
space. That's, that's a really
a Testament to the language

425
00:25:09.610 --> 00:25:13.660
itself. So this idea of,
of ownership goes cross threads.

426
00:25:13.660 --> 00:25:15.970
And then you said that
you can do both moving

427
00:25:16.300 --> 00:25:19.900
and borrowing. So this idea
of ownership can't be broken,

428
00:25:19.930 --> 00:25:23.110
you have to be specific,
which thread owns a piece

429
00:25:23.110 --> 00:25:27.160
of data. Exactly. Interesting. I
saw that there was an

430
00:25:27.160 --> 00:25:28.780
article or I'm not sure
it was a book that

431
00:25:28.780 --> 00:25:35.140
was called fearless, fearless concurrency
in, in rust. Is there

432
00:25:35.140 --> 00:25:38.230
a sense of you, you
don't have things that you

433
00:25:38.230 --> 00:25:41.560
have to worry about. You
can move without fear when

434
00:25:41.560 --> 00:25:47.890
you're coding in rust. Definitely
it's again, I don't have

435
00:25:47.920 --> 00:25:50.860
a whole lot of experience
with CNCS plus, but I

436
00:25:50.890 --> 00:25:54.430
remember in Ruby, the story
is kind of similar that

437
00:25:54.430 --> 00:25:58.150
there's not a whole lot
of support for writing concurrent

438
00:25:59.410 --> 00:26:02.860
stuff in Ruby. And I
would use concurrent libraries in

439
00:26:02.860 --> 00:26:04.960
Ruby and they would crash
a lot and do weird

440
00:26:04.960 --> 00:26:07.420
things. And that kind of
scared me off from trying

441
00:26:07.420 --> 00:26:13.780
to write it myself. But
yeah, I, I don't feel

442
00:26:13.780 --> 00:26:19.060
that way in rest. And
it's definitely, I've heard from

443
00:26:19.060 --> 00:26:24.520
other companies that, you know,
hire people who are more

444
00:26:24.520 --> 00:26:27.970
junior, who, if they were
writing CNC plus plus you'd

445
00:26:27.970 --> 00:26:30.370
want to review their code
a whole lot to make

446
00:26:30.370 --> 00:26:34.840
sure it was right, but
the compilers doing that review

447
00:26:34.840 --> 00:26:39.100
in rust. So if the
code compiles you, you've already

448
00:26:39.100 --> 00:26:42.430
had that code review basically,
and you can look more

449
00:26:42.430 --> 00:26:47.190
at the logic than the
pointers and passing data around

450
00:26:47.190 --> 00:26:50.570
between threads. Well, that brings
up a really interesting question.

451
00:26:50.570 --> 00:26:53.030
And I appreciate that. You've
had me think about this

452
00:26:53.030 --> 00:26:55.010
is that if I'm going
to go and hire someone

453
00:26:55.010 --> 00:26:57.440
in their mid twenties, this
is someone who may have

454
00:26:57.440 --> 00:26:59.840
never been exposed to see
her play flushed or thought

455
00:26:59.840 --> 00:27:02.720
about any of these problems.
So how would you test

456
00:27:02.720 --> 00:27:07.400
them for their understanding of
concurrency without accidentally testing or

457
00:27:07.400 --> 00:27:11.780
quizzing them on the historical
context of languages or, you

458
00:27:11.780 --> 00:27:13.610
know, dead or otherwise that
they would have never have

459
00:27:13.610 --> 00:27:16.130
used? Like, I want them
to understand how threads work

460
00:27:16.430 --> 00:27:19.190
and how to move data
around, but to your point,

461
00:27:19.220 --> 00:27:21.980
they may have never done
that. That works. So should

462
00:27:21.980 --> 00:27:24.620
they have studied, you know,
Latin when I'm asking them

463
00:27:24.620 --> 00:27:28.460
just thinking Well, so I
think there's still, this, this

464
00:27:28.460 --> 00:27:32.900
is really interesting question. There's
still things that are possible

465
00:27:32.900 --> 00:27:38.240
in rust. It's still possible
to create deadlocks. It's still

466
00:27:38.240 --> 00:27:44.240
possible to have resource starvation.
It's still possible to be

467
00:27:44.240 --> 00:27:48.710
holding onto a lock longer
than you think you're holding

468
00:27:48.710 --> 00:27:55.550
onto it. It's just that
the memory safety part is,

469
00:27:57.710 --> 00:28:01.340
is solved for you. So
I think there there's, it's

470
00:28:01.340 --> 00:28:05.150
still, you still have to
think about how am I

471
00:28:05.150 --> 00:28:09.320
going to parallelize this problem?
Like where, where is this

472
00:28:11.270 --> 00:28:14.210
is the, where can we
do things that are separate,

473
00:28:14.210 --> 00:28:16.550
that are independent and where
do we need to synchronize

474
00:28:16.550 --> 00:28:20.630
the data together? Where can
we spawned something and check

475
00:28:20.630 --> 00:28:24.200
on it to come back?
So I think more of

476
00:28:24.200 --> 00:28:28.610
the concepts of how you
do the work in a

477
00:28:28.610 --> 00:28:33.080
concurrent or parallel fashion is
still definitely relevant, but it's

478
00:28:33.080 --> 00:28:37.310
less of the, is this
undefined behavior or not, or

479
00:28:37.490 --> 00:28:41.960
is it possible that this
thread ends before this other

480
00:28:41.960 --> 00:28:44.780
thread and you don't think
it possible? And it actually

481
00:28:44.780 --> 00:28:47.900
blows everything up. That's really
helpful to think about. Yeah,

482
00:28:47.900 --> 00:28:50.540
it does. Because as someone
who is of a certain

483
00:28:50.540 --> 00:28:54.230
age, I don't want to
say to a new person

484
00:28:54.230 --> 00:28:56.690
that I'm going to higher
order my children. You need

485
00:28:56.690 --> 00:28:58.670
to learn how to change
your own oil and how

486
00:28:58.670 --> 00:29:02.090
to, you know, double clutch,
a stick shift in a

487
00:29:02.090 --> 00:29:05.600
world where lifts exist. You
know, you don't need to

488
00:29:05.600 --> 00:29:08.780
disassemble a carburetor. I don't
want to accidentally ask someone

489
00:29:08.780 --> 00:29:11.510
how to disassemble a carburetor
if that's just simply not

490
00:29:11.510 --> 00:29:12.860
a thing anymore. But I
would like to have a

491
00:29:12.860 --> 00:29:15.620
general sense of how cars
move in the world. So

492
00:29:15.650 --> 00:29:18.530
applying that analogy to programming
languages, I think is a

493
00:29:18.530 --> 00:29:22.190
fair one. Yeah. And I
definitely, I'm not of the

494
00:29:22.190 --> 00:29:26.240
school, obviously since I don't
know, see intimately, I'm not

495
00:29:26.240 --> 00:29:28.490
at a school that says,
Oh, you to be a

496
00:29:28.490 --> 00:29:30.620
good software program. Are you
happy to have a seat?

497
00:29:30.650 --> 00:29:35.000
Because for one thing that's
not, then why not? You

498
00:29:35.000 --> 00:29:37.400
have to learn assembly, which
I had a little assembling

499
00:29:37.400 --> 00:29:41.130
college. I understand the concept
of the family. You, you

500
00:29:41.130 --> 00:29:42.880
just don't programming and assembly
on a day to day

501
00:29:42.880 --> 00:29:47.410
basis unless your, your work
is at that level. It's

502
00:29:47.560 --> 00:29:52.930
completely possible to do meaningful
work at a higher level

503
00:29:52.930 --> 00:29:55.660
in computer programming. We have
come that far, that you

504
00:29:55.660 --> 00:29:58.450
are able to do that
is not required for you

505
00:29:58.450 --> 00:30:02.920
to know what every bit
of the computer is doing

506
00:30:02.920 --> 00:30:05.590
at any point. And it's
not actually possible for anyone

507
00:30:05.590 --> 00:30:08.020
to hold that in your
head anymore. Computers are doing

508
00:30:08.020 --> 00:30:13.360
too much. The processors are,
are rearranging your instructions in

509
00:30:13.360 --> 00:30:19.330
ways that no one even
understands much anymore. Exactly. So,

510
00:30:20.530 --> 00:30:25.120
yes, I definitely think it's,
there are concepts that transcend

511
00:30:25.210 --> 00:30:29.050
and concepts like how do
we split up this work

512
00:30:30.820 --> 00:30:33.730
that are a higher level
concepts that you should understand?

513
00:30:33.730 --> 00:30:37.030
And, and there are times
when you will need to

514
00:30:37.060 --> 00:30:41.080
dive into deeper things to
figure out why something isn't

515
00:30:41.080 --> 00:30:44.860
working or why it's slow
or things like that. But

516
00:30:45.250 --> 00:30:48.610
generally like we, we made
these abstractions, we should use

517
00:30:48.610 --> 00:30:52.890
them. Exactly. I appreciate that.
And if you go to

518
00:30:53.190 --> 00:30:57.810
rust-lang.org, you can learn how
Russ can set you up

519
00:30:57.840 --> 00:31:01.260
for success. Even on embedded
systems or low resource devices

520
00:31:01.920 --> 00:31:07.020
on networking systems, that'll even
compile to WebAssembly. It's a

521
00:31:07.020 --> 00:31:09.780
very welcoming community and it
appears to be really a

522
00:31:09.780 --> 00:31:13.860
language for everybody. That's what
we're trying to do. I

523
00:31:13.860 --> 00:31:16.890
appreciate that. And folks can
check out your book from

524
00:31:16.890 --> 00:31:20.040
no starch press. We'll make
sure we include a link

525
00:31:20.040 --> 00:31:22.710
in the show notes, the
rust programming language with Steve

526
00:31:23.190 --> 00:31:26.550
Clubnick and yourself, Carol Nichols. And
of course your rust in

527
00:31:26.550 --> 00:31:30.810
motion videos available at Manning.
We'll put that in the

528
00:31:30.810 --> 00:31:33.060
show notes as well. Thank
you so much, Carol Nichols for

529
00:31:33.060 --> 00:31:35.310
chatting with me today. Thank
you for chatting with me.

530
00:31:36.480 --> 00:31:39.330
This has been another episode
of Hanselminutes and we'll see

531
00:31:39.330 --> 00:31:52.200
you again next week. <inaudible>.

